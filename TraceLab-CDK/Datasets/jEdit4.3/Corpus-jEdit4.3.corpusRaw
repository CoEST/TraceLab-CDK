public AbbrevEditor()		{			GridBagLayout layout = new GridBagLayout();			setLayout(layout);				GridBagConstraints cons = new GridBagConstraints();			cons.anchor = cons.WEST;			cons.fill = cons.BOTH;			cons.weightx = 0.0f;			cons.gridx = 1;			cons.gridy = 1;				JLabel label = new JLabel(jEdit.getProperty("abbrev-editor.abbrev"),				SwingConstants.RIGHT);			label.setBorder(new EmptyBorder(0,0,0,12));			layout.setConstraints(label,cons);			add(label);			cons.gridx++;			cons.weightx = 1.0f;			abbrev = new JTextField();			layout.setConstraints(abbrev,cons);			add(abbrev);				cons.gridx = 1;			cons.weightx = 0.0f;			cons.gridwidth = 2;				cons.gridy++;			label = new JLabel(jEdit.getProperty("abbrev-editor.before"));			label.setBorder(new EmptyBorder(6,0,3,0));			layout.setConstraints(label,cons);			add(label);				cons.gridy++;			cons.weighty = 1.0f;			beforeCaret = new JTextArea(4,40);			JScrollPane scroller = new JScrollPane(beforeCaret);			layout.setConstraints(scroller,cons);			add(scroller);				cons.gridy++;			cons.weighty = 0.0f;			label = new JLabel(jEdit.getProperty("abbrev-editor.after"));			label.setBorder(new EmptyBorder(6,0,3,0));			layout.setConstraints(label,cons);			add(label);				cons.gridy++;			cons.weighty = 1.0f;			afterCaret = new JTextArea(4,40);			scroller = new JScrollPane(afterCaret);			layout.setConstraints(scroller,cons);			add(scroller);		}	
public String getAbbrev()		{			return abbrev.getText();		}	
public void setAbbrev(String abbrev)		{			this.abbrev.setText(abbrev);		}	
public String getExpansion()		{			StringBuilder buf = new StringBuilder();				String beforeCaretText = beforeCaret.getText();			String afterCaretText = afterCaret.getText();				for(int i = 0; i < beforeCaretText.length(); i++)			{				char ch = beforeCaretText.charAt(i);				switch(ch)				{				case '\n':					buf.append("\\n");					break;				case '\t':					buf.append("\\t");					break;				case '\\':					buf.append("\\\\");					break;				default:					buf.append(ch);					break;				}			}				if(afterCaretText.length() != 0)			{				buf.append("\\|");					for(int i = 0; i < afterCaretText.length(); i++)				{					char ch = afterCaretText.charAt(i);					switch(ch)					{					case '\n':						buf.append("\\n");						break;					case '\t':						buf.append("\\t");						break;					case '\\':						buf.append("\\\\");						break;					default:						buf.append(ch);						break;					}				}			}				return buf.toString();		}	
public void setExpansion(String expansion)		{			if(expansion == null)			{				beforeCaret.setText(null);				afterCaret.setText(null);				return;			}				String beforeCaretText = null;			String afterCaretText = null;			StringBuilder buf = new StringBuilder();				for(int i = 0; i < expansion.length(); i++)			{				char ch = expansion.charAt(i);					if(ch == '\\' && i != expansion.length() - 1)				{					ch = expansion.charAt(++i);					switch(ch)					{					case 't':						buf.append('\t');						break;					case 'n':						buf.append('\n');						break;					case '|':						beforeCaretText = buf.toString();						buf.setLength(0);						break;					default:						buf.append(ch);						break;					}				}				else					buf.append(ch);			}				if(beforeCaretText == null)				beforeCaretText = buf.toString();			else				afterCaretText = buf.toString();				beforeCaret.setText(beforeCaretText);			afterCaret.setText(afterCaretText);		}	
public JTextField getAbbrevField()		{			return abbrev;		}	
public JTextArea getBeforeCaretTextArea()		{			return beforeCaret;		}	
public JTextArea getAfterCaretTextArea()		{			return afterCaret;		}	
/**		 * Returns if abbreviations should be expanded after the		 * user finishes typing a word.		 */		public static boolean getExpandOnInput()		{			return expandOnInput;		}	
/**		 * Sets if abbreviations should be expanded after the		 * user finishes typing a word.		 * @param expandOnInput If true, typing a non-alphanumeric character		 * will automatically attempt to expand the current abbrev		 */		public static void setExpandOnInput(boolean expandOnInput)		{			Abbrevs.expandOnInput = expandOnInput;		}	
/**		 * Expands the abbrev at the caret position in the specified		 * view.		 * @param view The view		 * @param add If true and abbrev not found, will ask user if		 * it should be added		 * @since jEdit 2.6pre4		 */		public static boolean expandAbbrev(View view, boolean add)		{			//{{{ Figure out some minor things			Buffer buffer = view.getBuffer();			JEditTextArea textArea = view.getTextArea();			if(!buffer.isEditable())			{				view.getToolkit().beep();				return false;			}				int line = textArea.getCaretLine();			int lineStart = buffer.getLineStartOffset(line);			int caret = textArea.getCaretPosition();				String lineText = buffer.getLineText(line);			if(lineText.length() == 0)			{				if(add)					view.getToolkit().beep();				return false;			}				int pos = caret - lineStart;			if(pos == 0)			{				if(add)					view.getToolkit().beep();				return false;			} //}}}				// we reuse the 'pp' vector to save time			m_pp.removeAllElements();				int wordStart;			String abbrev;				//{{{ Handle abbrevs of the form abbrev#pos1#pos2#pos3#...			if(lineText.charAt(pos-1) == '#')			{				wordStart = lineText.indexOf('#');				wordStart = TextUtilities.findWordStart(lineText,wordStart,					buffer.getStringProperty("noWordSep") + '#');					abbrev = lineText.substring(wordStart,pos - 1);					// positional parameters will be inserted where $1, $2, $3, ...				// occurs in the expansion					int lastIndex = 0;				for(int i = 0; i < abbrev.length(); i++)				{					if(abbrev.charAt(i) == '#')					{						m_pp.addElement(abbrev.substring(lastIndex,i));						lastIndex = i + 1;					}				}					m_pp.addElement(abbrev.substring(lastIndex));					// the first element of pp is the abbrev itself				abbrev = m_pp.elementAt(0);				m_pp.removeElementAt(0);			} //}}}			//{{{ Handle ordinary abbrevs			else			{				wordStart = TextUtilities.findWordStart(lineText,pos - 1,					buffer.getStringProperty("noWordSep"));					abbrev = lineText.substring(wordStart,pos);			} //}}}				Expansion expand = expandAbbrev(buffer.getMode().getName(),				abbrev,(buffer.getBooleanProperty("noTabs") ?				buffer.getTabSize() : 0),m_pp);				//{{{ Maybe show add abbrev dialog			if(expand == null)			{				if(add)					new AddAbbrevDialog(view,abbrev);					return false;			} //}}}			//{{{ Insert the expansion			else			{				buffer.remove(lineStart + wordStart,					pos - wordStart);					int whitespace = buffer.insertIndented(					lineStart + wordStart,					expand.text);					int newlines = countNewlines(expand.text,					expand.caretPosition);					if(expand.caretPosition != -1)				{					textArea.setCaretPosition(lineStart + wordStart						+ expand.caretPosition						+ newlines * whitespace);				}				if(expand.posParamCount != m_pp.size())				{					view.getStatus().setMessageAndClear(						jEdit.getProperty(						"view.status.incomplete-abbrev",						new Integer[] { Integer.valueOf(m_pp.size()),						Integer.valueOf(expand.posParamCount) }));				}					return true;			} //}}}		}	
/**		 * Returns the global abbreviation set.		 * @since jEdit 2.3pre1		 */		public static Hashtable<String,String> getGlobalAbbrevs()		{			if(!loaded)				load();				return globalAbbrevs;		}	
/**		 * Sets the global abbreviation set.		 * @param globalAbbrevs The new global abbrev set		 * @since jEdit 2.3pre1		 */		public static void setGlobalAbbrevs(Hashtable<String,String> globalAbbrevs)		{			abbrevsChanged = true;			Abbrevs.globalAbbrevs = globalAbbrevs;		}	
/**		 * Returns the mode-specific abbreviation set.		 * @since jEdit 2.3pre1		 */		public static Hashtable<String,Hashtable<String,String>> getModeAbbrevs()		{			if(!loaded)				load();				return modes;		}	
/**		 * Sets the mode-specific abbreviation set.		 * @param modes The new mode abbrev set		 * @since jEdit 2.3pre1		 */		public static void setModeAbbrevs(Hashtable<String,Hashtable<String,String>> modes)		{			abbrevsChanged = true;			Abbrevs.modes = modes;		}	
/**		 * Adds an abbreviation to the global abbreviation list.		 * @param abbrev The abbreviation		 * @param expansion The expansion		 * @since jEdit 3.1pre1		 */		public static void addGlobalAbbrev(String abbrev, String expansion)		{			if(!loaded)				load();				globalAbbrevs.put(abbrev,expansion);			abbrevsChanged = true;		}	
/**		 * Adds a mode-specific abbrev.		 * @param mode The edit mode		 * @param abbrev The abbrev		 * @param expansion The expansion		 * @since jEdit 3.1pre1		 */		public static void addModeAbbrev(String mode, String abbrev, String expansion)		{			if(!loaded)				load();				Hashtable<String,String> modeAbbrevs = modes.get(mode);			if(modeAbbrevs == null)			{				modeAbbrevs = new Hashtable<String,String>();				modes.put(mode,modeAbbrevs);			}			modeAbbrevs.put(abbrev,expansion);			abbrevsChanged = true;		}	
static void save()		{			jEdit.setBooleanProperty("view.expandOnInput",expandOnInput);				String settings = jEdit.getSettingsDirectory();			if(abbrevsChanged && settings != null)			{				File file1 = new File(MiscUtilities.constructPath(settings,"#abbrevs#save#"));				File file2 = new File(MiscUtilities.constructPath(settings,"abbrevs"));				if(file2.exists() && file2.lastModified() != abbrevsModTime)				{					Log.log(Log.WARNING,Abbrevs.class,file2 + " changed on disk;"						+ " will not save abbrevs");				}				else				{					jEdit.backupSettingsFile(file2);						try					{						saveAbbrevs(new OutputStreamWriter(							new FileOutputStream(file1),							ENCODING));						file2.delete();						file1.renameTo(file2);					}					catch(Exception e)					{						Log.log(Log.ERROR,Abbrevs.class,"Error while saving " + file1);						Log.log(Log.ERROR,Abbrevs.class,e);					}					abbrevsModTime = file2.lastModified();				}			}		}	
private Abbrevs() {}	
private static void load()		{			globalAbbrevs = new Hashtable<String,String>();			modes = new Hashtable<String,Hashtable<String,String>>();				String settings = jEdit.getSettingsDirectory();			if(settings != null)			{				File file = new File(MiscUtilities.constructPath(settings,"abbrevs"));				abbrevsModTime = file.lastModified();					try				{					loadAbbrevs(new InputStreamReader(						new FileInputStream(file),ENCODING));					loaded = true;				}				catch(FileNotFoundException fnf)				{				}				catch(Exception e)				{					Log.log(Log.ERROR,Abbrevs.class,"Error while loading " + file);					Log.log(Log.ERROR,Abbrevs.class,e);				}			}				// only load global abbrevs if user abbrevs file could not be loaded			if(!loaded)			{				try				{					loadAbbrevs(new InputStreamReader(Abbrevs.class						.getResourceAsStream("default.abbrevs"),						ENCODING));				}				catch(Exception e)				{					Log.log(Log.ERROR,Abbrevs.class,"Error while loading default.abbrevs");					Log.log(Log.ERROR,Abbrevs.class,e);				}				loaded = true;			}		}	
private static int countNewlines(String s, int end)		{			int counter = 0;				for(int i = 0; i < end; i++)			{				if(s.charAt(i) == '\n')					counter++;			}				return counter;		}	
private static Expansion expandAbbrev(String mode, String abbrev,			int softTabSize, Vector<String> pp)		{			m_pp = pp;			if(!loaded)				load();				// try mode-specific abbrevs first			String expand = null;			Hashtable<String,String> modeAbbrevs = modes.get(mode);			if(modeAbbrevs != null)				expand = modeAbbrevs.get(abbrev);				if(expand == null)				expand = globalAbbrevs.get(abbrev);				if(expand == null)				return null;			else				return new Expansion(expand,softTabSize,m_pp);		}	
private static void loadAbbrevs(Reader _in) throws Exception		{			BufferedReader in = new BufferedReader(_in);				try			{				Hashtable<String,String> currentAbbrevs = globalAbbrevs;					String line;				while((line = in.readLine()) != null)				{					int index = line.indexOf('|');						if(line.length() == 0)						continue;					else if(line.startsWith("[") && index == -1)					{						if(line.equals("[global]"))							currentAbbrevs = globalAbbrevs;						else						{							String mode = line.substring(1,								line.length() - 1);							currentAbbrevs = modes.get(mode);							if(currentAbbrevs == null)							{								currentAbbrevs = new Hashtable<String,String>();								modes.put(mode,currentAbbrevs);							}						}					}					else if(index != -1)					{						currentAbbrevs.put(line.substring(0,index),							line.substring(index + 1));					}				}			}			finally			{				in.close();			}		}	
private static void saveAbbrevs(Writer _out) throws Exception		{			BufferedWriter out = new BufferedWriter(_out);			String lineSep = System.getProperty("line.separator");				// write global abbrevs			out.write("[global]");			out.write(lineSep);				saveAbbrevs(out,globalAbbrevs);				// write mode abbrevs			Enumeration<String> keys = modes.keys();			Enumeration<Hashtable<String,String>> values = modes.elements();			while(keys.hasMoreElements())			{				out.write('[');				out.write(keys.nextElement());				out.write(']');				out.write(lineSep);				saveAbbrevs(out,values.nextElement());			}				out.close();		}	
private static void saveAbbrevs(Writer out, Hashtable<String,String> abbrevs)			throws Exception		{			String lineSep = System.getProperty("line.separator");				Enumeration<String> keys = abbrevs.keys();			Enumeration<String> values = abbrevs.elements();			while(keys.hasMoreElements())			{				String abbrev = keys.nextElement();				out.write(abbrev);				out.write('|');				out.write(values.nextElement());				out.write(lineSep);			}		}	
Expansion(String text, int softTabSize, List<String> pp)			{				StringBuilder buf = new StringBuilder();				boolean backslash = false;					for(int i = 0; i < text.length(); i++)				{					char ch = text.charAt(i);					//{{{ Handle backslash					if(backslash)					{						backslash = false;							if(ch == '|')							caretPosition = buf.length();						else if(ch == 'n')						{							buf.append('\n');							lineCount++;						}						else if(ch == 't')						{							if(softTabSize == 0)								buf.append('\t');							else							{								for(int j = 0; j < softTabSize; j++)									buf.append(' ');							}						}						else							buf.append(ch);					}					else if(ch == '\\')						backslash = true;					//}}}					//{{{ Handle $					else if(ch == '$')					{						if(i != text.length() - 1)						{							ch = text.charAt(i + 1);							if(Character.isDigit(ch) && ch != '0')							{								i++;									int pos = ch - '0';								posParamCount = Math.max(pos,posParamCount);								// $n is 1-indexed, but vector								// contents is zero indexed								if(pos <= pp.size())									buf.append(pp.get(pos - 1));							}							else							{								// $key will be $key, for								// example								buf.append('$');							}						}						else							buf.append('$'); // $ at end is literal					} //}}}					else						buf.append(ch);				}					this.text = buf.toString();			}	
public AbbrevsOptionPane()		{			super("abbrevs");		}	
@Override		protected void _init()		{			setLayout(new BorderLayout());				JPanel panel = new JPanel(new BorderLayout(6,6));				expandOnInput = new JCheckBox(jEdit.getProperty("options.abbrevs"				+ ".expandOnInput"),Abbrevs.getExpandOnInput());				panel.add(expandOnInput,BorderLayout.NORTH);				JPanel panel2 = new JPanel();			panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));			panel2.setBorder(new EmptyBorder(0,0,6,0));			panel2.add(Box.createGlue());			JLabel label = new JLabel(jEdit.getProperty("options.abbrevs.set"));			label.setBorder(new EmptyBorder(0,0,0,12));			panel2.add(label);				Map<String,Hashtable<String,String>> _modeAbbrevs = Abbrevs.getModeAbbrevs();			modeAbbrevs = new HashMap<String,AbbrevsModel>();			Mode[] modes = jEdit.getModes();			Arrays.sort(modes,new StandardUtilities.StringCompare<Mode>(true));			String[] sets = new String[modes.length + 1];			sets[0] = "global";			for(int i = 0; i < modes.length; i++)			{				String name = modes[i].getName();				sets[i+1] = name;				modeAbbrevs.put(name,new AbbrevsModel(_modeAbbrevs.get(name)));			}				setsComboBox = new JComboBox(sets);			ActionHandler actionHandler = new ActionHandler();			setsComboBox.addActionListener(actionHandler);			panel2.add(setsComboBox);			panel2.add(Box.createGlue());			panel.add(panel2,BorderLayout.SOUTH);				add(BorderLayout.NORTH,panel);				globalAbbrevs = new AbbrevsModel(Abbrevs.getGlobalAbbrevs());			abbrevsTable = new JTable(globalAbbrevs);			abbrevsTable.getColumnModel().getColumn(1).setCellRenderer(				new Renderer());			abbrevsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);			abbrevsTable.getTableHeader().setReorderingAllowed(false);			abbrevsTable.getTableHeader().addMouseListener(new HeaderMouseHandler());			abbrevsTable.getSelectionModel().addListSelectionListener(				new SelectionHandler());			abbrevsTable.getSelectionModel().setSelectionMode(				ListSelectionModel.SINGLE_SELECTION);			abbrevsTable.addMouseListener(new TableMouseHandler());			Dimension d = abbrevsTable.getPreferredSize();			d.height = Math.min(d.height,200);			JScrollPane scroller = new JScrollPane(abbrevsTable);			scroller.setPreferredSize(d);			add(BorderLayout.CENTER,scroller);				JPanel buttons = new JPanel();			buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));			buttons.setBorder(new EmptyBorder(6,0,0,0));				add = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.abbrevs.add.icon")));			add.setToolTipText(jEdit.getProperty("options.abbrevs.add"));			add.addActionListener(actionHandler);			buttons.add(add);			remove = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.abbrevs.remove.icon")));			remove.setToolTipText(jEdit.getProperty("options.abbrevs.remove"));			remove.addActionListener(actionHandler);			buttons.add(remove);			edit = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.abbrevs.edit.icon")));			edit.setToolTipText(jEdit.getProperty("options.abbrevs.edit"));			edit.addActionListener(actionHandler);			buttons.add(edit);			buttons.add(Box.createGlue());				add(BorderLayout.SOUTH,buttons);			setsComboBox.setSelectedIndex(jEdit.getIntegerProperty("options.abbrevs.combobox.index", 0));			updateEnabled();		}	
@Override		protected void _save()		{			if(abbrevsTable.getCellEditor() != null)				abbrevsTable.getCellEditor().stopCellEditing();				Abbrevs.setExpandOnInput(expandOnInput.isSelected());				Abbrevs.setGlobalAbbrevs(globalAbbrevs.toHashtable());				Hashtable<String,Hashtable<String,String>> modeHash = new Hashtable<String,Hashtable<String,String>>();			Set<Map.Entry<String,AbbrevsModel>> entrySet = modeAbbrevs.entrySet();			for (Map.Entry<String,AbbrevsModel> entry : entrySet)			{				modeHash.put(entry.getKey(),entry.getValue().toHashtable());			}			Abbrevs.setModeAbbrevs(modeHash);		}	
private void updateEnabled()		{			int selectedRow = abbrevsTable.getSelectedRow();			edit.setEnabled(selectedRow != -1);			remove.setEnabled(selectedRow != -1);		}	
private void edit()		{			AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();				int row = abbrevsTable.getSelectedRow();				String abbrev = (String)abbrevsModel.getValueAt(row,0);			String expansion = (String)abbrevsModel.getValueAt(row,1);			String oldAbbrev = abbrev;				EditAbbrevDialog dialog = new EditAbbrevDialog(				GUIUtilities.getParentDialog(AbbrevsOptionPane.this),				abbrev,expansion,abbrevsModel.toHashtable());			abbrev = dialog.getAbbrev();			expansion = dialog.getExpansion();			if(abbrev != null && expansion != null)			{				for(int i = 0; i < abbrevsModel.getRowCount(); i++)				{					if(abbrevsModel.getValueAt(i,0).equals(oldAbbrev))					{						abbrevsModel.remove(i);						break;					}				}					add(abbrevsModel,abbrev,expansion);			}		}	
private void add(AbbrevsModel abbrevsModel, String abbrev,			String expansion)		{			for(int i = 0; i < abbrevsModel.getRowCount(); i++)			{				if(abbrevsModel.getValueAt(i,0).equals(abbrev))				{					abbrevsModel.remove(i);					break;				}			}				abbrevsModel.add(abbrev,expansion);			updateEnabled();		}	
@Override			public void mouseClicked(MouseEvent evt)			{				switch(abbrevsTable.getTableHeader().columnAtPoint(evt.getPoint()))				{				case 0:					((AbbrevsModel)abbrevsTable.getModel()).sort(0);					break;				case 1:					((AbbrevsModel)abbrevsTable.getModel()).sort(1);					break;				}			}	
@Override			public void mouseClicked(MouseEvent evt)			{				if(evt.getClickCount() == 2)					edit();			}	
public void valueChanged(ListSelectionEvent evt)			{				updateEnabled();			}	
public void actionPerformed(ActionEvent evt)			{				AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();					Object source = evt.getSource();				if(source == setsComboBox)				{					jEdit.setIntegerProperty("options.abbrevs.combobox.index", setsComboBox.getSelectedIndex());					String selected = (String)setsComboBox.getSelectedItem();					if(selected.equals("global"))					{						abbrevsTable.setModel(globalAbbrevs);					}					else					{						abbrevsTable.setModel(modeAbbrevs.get(selected));					}					updateEnabled();				}				else if(source == add)				{					EditAbbrevDialog dialog = new EditAbbrevDialog(						GUIUtilities.getParentDialog(AbbrevsOptionPane.this),						null,null,abbrevsModel.toHashtable());					String abbrev = dialog.getAbbrev();					String expansion = dialog.getExpansion();					if(abbrev != null && abbrev.length() != 0						&& expansion != null						&& expansion.length() != 0)					{						add(abbrevsModel,abbrev,expansion);					}				}				else if(source == edit)				{					edit();				}				else if(source == remove)				{					int selectedRow = abbrevsTable.getSelectedRow();					abbrevsModel.remove(selectedRow);					updateEnabled();				}			}	
@Override			public Component getTableCellRendererComponent(				JTable table,				Object value,				boolean isSelected,				boolean cellHasFocus,				int row,				int col)			{				String valueStr = value.toString();					// workaround for Swing's annoying processing of				// labels starting with <html>, which often breaks				if(valueStr.toLowerCase().startsWith("<html>"))					valueStr = ' ' + valueStr;				return super.getTableCellRendererComponent(table,valueStr,					isSelected,cellHasFocus,row,col);			}	
AbbrevsModel(Map<String,String> abbrevHash)			{				abbrevs = new Vector<Abbrev>();					if(abbrevHash != null)				{					Set<Map.Entry<String,String>> entrySet = abbrevHash.entrySet();					for (Map.Entry<String,String> entry : entrySet)					{						abbrevs.add(new Abbrev(entry.getKey(),						                       entry.getValue()));					}					sort(0);				}			}	
void sort(int col)			{				lastSort = col;				Collections.sort(abbrevs,new AbbrevCompare(col));				fireTableDataChanged();			}	
void add(String abbrev, String expansion)			{				abbrevs.add(new Abbrev(abbrev,expansion));				sort(lastSort);			}	
void remove(int index)			{				abbrevs.remove(index);				fireTableStructureChanged();			}	
public Hashtable<String,String> toHashtable()			{				Hashtable<String,String> hash = new Hashtable<String,String>();				for(int i = 0; i < abbrevs.size(); i++)				{					Abbrev abbrev = abbrevs.get(i);					if(abbrev.abbrev.length() > 0					   && abbrev.expand.length() > 0)					{						hash.put(abbrev.abbrev,abbrev.expand);					}				}				return hash;			}	
public int getColumnCount()			{				return 2;			}	
public int getRowCount()			{				return abbrevs.size();			}	
public Object getValueAt(int row, int col)			{				Abbrev abbrev = abbrevs.get(row);				switch(col)				{					case 0:						return abbrev.abbrev;					case 1:						return abbrev.expand;					default:						return null;				}			}	
@Override			public void setValueAt(Object value, int row, int col)			{				if(value == null)					value = "";					Abbrev abbrev = abbrevs.get(row);					if(col == 0)					abbrev.abbrev = (String)value;				else					abbrev.expand = (String)value;					fireTableRowsUpdated(row,row);			}	
@Override			public String getColumnName(int index)			{				switch(index)				{					case 0:						return jEdit.getProperty("options.abbrevs.abbrev");					case 1:						return jEdit.getProperty("options.abbrevs.expand");					default:						return null;				}			}	
AbbrevCompare(int col)				{					this.col = col;				}	
public int compare(Abbrev a1, Abbrev a2)				{					if(col == 0)					{						String abbrev1 = a1.abbrev.toLowerCase();						String abbrev2 = a2.abbrev.toLowerCase();							return StandardUtilities.compareStrings(							abbrev1,abbrev2,true);					}					else					{						String expand1 = a1.expand.toLowerCase();						String expand2 = a2.expand.toLowerCase();							return StandardUtilities.compareStrings(							expand1,expand2,true);					}				}	
Abbrev() {}	
Abbrev(String abbrev, String expand)				{					this.abbrev = abbrev;					this.expand = expand;				}	
public AboutDialog(View view)		{			super(view,jEdit.getProperty("about.title"), true);			setResizable(false);			JButton closeBtn = new JButton(jEdit.getProperty("common.close"));			closeBtn.addActionListener(this);			getRootPane().setDefaultButton(closeBtn);				JPanel p = new JPanel(new BorderLayout());			final AboutPanel aboutPanel = new AboutPanel();			JPanel flowP = new JPanel(new FlowLayout());			flowP.add(closeBtn);			flowP.add(Box.createRigidArea(new Dimension(40, 40)));			Dimension dim = new Dimension(10, 0);			p.add(BorderLayout.WEST, Box.createRigidArea(dim));			p.add(BorderLayout.EAST, Box.createRigidArea(dim));			p.add(BorderLayout.NORTH, Box.createRigidArea(new Dimension(10, 10)));			p.add(BorderLayout.SOUTH, flowP);			p.add(BorderLayout.CENTER, aboutPanel);				closeBtn.setToolTipText(jEdit.getProperty("about.navigate"));			closeBtn.addKeyListener(new KeyAdapter()			{				public void keyPressed(KeyEvent e)				{					aboutPanel.handleKeyEvent(e);				}			});				setContentPane(p);			pack();			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();			setLocation((d.width-getWidth())/2, (d.height-getHeight())/2);			addWindowListener(new WindowAdapter()			{				@Override				public void windowClosing(WindowEvent e)				{					closeDialog();				}			});			setVisible(true);		}	
public void actionPerformed(ActionEvent e)		{			closeDialog();		}	
private void closeDialog()		{			AboutPanel.stopThread();			dispose();		}	
AboutPanel()			{				String mode;				if (jEdit.getEditServer() != null)				{					if (jEdit.isBackgroundModeEnabled())						mode = jEdit.getProperty("about.mode.server-background");					else						mode = jEdit.getProperty("about.mode.server");				}				else					mode = jEdit.getProperty("about.mode.standalone");				String[] args = { jEdit.getVersion(), mode, System.getProperty("java.version") };				sBottomLine = jEdit.getProperty("about.version",args);				setFont(defaultFont);				fm = getFontMetrics(defaultFont);				FontMetrics fmBottom = getFontMetrics(bottomLineFont);				iLineHeight = fm.getHeight();				vLines = new Vector<String>(50);				image = (ImageIcon)GUIUtilities.loadIcon("about.png");				MediaTracker tracker = new MediaTracker(this);				tracker.addImage(image.getImage(), 0);					try				{					tracker.waitForID(0);				}				catch(Exception exc)				{					tell("AboutPanel: " + exc);				}					Dimension d = new Dimension(image.getIconWidth(), image.getIconHeight());				setSize(d);				setPreferredSize(d);				w = d.width;				h = d.height;				iBottomLineXOffset = (w / 2) - (fmBottom.stringWidth(sBottomLine) / 2);				iBottomLineYOffset = h-iLineHeight/2;				StringTokenizer st = new StringTokenizer(					jEdit.getProperty("about.text"),"\n");				while(st.hasMoreTokens())				{					vLines.add(st.nextToken());				}					iLineCount = vLines.size();				iListHeight = iLineCount * iLineHeight;				startThread();				updateUI();			}	
private void handleKeyEvent(KeyEvent e)			{				if (e.getKeyCode() == KeyEvent.VK_DOWN)				{					skipDrain = false;					Collections.rotate(vLines, -1);				}				else if (e.getKeyCode() == KeyEvent.VK_UP)				{					skipDrain = false;					Collections.rotate(vLines, 1);				}				else if ((e.getKeyCode() == KeyEvent.VK_LEFT) ||						(e.getKeyCode() == KeyEvent.VK_RIGHT) ||						(e.getKeyCode() == KeyEvent.VK_ESCAPE))				{					skipDrain = ! skipDrain;				}			}	
private void drain()			{				if (skipDrain)					return;				if (bufImage == null)				{					//pre-computing all data that can be known at this time					Dimension d = getSize();					bufImage = new BufferedImage(d.width, d.height,						BufferedImage.TYPE_INT_RGB);					g = bufImage.createGraphics();					rectangle = new Rectangle2D.Float(0, iTopPadding,						d.width, d.height-iBottomPadding-iTopPadding);					//"+1" makes sure every new line from below comes up smoothly					//cause it gets pre-painted and clipped as needed					iPipeLineCount = 1 + (int)Math.ceil(rectangle.height/iLineHeight);					y = d.height+iBottomPadding;					g.setFont(defaultFont);					gradientPaint = new GradientPaint(						rectangle.width/2, iTopPadding+80, new Color(80, 80, 80),						rectangle.width/2, iTopPadding, new Color(205, 205, 205)						);					g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);				}					g.drawImage(image.getImage(), 0, 0, w, h, this);					g.setFont(bottomLineFont);					g.setPaint(new Color(55, 55, 55));				g.drawString(sBottomLine, iBottomLineXOffset, iBottomLineYOffset);				// Draw a highlight effect				g.setPaint(new Color(255, 255, 255, 50));				g.drawString(sBottomLine, iBottomLineXOffset + 1, iBottomLineYOffset + 1);					g.setFont(defaultFont);				g.setPaint(Color.black);						g.drawRect(0, 0, w-1, h-1);				g.clip(rectangle);				g.setPaint(gradientPaint);				int iDrawnLinesCount = 0, yCoor = 0;					for (int i=0; i<iLineCount; i++)				{					//check whether the text line is above the canvas, if so, the code skips it					yCoor = y+ i * iLineHeight;					if (yCoor < iTopPadding)					{						continue;					}						//good to go, now draw only iPipeLineCount lines and get out from loop					String sLine = vLines.get(i);					int x = (w - fm.stringWidth(sLine))/2;					g.drawString(sLine, x, yCoor);					if (++iDrawnLinesCount >= iPipeLineCount)					{						break;					}				}					y--;				paint(getGraphics());					//check if the end of the list has been reached,				//if so rewind				if ((y + iListHeight) < iTopPadding)				{					y = h+iBottomPadding;				}			}	
@Override			public void update(Graphics g)			{				paint(g);			}	
@Override			public void paint(Graphics panelGraphics)			{				if (panelGraphics != null && bufImage != null)				{					panelGraphics.drawImage(bufImage, 0, 0, w, h, this);				}			}	
public void run()			{				try				{					while(doWork)					{						drain();						Thread.sleep(SLEEP_TIME);					}				}				catch(Exception exc)				{					Log.log(Log.ERROR, this, exc);				}					doWork = false;				th = null;			}	
public void startThread()			{				if (th == null)				{					th = new Thread(this);					doWork = true;					th.start();				}			}	
public static void stopThread()			{				doWork = false;			}	
public static void tell(Object obj)			{				String str = obj == null ? "NULL" : obj.toString();				JOptionPane.showMessageDialog(jEdit.getActiveView(), str, "Title", 1);			}	
/**	     * Constructor that takes a name as an argument, for use by	     * subclasses.	     *	     * @param name Name of the option pane.	     * @param caption String to use as the caption of the context menu	     *                configuration list.	     *	     * @since jEdit 4.3pre13	     */	    protected AbstractContextOptionPane(String name, String caption)	    {	        super(name);	        this.caption = new JLabel(caption);	    }	
/**	     * Initializes the pane's UI.	     */	    protected void _init()	    {	        setLayout(new BorderLayout());		        add(BorderLayout.NORTH,caption);				listModel = new DefaultListModel();			reloadContextList(getContextMenu());				        list = new JList(listModel);	        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);	        list.addListSelectionListener(new ListHandler());		        add(BorderLayout.CENTER,new JScrollPane(list));		        buttons = new JPanel();	        buttons.setBorder(new EmptyBorder(3,0,0,0));	        buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));	        ActionHandler actionHandler = new ActionHandler();	        add = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.context.add.icon")));	        add.setToolTipText(jEdit.getProperty("common.add"));	        add.addActionListener(actionHandler);	        buttons.add(add);	        buttons.add(Box.createHorizontalStrut(6));	        remove = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.context.remove.icon")));	        remove.setToolTipText(jEdit.getProperty("common.remove"));	        remove.addActionListener(actionHandler);	        buttons.add(remove);	        buttons.add(Box.createHorizontalStrut(6));	        moveUp = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.context.moveUp.icon")));	        moveUp.setToolTipText(jEdit.getProperty("common.moveUp"));	        moveUp.addActionListener(actionHandler);	        buttons.add(moveUp);	        buttons.add(Box.createHorizontalStrut(6));	        moveDown = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.context.moveDown.icon")));	        moveDown.setToolTipText(jEdit.getProperty("common.moveDown"));	        moveDown.addActionListener(actionHandler);	        buttons.add(moveDown);	        buttons.add(Box.createGlue());				// add "reset to defaults" button			reset = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.context.reset.icon")));			reset.setToolTipText(jEdit.getProperty("options.context.reset"));			reset.addActionListener(actionHandler);			buttons.add(reset);				        updateButtons();	        add(BorderLayout.SOUTH,buttons);	    }	
/**	     * Adds a widget to the "buttons" panel at the bottom. The component	     * will be added at the very right of the button row (separated from	     * the normal buttons).	     *	     * @since jEdit 4.3pre13	     */	    protected void addButton(JComponent c)	    {	        buttons.add(c);	    }	
public int compare(MenuItem obj1, MenuItem obj2)	        {	            return StandardUtilities.compareStrings(obj1.label, obj2.label, true);	        }	
protected void _save()	    {	    	StringBuilder buf = new StringBuilder();	        for(int i = 0; i < listModel.getSize(); i++)	        {	            if(i != 0)	                buf.append(' ');	            buf.append(((MenuItem)listModel.elementAt(i)).actionName);	        }	        saveContextMenu(buf.toString());	    }	
private void updateButtons()	    {	        int index = list.getSelectedIndex();	        remove.setEnabled(index != -1 && listModel.getSize() != 0);	        moveUp.setEnabled(index > 0);	        moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);	    }	
private void reloadContextList(String contextMenu)		{			listModel.clear();			StringTokenizer st = new StringTokenizer(contextMenu);			while(st.hasMoreTokens())			{				String actionName = st.nextToken();				if(actionName.equals("-"))					listModel.addElement(new AbstractContextOptionPane.MenuItem("-","-"));				else				{					EditAction action = jEdit.getAction(actionName);					if(action == null)						continue;					String label = action.getLabel();					if(label == null)						continue;					listModel.addElement(new AbstractContextOptionPane.MenuItem(actionName,label));				}			}		}	
MenuItem(String actionName, String label)	        {	            this.actionName = actionName;	            this.label = GUIUtilities.prettifyMenuLabel(label);	        }	
public String toString()	        {	            return label;	        }	
public void actionPerformed(ActionEvent evt)	        {	            Object source = evt.getSource();		            if(source == add)	            {	                ContextAddDialog dialog = new ContextAddDialog(	                    AbstractContextOptionPane.this);	                String selection = dialog.getSelection();	                if(selection == null)	                    return;		                int index = list.getSelectedIndex();	                if(index == -1)	                    index = listModel.getSize();	                else	                    index++;		                MenuItem menuItem;	                if(selection.equals("-"))	                    menuItem = new AbstractContextOptionPane.MenuItem("-","-");	                else	                {	                    menuItem = new AbstractContextOptionPane.MenuItem(selection,	                        jEdit.getAction(selection)	                        .getLabel());	                }		                listModel.insertElementAt(menuItem,index);	                list.setSelectedIndex(index);	                list.ensureIndexIsVisible(index);	            }	            else if(source == remove)	            {	                int index = list.getSelectedIndex();	                listModel.removeElementAt(index);	                if(listModel.getSize() != 0)	                {	                    list.setSelectedIndex(	                        Math.min(listModel.getSize()-1,	                        index));	                }	                updateButtons();	            }	            else if(source == moveUp)	            {	                int index = list.getSelectedIndex();	                Object selected = list.getSelectedValue();	                listModel.removeElementAt(index);	                listModel.insertElementAt(selected,index-1);	                list.setSelectedIndex(index-1);	                list.ensureIndexIsVisible(index - 1);	            }	            else if(source == moveDown)	            {	                int index = list.getSelectedIndex();	                Object selected = list.getSelectedValue();	                listModel.removeElementAt(index);	                listModel.insertElementAt(selected,index+1);	                list.setSelectedIndex(index+1);	                list.ensureIndexIsVisible(index+1);	            }				else if(source == reset)				{					String dialogType = "options.context.reset.dialog";					int result = GUIUtilities.confirm(list,dialogType,null,						JOptionPane.YES_NO_OPTION,						JOptionPane.WARNING_MESSAGE);										if(result == JOptionPane.YES_OPTION)					{						// the user should be able to cancel the options dialog 						// so we need to modify the list, not the actual property						// since the default value is not available, 						// we reset, fetch default value and re-set to original						String orgContext = jEdit.getProperty("view.context");						jEdit.resetProperty("view.context");						String defaultContext = jEdit.getProperty("view.context");						jEdit.setProperty("view.context", orgContext);						reloadContextList(defaultContext);												// reset selection if user had more buttons than default						list.setSelectedIndex(0);						list.ensureIndexIsVisible(0);						updateButtons();					}				}	        }	
public void valueChanged(ListSelectionEvent evt)	        {	            updateButtons();	        }	
public AbstractInputHandler()		{			repeatCount = 1;		}	
/**		 * Adds a key binding to this input handler. The key binding is		 * a list of white space separated key strokes of the form		 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,		 * or S for Shift, and key is either a character (a-z) or a field		 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)		 * @param keyBinding The key binding		 * @param action The action		 * @since jEdit 4.2pre1		 */		public void addKeyBinding(String keyBinding, String action)		{			addKeyBinding(keyBinding,(Object)action);		}	
/**		 * Adds a key binding to this input handler. The key binding is		 * a list of white space separated key strokes of the form		 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,		 * or S for Shift, and key is either a character (a-z) or a field		 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)		 * @param keyBinding The key binding		 * @param action The action		 */		public void addKeyBinding(String keyBinding, E action)		{			addKeyBinding(keyBinding,(Object)action);		}	
/**		 * Adds a key binding to this input handler. The key binding is		 * a list of white space separated key strokes of the form		 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,		 * or S for Shift, and key is either a character (a-z) or a field		 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)		 * @param keyBinding The key binding		 * @param action The action		 * @since jEdit 4.3pre1		 */		public void addKeyBinding(String keyBinding, Object action)		{			Hashtable current = bindings;				String prefixStr = null;				StringTokenizer st = new StringTokenizer(keyBinding);			while(st.hasMoreTokens())			{				String keyCodeStr = st.nextToken();				if(prefixStr == null)					prefixStr = keyCodeStr;				else					prefixStr = prefixStr + " " + keyCodeStr;					KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(keyCodeStr);				if(keyStroke == null)					return;					if(st.hasMoreTokens())				{					Object o = current.get(keyStroke);					if(o instanceof Hashtable)						current = (Hashtable)o;					else					{						Hashtable hash = new Hashtable();						hash.put(PREFIX_STR,prefixStr);						o = hash;						current.put(keyStroke,o);						current = (Hashtable)o;					}				}				else					current.put(keyStroke,action);			}		}	
/**		 * Removes a key binding from this input handler. This is not yet		 * implemented.		 * @param keyBinding The key binding		 */		public void removeKeyBinding(String keyBinding)		{			Hashtable current = bindings;				StringTokenizer st = new StringTokenizer(keyBinding);			while(st.hasMoreTokens())			{				String keyCodeStr = st.nextToken();				KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(keyCodeStr);				if(keyStroke == null)					return;					if(st.hasMoreTokens())				{					Object o = current.get(keyStroke);					if(o instanceof Hashtable)						current = ((Hashtable)o);					else if(o != null)					{						// we have binding foo						// but user asks to remove foo bar?						current.remove(keyStroke);						return;					}					else					{						// user asks to remove non-existent						return;					}				}				else					current.remove(keyStroke);			}		}	
/**		 * Removes all key bindings from this input handler.		 */		public void removeAllKeyBindings()		{			bindings.clear();		}	
/**		 * Returns either an edit action, or a hashtable if the specified key		 * is a prefix.		 * @param keyBinding The key binding		 * @since jEdit 3.2pre5		 */		public Object getKeyBinding(String keyBinding)		{			Hashtable current = bindings;			StringTokenizer st = new StringTokenizer(keyBinding);				while(st.hasMoreTokens())			{				KeyEventTranslator.Key keyStroke = KeyEventTranslator.parseKey(					st.nextToken());				if(keyStroke == null)					return null;					if(st.hasMoreTokens())				{					Object o = current.get(keyStroke);					if(o instanceof Hashtable)					{						if(!st.hasMoreTokens())							return o;						else							current = (Hashtable)o;					}					else						return o;				}				else				{					return current.get(keyStroke);				}			}				return null;		}	
/**		 * Returns the number of times the last action was executed.		 * It can be used with smartHome and smartEnd		 * @return the number of times the last action was executed		 * @since jEdit 2.5pre5		 */		public int getLastActionCount()		{			return lastActionCount;		}	
/**		 * Resets the last action count. This should be called when an		 * editing operation that is not an action is invoked, for example		 * a mouse click.		 * @since jEdit 4.0pre1		 */		public void resetLastActionCount()		{			lastActionCount = 0;		}	
public KeyListener getKeyEventInterceptor()		{			return keyEventInterceptor;		}	
/**		 * Sets the listener that will handle all key events in this		 * view. For example, the complete word command uses this so		 * that all key events are passed to the word list popup while		 * it is visible.		 * @param keyEventInterceptor the KeyListener that will receive the events		 */		public void setKeyEventInterceptor(KeyListener keyEventInterceptor)		{			this.keyEventInterceptor = keyEventInterceptor;		}	
/**		 * Returns if a prefix key has been pressed.		 */		public boolean isPrefixActive()		{			return readNextChar != null;		}	
/**		 * Replace the set of key bindings.		 * @since jEdit 4.3pre1		 */		public void setBindings(Hashtable bindings)		{			this.bindings = this.currentBindings = bindings;		}	
public void setCurrentBindings(Hashtable bindings)		{			currentBindings = bindings;		}	
/**		 *  If 		 */		protected void sendShortcutPrefixOff()		{			if(shortcutOn)			{				ShortcutPrefixActiveEvent.firePrefixStateChange(null, false);				shortcutOn = false;			}		}	
/**		 * Return a String representation of the keyboard event for		 * debugging purpose.		 *		 * @param evt the keyboard event		 * @return a String representation for this keyboard event		 * @since jEdit 4.3pre15		 */		public static String toString(KeyEvent evt)		{			String id;			switch(evt.getID())			{			case KeyEvent.KEY_PRESSED:				id = "KEY_PRESSED";				break;			case KeyEvent.KEY_RELEASED:				id = "KEY_RELEASED";				break;			case KeyEvent.KEY_TYPED:				id = "KEY_TYPED";				break;			default:				id = "unknown type";				break;			}				StringBuilder b = new StringBuilder(50);				b.append(id);			b.append(",keyCode=0x").append(Integer.toString(evt.getKeyCode(), 16));			b.append(",keyChar=0x").append(Integer.toString(evt.getKeyChar(), 16));			b.append(",modifiers=0x").append(Integer.toString(evt.getModifiers(), 16));				b.append(",consumed=");			b.append(evt.isConsumed()?'1':'0');				return b.toString();		}	
/**		 *		 * @param evt the keyboard event		 * @param from the source, it can be {@link org.gjt.sp.jedit.View#VIEW},		 * {@link org.gjt.sp.jedit.View#ACTION_BAR} or {@link org.gjt.sp.jedit.View#TEXT_AREA}		 * @param mode the mode is "press" or "type" and is used for debug only  		 * @param global tell if the event comes from the DefaultKeyboardFocusManager or not		 */		protected void processKeyEventKeyStrokeHandling(KeyEvent evt, int from, String mode, boolean global)		{			KeyEventTranslator.Key keyStroke = KeyEventTranslator.translateKeyEvent2(evt);				if(keyStroke != null)			{				keyStroke.setIsFromGlobalContext(global);				if(Debug.DUMP_KEY_EVENTS)				{					Log.log(Log.DEBUG,this,"Translated (key "+mode+"): "+keyStroke+" from "+from);				}				boolean consumed = false;				if(handleKey(keyStroke,keyStroke.isPhantom()))				{					evt.consume();						consumed = true;				}				if(Debug.DUMP_KEY_EVENTS)				{					Log.log(Log.DEBUG,this,"Translated (key "+mode+"): "+keyStroke+" from "+from+": consumed="+consumed+'.');				}			}		}	
/**		 * Creates a new option pane.		 * @param internalName The internal name. The option pane's label is set to the		 * value of the property named <code>options.<i>name</i>.label</code>.		 */		public AbstractOptionPane(String internalName)		{			this.name = internalName;			setLayout(gridBag = new GridBagLayout());		}	
/**		 * Returns the internal name of this option pane. The option pane's label		 * is set to the value of the property named		 * <code>options.<i>name</i>.label</code>.		 */		@Override		public String getName()		{			return name;		}	
/**		 * Returns the component that should be displayed for this option pane.		 * Because this class extends Component, it simply returns "this".		 */		public Component getComponent()		{			return this;		}	
/**		 * Do not override this method, override {@link #_init()} instead.		 */		// final in 4.2		public void init()		{			if(!initialized)			{				initialized = true;				_init();			}		}	
/**		 * Do not override this method, override {@link #_save()} instead.		 */		// final in 4.2		public void save()		{			if(initialized)				_save();		}	
/**		 * @return a label which has the same tooltiptext as the Component		 *    that it is a label for. This is used to create labels from inside		 *    AbstractOptionPane.		 * @since jEdit 4.3pre4		 */		public JLabel newLabel(String label, Component comp)		{			JLabel retval = new JLabel(label);			try /* to get the tooltip of the component */			{				JComponent jc = (JComponent) comp;				String tttext = jc.getToolTipText();				retval.setToolTipText(tttext);			}			catch (Exception e)			{				/* There probably wasn't a tooltip,				 * or it wasn't a JComponent.				   We don't care. */			}			return retval;		}	
/**		 * Adds a labeled component to the option pane. Components are		 * added in a vertical fashion, one per row. The label is		 * displayed to the left of the component.		 * @param label The label		 * @param comp The component		 */		public void addComponent(String label, Component comp)		{			JLabel l = newLabel(label, comp);			l.setBorder(new EmptyBorder(0,0,0,12));			addComponent(l,comp,GridBagConstraints.BOTH);		}	
/**		 * Adds a labeled component to the option pane. Components are		 * added in a vertical fashion, one per row. The label is		 * displayed to the left of the component.		 * @param label The label		 * @param comp The component		 * @param fill Fill parameter to GridBagConstraints for the right		 * component		 */		public void addComponent(String label, Component comp, int fill)		{			JLabel l = newLabel(label, comp);			l.setBorder(new EmptyBorder(0,0,0,12));			addComponent(l,comp,fill);		}	
/**		 * Adds a labeled component to the option pane. Components are		 * added in a vertical fashion, one per row. The label is		 * displayed to the left of the component.		 * @param comp1 The label		 * @param comp2 The component		 *		 * @since jEdit 4.1pre3		 */		public void addComponent(Component comp1, Component comp2)		{			addComponent(comp1,comp2,GridBagConstraints.BOTH);		}	
/**		 * Adds a labeled component to the option pane. Components are		 * added in a vertical fashion, one per row. The label is		 * displayed to the left of the component.		 * @param comp1 The label		 * @param comp2 The component		 * @param fill Fill parameter to GridBagConstraints for the right		 * component		 *		 * @since jEdit 4.1pre3		 */		public void addComponent(Component comp1, Component comp2, int fill)		{			copyToolTips(comp1, comp2);			GridBagConstraints cons = new GridBagConstraints();			cons.gridy = y++;			cons.gridheight = 1;			cons.gridwidth = 1;			cons.weightx = 0.0f;			cons.insets = new Insets(1,0,1,0);			cons.fill = GridBagConstraints.BOTH;				gridBag.setConstraints(comp1,cons);			add(comp1);				cons.fill = fill;			cons.gridx = 1;			cons.weightx = 1.0f;			gridBag.setConstraints(comp2,cons);			add(comp2);		}	
/**		 * Adds a component to the option pane. Components are		 * added in a vertical fashion, one per row.		 * @param comp The component		 */		public void addComponent(Component comp)		{			GridBagConstraints cons = new GridBagConstraints();			cons.gridy = y++;			cons.gridheight = 1;			cons.gridwidth = GridBagConstraints.REMAINDER;			cons.fill = GridBagConstraints.NONE;			cons.anchor = GridBagConstraints.WEST;			cons.weightx = 1.0f;			cons.insets = new Insets(1,0,1,0);				gridBag.setConstraints(comp,cons);			add(comp);		}	
/**		 * Adds a component to the option pane. Components are		 * added in a vertical fashion, one per row.		 * @param comp The component		 * @param fill Fill parameter to GridBagConstraints		 * @since jEdit 4.2pre2		 */		public void addComponent(Component comp, int fill)		{			GridBagConstraints cons = new GridBagConstraints();			cons.gridy = y++;			cons.gridheight = 1;			cons.gridwidth = GridBagConstraints.REMAINDER;			cons.fill = fill;			cons.anchor = GridBagConstraints.WEST;			cons.weightx = 1.0f;			cons.insets = new Insets(1,0,1,0);				gridBag.setConstraints(comp,cons);			add(comp);		}	
private static void copyToolTips(Component c1, Component c2)		{			int tooltips = 0;			int jc = 0;			String text = null;			JComponent jc1 = null;			try			{				jc1 = (JComponent) c1;				text = jc1.getToolTipText();				++jc;				if (text != null && text.length() > 0)					tooltips++;			}			catch (Exception e)			{			}				JComponent jc2 = null;			try			{				jc2 = (JComponent) c2;				String text2 = jc2.getToolTipText();				++jc;				if (text2 != null && text2.length() > 0)				{					text = text2;					tooltips++;				}			}			catch (Exception e)			{			}				if (tooltips == 1 && jc == 2)			{				jc1.setToolTipText(text);				jc2.setToolTipText(text);			}			}	
/**		 * Adds a separator component.		 * @since jEdit 4.1pre7		 */		public void addSeparator()		{			addComponent(Box.createVerticalStrut(6));				JSeparator sep = new JSeparator(SwingConstants.HORIZONTAL);				GridBagConstraints cons = new GridBagConstraints();			cons.gridy = y++;			cons.gridheight = 1;			cons.gridwidth = GridBagConstraints.REMAINDER;			cons.fill = GridBagConstraints.BOTH;			cons.anchor = GridBagConstraints.WEST;			cons.weightx = 1.0f;			//cons.insets = new Insets(1,0,1,0);				gridBag.setConstraints(sep,cons);			add(sep);				addComponent(Box.createVerticalStrut(6));		}	
/**		 * Adds a separator component.		 * @param label The separator label property		 * @since jEdit 2.6pre2		 */		public void addSeparator(String label)		{			if(y != 0)				addComponent(Box.createVerticalStrut(6));				Box box = new Box(BoxLayout.X_AXIS);			Box box2 = new Box(BoxLayout.Y_AXIS);			box2.add(Box.createGlue());			box2.add(new JSeparator(SwingConstants.HORIZONTAL));			box2.add(Box.createGlue());			box.add(box2);			JLabel l = new JLabel(jEdit.getProperty(label));			l.setMaximumSize(l.getPreferredSize());			box.add(l);			Box box3 = new Box(BoxLayout.Y_AXIS);			box3.add(Box.createGlue());			box3.add(new JSeparator(SwingConstants.HORIZONTAL));			box3.add(Box.createGlue());			box.add(box3);				GridBagConstraints cons = new GridBagConstraints();			cons.gridy = y++;			cons.gridheight = 1;			cons.gridwidth = GridBagConstraints.REMAINDER;			cons.fill = GridBagConstraints.BOTH;			cons.anchor = GridBagConstraints.WEST;			cons.weightx = 1.0f;			cons.insets = new Insets(1,0,1,0);				gridBag.setConstraints(box,cons);			add(box);		}	
/**		 * This method should create and arrange the components of the option pane		 * and initialize the option data displayed to the user. This method		 * is called when the option pane is first displayed, and is not		 * called again for the lifetime of the object.		 */		protected void _init() {}	
/**		 * Called when the options dialog's "ok" button is clicked.		 * This should save any properties being edited in this option		 * pane.		 */		protected void _save() {}	
public ActionBar(View view, boolean temp)		{			this.view = view;			this.temp = temp;						setLayout(new BoxLayout(this,BoxLayout.X_AXIS));			setFloatable(false);			add(Box.createHorizontalStrut(2));				JLabel label = new JLabel(jEdit.getProperty("view.action.prompt"));			add(label);			add(Box.createHorizontalStrut(12));			add(action = new ActionTextField());			action.setEnterAddsToHistory(false);			Dimension max = action.getPreferredSize();			max.width = Integer.MAX_VALUE;			action.setMaximumSize(max);			action.addActionListener(new ActionHandler());			action.getDocument().addDocumentListener(new DocumentHandler());				if(temp)			{				close = new RolloverButton(GUIUtilities.loadIcon("closebox.gif"));				close.addActionListener(new ActionHandler());				close.setToolTipText(jEdit.getProperty(					"view.action.close-tooltip"));				add(close);			}				// if 'temp' is true, hide search bar after user is done with it			this.temp = temp;		}	
public HistoryTextField getField()		{			return action;		}	
public void goToActionBar()		{			repeatCount = view.getInputHandler().getRepeatCount();			action.setText(null);			action.requestFocus();		}	
private void invoke()		{			String cmd;			if(popup != null)				cmd = popup.list.getSelectedValue().toString();			else			{				cmd = action.getText().trim();				int index = cmd.indexOf('=');				if(index != -1)				{					action.addCurrentToHistory();					String propName = cmd.substring(0,index).trim();					String propValue = cmd.substring(index + 1).trim();					String code;					/* construct a BeanShell snippet instead of					 * invoking directly so that user can record					 * property changes in macros. */					if(propName.startsWith("buffer."))					{						if(propName.equals("buffer.mode"))						{							code = "buffer.setMode(\""								+ StandardUtilities.charsToEscapes(								propValue) + "\");";						}						else						{							code = "buffer.setStringProperty(\""								+ StandardUtilities.charsToEscapes(								propName.substring("buffer.".length())								) + "\",\""								+ StandardUtilities.charsToEscapes(								propValue) + "\");";						}							code += "\nbuffer.propertiesChanged();";					}					else if(propName.startsWith("!buffer."))					{						code = "jEdit.setProperty(\""							+ StandardUtilities.charsToEscapes(							propName.substring(1)) + "\",\""							+ StandardUtilities.charsToEscapes(							propValue) + "\");\n"							+ "jEdit.propertiesChanged();";					}					else					{						code = "jEdit.setProperty(\""							+ StandardUtilities.charsToEscapes(							propName) + "\",\""							+ StandardUtilities.charsToEscapes(							propValue) + "\");\n"							+ "jEdit.propertiesChanged();";					}						Macros.Recorder recorder = view.getMacroRecorder();					if(recorder != null)						recorder.record(code);					BeanShell.eval(view,namespace,code);					cmd = null;				}				else if(cmd.length() != 0)				{					String[] completions = getCompletions(cmd);					if(completions.length != 0)					{						cmd = completions[0];					}				}				else					cmd = null;			}				if(popup != null)			{				popup.dispose();				popup = null;			}				final String finalCmd = cmd;			final EditAction act = (finalCmd == null ? null : jEdit.getAction(finalCmd));			if(temp)				view.removeToolBar(this);				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					view.getTextArea().requestFocus();					if(act == null)					{						if(finalCmd != null)						{							view.getStatus().setMessageAndClear(								jEdit.getProperty(								"view.action.no-completions"));						}					}					else					{						view.getInputHandler().setRepeatCount(repeatCount);						view.getInputHandler().invokeAction(act);					}				}			});		}	
private static String[] getCompletions(String str)		{			str = str.toLowerCase();			String[] actions = jEdit.getActionNames();			ArrayList<String> returnValue = new ArrayList<String>(actions.length);			for(int i = 0; i < actions.length; i++)			{				if(actions[i].toLowerCase().contains(str))					returnValue.add(actions[i]);			}				return returnValue.toArray(new String[returnValue.size()]);		}	
private void complete(boolean insertLongestPrefix)		{			String text = action.getText().trim();			String[] completions = getCompletions(text);			if(completions.length == 1)			{				if(insertLongestPrefix)					action.setText(completions[0]);			}			else if(completions.length != 0)			{				if(insertLongestPrefix)				{					String prefix = MiscUtilities.getLongestPrefix(						completions,true);					if(prefix.contains(text))						action.setText(prefix);				}					if(popup != null)					popup.setModel(completions);				else					popup = new CompletionPopup(completions);				return;			}				if(popup != null)			{				popup.dispose();				popup = null;			}		}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == close)					view.removeToolBar(ActionBar.this);				else					invoke();			}	
public void insertUpdate(DocumentEvent evt)			{				if(popup != null)					complete(false);			}	
public void removeUpdate(DocumentEvent evt)			{				if(popup != null)					complete(false);			}	
public void changedUpdate(DocumentEvent evt) {}	
ActionTextField()			{				super("action");				setSelectAllOnFocus(true);			}	
@Override			public boolean isManagingFocus()			{				return false;			}	
@Override			public boolean getFocusTraversalKeysEnabled()			{				return false;			}	
@Override			public void processKeyEvent(KeyEvent evt)			{				evt = KeyEventWorkaround.processKeyEvent(evt);				if(evt == null)					return;					switch(evt.getID())				{				case KeyEvent.KEY_TYPED:					char ch = evt.getKeyChar();					if(!nonDigit && Character.isDigit(ch))					{						super.processKeyEvent(evt);						repeat = true;						repeatCount = Integer.parseInt(action.getText());					}					else					{						nonDigit = true;						if(repeat)						{							passToView(evt);						}						else							super.processKeyEvent(evt);					}					break;				case KeyEvent.KEY_PRESSED:					int keyCode = evt.getKeyCode();					if(evt.isActionKey()						|| evt.isControlDown()						|| evt.isAltDown()						|| evt.isMetaDown()						|| keyCode == KeyEvent.VK_BACK_SPACE						|| keyCode == KeyEvent.VK_DELETE						|| keyCode == KeyEvent.VK_ENTER						|| keyCode == KeyEvent.VK_TAB						|| keyCode == KeyEvent.VK_ESCAPE)					{						nonDigit = true;						if(repeat)						{							passToView(evt);							break;						}						else if(keyCode == KeyEvent.VK_TAB)						{							complete(true);							evt.consume();						}						else if(keyCode == KeyEvent.VK_ESCAPE)						{							evt.consume();							if(popup != null)							{								popup.dispose();								popup = null;								action.requestFocus();							}							else							{								if(temp)									view.removeToolBar(ActionBar.this);								view.getEditPane().focusOnTextArea();							}							break;						}						else if((keyCode == KeyEvent.VK_UP							|| keyCode == KeyEvent.VK_DOWN)							&& popup != null)						{							popup.list.processKeyEvent(evt);							break;						}					}					super.processKeyEvent(evt);					break;				}			}	
private void passToView(final KeyEvent evt)			{				if(temp)					view.removeToolBar(ActionBar.this);				view.getTextArea().requestFocus();				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						view.getTextArea().requestFocus();						view.getInputHandler().setRepeatCount(repeatCount);						view.getInputHandler().processKeyEvent(evt,							View.ACTION_BAR, false);					}				});			}	
@Override			public void addNotify()			{				super.addNotify();				repeat = nonDigit = false;			}	
CompletionPopup(String[] actions)			{				super(view);					setContentPane(new JPanel(new BorderLayout())				{					/**					 * Returns if this component can be traversed by pressing the					 * Tab key. This returns false.					 */					@Override					public boolean isManagingFocus()					{						return false;					}						/**					 * Makes the tab key work in Java 1.4.					 */					@Override					public boolean getFocusTraversalKeysEnabled()					{						return false;					}				});					list = new CompletionList(actions);				list.setVisibleRowCount(8);				list.addMouseListener(new MouseHandler());				list.setSelectedIndex(0);				list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);					// stupid scrollbar policy is an attempt to work around				// bugs people have been seeing with IBM's JDK -- 7 Sep 2000				JScrollPane scroller = new JScrollPane(list,					ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,					ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);					getContentPane().add(scroller, BorderLayout.CENTER);					GUIUtilities.requestFocus(this,list);					pack();				Point p = new Point(0,-getHeight());				SwingUtilities.convertPointToScreen(p,action);				setLocation(p);				setVisible(true);					KeyHandler keyHandler = new KeyHandler();				addKeyListener(keyHandler);				list.addKeyListener(keyHandler);			}	
void setModel(String[] actions)			{				list.setListData(actions);				list.setSelectedIndex(0);			}	
@Override				public void mouseClicked(MouseEvent evt)				{					invoke();				}	
CompletionList(Object[] data)				{					super(data);				}	
					// we need this public not protected				@Override				public void processKeyEvent(KeyEvent evt)				{					super.processKeyEvent(evt);				}	
@Override				public void keyTyped(KeyEvent evt)				{					action.processKeyEvent(evt);				}	
@Override				public void keyPressed(KeyEvent evt)				{					int keyCode = evt.getKeyCode();					if(keyCode == KeyEvent.VK_ESCAPE)						action.processKeyEvent(evt);					else if(keyCode == KeyEvent.VK_ENTER)						invoke();					else if(keyCode == KeyEvent.VK_UP)					{						int selected = list.getSelectedIndex();						if(selected == 0)						{							list.setSelectedIndex(								list.getModel().getSize()								- 1);							evt.consume();						}					}					else if(keyCode == KeyEvent.VK_DOWN)					{						int selected = list.getSelectedIndex();						if(selected == list.getModel().getSize() - 1)						{							list.setSelectedIndex(0);							evt.consume();						}					}				}	
/**		 * Returns the action set that contains the specified action.		 * This method is still here for binary compatility		 *		 * @param action The action		 * @return the actionSet that contains the given action		 * @since jEdit 4.2pre1		 */		@Override		public ActionSet getActionSetForAction(String action)		{			return super.getActionSetForAction(action);		}	
/**		 * Returns the specified action.		 * @param name The action name		 * @return a EditAction or null if it doesn't exist		 * @since jEdit 4.2pre1		 */		@Override		public EditAction getAction(String name)		{			return super.getAction(name);		}	
ActionListHandler(String path, JEditActionSet actionSet)		{			this.path = path;			this.actionSet = actionSet;			stateStack = new Stack<String>();			code = new StringBuilder();			isSelected = new StringBuilder();		}	
@Override		public InputSource resolveEntity(String publicId, String systemId)		{			return XMLUtilities.findEntity(systemId, "actions.dtd", getClass());		}	
public void attribute(String aname, String value, boolean isSpecified)		{			aname = (aname == null) ? null : aname.intern();			value = (value == null) ? null : value.intern();				if(aname == "NAME")				actionName = value;			else if(aname == "NO_REPEAT")				noRepeat = (value == "TRUE");			else if(aname == "NO_RECORD")				noRecord = (value == "TRUE");			else if(aname == "NO_REMEMBER_LAST")				noRememberLast = (value == "TRUE");		}	
@Override		public void characters(char[] c, int off, int len)		{			String tag = peekElement();			if (tag.equals("CODE"))			{				code.append(c, off, len);			}			else if (tag.equals("IS_SELECTED"))			{				isSelected.append(c, off, len);			}		}	
@Override		public void startElement(String uri, String localName,					 String qName, Attributes attrs)		{			String tag = pushElement(qName);				if (tag.equals("ACTION"))			{				actionName = attrs.getValue("NAME");				noRepeat = "TRUE".equals(attrs.getValue("NO_REPEAT"));				noRecord = "TRUE".equals(attrs.getValue("NO_RECORD"));				noRememberLast = "TRUE".equals(attrs.getValue("NO_REMEMBER_LAST"));				code.setLength(0);				isSelected.setLength(0);			}		}	
@Override		public void endElement(String uri, String localName, String qName)		{			String tag = peekElement();				if (qName.equals(tag))			{				if (tag.equals("ACTION"))				{					String selected = (isSelected.length() > 0) ?						isSelected.toString() : null;					JEditAbstractEditAction action = 						actionSet.createBeanShellAction(actionName,										code.toString(),										selected,										noRepeat,										noRecord,										noRememberLast);					actionSet.addAction(action);					noRepeat = noRecord = noRememberLast = false;					code.setLength(0);					isSelected.setLength(0);				}					popElement();			}			else			{				// can't happen				throw new InternalError();			}		}	
@Override		public void startDocument()		{			try			{				pushElement(null);			}			catch (Exception e)			{				Log.log(Log.ERROR,this, e);			}		}	
private String pushElement(String name)		{			name = (name == null) ? null : name.intern();				stateStack.push(name);				return name;		}	
private String peekElement()		{			return stateStack.peek();		}	
private String popElement()		{			return stateStack.pop();		}	
/**		 * Creates a new action set.		 * @since jEdit 4.0pre1		 */		public ActionSet()		{			label = "<no label set; plugin bug>";		}	
/**		 * Creates a new action set.		 * @param plugin The plugin		 * @param cachedActionNames The list of cached action names		 * @param cachedActionToggleFlags The list of cached action toggle flags		 * @param uri The actions.xml URI		 * @since jEdit 4.2pre2		 */		public ActionSet(PluginJAR plugin, String[] cachedActionNames,			boolean[] cachedActionToggleFlags, URL uri)		{			this();			this.plugin = plugin;			this.uri = uri;			if(cachedActionNames != null)			{				for(int i = 0; i < cachedActionNames.length; i++)				{					actions.put(cachedActionNames[i],placeholder);					jEdit.setTemporaryProperty(cachedActionNames[i]						+ ".toggle",cachedActionToggleFlags[i]						? "true" : "false");				}			}			loaded = false;		}	
/**		 * Adds an action to the action set.		 * It exists for binary compatibility issues		 * @param action The action		 * @since jEdit 4.0pre1		 */		@Override		public void addAction(EditAction action)		{			super.addAction(action);		}	
protected EditAction[] getArray(int size)		{			return new EditAction[size];		}	
/**		 * Returns an array of all actions in this action set.<p>		 *		 * <b>Deferred loading:</b> this will load the action set if necessary.		 *		 * @since jEdit 4.0pre1		 */		@Override		public EditAction[] getActions()		{			return super.getActions();		}	
/**		 * Creates a new action set.		 * @param label The label, shown in the shortcuts option pane		 * @since jEdit 4.0pre1		 */		public ActionSet(String label)		{			this();			setLabel(label);		}	
/**		 * Return the action source label.		 * @since jEdit 4.0pre1		 */		public String getLabel()		{			return label;		}	
/**		 * Sets the action source label.		 * @param label The label		 * @since jEdit 4.0pre1		 */		public void setLabel(String label)		{			if(label == null)				throw new NullPointerException();			this.label = label;		}	
/**		 * Return the plugin this action set was loaded from, or null.		 * @since jEdit 4.2pre13		 */		public PluginJAR getPluginJAR()		{			return plugin;		}	
/**		 * Returns an array of all action names in this action set that should		 * be cached; namely, <code>BeanShellAction</code>s.		 * @since jEdit 4.2pre1		 */		@Override		public String[] getCacheableActionNames()		{			LinkedList<String> retVal = new LinkedList<String>();			Enumeration e = actions.elements();			while(e.hasMoreElements())			{				Object obj = e.nextElement();				if(obj == placeholder)				{					// ??? this should only be called with					// fully loaded action set					Log.log(Log.WARNING,this,"Action set not up "						+ "to date");				}				else if(obj instanceof BeanShellAction)					retVal.add(((BeanShellAction)obj).getName());			}			return retVal.toArray(new String[retVal.size()]);		}	
protected String getProperty(String name)		{			return jEdit.getProperty(name);		}	
public AbstractInputHandler getInputHandler()		{			return jEdit.getInputHandler();		}	
public int compareTo(Object o)		{			return label.compareTo(((ActionSet)o).label);		}	
@Override		public String toString()		{			return label;		}	
/**		 * Creates a BeanShellAction.		 * @since 4.3pre13		 */		 protected EditAction createBeanShellAction(String actionName,							    String code,							    String selected,							    boolean noRepeat,							    boolean noRecord,							    boolean noRememberLast)		{			return new BeanShellAction(actionName,code,selected,noRepeat,noRecord,noRememberLast);		}	
public AddAbbrevDialog(View view, String abbrev)		{			super(view,jEdit.getProperty("add-abbrev.title"),true);				this.view = view;				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				editor = new AbbrevEditor();			editor.setAbbrev(abbrev);			editor.setBorder(new EmptyBorder(6,0,12,0));			content.add(BorderLayout.CENTER,editor);				Box box = new Box(BoxLayout.X_AXIS);			box.add(Box.createGlue());			global = new JButton(jEdit.getProperty("add-abbrev.global"));			global.addActionListener(new ActionHandler());			box.add(global);			box.add(Box.createHorizontalStrut(6));			modeSpecific = new JButton(jEdit.getProperty("add-abbrev.mode"));			modeSpecific.addActionListener(new ActionHandler());			box.add(modeSpecific);			box.add(Box.createHorizontalStrut(6));			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(new ActionHandler());			box.add(cancel);			box.add(Box.createGlue());			content.add(BorderLayout.SOUTH,box);				KeyListener listener = new KeyHandler();			addKeyListener(listener);			editor.getBeforeCaretTextArea().addKeyListener(listener);			editor.getAfterCaretTextArea().addKeyListener(listener);				setDefaultCloseOperation(DISPOSE_ON_CLOSE);				if(abbrev == null)				GUIUtilities.requestFocus(this,editor.getAbbrevField());			else				GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());				pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == global)				{					String _abbrev = editor.getAbbrev();					if(_abbrev == null || _abbrev.length() == 0)					{						getToolkit().beep();						return;					}					Abbrevs.addGlobalAbbrev(_abbrev,editor.getExpansion());					Abbrevs.expandAbbrev(view,false);				}				else if(source == modeSpecific)				{					String _abbrev = editor.getAbbrev();					if(_abbrev == null || _abbrev.length() == 0)					{						getToolkit().beep();						return;					}					Abbrevs.addModeAbbrev(view.getBuffer().getMode().getName(),						_abbrev,editor.getExpansion());					Abbrevs.expandAbbrev(view,false);				}					dispose();			}	
public void keyPressed(KeyEvent evt)			{				if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)					dispose();			}	
/**		 * Creates a new all buffer set.		 * @param glob The filename glob		 * @since jEdit 2.7pre3		 */		public AllBufferSet(String glob)		{			this.glob = glob;		}	
/**		 * Returns the filename filter.		 * @since jEdit 2.7pre3		 */		public String getFileFilter()		{			return glob;		}	
/**		 * Returns the BeanShell code that will recreate this file set.		 * @since jEdit 2.7pre3		 */		@Override		public String getCode()		{			return "new AllBufferSet(\"" + StandardUtilities.charsToEscapes(glob)				+ "\")";		}	
@Override		protected String[] _getFiles(Component comp)		{			Buffer[] buffers = jEdit.getBuffers();			List<String> returnValue = new ArrayList<String>(buffers.length);				Pattern filter;			try			{				filter = Pattern.compile(StandardUtilities.globToRE(glob),					Pattern.CASE_INSENSITIVE);			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);				return null;			}				for(int i = 0; i < buffers.length; i++)			{				Buffer buffer = buffers[i];				if(filter.matcher(buffer.getName()).matches())					returnValue.add(buffer.getPath());			}				return returnValue.toArray(new String[returnValue.size()]);		}	
protected Anchor(DisplayManager displayManager,			TextArea textArea)		{			this.displayManager = displayManager;			this.textArea = textArea;		}	
@Override		public String toString()		{			return getClass().getName() + '[' + physicalLine + ','			       + scrollLine + ']';		}	
/**		 * Some content is inserted.		 *		 * @param startLine the start of the insert		 * @param numLines the number of insterted lines		 */		void contentInserted(int startLine, int numLines)		{			// The Anchor is changed only if the content was inserted before			if(physicalLine >= startLine)			{				if(physicalLine != startLine)					physicalLine += numLines;				callChanged = true;			}		}	
/**		 * Method called before a content is removed from a buffer.		 *		 * @param startLine the first line of the removed content		 * @param offset the offset in the start line		 * @param numLines the number of removed lines		 */		void preContentRemoved(int startLine, int offset, int numLines)		{			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"preContentRemoved() before:" + this);			// The removed content starts before the Anchor, we need to pull the anchor up			if(physicalLine >= startLine)			{				if(physicalLine == startLine)					callChanged = true;				else				{					int end = Math.min(startLine + numLines, physicalLine);					//Check the lines from the beginning of the removed content to the end (or the physical					//line of the Anchor if it is before the end of the removed content						//int loopStart = startLine + 1;						//{{{ treatment if the beginning of the deleted content is inside a physical line that has several line counts					/*if (displayManager.isLineVisible(startLine))					{						int screenLineCount = displayManager.screenLineMgr.getScreenLineCount(startLine);						if (screenLineCount > 1)						{							int lineStartOffset = textArea.getLineStartOffset(startLine);								int startScreenLine = textArea.getScreenLineOfOffset(lineStartOffset);							int deleteStartScreenLine = textArea.getScreenLineOfOffset(offset);							if (startScreenLine != deleteStartScreenLine)							{								loopStart = startLine + 2;								scrollLine -= screenLineCount - deleteStartScreenLine + startScreenLine;							}						}					}*/					//}}}						for(int i = startLine + 1; i <= end; i++)					{						//XXX						if(displayManager.isLineVisible(i))						{							scrollLine -=								displayManager									.screenLineMgr									.getScreenLineCount(i);						}					}					physicalLine -= end - startLine;					callChanged = true;				}			}			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"preContentRemoved() after:" + this);		}	
/**		 * @param frames The frames to be used in the animation		 * @param rate The frame rate of the animation, in frames per second		 * @param host The container that the animation is used in		 */		public AnimatedIcon(Image icon, Image[] frames, int rate, Component host)		{			super(icon);			this.icon = icon;			this.frames = frames;			delay = 1000/rate;			this.host = host;		}	
public Image[] getFrames()		{			return frames;		}	
public Image getIcon()		{			return icon;		}	
public int getRate()		{			return 1000/delay;		}	
public void setFrames(Image[] frames)		{			this.frames = frames;		}	
public void setIcon(Image icon)		{			this.icon = icon;		}	
public void setRate(int rate)		{			delay = 1000/rate;		}	
/**		 * Starts the animation rolling		 */		public void start()		{			if(timer != null)				return;				timer = new Timer(delay,new Animator());			timer.start();		}	
/**		 * Stops the animation, and resets to frame 0		 */		public void stop()		{			current = 0;			if(timer != null)			{				timer.stop();				timer = null;			}				setImage(icon);			host.repaint();		}	
public void actionPerformed(ActionEvent evt)			{				current = (current + 1) % frames.length;				setImage(frames[current]);				host.repaint();			}	
public void set(int newValue)		{			m_val = newValue;		}	
public AntiAlias(boolean isEnabled)		{			m_val = isEnabled ? 1 : 0;		}	
public AntiAlias(int val)		{			m_val = val;		}	
public AntiAlias(String v)		{			fromString(v);		}	
public boolean equals(Object other)		{			return toString().equals(other.toString());			}	
public void fromString(String v)		{			for (int i = 0; i < comboChoices.length; ++i)			{				if (comboChoices[i].equals(v))				{					m_val = i;				}			}		}	
public String toString()		{			return comboChoices[m_val].toString();		}	
public int val()		{			return m_val;		}	
public AppearanceOptionPane()		{			super("appearance");		}	
@Override		protected void _init()		{			/* Look and feel */			addComponent(new JLabel(jEdit.getProperty("options.appearance.lf.note")));				lfs = UIManager.getInstalledLookAndFeels();			String[] names = new String[lfs.length];			String lf = UIManager.getLookAndFeel().getClass().getName();			int index = 0;			for(int i = 0; i < names.length; i++)			{				names[i] = lfs[i].getName();				if(lf.equals(lfs[i].getClassName()))					index = i;			}				lookAndFeel = new JComboBox(names);			lookAndFeel.setSelectedIndex(index);			lookAndFeel.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					updateEnabled();				}			});							addComponent(jEdit.getProperty("options.appearance.lf"),				lookAndFeel);			addDockingFrameworkChooser();				/* Icon Theme */			String[] themes = IconTheme.builtInNames();			iconThemes = new JComboBox(themes);			addComponent(jEdit.getProperty("options.appearance.iconTheme"), iconThemes);			oldTheme = IconTheme.get();			for (int i=0; i<themes.length; ++i)			{				if (themes[i].equals(oldTheme))				{					iconThemes.setSelectedIndex(i);					break;				}			}						/* Primary Metal L&F font */			primaryFont = new FontSelector(jEdit.getFontProperty(				"metal.primary.font"));			addComponent(jEdit.getProperty("options.appearance.primaryFont"),				primaryFont);				/* Secondary Metal L&F font */			secondaryFont = new FontSelector(jEdit.getFontProperty(				"metal.secondary.font"));			addComponent(jEdit.getProperty("options.appearance.secondaryFont"),				secondaryFont);				/*			antiAliasExtras = new JComboBox(AntiAlias.comboChoices);			antiAliasExtras.setSelectedIndex(AntiAlias.appearance().val());			antiAliasExtras.setToolTipText(jEdit.getProperty("options.textarea.antiAlias.tooltip"));			addComponent(jEdit.getProperty("options.appearance.fonts.antialias"), antiAliasExtras);			*/			updateEnabled();				/* History count */			history = new NumericTextField(jEdit.getProperty("history"), true);			addComponent(jEdit.getProperty("options.appearance.history"),history);				/* Menu spillover count */			menuSpillover = new NumericTextField(jEdit.getProperty("menu.spillover"), true);			addComponent(jEdit.getProperty("options.appearance.menuSpillover"),menuSpillover);				continuousLayout = new JCheckBox(jEdit.getProperty(				"options.appearance.continuousLayout.label"));			continuousLayout.setSelected(jEdit.getBooleanProperty("appearance.continuousLayout"));			addComponent(continuousLayout);				addSeparator("options.appearance.startup.label");				/* Show splash screen */			showSplash = new JCheckBox(jEdit.getProperty(				"options.appearance.showSplash"));			String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory == null)				showSplash.setSelected(true);			else				showSplash.setSelected(!new File(settingsDirectory,"nosplash").exists());			addComponent(showSplash);				/* Show tip of the day */			showTips = new JCheckBox(jEdit.getProperty(				"options.appearance.showTips"));			showTips.setSelected(jEdit.getBooleanProperty("tip.show"));			addComponent(showTips);				addSeparator("options.appearance.experimental.label");			addComponent(GUIUtilities.createMultilineLabel(				jEdit.getProperty("options.appearance.experimental.caption")));				/* Use jEdit colors in all text components */			textColors = new JCheckBox(jEdit.getProperty(				"options.appearance.textColors"));			textColors.setSelected(jEdit.getBooleanProperty("textColors"));			addComponent(textColors);				/* Decorate frames with look and feel (JDK 1.4 only) */			decorateFrames = new JCheckBox(jEdit.getProperty(				"options.appearance.decorateFrames"));			decorateFrames.setSelected(jEdit.getBooleanProperty("decorate.frames"));			addComponent(decorateFrames);				/* Decorate dialogs with look and feel (JDK 1.4 only) */			decorateDialogs = new JCheckBox(jEdit.getProperty(				"options.appearance.decorateDialogs"));			decorateDialogs.setSelected(jEdit.getBooleanProperty("decorate.dialogs"));			addComponent(decorateDialogs);		}	
@Override		protected void _save()		{			String lf = lfs[lookAndFeel.getSelectedIndex()].getClassName();			jEdit.setProperty("lookAndFeel",lf);			jEdit.setFontProperty("metal.primary.font",primaryFont.getFont());			jEdit.setFontProperty("metal.secondary.font",secondaryFont.getFont());			jEdit.setProperty("history",history.getText());			jEdit.setProperty("menu.spillover",menuSpillover.getText());			jEdit.setBooleanProperty("tip.show",showTips.isSelected());			jEdit.setBooleanProperty("appearance.continuousLayout",continuousLayout.isSelected());			IconTheme.set(iconThemes.getSelectedItem().toString());				jEdit.setProperty(View.VIEW_DOCKING_FRAMEWORK_PROPERTY,				(String) dockingFramework.getSelectedItem());				/* AntiAlias nv = AntiAlias.appearance();			 int idx = antiAliasExtras.getSelectedIndex();			nv.set(idx);			primaryFont.setAntiAliasEnabled(idx > 0);			secondaryFont.setAntiAliasEnabled(idx > 0);			primaryFont.repaint();			secondaryFont.repaint(); */				// this is handled a little differently from other jEdit settings			// as the splash screen flag needs to be known very early in the			// startup sequence, before the user properties have been loaded			String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory != null)			{				File file = new File(settingsDirectory,"nosplash");				if(showSplash.isSelected())					file.delete();				else				{					FileOutputStream out = null;					try					{						out = new FileOutputStream(file);						out.write('\n');						out.close();					}					catch(IOException io)					{						Log.log(Log.ERROR,this,io);					}					finally					{						IOUtilities.closeQuietly(out);					}				}			}			jEdit.setBooleanProperty("textColors",textColors.isSelected());			jEdit.setBooleanProperty("decorate.frames",decorateFrames.isSelected());			jEdit.setBooleanProperty("decorate.dialogs",decorateDialogs.isSelected());		}	
private void updateEnabled()		{			String className = lfs[lookAndFeel.getSelectedIndex()]				.getClassName();				if(className.equals("javax.swing.plaf.metal.MetalLookAndFeel")				|| className.equals("com.incors.plaf.kunststoff.KunststoffLookAndFeel"))			{				primaryFont.setEnabled(true);				secondaryFont.setEnabled(true);			}			else			{				primaryFont.setEnabled(false);				secondaryFont.setEnabled(false);			}		}	
private void addDockingFrameworkChooser()		{				String [] frameworks =				ServiceManager.getServiceNames(View.DOCKING_FRAMEWORK_PROVIDER_SERVICE);			dockingFramework = new JComboBox(frameworks);			String framework = View.getDockingFrameworkName();			for (int i = 0; i < frameworks.length; i++)			{				if (frameworks[i].equals(framework))				{					dockingFramework.setSelectedIndex(i);					break;				}			}			addComponent(new JLabel(jEdit.getProperty("options.appearance.selectFramework.label")), dockingFramework);		}	
/**		 * Returns a marked, rewindable stream.		 * Calling reset() method rewinds the stream to its beginning.		 * But reset() can fail if too long bytes were read.		 */		public static BufferedInputStream getMarkedStream(InputStream in)		{			int bufferSize = BufferIORequest.getByteIOBufferSize();			BufferedInputStream markable				= new BufferedInputStream(in, bufferSize);			assert(markable.markSupported());			markable.mark(bufferSize);			return markable;		}	
/**		 * Returns wheather the stream is gzipped.		 * This method reads a few bytes from the sample. So a caller		 * must take care of mark() to reuse the contents. Wraping the		 * stream by getMarkedStream() is suitable.		 */		public static boolean isGzipped(InputStream sample)			throws IOException		{			int magic1 = GZIPInputStream.GZIP_MAGIC & 0xff;			int magic2 = (GZIPInputStream.GZIP_MAGIC >> 8) & 0xff;			return sample.read() == magic1				&& sample.read() == magic2;		}	
/**		 * Returns the user configured ordered list of encoding detectors.		 * This method reads property "encodingDetectors".		 */		public static List<EncodingDetector> getEncodingDetectors()		{			List<EncodingDetector> detectors				= new ArrayList<EncodingDetector>();			String propName = "encodingDetectors";			String selectedDetectors				= jEdit.getProperty(propName, "BOM XML-PI");			if (selectedDetectors != null				&& selectedDetectors.length() > 0)			{				for (String name: selectedDetectors.split("\\s+"))				{					EncodingDetector service						= getEncodingDetectorService(name);					if (service != null)					{						detectors.add(service);					}					else					{						Log.log(Log.ERROR, AutoDetection.class							, "getEncodingDetectors():"								+ " No EncodingDetector for the name"								+ " \"" + name + "\"");					}				}			}			return detectors;		}	
/**		 * Returns an auto detected encoding from content of markedStream.		 * This method assumes that markedStream is wrapped by		 * getMarkedStream() method.		 */		public static String getDetectedEncoding(BufferedInputStream markedStream)			throws IOException		{			List<EncodingDetector> detectors = getEncodingDetectors();			for (EncodingDetector detector: detectors)			{				// FIXME: Here the method reset() can fail if the				// previous detector read more than buffer size of				// markedStream.				markedStream.reset();				// Wrap once more so that calling mark()				// or reset() in detectEncoding() don't				// alter the mark position of markedStream.				String detected = detector.detectEncoding(					new BufferedInputStream(markedStream));				if (detected != null)				{					return detected;				}			}			return null;		}	
/**			 * Do some auto detection for a stream and hold the			 * result in this instance.			 * @param in the stream			 */			public Result(InputStream in) throws IOException			{				BufferedInputStream marked = getMarkedStream(in);					gzipped = isGzipped(marked);				if (gzipped)				{					marked.reset();					marked = getMarkedStream(						new GZIPInputStream(marked));				}					marked.reset();				encoding = AutoDetection.getDetectedEncoding(marked);					markedStream = marked;			}	
/**			 * Returns the stream which can be read the contents of			 * the original stream.			 * Some bytes ware read from original stream for auto			 * detections. But they are rewinded at this method.			 */			public BufferedInputStream getRewindedStream()				throws IOException			{				markedStream.reset();				return markedStream;			}	
/**			 * Returns true if the stream is gzipped.			 */			public boolean streamIsGzipped()			{				return gzipped;			}	
/**			 * Returns the auto detected encoding.			 * Returns null if no encoding was detected.			 */			public String getDetectedEncoding()			{				return encoding;			}	
/**		 * Returns a service of EncodingDetector for name.		 */		private static EncodingDetector getEncodingDetectorService(String name)		{			String serviceClass = "org.gjt.sp.jedit.io.EncodingDetector";			Object service = ServiceManager.getService(serviceClass, name);			if (service != null && service instanceof EncodingDetector)			{				return (EncodingDetector)service;			}			else			{				return null;			}		}	
public static void setInterval(int interval)		{			if(interval == 0)			{				if(timer != null)				{					timer.stop();					timer = null;				}					return;			}				interval *= 1000;				if(timer == null)			{				timer = new Timer(interval,new Autosave());				timer.start();			}			else				timer.setDelay(interval);		}	
public static void stop()		{			if(timer != null)				timer.stop();		}	
public void actionPerformed(ActionEvent evt)		{			if (jEdit.getIntegerProperty("autosave",0) == 0)					return;			// might come in handy useful some time			/* Runtime runtime = Runtime.getRuntime();			int freeMemory = (int)(runtime.freeMemory() / 1024);			int totalMemory = (int)(runtime.totalMemory() / 1024);			int usedMemory = (totalMemory - freeMemory);				Log.log(Log.DEBUG,this,"Java heap: " + usedMemory + "Kb / "				+ totalMemory + "Kb, " + (usedMemory * 100 / totalMemory)				+ "%"); */				// save list of open files			if(jEdit.getViewCount() != 0				&& PerspectiveManager.isPerspectiveDirty())			{				PerspectiveManager.setPerspectiveDirty(false);				PerspectiveManager.savePerspective(true);			}			boolean autosaveUntitled = jEdit.getBooleanProperty("autosaveUntitled");			Buffer[] bufferArray = jEdit.getBuffers();			for(int i = 0; i < bufferArray.length; i++)			{				Buffer buffer = bufferArray[i];				if (autosaveUntitled || !buffer.isUntitled())					buffer.autosave();			}				// flush log			Log.flushStream();		}	
private Autosave() {}	
static void init()		{			Log.log(Log.MESSAGE, BeanShell.class, "Beanshell Init");		}	
/**		 * Evaluates the text selected in the specified text area.		 * @since jEdit 2.7pre2		 */		public static void evalSelection(View view, JEditTextArea textArea)		{			bsh.evalSelection(view, textArea);		}	
/**		 * Prompts for a BeanShell expression to evaluate.		 * @since jEdit 2.7pre2		 */		public static void showEvaluateDialog(View view)		{			String command = GUIUtilities.input(view,"beanshell-eval-input",null);			if(command != null)			{				if(!command.endsWith(";"))					command = command + ";";					int repeat = view.getInputHandler().getRepeatCount();					if(view.getMacroRecorder() != null)				{					view.getMacroRecorder().record(repeat,command);				}					Object returnValue = null;				try				{					for(int i = 0; i < repeat; i++)					{						returnValue = bsh._eval(view,bsh.getNameSpace(),command);					}				}				catch(Throwable e)				{					Log.log(Log.ERROR,BeanShell.class,e);						bsh.handleException(view,null,e);				}					if(returnValue != null)				{					String[] args = { returnValue.toString() };					GUIUtilities.message(view,"beanshell-eval",args);				}			}		}	
/**		 * Evaluates the specified script for each selected line.		 * @since jEdit 4.0pre1		 */		public static void showEvaluateLinesDialog(View view)		{			String command = GUIUtilities.input(view,"beanshell-eval-line",null);				JEditTextArea textArea = view.getTextArea();			Buffer buffer = view.getBuffer();				if(command == null || command.length() == 0)				return;				Selection[] selection = textArea.getSelection();			if(selection.length == 0)			{				view.getToolkit().beep();				return;			}				if(!command.endsWith(";"))				command = command + ";";				String script = "int[] lines = textArea.getSelectedLines();\n"				+ "for(int i = 0; i < lines.length; i++)\n"				+ "{\n"					+ "line = lines[i];\n"					+ "index = line - lines[0];\n"					+ "start = buffer.getLineStartOffset(line);\n"					+ "end = buffer.getLineEndOffset(line);\n"					+ "text = buffer.getText(start,end - start - 1);\n"					+ "newText = " + command + "\n"					+ "if(newText != null)\n"					+ "{\n"						+ "buffer.remove(start,end - start - 1);\n"						+ "buffer.insert(start,String.valueOf(newText));\n"					+ "}\n"				+ "}\n";				if(view.getMacroRecorder() != null)				view.getMacroRecorder().record(1,script);				try			{				buffer.beginCompoundEdit();					bsh.eval(view,script);			}			finally			{				buffer.endCompoundEdit();			}				textArea.selectNone();		}	
/**		 * Runs a BeanShell script. Errors are shown in a dialog box.<p>		 *		 * If the <code>in</code> parameter is non-null, the script is		 * read from that stream; otherwise it is read from the file identified		 * by <code>path</code>.<p>		 *		 * The <code>scriptPath</code> BeanShell variable is set to the path		 * name of the script.		 *		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param path The script file's VFS path.		 * @param in The reader to read the script from, or <code>null</code>.		 * @param ownNamespace If set to <code>false</code>, methods and		 * variables defined in the script will be available to all future		 * uses of BeanShell; if set to <code>true</code>, they will be lost as		 * soon as the script finishes executing. jEdit uses a value of		 * <code>false</code> when running startup scripts, and a value of		 * <code>true</code> when running all other macros.		 *		 * @since jEdit 4.0pre7		 */		public static void runScript(View view, String path, Reader in,			boolean ownNamespace)		{			try			{				_runScript(view,path,in,ownNamespace);			}			catch(Throwable e)			{				Log.log(Log.ERROR,BeanShell.class,e);					bsh.handleException(view,path,e);			}		}	
/**		 * Runs a BeanShell script. Errors are shown in a dialog box.<p>		 *		 * If the <code>in</code> parameter is non-null, the script is		 * read from that stream; otherwise it is read from the file identified		 * by <code>path</code>.<p>		 *		 * The <code>scriptPath</code> BeanShell variable is set to the path		 * name of the script.		 *		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param path The script file's VFS path.		 * @param in The reader to read the script from, or <code>null</code>.		 * @param namespace The namespace to run the script in.		 *		 * @since jEdit 4.2pre5		 */		public static void runScript(View view, String path, Reader in,			NameSpace namespace)		{			try			{				_runScript(view,path,in,namespace);			}			catch(Throwable e)			{				Log.log(Log.ERROR,BeanShell.class,e);					bsh.handleException(view,path,e);			}		}	
/**		 * Runs a BeanShell script. Errors are passed to the caller.<p>		 *		 * If the <code>in</code> parameter is non-null, the script is		 * read from that stream; otherwise it is read from the file identified		 * by <code>path</code>.<p>		 *		 * The <code>scriptPath</code> BeanShell variable is set to the path		 * name of the script.		 *		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param path The script file's VFS path.		 * @param in The reader to read the script from, or <code>null</code>.		 * @param ownNamespace If set to <code>false</code>, methods and		 * variables defined in the script will be available to all future		 * uses of BeanShell; if set to <code>true</code>, they will be lost as		 * soon as the script finishes executing. jEdit uses a value of		 * <code>false</code> when running startup scripts, and a value of		 * <code>true</code> when running all other macros.		 * @exception Exception instances are thrown when various BeanShell errors		 * occur		 * @since jEdit 4.0pre7		 */		public static void _runScript(View view, String path, Reader in,			boolean ownNamespace) throws Exception		{			_runScript(view,path,in,ownNamespace				? new NameSpace(bsh.getNameSpace(),"namespace")				: bsh.getNameSpace());		}	
/**		 * Runs a BeanShell script. Errors are passed to the caller.<p>		 *		 * If the <code>in</code> parameter is non-null, the script is		 * read from that stream; otherwise it is read from the file identified		 * by <code>path</code>.<p>		 *		 * The <code>scriptPath</code> BeanShell variable is set to the path		 * name of the script.		 *		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param path The script file's VFS path.		 * @param in The reader to read the script from, or <code>null</code>.		 * @param namespace The namespace to run the script in.		 * @exception Exception instances are thrown when various BeanShell errors		 * occur		 * @since jEdit 4.2pre5		 */		public static void _runScript(View view, String path, Reader in,			NameSpace namespace) throws Exception		{			Log.log(Log.MESSAGE,BeanShell.class,"Running script " + path);				Interpreter interp = BeanShellFacade.createInterpreter(namespace);				try			{				if(in == null)				{					Buffer buffer = jEdit.openTemporary(null,						null,path,false);						if(!buffer.isLoaded())						VFSManager.waitForRequests();						in = new StringReader(buffer.getText(0,						buffer.getLength()));				}					bsh.setupDefaultVariables(namespace,view);				interp.set("scriptPath",path);					running = true;					interp.eval(in,namespace,path);			}			catch(Exception e)			{				BeanShellFacade.unwrapException(e);			}			finally			{				running = false;				try				{					// no need to do this for macros!					if(namespace == bsh.getNameSpace())					{						bsh.resetDefaultVariables(namespace);						interp.unset("scriptPath");					}				}				catch(EvalError e)				{					// do nothing				}			}		}	
/**		 * Evaluates the specified BeanShell expression. Errors are reported in		 * a dialog box.		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param namespace The namespace		 * @param command The expression		 * @since jEdit 4.0pre8		 */		public static Object eval(View view, NameSpace namespace, String command)		{			return bsh.eval(view, namespace, command);		}	
/**		 * Evaluates the specified BeanShell expression. Unlike		 * <code>eval()</code>, this method passes any exceptions to the caller.		 *		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param namespace The namespace		 * @param command The expression		 * @exception Exception instances are thrown when various BeanShell		 * errors occur		 * @since jEdit 3.2pre7		 */		public static Object _eval(View view, NameSpace namespace, String command)			throws Exception		{			return bsh._eval(view, namespace, command);		}	
/**		 * Caches a block of code, returning a handle that can be passed to		 * runCachedBlock().		 * @param id An identifier. If null, a unique identifier is generated		 * @param code The code		 * @param namespace If true, the namespace will be set		 * @exception Exception instances are thrown when various BeanShell errors		 * occur		 * @since jEdit 4.1pre1		 */		public static BshMethod cacheBlock(String id, String code, boolean namespace)			throws Exception		{			return bsh.cacheBlock(id, code, namespace);		}	
/**		 * Runs a cached block of code in the specified namespace. Faster than		 * evaluating the block each time.		 * @param method The method instance returned by cacheBlock()		 * @param view The view		 * @param namespace The namespace to run the code in		 * @exception Exception instances are thrown when various BeanShell		 * errors occur		 * @since jEdit 4.1pre1		 */		public static Object runCachedBlock(BshMethod method, View view,			NameSpace namespace) throws Exception		{			return bsh.runCachedBlock(method, view, namespace);		}	
/**		 * Returns if a BeanShell script or macro is currently running.		 * @since jEdit 2.7pre2		 */		public static boolean isScriptRunning()		{			return running;		}	
/**		 * Returns the global namespace.		 * @since jEdit 3.2pre5		 */		public static NameSpace getNameSpace()		{			return bsh.getNameSpace();		}	
/**		 * @deprecated The <code>rethrowBshErrors</code> parameter is now		 * obsolete; call <code>_runScript()</code> or <code>runScript()</code>		 * instead.		 */		@Deprecated		public static void runScript(View view, String path,			boolean ownNamespace, boolean rethrowBshErrors)		{			runScript(view,path,null,ownNamespace);		}	
/**		 * @deprecated The <code>rethrowBshErrors</code> parameter is now		 * obsolete; call <code>_runScript()</code> or <code>runScript()</code>		 * instead.		 */		@Deprecated		public static void runScript(View view, String path, Reader in,			boolean ownNamespace, boolean rethrowBshErrors)		{			runScript(view,path,in,ownNamespace);		}	
/**		 * @deprecated The <code>rethrowBshErrors</code> parameter is now		 * obsolete; call <code>_eval()</code> or <code>eval()</code> instead.		 */		@Deprecated		public static Object eval(View view, String command,			boolean rethrowBshErrors)		{			return bsh.eval(view,command);		}	
/**		 * @deprecated The <code>rethrowBshErrors</code> parameter is now		 * obsolete; call <code>_eval()</code> or <code>eval()</code> instead.		 */		@Deprecated		public static Object eval(View view, NameSpace namespace,			String command, boolean rethrowBshErrors)		{			return eval(view,namespace,command);		}	
/**		 * Causes BeanShell internal structures to drop references to cached		 * Class instances.		 */		static void resetClassManager()		{			bsh.resetClassManager();		}	
private MyBeanShellFacade()			{				classManager.setClassLoader(new JARClassLoader());			}	
@Override			protected void init()			{				super.init();				global.importPackage("org.gjt.sp.jedit.browser");				global.importPackage("org.gjt.sp.jedit.bufferset");				global.importPackage("org.gjt.sp.jedit.statusbar");				global.importPackage("org.gjt.sp.jedit.gui");				global.importPackage("org.gjt.sp.jedit.help");				global.importPackage("org.gjt.sp.jedit.io");				global.importPackage("org.gjt.sp.jedit.menu");				global.importPackage("org.gjt.sp.jedit.msg");				global.importPackage("org.gjt.sp.jedit.options");				global.importPackage("org.gjt.sp.jedit.pluginmgr");				global.importPackage("org.gjt.sp.jedit.print");				global.importPackage("org.gjt.sp.jedit.search");			}	
@Override			protected void setupDefaultVariables(NameSpace namespace, View view) throws UtilEvalError 			{				if(view != null)				{					EditPane editPane = view.getEditPane();					namespace.setVariable("view",view, false);					namespace.setVariable("editPane",editPane, false);					namespace.setVariable("buffer",editPane.getBuffer(), false);					namespace.setVariable("textArea",editPane.getTextArea(), false);					namespace.setVariable("wm",view.getDockableWindowManager(), false);				}			}	
@Override			protected void resetDefaultVariables(NameSpace namespace) throws UtilEvalError			{				namespace.setVariable("view",null, false);				namespace.setVariable("editPane",null, false);				namespace.setVariable("buffer",null, false);				namespace.setVariable("textArea",null, false);				namespace.setVariable("wm",null, false);			}	
@Override			protected void handleException(View view, String path, Throwable t)			{				if(t instanceof IOException)				{					VFSManager.error(view,path,"ioerror.read-error",						new String[] { t.toString() });				}				else					new BeanShellErrorDialog(view,t);			}	
public BeanShellAction(String name, String code, String isSelected,			boolean noRepeat, boolean noRecord, boolean noRememberLast)		{			super(name);				/* Some characters that we like to use in action names			 * ('.', '-') are not allowed in BeanShell identifiers. */			String sanitizedName = name.replace('.','_').replace('-','_');			this.code = new CachedBshMethod("action_" + sanitizedName, code);			if (isSelected != null)			{				this.isSelected = new CachedBshMethod("selected_" + sanitizedName, isSelected);			}			this.noRepeat = noRepeat;			this.noRecord = noRecord;			this.noRememberLast = noRememberLast;				jEdit.setTemporaryProperty(name + ".toggle",				isSelected != null ? "true" : "false");		}	
public void invoke(View view)		{			try			{				BeanShell.runCachedBlock(code.get(),view,					new NameSpace(BeanShell.getNameSpace(),					"BeanShellAction.invoke()"));			}			catch(Throwable e)			{				Log.log(Log.ERROR,this,e);					new BeanShellErrorDialog(view,e);			}		}	
public boolean isSelected(Component comp)		{			if(isSelected == null)				return false;				NameSpace global = BeanShell.getNameSpace();				try			{				View view = GUIUtilities.getView(comp);					// undocumented hack to allow browser actions to work.				// XXX - clean up in 4.3				global.setVariable("_comp",comp);					return Boolean.TRUE.equals(BeanShell.runCachedBlock(					isSelected.get(),view,					new NameSpace(BeanShell.getNameSpace(),					"BeanShellAction.isSelected()")));			}			catch(Throwable e)			{				Log.log(Log.ERROR,this,e);					// dialogs fuck things up if a menu is visible, etc!				//new BeanShellErrorDialog(view,e);					// so that in the future we don't see streams of				// exceptions				isSelected = null;					return false;			}			finally			{				try				{					global.setVariable("_comp",null);				}				catch(UtilEvalError err)				{					Log.log(Log.ERROR,this,err);				}			}		}	
public boolean noRepeat()		{			return noRepeat;		}	
public boolean noRecord()		{			return noRecord;		}	
/**		 * Returns if this edit action should not be remembered as the most		 * recently invoked action.		 * @since jEdit 4.2pre1		 */		public boolean noRememberLast()		{			return noRememberLast;		}	
public String getCode()		{			return code.getSource().trim();		}	
public CachedBshMethod(String name, String source)			{				this.name = name;				this.source = source;				this.cache = null;			}	
public BshMethod get() throws java.lang.Exception			{				if (cache != null)				{					BshMethod cached = cache.get();					if (cached != null)					{						return cached;					}				}				BshMethod newOne = BeanShell.cacheBlock(name, source, true);				cache = new SoftReference<BshMethod>(newOne);				return newOne;			}	
public String getSource()			{				return source;			}	
public BeanShellErrorDialog(Frame frame, Throwable t)		{			super(frame,"beanshell-error",t);		}	
public BeanShellErrorDialog(View view, Throwable t)		{			this((Frame)view,t);		}	
protected BeanShellFacade()		{			classManager = new ClassManagerImpl();			global = new NameSpace(classManager,				"jEdit embedded BeanShell interpreter");				interpForMethods = createInterpreter(global);			init();		}	
/**		 * Initialize things. It is called by the constructor.		 * You can override it to import other packages		 */		protected void init()		{			global.importPackage("org.gjt.sp.jedit");			global.importPackage("org.gjt.sp.jedit.buffer");			global.importPackage("org.gjt.sp.jedit.syntax");			global.importPackage("org.gjt.sp.jedit.textarea");			global.importPackage("org.gjt.sp.util");		}	
/**		 * Evaluates the text selected in the specified text area.		 */		public void evalSelection(T param, TextArea textArea)		{			String command = textArea.getSelectedText();			if(command == null)			{				textArea.getToolkit().beep();				return;			}			Object returnValue = eval(param,global,command);			if(returnValue != null)				textArea.setSelectedText(returnValue.toString());		}	
/**		 * Evaluates the specified BeanShell expression with the global namespace		 * @param param The parameter		 * @param command The expression		 */		public Object eval(T param, String command)		{			return eval(param, global, command);		}	
/**		 * Evaluates the specified BeanShell expression. Errors are reported in		 * a dialog box.		 * @param param The parameter		 * @param namespace The namespace		 * @param command The expression		 */		public Object eval(T param, NameSpace namespace, String command)		{			try			{				return _eval(param,namespace,command);			}			catch(Throwable e)			{				Log.log(Log.ERROR,BeanShellFacade.class,e);					handleException(param,null,e);			}				return null;		}	
/**		 * Evaluates the specified BeanShell expression. Unlike		 * <code>eval()</code>, this method passes any exceptions to the caller.		 *		 * @param view The view. Within the script, references to		 * <code>buffer</code>, <code>textArea</code> and <code>editPane</code>		 * are determined with reference to this parameter.		 * @param namespace The namespace		 * @param command The expression		 * @exception Exception instances are thrown when various BeanShell		 * errors occur		 */		public Object _eval(T view, NameSpace namespace, String command)			throws Exception		{			Interpreter interp = createInterpreter(namespace);				try			{				setupDefaultVariables(namespace,view);				if(Debug.BEANSHELL_DEBUG)					Log.log(Log.DEBUG,BeanShellFacade.class,command);				return interp.eval(command);			}			catch(Exception e)			{				unwrapException(e);				// never called				return null;			}			finally			{				try				{					resetDefaultVariables(namespace);				}				catch(UtilEvalError e)				{					// do nothing				}			}		}	
/**		 * Caches a block of code, returning a handle that can be passed to		 * runCachedBlock().		 * @param id An identifier.		 * @param code The code		 * @param namespace If true, the namespace will be set		 * @exception Exception instances are thrown when various BeanShell errors		 * occur		 */		public BshMethod cacheBlock(String id, String code, boolean namespace)			throws Exception		{			// Make local namespace so that the method could be GCed			// if it becomes unnecessary.			NameSpace local = new NameSpace(global, "__internal_" + id);			// This name should be unique enough not to shadow any outer			// identifier.			String name = "__runCachedMethod";			if(namespace)			{				_eval(null,local,name + "(ns) {\nthis.callstack.set(0,ns);\n" + code + "\n}");				return local.getMethod(name,new Class[] { NameSpace.class });			}			else			{				_eval(null,local,name + "() {\n" + code + "\n}");				return local.getMethod(name,new Class[0]);			}		}	
/**		 * Runs a cached block of code in the specified namespace. Faster than		 * evaluating the block each time.		 * @param method The method instance returned by cacheBlock()		 * @param namespace The namespace to run the code in		 * @exception Exception instances are thrown when various BeanShell		 * errors occur		 */		public Object runCachedBlock(BshMethod method, T param,			NameSpace namespace) throws Exception		{			boolean useNamespace;			if(namespace == null)			{				useNamespace = false;				namespace = global;			}			else				useNamespace = true;				try			{				setupDefaultVariables(namespace,param);					Object retVal = method.invoke(useNamespace					? new Object[] { namespace }					: NO_ARGS,					interpForMethods,new CallStack(), null);				if(retVal instanceof Primitive)				{					if(retVal == Primitive.VOID)						return null;					else						return ((Primitive)retVal).getValue();				}				else					return retVal;			}			catch(Exception e)			{				unwrapException(e);				// never called				return null;			}			finally			{				resetDefaultVariables(namespace);			}		}	
/**		 * Returns the global namespace.		 */		public NameSpace getNameSpace()		{			return global;		}	
/**		 * Causes BeanShell internal structures to drop references to cached		 * Class instances.		 */		void resetClassManager()		{			classManager.reset();		}	
protected static Interpreter createInterpreter(NameSpace nameSpace)		{			return new Interpreter(null,System.out,System.err,false,nameSpace);		}	
/**		 * This extracts an exception from a 'wrapping' exception, as BeanShell		 * sometimes throws. This gives the user a more accurate error traceback		 */		protected static void unwrapException(Exception e) throws Exception		{			if(e instanceof TargetError)			{				Throwable t = ((TargetError)e).getTarget();				if(t instanceof Exception)					throw (Exception)t;				else if(t instanceof Error)					throw (Error)t;			}				if(e instanceof InvocationTargetException)			{				Throwable t = ((InvocationTargetException)e).getTargetException();				if(t instanceof Exception)					throw (Exception)t;				else if(t instanceof Error)					throw (Error)t;			}				throw e;		}	
public BlockNameSpace( NameSpace parent ) 			throws EvalError		{			super( parent, parent.getName()+ "/BlockNameSpace" );	    }	
/**			Override the standard namespace behavior to make assignments			happen in our parent (enclosing) namespace, unless the variable has			already been assigned here via a typed declaration or through			the special setBlockVariable() (used for untyped args in try/catch).			<p>			i.e. only allow typed var declaration to happen in this namespace.			Typed vars are handled in the ordinary way local scope.  All untyped			assignments are delegated to the enclosing context.		*/		/*			Note: it may see like with the new 1.3 scoping this test could be			removed, but it cannot.  When recurse is false we still need to set the			variable in our parent, not here.		*/	    public void	setVariable( 			String name, Object value, boolean strictJava, boolean recurse ) 			throws UtilEvalError 		{			if ( weHaveVar( name ) ) 				// set the var here in the block namespace				super.setVariable( name, value, strictJava, false );			else				// set the var in the enclosing (parent) namespace				getParent().setVariable( name, value, strictJava, recurse );	    }	
/**			Set an untyped variable in the block namespace.			The BlockNameSpace would normally delegate this set to the parent.			Typed variables are naturally set locally.			This is used in try/catch block argument. 		*/	    public void	setBlockVariable( String name, Object value ) 			throws UtilEvalError 		{			super.setVariable( name, value, false/*strict?*/, false );		}	
/**			We have the variable: either it was declared here with a type, giving			it block local scope or an untyped var was explicitly set here via			setBlockVariable().		*/		private boolean weHaveVar( String name ) 		{			// super.variables.containsKey( name ) not any faster, I checked			try {				return super.getVariableImpl( name, false ) != null;			} catch ( UtilEvalError e ) { return false; }		}	
/** do we need this? */		private NameSpace getNonBlockParent() 		{			NameSpace parent = super.getParent();			if ( parent instanceof BlockNameSpace )				return ((BlockNameSpace)parent).getNonBlockParent();			else				return parent;		}	
/**			Get a 'this' reference is our parent's 'this' for the object closure.			e.g. Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )			resolves to the parent namespace (e.g. the namespace containing the			"if" statement). 			@see #getBlockThis( Interpreter )		*/	    This getThis( Interpreter declaringInterpreter ) {			return getNonBlockParent().getThis( declaringInterpreter );		}	
/**			super is our parent's super		*/	    public This getSuper( Interpreter declaringInterpreter ) {			return getNonBlockParent().getSuper( declaringInterpreter );		}	
/**			delegate import to our parent		*/	    public void	importClass(String name) {			getParent().importClass( name );		}	
/**			delegate import to our parent		*/	    public void	importPackage(String name) {			getParent().importPackage( name );		}	
public void	setMethod(String name, BshMethod method) 			throws UtilEvalError		{			getParent().setMethod( name, method );		}	
/**		 * Creates a new string literal matcher.		 * @param pattern the search pattern		 * @param ignoreCase <code>true</code> if you want to ignore case		 */		public BoyerMooreSearchMatcher(String pattern, boolean ignoreCase)		{			this.pattern = pattern.toCharArray();			if(ignoreCase)			{				for(int i = 0; i < this.pattern.length; i++)				{					this.pattern[i] = Character.toUpperCase(						this.pattern[i]);				}			}				this.ignoreCase = ignoreCase;				pattern_end = this.pattern.length - 1;		}	
/**		 * Returns the offset of the first match of the specified text		 * within this matcher.		 * @param text The text to search in		 * @param start True if the start of the segment is the beginning of the		 * buffer		 * @param end True if the end of the segment is the end of the buffer		 * @param firstTime If false and the search string matched at the start		 * offset with length zero, automatically find next match		 * @param reverse If true, searching will be performed in a backward		 * direction.		 * @return an array where the first element is the start offset		 * of the match, and the second element is the end offset of		 * the match		 * @since jEdit 4.2pre4		 */		public SearchMatcher.Match nextMatch(CharSequence text,			boolean start, boolean end, boolean firstTime,			boolean reverse)		{			int pos = match(text,reverse);				if (pos == -1)			{				return null;			}			else			{				returnValue.start = pos;				returnValue.end = pos + pattern.length;				return returnValue;			}		}	
/**		 *  a good introduction to the Boyer-Moore fast string matching		 *  algorithm may be found on Moore's website at:		 *		 *   http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/		 *		 * @since jEdit 4.3pre5		 */		public int match(CharSequence text, boolean reverse)		{			//{{{			// lazily create skip and suffix arrays for either the			// search pattern, or the reversed search pattern			int[] skip, suffix;			if(reverse)			{				if(back_skip == null)				{					back_skip = generateSkipArray(true);					back_suffix = generateSuffixArray(true);				}				skip = back_skip;				suffix = back_suffix;			}			else			{				if(fwd_skip == null)				{					fwd_skip = generateSkipArray(false);					fwd_suffix = generateSuffixArray(false);				}				skip = fwd_skip;				suffix = fwd_suffix;			} //}}}				// position variable for pattern test position			int pos;				// position variable for pattern start			int anchor = 0;				// last possible start position of a match with this pattern;			// this is negative if the pattern is longer than the text			// causing the search loop below to immediately fail			//int last_anchor = reverseSearch			//	? offset + pattern.length - 1			//	: length - pattern.length;				char ch = 0;				int bad_char;			int good_suffix;				// the search works by starting the anchor (first character			// of the pattern) at the initial offset. as long as the			// anchor is far enough from the enough of the text for the			// pattern to match, and until the pattern matches, we			// compare the pattern to the text from the last character			// to the first character in reverse order. where a character			// in the pattern mismatches, we use the two heuristics			// based on the mismatch character and its position in the			// pattern to determine the furthest we can move the anchor			// without missing any potential pattern matches.			SEARCH:			while (anchor + pattern_end < text.length())			{				for (pos = pattern_end; pos >= 0; --pos)				{					ch = text.charAt(pos + anchor);					if(ignoreCase)						ch = Character.toUpperCase(ch);						// pattern test					if ((reverse ? ch != pattern[pattern_end - pos]						: ch != pattern[pos]))					{						// character mismatch, determine how many characters to skip							// heuristic #1						bad_char = pos - skip[getSkipIndex(ch)];							// heuristic #2						good_suffix = suffix[pos];							// skip the greater of the two distances provided by the						// heuristics						int skip_index = (bad_char > good_suffix) ? bad_char : good_suffix;						anchor += skip_index;							// go back to the while loop						continue SEARCH;					}				}					// MATCH: return the position of its first character				return anchor;			}				// MISMATCH: return -1 as defined by API			return -1;		}	
public String toString()		{			return "BoyerMooreSearchMatcher[" + new String(pattern) + ',' + ignoreCase + ']';		}	
private int[] generateSkipArray(boolean reverse)		{			// initialize the skip array to all zeros			int[] skip = new int[256];				// leave the table cleanly-initialized for an empty pattern			if (pattern.length == 0)				return skip;				int pos = 0;				do			{				skip[getSkipIndex(pattern[reverse ? pattern_end - pos : pos])] = pos;			}			while (++pos < pattern.length);				return skip;		}	
private static final int getSkipIndex(char ch)		{			return ch & 0x000000FF;		}	
private int[] generateSuffixArray(boolean reverse)		{			int m = pattern.length;				int j = m + 1;				int[] suffix = new int[j];			int[] tmp = new int[j];			tmp[m] = j;				for (int i = m; i > 0; --i)			{				while (j <= m && pattern[reverse ? pattern_end - i + 1 : i - 1]					!= pattern[reverse ? pattern_end - j + 1 : j - 1])				{					if (suffix[j] == 0)					{						suffix[j] = j - i;					}						j = tmp[j];				}					tmp[i - 1] = --j;			}				int k = tmp[0];				for (j = 0; j <= m; j++)			{				// the code above builds a 1-indexed suffix array,				// but we shift it to be 0-indexed, ignoring the				// original 0-th element				if (j > 0)				{					suffix[j - 1] = (suffix[j] == 0) ? k : suffix[j];				}					if (j == k)				{					k = tmp[k];				}			}				return suffix;		}	
public BracketIndentRule(char openBracket, char closeBracket)		{			this.openBracket = openBracket;			this.closeBracket = closeBracket;		}	
/**		 * @deprecated		 *   Use {@link #getBrackets(JEditBuffer,int,int,int)} instead.		 *   Brackets in comments or literals should be ignored for indent.		 *   But it can't be done without syntax parsing of a buffer.		 */		@Deprecated		public Brackets getBrackets(String line)		{			Brackets brackets = new Brackets();				for(int i = 0; i < line.length(); i++)			{				char ch = line.charAt(i);				if(ch == openBracket)				{					/* Don't increase indent when we see					an explicit fold. */					if(line.length() - i >= 3)					{						if(line.substring(i,i+3).equals("{{{")) /* }}} */						{							i += 2;							continue;						}					}					brackets.openCount++;				}				else if(ch == closeBracket)				{					if(brackets.openCount != 0)						brackets.openCount--;					else						brackets.closeCount++;				}			}				return brackets;		}	
public Brackets getBrackets(JEditBuffer buffer, int lineIndex)		{			return getBrackets(buffer, lineIndex,				0, buffer.getLineLength(lineIndex));		}	
public Brackets getBrackets(JEditBuffer buffer, int lineIndex,			int begin, int end)		{			LineScanner scanner = new LineScanner(begin, end);			buffer.markTokens(lineIndex, scanner);			return scanner.result;		}	
public String toString()		{			return getClass().getName() + "[" + openBracket + ","				+ closeBracket + "]";		}	
public LineScanner(int begin, int end)			{				this.result = new Brackets();				this.scannedIndex = 0;				this.beginIndex = begin;				this.endIndex = end;			}	
boolean rejectsToken(byte id)			{				// Rejects comments and literals.				// Accepts all others.				switch (id)				{				case Token.COMMENT1:				case Token.COMMENT2:				case Token.COMMENT3:				case Token.COMMENT4:				case Token.LITERAL1:				case Token.LITERAL2:				case Token.LITERAL3:				case Token.LITERAL4:					return true;				default:					return false;				}			}	
private void scan(Segment seg, int offset, int length)			{				int index = scannedIndex;				if (index >= endIndex)				{					return;				}				if (index < beginIndex)				{					int numToSkip = beginIndex - index;					if (numToSkip >= length)					{						return;					}					offset += numToSkip;					length -= numToSkip;					index = beginIndex;				}				if (index + length > endIndex)				{					length = endIndex - index;				}					for (int i = 0; i < length; ++i)				{					char c = seg.array[seg.offset + offset + i];					if(c == openBracket)					{						result.openCount++;					}					else if(c == closeBracket)					{						if(result.openCount != 0)							result.openCount--;						else							result.closeCount++;					}				}			}	
public void handleToken(Segment seg				, byte id, int offset, int length				, TokenMarker.LineContext context)			{				if (!rejectsToken(id))				{					scan(seg, offset, length);				}				scannedIndex += length;			}	
public void setLineContext(TokenMarker.LineContext lineContext)			{			}	
public BrowserColorsOptionPane()		{			super("browser.colors");		}	
protected void _init()		{			setLayout(new BorderLayout());				colorsModel = new BrowserColorsModel();			colorsTable = new JTable(colorsModel);			colorsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);			colorsTable.getTableHeader().setReorderingAllowed(false);			colorsTable.addMouseListener(new MouseHandler());			colorsTable.getSelectionModel().addListSelectionListener(				new SelectionHandler());			TableColumnModel tcm = colorsTable.getColumnModel();			tcm.getColumn(1).setCellRenderer(new BrowserColorsModel.ColorRenderer());			Dimension d = colorsTable.getPreferredSize();			d.height = Math.min(d.height,200);			JScrollPane scroller = new JScrollPane(colorsTable);			scroller.setPreferredSize(d);			add(BorderLayout.CENTER,scroller);				JPanel buttons = new JPanel();			buttons.setBorder(new EmptyBorder(3,0,0,0));			buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));			ActionHandler actionHandler = new ActionHandler();			add = new RolloverButton(GUIUtilities.loadIcon("Plus.png"));			add.setToolTipText(jEdit.getProperty("common.add"));			add.addActionListener(actionHandler);			buttons.add(add);			buttons.add(Box.createHorizontalStrut(6));			remove = new RolloverButton(GUIUtilities.loadIcon("Minus.png"));			remove.setToolTipText(jEdit.getProperty("common.remove"));			remove.addActionListener(actionHandler);			buttons.add(remove);			buttons.add(Box.createHorizontalStrut(6));			moveUp = new RolloverButton(GUIUtilities.loadIcon("ArrowU.png"));			moveUp.setToolTipText(jEdit.getProperty("common.moveUp"));			moveUp.addActionListener(actionHandler);			buttons.add(moveUp);			buttons.add(Box.createHorizontalStrut(6));			moveDown = new RolloverButton(GUIUtilities.loadIcon("ArrowD.png"));			moveDown.setToolTipText(jEdit.getProperty("common.moveDown"));			moveDown.addActionListener(actionHandler);			buttons.add(moveDown);			buttons.add(Box.createGlue());				add(BorderLayout.SOUTH,buttons);				updateEnabled();		}	
protected void _save()		{			colorsModel.save();		}	
private void updateEnabled()		{			int selectedRow = colorsTable.getSelectedRow();			remove.setEnabled(selectedRow != -1);			moveUp.setEnabled(selectedRow > 0);			moveUp.setEnabled(selectedRow != -1 && selectedRow !=				colorsModel.getRowCount());		}	
private void setSelectedRow(int row)		{			colorsTable.getSelectionModel().setSelectionInterval(row,row);			colorsTable.scrollRectToVisible(colorsTable.getCellRect(row,0,true));		}	
public void valueChanged(ListSelectionEvent evt)			{				updateEnabled();			}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == add)				{					colorsModel.add();				}				else if(source == remove)				{					int selectedRow = colorsTable.getSelectedRow();					colorsModel.remove(selectedRow);					updateEnabled();				}				else if(source == moveUp)				{					int selectedRow = colorsTable.getSelectedRow();					if(selectedRow != 0)					{						colorsModel.moveUp(selectedRow);						setSelectedRow(selectedRow - 1);					}					updateEnabled();				}				else if(source == moveDown)				{					int selectedRow = colorsTable.getSelectedRow();					if(selectedRow != colorsTable.getRowCount() - 1)					{						colorsModel.moveDown(selectedRow);						setSelectedRow(selectedRow + 1);					}					updateEnabled();				}			}	
public void mouseClicked(MouseEvent evt)			{				Point p = evt.getPoint();				int row = colorsTable.rowAtPoint(p);				int column = colorsTable.columnAtPoint(p);				if(row == -1 || column != 1)					return;					Color color = JColorChooser.showDialog(					BrowserColorsOptionPane.this,					jEdit.getProperty("colorChooser.title"),					(Color)colorsModel.getValueAt(row,1));				if(color != null)					colorsModel.setValueAt(color,row,1);			}	
BrowserColorsModel()		{			entries = new ArrayList<Entry>();				int i = 0;			String glob;			while((glob = jEdit.getProperty("vfs.browser.colors." + i + ".glob")) != null)			{				entries.add(new Entry(glob,					jEdit.getColorProperty(					"vfs.browser.colors." + i + ".color",					Color.black)));				i++;			}		}	
void add()		{			entries.add(new Entry("",UIManager.getColor("Tree.foreground")));			fireTableRowsInserted(entries.size() - 1,entries.size() - 1);		}	
void remove(int index)		{			entries.remove(index);			fireTableRowsDeleted(entries.size(),entries.size());		}	
public void moveUp(int index)		{			Entry entry = entries.get(index);			entries.remove(index);			entries.add(index - 1,entry);			fireTableRowsUpdated(index - 1,index);		}	
public void moveDown(int index)		{			Entry entry = entries.get(index);			entries.remove(index);			entries.add(index + 1,entry);			fireTableRowsUpdated(index,index + 1);		}	
void save()		{			int i;			for(i = 0; i < entries.size(); i++)			{				Entry entry = entries.get(i);				jEdit.setProperty("vfs.browser.colors." + i + ".glob",					entry.glob);				jEdit.setColorProperty("vfs.browser.colors." + i + ".color",					entry.color);			}			jEdit.unsetProperty("vfs.browser.colors." + i + ".glob");			jEdit.unsetProperty("vfs.browser.colors." + i + ".color");		}	
public int getColumnCount()		{			return 2;		}	
public int getRowCount()		{			return entries.size();		}	
public Object getValueAt(int row, int col)		{			Entry entry = entries.get(row);				switch(col)			{			case 0:				return entry.glob;			case 1:				return entry.color;			default:				return null;			}		}	
public boolean isCellEditable(int row, int col)		{			return col == 0;		}	
public void setValueAt(Object value, int row, int col)		{			Entry entry = entries.get(row);				if(col == 0)				entry.glob = (String)value;			else				entry.color = (Color)value;				fireTableRowsUpdated(row,row);		}	
public String getColumnName(int index)		{			switch(index)			{			case 0:				return jEdit.getProperty("options.browser.colors.glob");			case 1:				return jEdit.getProperty("options.browser.colors.color");			default:				return null;			}		}	
public Class getColumnClass(int col)		{			switch(col)			{			case 0:				return String.class;			case 1:				return Color.class;			default:				throw new InternalError();			}		}	
Entry(String glob, Color color)			{				this.glob = glob;				this.color = color;			}	
ColorRenderer()			{				setOpaque(true);				setBorder(SyntaxHiliteOptionPane.noFocusBorder);			}	
public Component getTableCellRendererComponent(				JTable table,				Object value,				boolean isSelected,				boolean cellHasFocus,				int row,				int col)			{				if (isSelected)				{					setBackground(table.getSelectionBackground());					setForeground(table.getSelectionForeground());				}				else				{					setBackground(table.getBackground());					setForeground(table.getForeground());				}					if (value != null)					setBackground((Color)value);					setBorder(cellHasFocus ? UIManager.getBorder(					"Table.focusCellHighlightBorder")					: SyntaxHiliteOptionPane.noFocusBorder);				return this;			}	
public BrowserCommandsMenu(VFSBrowser browser, VFSFile[] files)		{			this.browser = browser;				if(files != null)			{				VFS vfs = VFSManager.getVFSForPath(					files[0].getDeletePath());				int type = files[0].getType();					boolean fileOpen = (jEdit.getBuffer(files[0].getPath()) != null);					/* We check this flag separately so that we can				delete open files from the favorites. */				boolean deletePathOpen = (jEdit.getBuffer(files[0].getDeletePath()) != null);					boolean delete = !deletePathOpen					&& (vfs.getCapabilities()					& VFS.DELETE_CAP) != 0;				boolean rename = !fileOpen					&& (vfs.getCapabilities()					& VFS.RENAME_CAP) != 0;					for(int i = 1; i < files.length; i++)				{					VFSFile file = files[i];						VFS _vfs = VFSManager.getVFSForPath(file.getDeletePath());					delete &= (vfs == _vfs) && (_vfs.getCapabilities()						& VFS.DELETE_CAP) != 0;						if(type == file.getType())						/* all good */;					else					{						// this will disable most operations if						// files of multiple types are selected						type = -1;					}						// set rename to false if > 1 file selected					rename = false;						// show 'close' item if at least one selected					// file is currently open					if(jEdit.getBuffer(file.getPath()) != null)						fileOpen = true;				}					if(type == VFSFile.DIRECTORY					|| type == VFSFile.FILESYSTEM)				{					if(files.length == 1)						add(createMenuItem("browse"));					if(browser.getMode() == VFSBrowser.BROWSER)						add(createMenuItem("browse-window"));				}				else if(type == VFSFile.FILE					&& (browser.getMode() == VFSBrowser.BROWSER					|| browser.getMode() == VFSBrowser.BROWSER_DIALOG))				{					add(createMenuItem("open"));					add(GUIUtilities.loadMenu(						VFSBrowser.getActionContext(),						"vfs.browser.open-in"));					add(createMenuItem("insert"));						if(fileOpen)						add(createMenuItem("close"));				}				else if(type != -1)					add(createMenuItem("open"));					if(rename)					add(createMenuItem("rename"));					if(delete)					add(createMenuItem("delete"));					add(createMenuItem("copy-path"));				add(createMenuItem("paste"));								if((files.length == 1) || (browser.getSelectedFiles().length != 0)) 			   		add(createMenuItem("properties"));								addSeparator();			}				add(createMenuItem("up"));			add(createMenuItem("previous"));			add(createMenuItem("next"));			add(createMenuItem("reload"));			add(createMenuItem("roots"));			add(createMenuItem("home"));			add(createMenuItem("synchronize"));			addSeparator();				if(browser.getMode() == VFSBrowser.BROWSER)				add(createMenuItem("new-file"));				add(createMenuItem("new-directory"));				if(browser.getMode() == VFSBrowser.BROWSER)			{				addSeparator();				add(createMenuItem("search-directory"));			}				addSeparator();				add(createMenuItem("show-hidden-files"));				if(browser.getMode() == VFSBrowser.BROWSER				|| browser.getMode() == VFSBrowser.BROWSER_DIALOG)			{				addSeparator();				add(createEncodingMenu());			}			addSeparator();			add(createPluginMenu(browser));			update();		}	
public void update()		{			if(encodingMenuItems != null)			{				JRadioButtonMenuItem mi = encodingMenuItems.get(					browser.currentEncoding);				if(mi != null)				{					mi.setSelected(true);					otherEncoding.setText(jEdit.getProperty(						"vfs.browser.other-encoding.label"));				}				else				{					otherEncoding.setSelected(true);					otherEncoding.setText(jEdit.getProperty(						"vfs.browser.other-encoding-2.label",						new String[] { browser.currentEncoding }));				}			}		}	
private JMenuItem createMenuItem(String name)		{			return GUIUtilities.loadMenuItem(VFSBrowser.getActionContext(),				"vfs.browser." + name,false);		}	
private JMenu createEncodingMenu()		{			ActionHandler actionHandler = new ActionHandler();				encodingMenuItems = new HashMap<String, JRadioButtonMenuItem>();			JMenu encodingMenu = new JMenu(jEdit.getProperty(				"vfs.browser.commands.encoding.label"));				JMenu menu = encodingMenu;				autoDetect = new JCheckBoxMenuItem(				jEdit.getProperty(				"vfs.browser.commands.encoding.auto-detect"));			autoDetect.setSelected(browser.autoDetectEncoding);			autoDetect.setActionCommand("auto-detect");			autoDetect.addActionListener(actionHandler);			menu.add(autoDetect);			menu.addSeparator();				ButtonGroup grp = new ButtonGroup();				List<JMenuItem> encodingMenuItemList = new ArrayList<JMenuItem>();			String[] encodings = MiscUtilities.getEncodings(true);			for(int i = 0; i < encodings.length; i++)			{				String encoding = encodings[i];				JRadioButtonMenuItem mi = new JRadioButtonMenuItem(encoding);				mi.setActionCommand("encoding@" + encoding);				mi.addActionListener(actionHandler);				grp.add(mi);				encodingMenuItems.put(encoding,mi);				encodingMenuItemList.add(mi);			}				String systemEncoding = System.getProperty("file.encoding");			if(encodingMenuItems.get(systemEncoding) == null)			{				JRadioButtonMenuItem mi = new JRadioButtonMenuItem(					systemEncoding);				mi.setActionCommand("encoding@" + systemEncoding);				mi.addActionListener(actionHandler);				grp.add(mi);				encodingMenuItems.put(systemEncoding,mi);				encodingMenuItemList.add(mi);			}				Collections.sort(encodingMenuItemList,				new MenuItemTextComparator());				Iterator iter = encodingMenuItemList.iterator();			while(iter.hasNext())			{				JRadioButtonMenuItem mi = (JRadioButtonMenuItem)					iter.next();					if(menu.getMenuComponentCount() > 20)				{					JMenu newMenu = new JMenu(						jEdit.getProperty("common.more"));					menu.add(newMenu);					menu = newMenu;				}					menu.add(mi);			}			menu.addSeparator();				otherEncoding = new JRadioButtonMenuItem();			otherEncoding.setActionCommand("other-encoding");			otherEncoding.addActionListener(actionHandler);			grp.add(otherEncoding);			menu.add(otherEncoding);				return encodingMenu;		}	
private JMenu createPluginMenu(VFSBrowser browser)		{			JMenu pluginMenu = new JMenu(jEdit.getProperty(				"vfs.browser.plugins.label"));			return (JMenu)browser.createPluginsMenu(pluginMenu,false);					}	
public void actionPerformed(ActionEvent evt)			{				String actionCommand = evt.getActionCommand();					if(actionCommand.equals("auto-detect"))				{					browser.autoDetectEncoding						= autoDetect.isSelected();				}				else if(actionCommand.equals("other-encoding"))				{					String encoding = GUIUtilities.input(browser,						"encoding-prompt",null,						jEdit.getProperty("buffer.encoding",						System.getProperty("file.encoding")));					if(encoding == null)						return;					browser.currentEncoding = encoding;				}				else if(actionCommand.startsWith("encoding@"))				{					browser.currentEncoding = actionCommand.substring(9);				}			}	
/**		 * Creates a new browser I/O request.		 * @param type The request type		 * @param browser The VFS browser instance		 * @param path1 The first path name to operate on		 * @param path2 The second path name to operate on		 * @param loadInfo A two-element array filled out by the request;		 * element 1 is the canonical path, element 2 is the file list.		 */		BrowserIORequest(int type, VFSBrowser browser,			Object session, VFS vfs, String path1, String path2,			Object[] loadInfo)		{			this.type = type;			this.browser = browser;			this.session = session;			this.vfs = vfs;			this.path1 = path1;			this.path2 = path2;			this.loadInfo = loadInfo;		}	
public void run()		{			switch(type)			{			case LIST_DIRECTORY:				listDirectory();				break;			case DELETE:				delete();				break;			case RENAME:				rename();				break;			case MKDIR:				mkdir();				break;			}		}	
public String toString()		{			String typeString;			switch(type)			{			case LIST_DIRECTORY:				typeString = "LIST_DIRECTORY";				break;			case DELETE:				typeString = "DELETE";				break;			case RENAME:				typeString = "RENAME";				break;			case MKDIR:				typeString = "MKDIR";				break;			default:				typeString = "UNKNOWN!!!";				break;			}				return getClass().getName() + "[type=" + typeString				+ ",vfs=" + vfs + ",path1=" + path1				+ ",path2=" + path2 + "]";		}	
private void listDirectory()		{			VFSFile[] directory = null;				String[] args = { path1 };			setStatus(jEdit.getProperty("vfs.status.listing-directory",args));				String canonPath = path1;				try			{				setAbortable(true);					canonPath = vfs._canonPath(session,path1,browser);				directory = vfs._listFiles(session,canonPath,browser);			}			catch(IOException io)			{				setAbortable(false);				Log.log(Log.ERROR,this,io);				String[] pp = { io.toString() };				VFSManager.error(browser,path1,"ioerror.directory-error",pp);			}			catch(WorkThread.Abort a)			{			}			finally			{				try				{					vfs._endVFSSession(session,browser);				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					String[] pp = { io.toString() };					VFSManager.error(browser,path1,"ioerror.directory-error",pp);				}			}				setAbortable(false);				loadInfo[0] = canonPath;			loadInfo[1] = directory;		}	
private void delete()		{			try			{				setAbortable(true);				String[] args = { path1 };				setStatus(jEdit.getProperty("vfs.status.deleting",args));					try				{					path1 = vfs._canonPath(session,path1,browser);							if(!vfs._delete(session,path1,browser))						VFSManager.error(browser,path1,"ioerror.delete-error",null);				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					String[] pp = { io.toString() };					VFSManager.error(browser,path1,"ioerror.directory-error",pp);				}			}			catch(WorkThread.Abort a)			{			}			finally			{				try				{					vfs._endVFSSession(session,browser);				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					String[] pp = { io.toString() };					VFSManager.error(browser,path1,"ioerror.directory-error",pp);				}			}		}	
private void rename()		{			try			{				setAbortable(true);				String[] args = { path1, path2 };				setStatus(jEdit.getProperty("vfs.status.renaming",args));					try				{					path1 = vfs._canonPath(session,path1,browser);					path2 = vfs._canonPath(session,path2,browser);						VFSFile file = vfs._getFile(session,path2,browser);					if(file != null)					{						if((OperatingSystem.isCaseInsensitiveFS())							&& path1.equalsIgnoreCase(path2))						{							// allow user to change name							// case						}						else						{							VFSManager.error(browser,path1,								"ioerror.rename-exists",								new String[] { path2 });							return;						}					}						if(!vfs._rename(session,path1,path2,browser))						VFSManager.error(browser,path1,"ioerror.rename-error",							new String[] { path2 });				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					String[] pp = { io.toString() };					VFSManager.error(browser,path1,"ioerror.directory-error",pp);				}			}			catch(WorkThread.Abort a)			{			}			finally			{				try				{					vfs._endVFSSession(session,browser);				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					String[] pp = { io.toString() };					VFSManager.error(browser,path1,"ioerror.directory-error",pp);				}			}		}	
private void mkdir()		{			try			{				setAbortable(true);				String[] args = { path1 };				setStatus(jEdit.getProperty("vfs.status.mkdir",args));					try				{					path1 = vfs._canonPath(session,path1,browser);						if(!vfs._mkdir(session,path1,browser))						VFSManager.error(browser,path1,"ioerror.mkdir-error",null);				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					args[0] = io.toString();					VFSManager.error(browser,path1,"ioerror",args);				}			}			catch(WorkThread.Abort a)			{			}			finally			{				try				{					vfs._endVFSSession(session,browser);				}				catch(IOException io)				{					setAbortable(false);					Log.log(Log.ERROR,this,io);					String[] args = { io.toString() };					VFSManager.error(browser,path1,"ioerror",args);				}			}		}	
public BrowserOptionPane()		{			super("browser.general");		}	
public void _init()		{			/* Default directory */			String[] dirs = {				jEdit.getProperty("options.browser.general.defaultPath.favorites"),				jEdit.getProperty("options.browser.general.defaultPath.home"),				jEdit.getProperty("options.browser.general.defaultPath.last"),				jEdit.getProperty("options.browser.general.defaultPath.buffer"),				jEdit.getProperty("options.browser.general.defaultPath.working")			};				defaultDirectory = new JComboBox(dirs);			String defaultDir = jEdit.getProperty("vfs.browser.defaultPath");			if("favorites".equals(defaultDir))				defaultDirectory.setSelectedIndex(0);			else if("home".equals(defaultDir))				defaultDirectory.setSelectedIndex(1);			else if("last".equals(defaultDir))				defaultDirectory.setSelectedIndex(2);			else if("buffer".equals(defaultDir))				defaultDirectory.setSelectedIndex(3);			else if("working".equals(defaultDir))				defaultDirectory.setSelectedIndex(4);			addComponent(jEdit.getProperty("options.browser.general.defaultPath"),				defaultDirectory);				/* Show tool bar */			showToolbar = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.showToolbar"));			showToolbar.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".showToolbar"));			addComponent(showToolbar);				/* Show menu bar */			showMenubar = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.showMenubar"));			showMenubar.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".showMenubar"));			addComponent(showMenubar);				/* Show icons */			showIcons = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.showIcons"));			showIcons.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".showIcons"));			addComponent(showIcons);				/* Show hidden files */			showHiddenFiles = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.showHiddenFiles"));			showHiddenFiles.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".showHiddenFiles"));			addComponent(showHiddenFiles);				/* Ignore case when sorting */			sortIgnoreCase = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.sortIgnoreCase"));			sortIgnoreCase.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".sortIgnoreCase"));			addComponent(sortIgnoreCase);				/* Mix files and directories */			sortMixFilesAndDirs = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.sortMixFilesAndDirs"));			sortMixFilesAndDirs.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".sortMixFilesAndDirs"));			addComponent(sortMixFilesAndDirs);				/* Double-click close */			doubleClickClose = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.doubleClickClose"));			doubleClickClose.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".doubleClickClose"));			addComponent(doubleClickClose);				/* split VFSFileDialog horizontally */			currentBufferFilter = new JCheckBox(jEdit.getProperty("options.browser"				+ ".general.currentBufferFilter"));			currentBufferFilter.setSelected(jEdit.getBooleanProperty("vfs.browser"				+ ".currentBufferFilter"));			addComponent(currentBufferFilter);				/* use default icons. */			useDefaultIcons = new JCheckBox(jEdit.getProperty("options.browser.general.useDefaultIcons"));			useDefaultIcons.setSelected(jEdit.getBooleanProperty("vfs.browser.useDefaultIcons"));			addComponent(useDefaultIcons);		}	
public void _save()		{			String[] dirs = { "favorites", "home", "last", "buffer", "working"};			jEdit.setProperty("vfs.browser.defaultPath",dirs[defaultDirectory				.getSelectedIndex()]);			jEdit.setBooleanProperty("vfs.browser.showToolbar",				showToolbar.isSelected());			jEdit.setBooleanProperty("vfs.browser.showMenubar",				showMenubar.isSelected());			jEdit.setBooleanProperty("vfs.browser.showIcons",				showIcons.isSelected());			jEdit.setBooleanProperty("vfs.browser.showHiddenFiles",				showHiddenFiles.isSelected());			jEdit.setBooleanProperty("vfs.browser.sortIgnoreCase",				sortIgnoreCase.isSelected());			jEdit.setBooleanProperty("vfs.browser.sortMixFilesAndDirs",				sortMixFilesAndDirs.isSelected());			jEdit.setBooleanProperty("vfs.browser.doubleClickClose",				doubleClickClose.isSelected());			jEdit.setBooleanProperty("vfs.browser.currentBufferFilter",				currentBufferFilter.isSelected());			jEdit.setBooleanProperty("vfs.browser.useDefaultIcons",				useDefaultIcons.isSelected());		}	
BrowserView(final VFSBrowser browser)		{			this.browser = browser;				tmpExpanded = new HashSet<String>();			DockableWindowManager dwm = jEdit.getActiveView().getDockableWindowManager();			KeyListener keyListener = dwm.closeListener(VFSBrowser.NAME);				parentDirectories = new ParentDirectoryList();			parentDirectories.addKeyListener(keyListener);			parentDirectories.setName("parent");						parentDirectories.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			parentDirectories.setCellRenderer(new ParentDirectoryRenderer());			parentDirectories.setVisibleRowCount(5);			parentDirectories.addMouseListener(new ParentMouseHandler());				final JScrollPane parentScroller = new JScrollPane(parentDirectories);			parentScroller.setMinimumSize(new Dimension(0,0));				table = new VFSDirectoryEntryTable(this);			table.addMouseListener(new TableMouseHandler());			table.setName("file");			JScrollPane tableScroller = new JScrollPane(table);			tableScroller.setMinimumSize(new Dimension(0,0));			tableScroller.getViewport().setBackground(table.getBackground());			tableScroller.getViewport().addMouseListener(new TableMouseHandler());			splitPane = new JSplitPane(				browser.isHorizontalLayout()				? JSplitPane.HORIZONTAL_SPLIT : JSplitPane.VERTICAL_SPLIT,				jEdit.getBooleanProperty("appearance.continuousLayout"),				parentScroller, tableScroller);			splitPane.setOneTouchExpandable(true);				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					String prop = browser.isHorizontalLayout() ? "vfs.browser.horizontalSplitter" : "vfs.browser.splitter";					int loc = jEdit.getIntegerProperty(prop,-1);					if(loc == -1)						loc = parentScroller.getPreferredSize().height;						splitPane.setDividerLocation(loc);					parentDirectories.ensureIndexIsVisible(						parentDirectories.getModel()						.getSize());				}			});				if(browser.isMultipleSelectionEnabled())				table.getSelectionModel().setSelectionMode(					ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);			else				table.getSelectionModel().setSelectionMode(					ListSelectionModel.SINGLE_SELECTION);				setLayout(new BorderLayout());				add(BorderLayout.CENTER,splitPane);				propertiesChanged();		}	
public void focusOnFileView()		{			table.requestFocus();		}	
@Override		public void removeNotify()		{			String prop = browser.isHorizontalLayout() ? "vfs.browser.horizontalSplitter" : "vfs.browser.splitter";			jEdit.setIntegerProperty(prop,splitPane.getDividerLocation());				super.removeNotify();		}	
public VFSFile[] getSelectedFiles()		{			return table.getSelectedFiles();		}	
public void selectNone()		{			table.clearSelection();		}	
public void saveExpansionState()		{			tmpExpanded.clear();			table.getExpandedDirectories(tmpExpanded);		}	
public void clearExpansionState()		{			tmpExpanded.clear();		}	
public void loadDirectory(Object node, String path,			boolean addToHistory)		{			path = MiscUtilities.constructPath(browser.getDirectory(),path);			VFS vfs = VFSManager.getVFSForPath(path);				Object session = vfs.createVFSSession(path,this);			if(session == null)				return;				if(node == null)			{				parentDirectories.setListData(new Object[] {					new LoadingPlaceholder() });			}				Object[] loadInfo = new Object[2];				VFSManager.runInWorkThread(new BrowserIORequest(				BrowserIORequest.LIST_DIRECTORY,browser,				session,vfs,path,null,loadInfo));			browser.directoryLoaded(node,loadInfo,addToHistory);		}	
/**		 * Rebuild the parent view after a directory has been loaded.		 *		 * @param node		 * @param path		 * @param directory  		 */		public void directoryLoaded(Object node, String path, java.util.List<VFSFile> directory)		{			//{{{ If reloading root, update parent directory list			if(node == null)			{				DefaultListModel parentList = new DefaultListModel();					String parent = path;					for(;;)				{					VFS _vfs = VFSManager.getVFSForPath(parent);					VFSFile file = null;					if (_vfs instanceof FileVFS)					{						Object session = _vfs.createVFSSession(path, browser);						try						{							file = _vfs._getFile(session, parent, browser);							if (file != null)							{								file.setName(_vfs.getFileName(parent));							}						}						catch (IOException e)						{							Log.log(Log.ERROR, this, e, e);						}					}					if (file == null)					{						// create a DirectoryEntry manually						// instead of using _vfs._getFile()						// since so many VFS's have broken						// implementations of this method						file = new VFSFile(								_vfs.getFileName(parent),								parent,parent,								VFSFile.DIRECTORY,								0L,false);					}							/*parentList.insertElementAt(new VFSFile(						_vfs.getFileName(parent),						parent,parent,						VFSFile.DIRECTORY,						0L,false),0);*/					parentList.insertElementAt(file,0);					String newParent = _vfs.getParentOfPath(parent);						if(newParent == null ||						MiscUtilities.pathsEqual(parent,newParent))						break;					else						parent = newParent;				}					parentDirectories.setModel(parentList);				int index = parentList.getSize() - 1;				parentDirectories.setSelectedIndex(index);				parentDirectories.ensureIndexIsVisible(index);			} //}}}				table.setDirectory(VFSManager.getVFSForPath(path),				node,directory,tmpExpanded);		}	
public void updateFileView()		{			table.repaint();		}	
public void maybeReloadDirectory(String path)		{			String browserDir = browser.getDirectory();			String symlinkBrowserDir;			if(MiscUtilities.isURL(browserDir))			{				symlinkBrowserDir = browserDir;			}			else			{				symlinkBrowserDir = MiscUtilities.resolveSymlinks(					browserDir);			}				if(MiscUtilities.pathsEqual(path,symlinkBrowserDir))			{				saveExpansionState();				loadDirectory(null,browserDir,false);			}				// because this method is called for *every* VFS update,			// we don't want to scan the tree all the time. So we			// use the following algorithm to determine if the path			// might be part of the tree:			// - if the path starts with the browser's current directory,			//   we do the tree scan			// - if the browser's directory is 'favorites:' -- we have to			//   do the tree scan, as every path can appear under the			//   favorites list			// - if the browser's directory is 'roots:' and path is on			//   the local filesystem, do a tree scan				if(!browserDir.startsWith(FavoritesVFS.PROTOCOL)				&& !browserDir.startsWith(FileRootsVFS.PROTOCOL)				&& !path.startsWith(symlinkBrowserDir))				return;				if(browserDir.startsWith(FileRootsVFS.PROTOCOL)				&& MiscUtilities.isURL(path)				&& !MiscUtilities.getProtocolOfURL(path)				.equals("file"))				return;				table.maybeReloadDirectory(path);		}	
public void propertiesChanged()		{			showIcons = jEdit.getBooleanProperty("vfs.browser.showIcons");			table.propertiesChanged();			GUIUtilities.initContinuousLayout(splitPane);			splitPane.setBorder(null);		}	
/**		 * Returns the associated <code>VFSBrowser</code> instance.		 * @since jEdit 4.2pre1		 */		public VFSBrowser getBrowser()		{			return browser;		}	
public VFSDirectoryEntryTable getTable()		{			return table;		}	
public JList getParentDirectoryList()		{			return parentDirectories;		}	
private void showFilePopup(VFSFile[] files, Component comp,			Point point)		{			popup = new BrowserCommandsMenu(browser,files);			// for the parent directory right-click; on the click we select			// the clicked item, but when the popup goes away we select the			// currently showing directory.			popup.addPopupMenuListener(new PopupMenuListener()			{				public void popupMenuCanceled(PopupMenuEvent e) {}					public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}					public void popupMenuWillBecomeInvisible(PopupMenuEvent e)				{					// we use SwingUtilities.invokeLater()					// so that the action is executed before					// the popup is hidden.					SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							int index = parentDirectories								.getModel()								.getSize() - 1;							parentDirectories.setSelectedIndex(index);						}					});				}			});			GUIUtilities.showPopupMenu(popup,comp,point.x,point.y);		}	
ParentDirectoryRenderer()			{				plainFont = UIManager.getFont("Tree.font");				if(plainFont == null)					plainFont = jEdit.getFontProperty("metal.secondary.font");				boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());			}	
@Override			public Component getListCellRendererComponent(				JList list,				Object value,				int index,				boolean isSelected,				boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,index,					isSelected,cellHasFocus);					ParentDirectoryRenderer.this.setBorder(new EmptyBorder(					1,index * 5 + 1,1,1));					if(value instanceof LoadingPlaceholder)				{					ParentDirectoryRenderer.this.setFont(plainFont);						setIcon(showIcons ? FileCellRenderer.loadingIcon : null);					setText(jEdit.getProperty("vfs.browser.tree.loading"));				}				else if(value instanceof VFSFile)				{					VFSFile dirEntry = (VFSFile)value;					ParentDirectoryRenderer.this.setFont(boldFont);						setIcon(showIcons ? FileCellRenderer.getIconForFile(dirEntry,true)						: null);					setText(dirEntry.getName());				}				else if(value == null)					setText("VFS does not follow VFS API");					return this;			}	
@Override			public void mousePressed(MouseEvent evt)			{				int row = parentDirectories.locationToIndex(evt.getPoint());				if(row != -1)				{					Object obj = parentDirectories.getModel()						.getElementAt(row);					if(obj instanceof VFSFile)					{						VFSFile dirEntry = (VFSFile)obj;						if(GUIUtilities.isPopupTrigger(evt))						{							if(popup != null && popup.isVisible())							{								popup.setVisible(false);								popup = null;							}							else							{								parentDirectories.setSelectedIndex(row);								showFilePopup(new VFSFile[] {									dirEntry },parentDirectories,									evt.getPoint());							}						}					}				}			}	
@Override			public void mouseReleased(MouseEvent evt)			{				if(evt.getClickCount() % 2 != 0 &&					!GUIUtilities.isMiddleButton(evt.getModifiers()))					return;					int row = parentDirectories.locationToIndex(evt.getPoint());				if(row != -1)				{					Object obj = parentDirectories.getModel()						.getElementAt(row);					if(obj instanceof VFSFile)					{						VFSFile dirEntry = (VFSFile)obj;						if(!GUIUtilities.isPopupTrigger(evt))						{							browser.setDirectory(dirEntry.getPath());							if(browser.getMode() == VFSBrowser.BROWSER)							focusOnFileView();						}					}				}			}	
@Override			public void mouseClicked(MouseEvent evt)			{				Point p = evt.getPoint();				int row = table.rowAtPoint(p);				int column = table.columnAtPoint(p);				if(row == -1)					return;				if(column == 0)				{					VFSDirectoryEntryTableModel.Entry entry						= (VFSDirectoryEntryTableModel.Entry)						table.getModel().getValueAt(row,0);					if(FileCellRenderer.ExpansionToggleBorder						.isExpansionToggle(entry.level,p.x))					{						return;					}				}					if((evt.getModifiers() & InputEvent.BUTTON1_MASK) != 0					&& evt.getClickCount() % 2 == 0)				{					browser.filesActivated(evt.isShiftDown()						? VFSBrowser.M_OPEN_NEW_VIEW						: VFSBrowser.M_OPEN,true);				}				else if(GUIUtilities.isMiddleButton(evt.getModifiers()))				{					if(evt.isShiftDown())						table.getSelectionModel().addSelectionInterval(row,row);					else						table.getSelectionModel().setSelectionInterval(row,row);					browser.filesActivated(evt.isShiftDown()						? VFSBrowser.M_OPEN_NEW_VIEW						: VFSBrowser.M_OPEN,true);				}			}	
@Override			public void mousePressed(MouseEvent evt)			{				Point p = evt.getPoint();				if(evt.getSource() != table)				{					p.x -= table.getX();					p.y -= table.getY();				}					int row = table.rowAtPoint(p);				int column = table.columnAtPoint(p);				if(column == 0 && row != -1)				{					VFSDirectoryEntryTableModel.Entry entry						= (VFSDirectoryEntryTableModel.Entry)						table.getModel().getValueAt(row,0);					if(FileCellRenderer.ExpansionToggleBorder						.isExpansionToggle(entry.level,p.x))					{						table.toggleExpanded(row);						return;					}				}					if(GUIUtilities.isMiddleButton(evt.getModifiers()))				{					if(row == -1)						/* nothing */;					else if(evt.isShiftDown())						table.getSelectionModel().addSelectionInterval(row,row);					else						table.getSelectionModel().setSelectionInterval(row,row);				}				else if(GUIUtilities.isPopupTrigger(evt))				{					if(popup != null && popup.isVisible())					{						popup.setVisible(false);						popup = null;						return;					}						if(row == -1)						showFilePopup(null,table,evt.getPoint());					else					{						if(!table.getSelectionModel().isSelectedIndex(row))							table.getSelectionModel().setSelectionInterval(row,row);						showFilePopup(getSelectedFiles(),table,evt.getPoint());					}				}			}	
@Override			public void mouseReleased(MouseEvent evt)			{				if(!GUIUtilities.isPopupTrigger(evt)					&& table.getSelectedRow() != -1)				{					browser.filesSelected();				}			}	
public String getPath(int row)			{				Collection<String> components = new LinkedList<String>();				for (int i=1; i<=row; ++i)					components.add(getModel().getElementAt(i).toString());				return getModel().getElementAt(0) + TextUtilities.join(components, File.separator);			}	
@Override			protected void processKeyEvent(KeyEvent evt)			{				if (evt.getID() == KeyEvent.KEY_PRESSED)				{					ActionContext ac = VFSBrowser.getActionContext();					int row = parentDirectories.getSelectedIndex();					switch(evt.getKeyCode())					{					case KeyEvent.VK_DOWN:						evt.consume();									if (row < parentDirectories.getSize().height-1) 							parentDirectories.setSelectedIndex(++row);						break;					case KeyEvent.VK_LEFT:						if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)						{							evt.consume();							browser.previousDirectory();						}						else super.processEvent(evt);						break;					case KeyEvent.VK_RIGHT:						if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)						{							evt.consume();							browser.nextDirectory();						}						else super.processEvent(evt);						break;					case KeyEvent.VK_TAB:						evt.consume();						if ((evt.getModifiers() & KeyEvent.SHIFT_MASK) > 0)							browser.focusOnDefaultComponent();						else							table.requestFocus();						break;					case KeyEvent.VK_UP :						evt.consume();						if (row > 0)						{							parentDirectories.setSelectedIndex(--row);						}						break;					case KeyEvent.VK_BACK_SPACE:						evt.consume();						EditAction up = ac.getAction("vfs.browser.up");						ac.invokeAction(evt, up);						break;					case KeyEvent.VK_F5: 						evt.consume();						EditAction reload = ac.getAction("vfs.browser.reload");						ac.invokeAction(evt, reload);						break;					case KeyEvent.VK_ENTER: 						evt.consume();						String path = getPath(row);						getBrowser().setDirectory(path);						table.requestFocus();						break;	/* These actions don't work because they look at the EntryTable for the current selected	 * 	item. We need actions that look at the parentDirectoryList item instead.	 * 										case KeyEvent.VK_DELETE:						evt.consume();						ea = ac.getAction("vfs.browser.delete");						ac.invokeAction(evt, ea);						break; 					case KeyEvent.CTRL_MASK | KeyEvent.VK_N:  						evt.consume();						ea = ac.getAction("vfs.browser.new-file");						ac.invokeAction(evt, ea);						break;					case KeyEvent.VK_INSERT:						evt.consume();						ea = ac.getAction("vfs.browser.new-directory");						ac.invokeAction(evt, ea);						break; */										}				}				else if(evt.getID() == KeyEvent.KEY_TYPED)				{					if(evt.isControlDown() || evt.isAltDown()						|| evt.isMetaDown())					{						evt.consume();						return;					}					switch(evt.getKeyChar())					{					case '~':						evt.consume();						if(browser.getMode() == VFSBrowser.BROWSER)							browser.setDirectory(System.getProperty(								"user.home"));						break;					case '/':						evt.consume();						if(browser.getMode() == VFSBrowser.BROWSER)							browser.rootDirectory();						break;					case '-':						evt.consume();						if(browser.getMode() == VFSBrowser.BROWSER)						{							browser.setDirectory(								browser.getView().getBuffer()								.getDirectory());						}						break;					}				}				if (!evt.isConsumed())					super.processKeyEvent(evt);			}	
BSHAllocationExpression(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter) 			throws EvalError	    {	        // type is either a class name or a primitive type	        SimpleNode type = (SimpleNode)jjtGetChild(0);		        // args is either constructor arguments or array dimensions	        SimpleNode args = (SimpleNode)jjtGetChild(1);		        if ( type instanceof BSHAmbiguousName )	        {	            BSHAmbiguousName name = (BSHAmbiguousName)type;		            if (args instanceof BSHArguments)	                return objectAllocation(name, (BSHArguments)args, 						callstack, interpreter );	            else	                return objectArrayAllocation(name, (BSHArrayDimensions)args, 						callstack, interpreter );	        }	        else	            return primitiveArrayAllocation((BSHPrimitiveType)type,	                (BSHArrayDimensions)args, callstack, interpreter );	    }	
private Object objectAllocation(			BSHAmbiguousName nameNode, BSHArguments argumentsNode, 			CallStack callstack, Interpreter interpreter 		) 			throws EvalError	    {			NameSpace namespace = callstack.top();		        Object[] args = argumentsNode.getArguments( callstack, interpreter );	        if ( args == null)	            throw new EvalError( "Null args in new.", this, callstack );				// Look for scripted class object	        Object obj = nameNode.toObject( 				callstack, interpreter, false/* force class*/ );				// Try regular class		        obj = nameNode.toObject( 				callstack, interpreter, true/*force class*/ );		        Class type = null;			if ( obj instanceof ClassIdentifier )	        	type = ((ClassIdentifier)obj).getTargetClass();			else				throw new EvalError( 					"Unknown class: "+nameNode.text, this, callstack );				// Is an inner class style object allocation			boolean hasBody = jjtGetNumChildren() > 2;				if ( hasBody ) 			{	        	BSHBlock body = (BSHBlock)jjtGetChild(2);				if ( type.isInterface() )					return constructWithInterfaceBody( 						type, args, body, callstack, interpreter );				else					return constructWithClassBody( 						type, args, body, callstack, interpreter );			} else				return constructObject( type, args, callstack );	    }	
private Object constructObject( 			Class type, Object[] args, CallStack callstack ) 			throws EvalError		{			Object obj;	        try {	            obj = Reflect.constructObject( type, args );	        } catch ( ReflectError e) {	            throw new EvalError(					"Constructor error: " + e.getMessage(), this, callstack );	        } catch(InvocationTargetException e) {				// No need to wrap this debug				Interpreter.debug("The constructor threw an exception:\n\t" +					e.getTargetException());	            throw new TargetError(					"Object constructor", e.getTargetException(), 					this, callstack, true);	        }				String className = type.getName();			// Is it an inner class?			if ( className.indexOf("$") == -1 )				return obj;				// Temporary hack to support inner classes 			// If the obj is a non-static inner class then import the context...			// This is not a sufficient emulation of inner classes.			// Replace this later...				// work through to class 'this'			This ths = callstack.top().getThis( null );			NameSpace instanceNameSpace = 				Name.getClassNameSpace( ths.getNameSpace() );						// Change the parent (which was the class static) to the class instance			// We really need to check if we're a static inner class here first...			// but for some reason Java won't show the static modifier on our			// fake inner classes...  could generate a flag field.			if ( instanceNameSpace != null 				&& className.startsWith( instanceNameSpace.getName() +"$") 			)			{				try {					ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(						obj, className, instanceNameSpace );				} catch ( UtilEvalError e ) {					throw e.toEvalError( this, callstack );				}			}				return obj;		}	
private Object constructWithClassBody( 			Class type, Object[] args, BSHBlock block,			CallStack callstack, Interpreter interpreter ) 			throws EvalError		{			String name = callstack.top().getName() + "$" + (++innerClassCount);			Modifiers modifiers = new Modifiers();			modifiers.addModifier( Modifiers.CLASS, "public" );			Class clas;			try {				clas = ClassGenerator.getClassGenerator() .generateClass( 					name, modifiers, null/*interfaces*/, type/*superClass*/, 					block, false/*isInterface*/, callstack, interpreter );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}			try {				return Reflect.constructObject( clas, args );			} catch ( Exception e ) {				if ( e instanceof InvocationTargetException )					e = (Exception)((InvocationTargetException)e)						.getTargetException();				throw new EvalError(					"Error constructing inner class instance: "+e, this, callstack				);			}		}	
private Object constructWithInterfaceBody( 			Class type, Object[] args, BSHBlock body,			CallStack callstack, Interpreter interpreter ) 			throws EvalError		{			NameSpace namespace = callstack.top();			NameSpace local = new NameSpace(namespace, "AnonymousBlock");			callstack.push(local);			body.eval( callstack, interpreter, true/*overrideNamespace*/ );			callstack.pop();			// statical import fields from the interface so that code inside			// can refer to the fields directly (e.g. HEIGHT)			local.importStatic( type );			try {				return local.getThis(interpreter).getInterface( type );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}		}	
private Object objectArrayAllocation(			BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode, 			CallStack callstack, Interpreter interpreter 		) 			throws EvalError	    {			NameSpace namespace = callstack.top();	        Class type = nameNode.toClass( callstack, interpreter );	        if ( type == null )	            throw new EvalError( "Class " + nameNode.getName(namespace) 					+ " not found.", this, callstack );				return arrayAllocation( dimensionsNode, type, callstack, interpreter );	    }	
private Object primitiveArrayAllocation(			BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode, 			CallStack callstack, Interpreter interpreter 		) 			throws EvalError	    {	        Class type = typeNode.getType();				return arrayAllocation( dimensionsNode, type, callstack, interpreter );	    }	
private Object arrayAllocation( 			BSHArrayDimensions dimensionsNode, Class type, 			CallStack callstack, Interpreter interpreter )			throws EvalError		{			/*				dimensionsNode can return either a fully intialized array or VOID.				when VOID the prescribed array dimensions (defined and undefined)				are contained in the node.			*/	        Object result = dimensionsNode.eval( type, callstack, interpreter );	        if ( result != Primitive.VOID )	            return result;			else				return arrayNewInstance( type, dimensionsNode, callstack );		}	
/**			Create an array of the dimensions specified in dimensionsNode.			dimensionsNode may contain a number of "undefined" as well as "defined"			dimensions.			<p>				Background: in Java arrays are implemented in arrays-of-arrays style			where, for example, a two dimensional array is a an array of arrays of			some base type.  Each dimension-type has a Java class type associated 			with it... so if foo = new int[5][5] then the type of foo is 			int [][] and the type of foo[0] is int[], etc.  Arrays may also be 			specified with undefined trailing dimensions - meaning that the lower 			order arrays are not allocated as objects. e.g.  			if foo = new int [5][]; then foo[0] == null //true; and can later be 			assigned with the appropriate type, e.g. foo[0] = new int[5];			(See Learning Java, O'Reilly & Associates more background).			<p>				To create an array with undefined trailing dimensions using the			reflection API we must use an array type to represent the lower order			(undefined) dimensions as the "base" type for the array creation... 			Java will then create the correct type by adding the dimensions of the 			base type to specified allocated dimensions yielding an array of			dimensionality base + specified with the base dimensons unallocated.  			To create the "base" array type we simply create a prototype, zero 			length in each dimension, array and use it to get its class 			(Actually, I think there is a way we could do it with Class.forName() 			but I don't trust this).   The code is simpler than the explanation...			see below.		*/		private Object arrayNewInstance( 			Class type, BSHArrayDimensions dimensionsNode, CallStack callstack )			throws EvalError		{			if ( dimensionsNode.numUndefinedDims > 0 )			{	            Object proto = Array.newInstance( 					type, new int [dimensionsNode.numUndefinedDims] ); // zeros				type = proto.getClass();			}		        try {	            return Array.newInstance( 					type, dimensionsNode.definedDimensions);	        } catch( NegativeArraySizeException e1 ) {				throw new TargetError( e1, this, callstack );	        } catch( Exception e ) {	            throw new EvalError("Can't construct primitive array: " +	                e.getMessage(), this, callstack);	        }		}	
BSHAmbiguousName(int id) { super(id); }	
public Name getName( NameSpace namespace )	    {	        return namespace.getNameResolver( text );	    }	
public Object toObject( CallStack callstack, Interpreter interpreter ) 			throws EvalError	    {			return toObject( callstack, interpreter, false );	    }	
Object toObject( 			CallStack callstack, Interpreter interpreter, boolean forceClass ) 			throws EvalError	    {			try {	        	return 					getName( callstack.top() ).toObject( 						callstack, interpreter, forceClass );			} catch ( UtilEvalError e ) {	//e.printStackTrace();				throw e.toEvalError( this, callstack );			}	    }	
public Class toClass( CallStack callstack, Interpreter interpreter ) 			throws EvalError	    {			try {	        	return getName( callstack.top() ).toClass();			} catch ( ClassNotFoundException e ) {				throw new EvalError( e.getMessage(), this, callstack );			} catch ( UtilEvalError e2 ) {				// ClassPathException is a type of UtilEvalError				throw e2.toEvalError( this, callstack );			}	    }	
public LHS toLHS( CallStack callstack, Interpreter interpreter)			throws EvalError	    {			try {				return getName( callstack.top() ).toLHS( callstack, interpreter );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}	    }	
public Object eval( CallStack callstack, Interpreter interpreter ) 			throws EvalError	    {			throw new InterpreterError( 				"Don't know how to eval an ambiguous name!"				+"  Use toObject() if you want an object." );	    }	
public String toString() {			return "AmbigousName: "+text;		}	
BSHArguments(int id) { super(id); }	
/**			This node holds a set of arguments for a method invocation or			constructor call.				Note: arguments are not currently allowed to be VOID.		*/		/*			Disallowing VOIDs here was an easy way to support the throwing of a 			more descriptive error message on use of an undefined argument to a 			method call (very common).  If it ever turns out that we need to 			support that for some reason we'll have to re-evaluate how we get 			"meta-information" about the arguments in the various invoke() methods 			that take Object [].  We could either pass BSHArguments down to 			overloaded forms of the methods or throw an exception subtype 			including the argument position back up, where the error message would			be compounded.		*/	    public Object[] getArguments( CallStack callstack, Interpreter interpreter)			throws EvalError	    {	        // evaluate each child	        Object[] args = new Object[jjtGetNumChildren()];	        for(int i = 0; i < args.length; i++)			{	            args[i] = ((SimpleNode)jjtGetChild(i)).eval(callstack, interpreter);				if ( args[i] == Primitive.VOID )					throw new EvalError( "Undefined argument: " + 						((SimpleNode)jjtGetChild(i)).getText(), this, callstack );			}		        return args;	    }	
BSHArrayDimensions(int id) { super(id); }	
public void addDefinedDimension() { numDefinedDims++; }	
public void addUndefinedDimension() { numUndefinedDims++; }	
public Object eval( 				Class type, CallStack callstack, Interpreter interpreter ) 			throws EvalError 		{			if ( Interpreter.DEBUG ) Interpreter.debug("array base type = "+type);			baseType = type;			return eval( callstack, interpreter );		}	
/**			Evaluate the structure of the array in one of two ways:					a) an initializer exists, evaluate it and return				the fully constructed array object, also record the dimensions				of that array								b) evaluate and record the lengths in each dimension and 				return void.				The structure of the array dims is maintained in dimensions.		*/	    public Object eval( CallStack callstack, Interpreter interpreter )  			throws EvalError	    {			SimpleNode child = (SimpleNode)jjtGetChild(0);				/*				Child is array initializer.  Evaluate it and fill in the 				dimensions it returns.  Initialized arrays are always fully defined				(no undefined dimensions to worry about).  				The syntax uses the undefinedDimension count.				e.g. int [][] { 1, 2 };			*/			if (child instanceof BSHArrayInitializer)			{				if ( baseType == null )					throw new EvalError( 						"Internal Array Eval err:  unknown base type", 						this, callstack );					Object initValue = ((BSHArrayInitializer)child).eval(					baseType, numUndefinedDims, callstack, interpreter);					Class arrayClass = initValue.getClass();				int actualDimensions = Reflect.getArrayDimensions(arrayClass);				definedDimensions = new int[ actualDimensions ];					// Compare with number of dimensions actually created with the				// number specified (syntax uses the undefined ones here)				if ( definedDimensions.length != numUndefinedDims )					throw new EvalError(					"Incompatible initializer. Allocation calls for a " + 					numUndefinedDims+ " dimensional array, but initializer is a " +						actualDimensions + " dimensional array", this, callstack );					// fill in definedDimensions [] lengths				Object arraySlice = initValue;				for ( int i = 0; i < definedDimensions.length; i++ ) {					definedDimensions[i] = Array.getLength( arraySlice );					if ( definedDimensions[i] > 0 )						arraySlice = Array.get(arraySlice, 0);				}					return initValue;			}			else 			// Evaluate the defined dimensions of the array			{				definedDimensions = new int[ numDefinedDims ];					for(int i = 0; i < numDefinedDims; i++)				{					try {						Object length = ((SimpleNode)jjtGetChild(i)).eval(							callstack, interpreter);						definedDimensions[i] = ((Primitive)length).intValue();					}					catch(Exception e)					{						throw new EvalError(							"Array index: " + i + 							" does not evaluate to an integer", this, callstack );					}				}			}		        return Primitive.VOID;	    }	
BSHArrayInitializer(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError 		{			throw new EvalError( "Array initializer has no base type.", 				this, callstack );		}	
/**			Construct the array from the initializer syntax.				@param baseType the base class type of the array (no dimensionality)			@param dimensions the top number of dimensions of the array 				e.g. 2 for a String [][];		*/	    public Object eval( Class baseType, int dimensions, 							CallStack callstack, Interpreter interpreter ) 			throws EvalError	    {	        int numInitializers = jjtGetNumChildren();				// allocate the array to store the initializers			int [] dima = new int [dimensions]; // description of the array			// The other dimensions default to zero and are assigned when 			// the values are set.			dima[0] = numInitializers;	        Object initializers =  Array.newInstance( baseType, dima );				// Evaluate the initializers	        for (int i = 0; i < numInitializers; i++)	        {				SimpleNode node = (SimpleNode)jjtGetChild(i);	            Object currentInitializer;				if ( node instanceof BSHArrayInitializer ) {					if ( dimensions < 2 )						throw new EvalError(							"Invalid Location for Intializer, position: "+i, 							this, callstack );	            	currentInitializer = 						((BSHArrayInitializer)node).eval( 							baseType, dimensions-1, callstack, interpreter);				} else	            	currentInitializer = node.eval( callstack, interpreter);					if ( currentInitializer == Primitive.VOID )					throw new EvalError(						"Void in array initializer, position"+i, this, callstack );					// Determine if any conversion is necessary on the initializers.				//				// Quick test to see if conversions apply:				// If the dimensionality of the array is 1 then the elements of				// the initializer can be primitives or boxable types.  If it is				// greater then the values must be array (object) types and there				// are currently no conversions that we do on those.				// If we have conversions on those in the future then we need to				// get the real base type here instead of the dimensionless one.				Object value = currentInitializer;				if ( dimensions == 1 )				{					// We do a bsh cast here.  strictJava should be able to affect					// the cast there when we tighten control					try {						value = Types.castObject(							currentInitializer, baseType, Types.CAST );					} catch ( UtilEvalError e ) {						throw e.toEvalError(							"Error in array initializer", this, callstack );					}					// unwrap any primitive, map voids to null, etc.					value = Primitive.unwrap( value );				}						// store the value in the array	            try {					Array.set(initializers, i, value);	            } catch( IllegalArgumentException e ) {					Interpreter.debug("illegal arg"+e);					throwTypeError( baseType, currentInitializer, i, callstack );	            } catch( ArrayStoreException e ) { // I think this can happen					Interpreter.debug("arraystore"+e);					throwTypeError( baseType, currentInitializer, i, callstack );	            }	        }		        return initializers;	    }	
private void throwTypeError( 			Class baseType, Object initializer, int argNum, CallStack callstack ) 			throws EvalError		{			String rhsType;			if (initializer instanceof Primitive)				rhsType = 					((Primitive)initializer).getType().getName();			else				rhsType = Reflect.normalizeClassName(					initializer.getClass());				throw new EvalError ( "Incompatible type: " + rhsType 				+" in initializer of array type: "+ baseType				+" at position: "+argNum, this, callstack );		}	
BSHAssignment(int id) { super(id); }	
public Object eval(			CallStack callstack, Interpreter interpreter) 			throws EvalError	    {	        BSHPrimaryExpression lhsNode = 				(BSHPrimaryExpression)jjtGetChild(0);				if ( lhsNode == null )				throw new InterpreterError( "Error, null LHSnode" );				boolean strictJava = interpreter.getStrictJava();	        LHS lhs = lhsNode.toLHS( callstack, interpreter);	        if ( lhs == null )	            throw new InterpreterError( "Error, null LHS" );				// For operator-assign operations save the lhs value before evaluating			// the rhs.  This is correct Java behavior for postfix operations			// e.g. i=1; i+=i++; // should be 2 not 3			Object lhsValue = null;			if ( operator != ASSIGN ) // assign doesn't need the pre-value				try {					lhsValue = lhs.getValue();				} catch ( UtilEvalError e ) {					throw e.toEvalError( this, callstack );				}		        SimpleNode rhsNode = (SimpleNode)jjtGetChild(1);		        Object rhs;						// implement "blocks" foo = { };			// if ( rhsNode instanceof BSHBlock )			//    rsh =			// else	        rhs = rhsNode.eval(callstack, interpreter);		        if ( rhs == Primitive.VOID )	            throw new EvalError("Void assignment.", this, callstack );				try {				switch(operator)				{					case ASSIGN:						return lhs.assign( rhs, strictJava );						case PLUSASSIGN:						return lhs.assign( 							operation(lhsValue, rhs, PLUS), strictJava );			            case MINUSASSIGN:						return lhs.assign( 							operation(lhsValue, rhs, MINUS), strictJava );						case STARASSIGN:						return lhs.assign( 							operation(lhsValue, rhs, STAR), strictJava );			            case SLASHASSIGN:						return lhs.assign( 							operation(lhsValue, rhs, SLASH), strictJava );			            case ANDASSIGN:					case ANDASSIGNX:						return lhs.assign( 							operation(lhsValue, rhs, BIT_AND), strictJava );			            case ORASSIGN:		            case ORASSIGNX:		                return lhs.assign( 							operation(lhsValue, rhs, BIT_OR), strictJava );			            case XORASSIGN:		                return lhs.assign( 							operation(lhsValue, rhs, XOR), strictJava );			            case MODASSIGN:		                return lhs.assign( 							operation(lhsValue, rhs, MOD), strictJava );			            case LSHIFTASSIGN:		            case LSHIFTASSIGNX:		                return lhs.assign( 							operation(lhsValue, rhs, LSHIFT), strictJava );			            case RSIGNEDSHIFTASSIGN:		            case RSIGNEDSHIFTASSIGNX:		                return lhs.assign( 						operation(lhsValue, rhs, RSIGNEDSHIFT ), strictJava );			            case RUNSIGNEDSHIFTASSIGN:		            case RUNSIGNEDSHIFTASSIGNX:		                return lhs.assign( 							operation(lhsValue, rhs, RUNSIGNEDSHIFT), 							strictJava );						default:						throw new InterpreterError(							"unimplemented operator in assignment BSH");				}			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}	    }	
private Object operation( Object lhs, Object rhs, int kind ) 			throws UtilEvalError	    {			/*				Implement String += value;				According to the JLS, value may be anything.				In BeanShell, we'll disallow VOID (undefined) values.				(or should we map them to the empty string?)			*/			if ( lhs instanceof String && rhs != Primitive.VOID ) {				if ( kind != PLUS )					throw new UtilEvalError(						"Use of non + operator with String LHS" );					return (String)lhs + rhs;			}		        if ( lhs instanceof Primitive || rhs instanceof Primitive )	            if(lhs == Primitive.VOID || rhs == Primitive.VOID)	                throw new UtilEvalError(						"Illegal use of undefined object or 'void' literal" );	            else if ( lhs == Primitive.NULL || rhs == Primitive.NULL )	                throw new UtilEvalError(						"Illegal use of null object or 'null' literal" );			        if( (lhs instanceof Boolean || lhs instanceof Character ||	             lhs instanceof Number || lhs instanceof Primitive) &&	            (rhs instanceof Boolean || rhs instanceof Character ||	             rhs instanceof Number || rhs instanceof Primitive) )	        {	            return Primitive.binaryOperation(lhs, rhs, kind);	        }		        throw new UtilEvalError("Non primitive value in operator: " +	            lhs.getClass() + " " + tokenImage[kind] + " " + rhs.getClass() );	    }	
BSHBinaryExpression(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError	    {	        Object lhs = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);				/*				Doing instanceof?  Next node is a type.			*/	        if (kind == INSTANCEOF)	        {				// null object ref is not instance of any type				if ( lhs == Primitive.NULL )					return new Primitive(false);		            Class rhs = ((BSHType)jjtGetChild(1)).getType( 					callstack, interpreter );			/*				// primitive (number or void) cannot be tested for instanceof	            if (lhs instanceof Primitive)					throw new EvalError("Cannot be instance of primitive type." );			*/				/*					Primitive (number or void) is not normally an instanceof					anything.  But for internal use we'll test true for the					bsh.Primitive class.  					i.e. (5 instanceof bsh.Primitive) will be true				*/				if ( lhs instanceof Primitive )					if ( rhs == org.gjt.sp.jedit.bsh.Primitive.class )						return new Primitive(true);					else						return new Primitive(false);					// General case - performe the instanceof based on assignability	            boolean ret = Types.isJavaBaseAssignable( rhs, lhs.getClass() );	            return new Primitive(ret);	        }					// The following two boolean checks were tacked on.			// This could probably be smoothed out.				/*				Look ahead and short circuit evaluation of the rhs if:					we're a boolean AND and the lhs is false.			*/			if ( kind == BOOL_AND || kind == BOOL_ANDX ) {				Object obj = lhs;				if ( isPrimitiveValue(lhs) )					obj = ((Primitive)lhs).getValue();				if ( obj instanceof Boolean && 					( ((Boolean)obj).booleanValue() == false ) )					return new Primitive(false);			}			/*				Look ahead and short circuit evaluation of the rhs if:					we're a boolean AND and the lhs is false.			*/			if ( kind == BOOL_OR || kind == BOOL_ORX ) {				Object obj = lhs;				if ( isPrimitiveValue(lhs) )					obj = ((Primitive)lhs).getValue();				if ( obj instanceof Boolean && 					( ((Boolean)obj).booleanValue() == true ) )					return new Primitive(true);			}				// end stuff that was tacked on for boolean short-circuiting.				/*				Are both the lhs and rhs either wrappers or primitive values?				do binary op			*/			boolean isLhsWrapper = isWrapper( lhs );	        Object rhs = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);			boolean isRhsWrapper = isWrapper( rhs );			if ( 				( isLhsWrapper || isPrimitiveValue( lhs ) )				&& ( isRhsWrapper || isPrimitiveValue( rhs ) )			)	        {				// Special case for EQ on two wrapper objects				if ( (isLhsWrapper && isRhsWrapper && kind == EQ)) 				{					/*  						Don't auto-unwrap wrappers (preserve identity semantics)						FALL THROUGH TO OBJECT OPERATIONS BELOW.					*/				} else					try {						return Primitive.binaryOperation(lhs, rhs, kind);					} catch ( UtilEvalError e ) {						throw e.toEvalError( this, callstack  );					}	        }		/*		Doing the following makes it hard to use untyped vars...		e.g. if ( arg == null ) ...what if arg is a primitive?		The answer is that we should test only if the var is typed...?		need to get that info here...				else			{			// Do we have a mixture of primitive values and non-primitives ?  			// (primitiveValue = not null, not void)				int primCount = 0;			if ( isPrimitiveValue( lhs ) )				++primCount;			if ( isPrimitiveValue( rhs ) )				++primCount;				if ( primCount > 1 )				// both primitive types, should have been handled above				throw new InterpreterError("should not be here");			else 			if ( primCount == 1 )				// mixture of one and the other				throw new EvalError("Operator: '" + tokenImage[kind]					+"' inappropriate for object / primitive combination.", 					this, callstack );				// else fall through to handle both non-primitive types				// end check for primitive and non-primitive mix 			}		*/				/*				Treat lhs and rhs as arbitrary objects and do the operation.				(including NULL and VOID represented by their Primitive types)			*/			//System.out.println("binary op arbitrary obj: {"+lhs+"}, {"+rhs+"}");	        switch(kind)	        {	            case EQ:	                return new Primitive((lhs == rhs));		            case NE:	                return new Primitive((lhs != rhs));		            case PLUS:	                if(lhs instanceof String || rhs instanceof String)	                    return lhs.toString() + rhs.toString();		            // FALL THROUGH TO DEFAULT CASE!!!		            default:	                if(lhs instanceof Primitive || rhs instanceof Primitive)	                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )	                        throw new EvalError(					"illegal use of undefined variable, class, or 'void' literal", 								this, callstack );	                    else 						if ( lhs == Primitive.NULL || rhs == Primitive.NULL )	                        throw new EvalError(					"illegal use of null value or 'null' literal", this, callstack);		                throw new EvalError("Operator: '" + tokenImage[kind] +	                    "' inappropriate for objects", this, callstack );	        }	    }	
private boolean isPrimitiveValue( Object obj ) {	        return ( (obj instanceof Primitive) 				&& (obj != Primitive.VOID) && (obj != Primitive.NULL) );		}	
private boolean isWrapper( Object obj ) {	        return ( obj instanceof Boolean || 				obj instanceof Character || obj instanceof Number );		}	
BSHBlock(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter) 			throws EvalError		{			return eval( callstack, interpreter, false );		}	
/**			@param overrideNamespace if set to true the block will be executed			in the current namespace (not a subordinate one).			<p>			If true *no* new BlockNamespace will be swapped onto the stack and 			the eval will happen in the current			top namespace.  This is used by BshMethod, TryStatement, etc.  			which must intialize the block first and also for those that perform 			multiple passes in the same block.		*/		public Object eval( 			CallStack callstack, Interpreter interpreter, 			boolean overrideNamespace ) 			throws EvalError		{			Object syncValue = null;			if ( isSynchronized ) 			{				// First node is the expression on which to sync				SimpleNode exp = ((SimpleNode)jjtGetChild(0));				syncValue = exp.eval(callstack, interpreter);			}				Object ret;			if ( isSynchronized ) // Do the actual synchronization				synchronized( syncValue )				{					ret = evalBlock( 						callstack, interpreter, overrideNamespace, null/*filter*/);				}			else					ret = evalBlock( 						callstack, interpreter, overrideNamespace, null/*filter*/ );				return ret;		}	
Object evalBlock( 			CallStack callstack, Interpreter interpreter, 			boolean overrideNamespace, NodeFilter nodeFilter ) 			throws EvalError		{				Object ret = Primitive.VOID;			NameSpace enclosingNameSpace = null;			if ( !overrideNamespace ) 			{				enclosingNameSpace= callstack.top();				BlockNameSpace bodyNameSpace = 					new BlockNameSpace( enclosingNameSpace );					callstack.swap( bodyNameSpace );			}				int startChild = isSynchronized ? 1 : 0;			int numChildren = jjtGetNumChildren();				try {				/*					Evaluate block in two passes: 					First do class declarations then do everything else.				*/				for(int i=startChild; i<numChildren; i++)				{					SimpleNode node = ((SimpleNode)jjtGetChild(i));						if ( nodeFilter != null && !nodeFilter.isVisible( node ) )						continue;						if ( node instanceof BSHClassDeclaration )						node.eval( callstack, interpreter );				}				for(int i=startChild; i<numChildren; i++)				{					SimpleNode node = ((SimpleNode)jjtGetChild(i));					if ( node instanceof BSHClassDeclaration )						continue;						// filter nodes					if ( nodeFilter != null && !nodeFilter.isVisible( node ) )						continue;						ret = node.eval( callstack, interpreter );						// statement or embedded block evaluated a return statement					if ( ret instanceof ReturnControl )						break;				}			} finally {				// make sure we put the namespace back when we leave.				if ( !overrideNamespace ) 					callstack.swap( enclosingNameSpace );			}			return ret;		}	
public BSHCastExpression(int id) { super(id); }	
/**			@return the result of the cast.		*/		public Object eval(			CallStack callstack, Interpreter interpreter ) throws EvalError	    {			NameSpace namespace = callstack.top();	        Class toType = ((BSHType)jjtGetChild(0)).getType( 				callstack, interpreter );			SimpleNode expression = (SimpleNode)jjtGetChild(1);		        // evaluate the expression	        Object fromValue = expression.eval(callstack, interpreter);	        Class fromType = fromValue.getClass();				// TODO: need to add isJavaCastable() test for strictJava			// (as opposed to isJavaAssignable())			try {				return Types.castObject( fromValue, toType, Types.CAST );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack  );			}	    }	
BSHClassDeclaration(int id) { super(id); }	
/**		*/		public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError		{			int child = 0;				// resolve superclass if any			Class superClass = null;			if ( extend ) 			{				BSHAmbiguousName superNode = (BSHAmbiguousName)jjtGetChild(child++);				superClass = superNode.toClass( callstack, interpreter );			}				// Get interfaces			Class [] interfaces = new Class[numInterfaces];			for( int i=0; i<numInterfaces; i++) {				BSHAmbiguousName node = (BSHAmbiguousName)jjtGetChild(child++);				interfaces[i] = node.toClass(callstack, interpreter);				if ( !interfaces[i].isInterface() )					throw new EvalError(						"Type: "+node.text+" is not an interface!", 						this, callstack );			}				BSHBlock block;			// Get the class body BSHBlock			if ( child < jjtGetNumChildren() )				block = (BSHBlock)jjtGetChild(child);			else				block = new BSHBlock( ParserTreeConstants.JJTBLOCK );				try {				return ClassGenerator.getClassGenerator().generateClass( 					name, modifiers, interfaces, superClass, block, isInterface,					callstack, interpreter );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}			}	
public String toString() {			return "ClassDeclaration: "+name;		}	
/**	        @param bases URLs JARClassLoader seems to require absolute paths	    */	    public BshClassLoader( BshClassManager classManager, URL [] bases ) {	        super( bases );	        this.classManager = classManager;	    }	
/**	        @param bcp URLs JARClassLoader seems to require absolute paths	    */	    public BshClassLoader( BshClassManager classManager, BshClassPath bcp ) {	        this( classManager, bcp.getPathComponents() );	    }	
/**	        For use by children	        @param classManager URLs JARClassLoader seems to require absolute paths	    */	    protected BshClassLoader( BshClassManager classManager ) {	        this( classManager, new URL [] { } );	    }	
public void addURL( URL url ) {	        super.addURL( url );	    }	
/**	        This modification allows us to reload classes which are in the	        Java VM user classpath.  We search first rather than delegate to	        the parent classloader (or bootstrap path) first.		        An exception is for BeanShell core classes which are always loaded from	        the same classloader as the interpreter.	    */	    public Class loadClass(String name, boolean resolve)	        throws ClassNotFoundException	    {	        Class c = null;		        /*	            Check first for classes loaded through this loader.	            The VM will not allow a class to be loaded twice.	        */	        c = findLoadedClass(name);	        if ( c != null )	            return c;		// This is copied from ClassManagerImpl	// We should refactor this somehow if it sticks around	        if ( name.startsWith( ClassManagerImpl.BSH_PACKAGE ) )	            try {	                return org.gjt.sp.jedit.bsh.Interpreter.class.getClassLoader().loadClass( name );	            } catch ( ClassNotFoundException e ) {}		        /*	            Try to find the class using our classloading mechanism.	            Note: I wish we didn't have to catch the exception here... slow	        */	        try {	            c = findClass( name );	        } catch ( ClassNotFoundException e ) { }		        if ( c == null )	            throw new ClassNotFoundException("here in loaClass");		        if ( resolve )	            resolveClass( c );		        return c;	    }	
/**	        Find the correct source for the class...		        Try designated loader if any	        Try our URLClassLoader paths if any	        Try base loader if any	        Try system ???	    */	    // add some caching for not found classes?	    protected Class findClass( String name )	        throws ClassNotFoundException	    {	        // Deal with this cast somehow... maybe have this class use	        // ClassManagerImpl type directly.	        // Don't add the method to BshClassManager... it's really an impl thing	        ClassManagerImpl bcm = (ClassManagerImpl)getClassManager();		        // Should we try to load the class ourselves or delegate?	        // look for overlay loader		        // Deal with this cast somehow... maybe have this class use	        // ClassManagerImpl type directly.	        // Don't add the method to BshClassManager... it's really an impl thing	        ClassLoader cl = bcm.getLoaderForClass( name );		        Class c;		        // If there is a designated loader and it's not us delegate to it	        if ( cl != null && cl != this )	            try {	                return cl.loadClass( name );	            } catch ( ClassNotFoundException e ) {	                throw new ClassNotFoundException(	                    "Designated loader could not find class: "+e );	            }		        // Let URLClassLoader try any paths it may have	        if ( getURLs().length > 0 )	            try {	                return super.findClass(name);	            } catch ( ClassNotFoundException e ) {	                //System.out.println(	                //	"base loader here caught class not found: "+name );	            }			        // If there is a baseLoader and it's not us delegate to it	        cl = bcm.getBaseLoader();		        if ( cl != null && cl != this )	            try {	                return cl.loadClass( name );	            } catch ( ClassNotFoundException e ) { }		        // Try system loader	        return bcm.plainClassForName( name );	    }	
BshClassManager getClassManager() { return classManager; }	
/**	        Create a new instance of the class manager.	        Class manager instnaces are now associated with the interpreter.		        @see org.gjt.sp.jedit.bsh.Interpreter#getClassManager() getClassManager	        @see org.gjt.sp.jedit.bsh.Interpreter#setClassLoader(ClassLoader) setClassLoader	    */	    public static BshClassManager createClassManager( Interpreter interpreter )	    {	        BshClassManager manager;		        // Do we have the necessary jdk1.2 packages and optional package?	        if ( Capabilities.classExists("java.lang.ref.WeakReference")	            && Capabilities.classExists("java.util.HashMap")	            && Capabilities.classExists("org.gjt.sp.jedit.bsh.classpath.ClassManagerImpl")	        )	            try {	                // Try to load the module	                // don't refer to it directly here or we're dependent upon it	                Class clas = Class.forName( "org.gjt.sp.jedit.bsh.classpath.ClassManagerImpl" );	                manager = (BshClassManager)clas.newInstance();	            } catch ( Exception e ) {	                throw new InterpreterError("Error loading classmanager: "+e);	            }	        else	            manager = new BshClassManager();		        if ( interpreter == null )	            interpreter = new Interpreter();	        manager.declaringInterpreter = interpreter;	        return manager;	    }	
public boolean classExists( String name ) {	        return ( classForName( name ) != null );	    }	
/**	        Load the specified class by name, taking into account added classpath	        and reloaded classes, etc.	        Note: Again, this is just a trivial implementation.	        See bsh.classpath.ClassManagerImpl for the fully functional class	        management package.	        @return the class or null	    */	    public Class classForName( String name )	    {	        if ( isClassBeingDefined( name ) )	            throw new InterpreterError(	                "Attempting to load class in the process of being defined: "	                +name );		        Class clas = null;	        try {	            clas = plainClassForName( name );	        } catch ( ClassNotFoundException e ) { /*ignore*/ }		        // try scripted class	        if ( clas == null )	            clas = loadSourceClass( name );		        return clas;	    }	
protected Class loadSourceClass( String name )	    {	        String fileName = "/"+name.replace('.','/')+".java";	        InputStream in = getResourceAsStream( fileName );	        if ( in == null )	            return null;		        try {	            System.out.println("Loading class from source file: "+fileName);	            declaringInterpreter.eval( new InputStreamReader(in) );	        } catch ( EvalError e ) {	            // ignore	            System.err.println( e );	        }	        try {	            return plainClassForName( name );	        } catch ( ClassNotFoundException e ) {	            System.err.println("Class not found in source file: "+name );	            return null;	        }	    }	
/**	        Perform a plain Class.forName() or call the externally provided	        classloader.	        If a BshClassManager implementation is loaded the call will be	        delegated to it, to allow for additional hooks.	        <p/>		        This simply wraps that bottom level class lookup call and provides a	        central point for monitoring and handling certain Java version	        dependent bugs, etc.		        @see #classForName( String )	        @return the class	    */	    public Class plainClassForName( String name )	        throws ClassNotFoundException	    {	        Class c = null;		        try {	            if ( externalClassLoader != null )	                c = externalClassLoader.loadClass( name );	            else	                c = Class.forName( name );		            cacheClassInfo( name, c );		        /*	            Original note: Jdk under Win is throwing these to	            warn about lower case / upper case possible mismatch.	            e.g. bsh.console bsh.Console		            Update: Prior to 1.3 we were squeltching NoClassDefFoundErrors	            which was very annoying.  I cannot reproduce the original problem	            and this was never a valid solution.  If there are legacy VMs that	            have problems we can include a more specific test for them here.	        */	        } catch ( NoClassDefFoundError e ) {	            throw noClassDefFound( name, e );	        }		        return c;	    }	
/**	        Get a resource URL using the BeanShell classpath	        @param path should be an absolute path	    */	    public URL getResource( String path )	    {	        URL url = null;	        if ( externalClassLoader != null )	        {	            // classloader wants no leading slash	            url = externalClassLoader.getResource( path.substring(1) );	        }	        if ( url == null )	            url = Interpreter.class.getResource( path );		        return url;	    }	
/**	        Get a resource stream using the BeanShell classpath	        @param path should be an absolute path	    */	    public InputStream getResourceAsStream( String path )	    {	        InputStream in = null;	        if ( externalClassLoader != null )	        {	            // classloader wants no leading slash	            in = externalClassLoader.getResourceAsStream( path.substring(1) );	        }	        if ( in == null )	            in = Interpreter.class.getResourceAsStream( path );		        return in;	    }	
/**	        Cache info about whether name is a class or not.	        @param value	            if value is non-null, cache the class	            if value is null, set the flag that it is *not* a class to	            speed later resolution	    */	    public void cacheClassInfo( String name, Class value ) {	        if ( value != null )	            absoluteClassCache.put( name, value );	        else	            absoluteNonClasses.put( name, NOVALUE );	    }	
/**	        Cache a resolved (possibly overloaded) method based on the	        argument types used to invoke it, subject to classloader change.	        Static and Object methods are cached separately to support fast lookup	        in the general case where either will do.	    */	    public void cacheResolvedMethod(	        Class clas, Class [] types, Method method )	    {	        if ( Interpreter.DEBUG )	            Interpreter.debug(	                "cacheResolvedMethod putting: " + clas +" "+ method );		        SignatureKey sk = new SignatureKey( clas, method.getName(), types );	        if ( Modifier.isStatic( method.getModifiers() ) )	            resolvedStaticMethods.put( sk, method );	        else	            resolvedObjectMethods.put( sk, method );	    }	
/**	        Return a previously cached resolved method.	        @param onlyStatic specifies that only a static method may be returned.	        @return the Method or null	    */	    protected Method getResolvedMethod(	        Class clas, String methodName, Class [] types, boolean onlyStatic  )	    {	        SignatureKey sk = new SignatureKey( clas, methodName, types );		        // Try static and then object, if allowed	        // Note that the Java compiler should not allow both.	        Method method = (Method)resolvedStaticMethods.get( sk );	        if ( method == null && !onlyStatic)	            method = (Method)resolvedObjectMethods.get( sk );		        if ( Interpreter.DEBUG )	        {	            if ( method == null )	                Interpreter.debug(	                    "getResolvedMethod cache MISS: " + clas +" - "+methodName );	            else	                Interpreter.debug(	                    "getResolvedMethod cache HIT: " + clas +" - " +method );	        }	        return method;	    }	
/**	        Clear the caches in BshClassManager	    */	    protected void clearCaches()	    {	        absoluteNonClasses = new Hashtable();	        absoluteClassCache = new Hashtable();	        resolvedObjectMethods = new Hashtable();	        resolvedStaticMethods = new Hashtable();	    }	
/**	        Set an external class loader.  BeanShell will use this at the same	        point it would otherwise use the plain Class.forName().	        i.e. if no explicit classpath management is done from the script	        (addClassPath(), setClassPath(), reloadClasses()) then BeanShell will	        only use the supplied classloader.  If additional classpath management	        is done then BeanShell will perform that in addition to the supplied	        external classloader.	        However BeanShell is not currently able to reload	        classes supplied through the external classloader.	    */	    public void setClassLoader( ClassLoader externalCL )	    {	        externalClassLoader = externalCL;	        classLoaderChanged();	    }	
public void addClassPath( URL path )	        throws IOException {	    }	
/**	        Clear all loaders and start over.  No class loading.	    */	    public void reset() {	        clearCaches();	    }	
/**	        Set a new base classpath and create a new base classloader.	        This means all types change.	    */	    public void setClassPath( URL [] cp )	        throws UtilEvalError	    {	        throw cmUnavailable();	    }	
/**	        Overlay the entire path with a new class loader.	        Set the base path to the user path + base path.		        No point in including the boot class path (can't reload thos).	    */	    public void reloadAllClasses() throws UtilEvalError {	        throw cmUnavailable();	    }	
/**	        Reloading classes means creating a new classloader and using it	        whenever we are asked for classes in the appropriate space.	        For this we use a DiscreteFilesClassLoader	    */	    public void reloadClasses( String [] classNames )	        throws UtilEvalError	    {	        throw cmUnavailable();	    }	
/**	        Reload all classes in the specified package: e.g. "com.sun.tools"		        The special package name "<unpackaged>" can be used to refer	        to unpackaged classes.	    */	    public void reloadPackage( String pack )	        throws UtilEvalError	    {	        throw cmUnavailable();	    }	
/**	        Support for "import *;"	        Hide details in here as opposed to NameSpace.	    */	    protected void doSuperImport()	        throws UtilEvalError	    {	        throw cmUnavailable();	    }	
/**	        A "super import" ("import *") operation has been performed.	    */	    protected boolean hasSuperImport()	    {	        return false;	    }	
/**	        Return the name or null if none is found,	        Throw an ClassPathException containing detail if name is ambigous.	    */	    protected String getClassNameByUnqName( String name )	        throws UtilEvalError	    {	        throw cmUnavailable();	    }	
public void addListener( Listener l ) { }	
public void removeListener( Listener l ) { }	
public void dump( PrintWriter pw ) {	        pw.println("BshClassManager: no class manager.");	    }	
/**	        Flag the class name as being in the process of being defined.	        The class manager will not attempt to load it.	    */	    /*	        Note: this implementation is temporary. We currently keep a flat	        namespace of the base name of classes.  i.e. BeanShell cannot be in the	        process of defining two classes in different packages with the same	        base name.  To remove this limitation requires that we work through	        namespace imports in an analogous (or using the same path) as regular	        class import resolution.  This workaround should handle most cases	        so we'll try it for now.	    */	    protected void definingClass( String className ) {	        String baseName = Name.suffix(className,1);	        int i = baseName.indexOf("$");	        if ( i != -1 )	            baseName = baseName.substring(i+1);	        String cur = (String)definingClassesBaseNames.get( baseName );	        if ( cur != null )	            throw new InterpreterError("Defining class problem: "+className	                +": BeanShell cannot yet simultaneously define two or more "	                +"dependant classes of the same name.  Attempt to define: "	                + className +" while defining: "+cur	            );	        definingClasses.put( className, NOVALUE );	        definingClassesBaseNames.put( baseName, className );	    }	
protected boolean isClassBeingDefined( String className ) {	        return definingClasses.get( className ) != null;	    }	
/**	        This method is a temporary workaround used with definingClass.	        It is to be removed at some point.	    */	    protected String getClassBeingDefined( String className ) {	        String baseName = Name.suffix(className,1);	        return (String)definingClassesBaseNames.get( baseName );	    }	
/**	        Indicate that the specified class name has been defined and may be	        loaded normally.	    */	    protected void doneDefiningClass( String className ) {	        String baseName = Name.suffix(className,1);	        definingClasses.remove( className );	        definingClassesBaseNames.remove( baseName );	    }	
public Class defineClass( String name, byte [] code )	    {	        throw new InterpreterError("Can't create class ("+name	            +") without class manager package.");	    /*	        Old implementation injected classes into the parent classloader.	        This was incorrect behavior for several reasons.  The biggest problem	        is that classes could therefore only be defined once across all	        executions of the script...		        ClassLoader cl = this.getClass().getClassLoader();	        Class clas;	        try {	            clas = (Class)Reflect.invokeObjectMethod(	                cl, "defineClass",	                new Object [] {	                    name, code,	                    new Primitive( (int)0 )/offset/,	                    new Primitive( code.length )/len/	                },	                (Interpreter)null, (CallStack)null, (SimpleNode)null	            );	        } catch ( Exception e ) {	            e.printStackTrace();	            throw new InterpreterError("Unable to define class: "+ e );	        }	        absoluteNonClasses.remove( name ); // may have been axed previously	        return clas;	    */	    }	
protected void classLoaderChanged() { }	
/**	        Annotate the NoClassDefFoundError with some info about the class	        we were trying to load.	    */	    protected static Error noClassDefFound( String className, Error e ) {	        return new NoClassDefFoundError(	            "A class required by class: "+className +" could not be loaded:\n"	            +e.toString() );	    }	
protected static UtilEvalError cmUnavailable() {	        return new Capabilities.Unavailable(	            "ClassLoading features unavailable.");	    }	
SignatureKey( Class clas, String methodName, Class [] types ) {	            this.clas = clas;	            this.methodName = methodName;	            this.types = types;	        }	
public int hashCode()	        {	            if ( hashCode == 0 )	            {	                hashCode = clas.hashCode() * methodName.hashCode();	                if ( types == null ) // no args method	                    return hashCode;	                for( int i =0; i < types.length; i++ ) {	                    int hc = types[i] == null ? 21 : types[i].hashCode();	                    hashCode = hashCode*(i+1) + hc;	                }	            }	            return hashCode;	        }	
public boolean equals( Object o ) {	            SignatureKey target = (SignatureKey)o;	            if ( types == null )	                return target.types == null;	            if ( clas != target.clas )	                return false;	            if ( !methodName.equals( target.methodName ) )	                return false;	            if ( types.length != target.types.length )	                return false;	            for( int i =0; i< types.length; i++ )	            {	                if ( types[i]==null )	                {	                    if ( !(target.types[i]==null) )	                        return false;	                } else	                    if ( !types[i].equals( target.types[i] ) )	                        return false;	            }		            return true;	        }	
public BshClassPath( String name ) { 			this.name = name;			reset();		}	
public BshClassPath(  String name, URL [] urls ) {			this( name );			add( urls );		}	
public void setPath( URL[] urls ) {			reset();			add( urls );		}	
/**			Add the specified BshClassPath as a component of our path.			Changes in the bcp will be reflected through us.		*/		public void addComponent( BshClassPath bcp ) { 			if ( compPaths == null )				compPaths = new ArrayList();			compPaths.add( bcp );			bcp.addListener( this );		}	
public void add( URL [] urls ) { 			path.addAll( Arrays.asList(urls) );			if ( mapsInitialized )				map( urls );		}	
public void add( URL url ) throws IOException { 			path.add(url);			if ( mapsInitialized )				map( url );		}	
/**			Get the path components including any component paths.		*/		public URL [] getPathComponents() {			return (URL[])getFullPath().toArray( new URL[0] );		}	
/**			Return the set of class names in the specified package			including all component paths.		*/		synchronized public Set getClassesForPackage( String pack ) {			insureInitialized();			Set set = new HashSet();			Collection c = (Collection)packageMap.get( pack );			if ( c != null )				set.addAll( c );				if ( compPaths != null )				for (int i=0; i<compPaths.size(); i++) {					c = ((BshClassPath)compPaths.get(i)).getClassesForPackage( 						pack );					if ( c != null )						set.addAll( c );				}			return set;		}	
/**			Return the source of the specified class which may lie in component 			path.		*/		synchronized public ClassSource getClassSource( String className ) 		{			// Before triggering classpath mapping (initialization) check for			// explicitly set class sources (e.g. generated classes).  These would			// take priority over any found in the classpath anyway.			ClassSource cs = (ClassSource)classSource.get( className );			if ( cs != null )				return cs;				insureInitialized(); // trigger possible mapping				cs = (ClassSource)classSource.get( className );			if ( cs == null && compPaths != null )				for (int i=0; i<compPaths.size() && cs==null; i++)					cs = ((BshClassPath)compPaths.get(i)).getClassSource(className);			return cs;		}	
/**			Explicitly set a class source.  This is used for generated classes, but			could potentially be used to allow a user to override which version of			a class from the classpath is located.		*/		synchronized public void setClassSource( String className, ClassSource cs ) 		{			classSource.put( className, cs );		}	
/**			If the claspath map is not initialized, do it now.			If component maps are not do them as well...				Random note:			Should this be "insure" or "ensure".  I know I've seen "ensure" used			in the JDK source.  Here's what Webster has to say:					Main Entry:ensure Pronunciation:in-'shur				Function:transitive verb Inflected				Form(s):ensured; ensuring : to make sure,				certain, or safe : GUARANTEE synonyms ENSURE,				INSURE, ASSURE, SECURE mean to make a thing or				person sure. ENSURE, INSURE, and ASSURE are				interchangeable in many contexts where they				indicate the making certain or inevitable of an				outcome, but INSURE sometimes stresses the				taking of necessary measures beforehand, and				ASSURE distinctively implies the removal of				doubt and suspense from a person's mind. SECURE				implies action taken to guard against attack or				loss.		*/		public void insureInitialized() 		{			insureInitialized( true );		}	
/**			@param topPath indicates that this is the top level classpath			component and it should send the startClassMapping message		*/		protected synchronized void insureInitialized( boolean topPath ) 		{			// If we are the top path and haven't been initialized before			// inform the listeners we are going to do expensive map			if ( topPath && !mapsInitialized )				startClassMapping();				// initialize components			if ( compPaths != null )				for (int i=0; i< compPaths.size(); i++)					((BshClassPath)compPaths.get(i)).insureInitialized( false );				// initialize ourself			if ( !mapsInitialized ) 				map( (URL[])path.toArray( new URL[0] ) );				if ( topPath && !mapsInitialized )				endClassMapping();				mapsInitialized = true;		}	
/**			Get the full path including component paths.			(component paths listed first, in order)			Duplicate path components are removed.		*/		protected List getFullPath() 		{			List list = new ArrayList();			if ( compPaths != null ) {				for (int i=0; i<compPaths.size(); i++) {					List l = ((BshClassPath)compPaths.get(i)).getFullPath();					// take care to remove dups					// wish we had an ordered set collection					Iterator it = l.iterator();					while ( it.hasNext() ) {						Object o = it.next();						if ( !list.contains(o) )							list.add( o );					}				}			}			list.addAll( path );			return list;		}	
/**			Support for super import "*";			Get the full name associated with the unqualified name in this 			classpath.  Returns either the String name or an AmbiguousName object			encapsulating the various names.		*/		public String getClassNameByUnqName( String name ) 			throws ClassPathException		{			insureInitialized();			UnqualifiedNameTable unqNameTable = getUnqualifiedNameTable();				Object obj = unqNameTable.get( name );			if ( obj instanceof AmbiguousName )				throw new ClassPathException("Ambigous class names: "+					((AmbiguousName)obj).get() );				return (String)obj;		}	
private UnqualifiedNameTable getUnqualifiedNameTable() {			if ( unqNameTable == null )				unqNameTable = buildUnqualifiedNameTable();			return unqNameTable;		}	
private UnqualifiedNameTable buildUnqualifiedNameTable() 		{			UnqualifiedNameTable unqNameTable = new UnqualifiedNameTable();				// add component names			if ( compPaths != null )				for (int i=0; i<compPaths.size(); i++) {					Set s = ((BshClassPath)compPaths.get(i)).classSource.keySet();					Iterator it = s.iterator();					while(it.hasNext()) 						unqNameTable.add( (String)it.next() );				}				// add ours			Iterator it = classSource.keySet().iterator();			while(it.hasNext()) 				unqNameTable.add( (String)it.next() );						return unqNameTable;		}	
public String [] getAllNames() 		{			insureInitialized();				List names = new ArrayList();			Iterator it = getPackagesSet().iterator();			while( it.hasNext() ) {				String pack = (String)it.next();				names.addAll( 					removeInnerClassNames( getClassesForPackage( pack ) ) ); 			}				if ( nameCompletionIncludesUnqNames )				names.addAll( getUnqualifiedNameTable().keySet() );				return (String [])names.toArray(new String[0]);		}	
/**			call map(url) for each url in the array		*/		synchronized void map( URL [] urls ) 		{ 			for(int i=0; i< urls.length; i++)				try{					map( urls[i] );				} catch ( IOException e ) {					String s = "Error constructing classpath: " +urls[i]+": "+e;					errorWhileMapping( s );				}		}	
synchronized void map( URL url ) 			throws IOException 		{ 			String name = url.getFile();			File f = new File( name );				if ( f.isDirectory() ) {				classMapping( "Directory "+ f.toString() );				map( traverseDirForClasses( f ), new DirClassSource(f) );			} else if ( isArchiveFileName( name ) ) {				classMapping("Archive: "+url );				map( searchJarForClasses( url ), new JarClassSource(url) );			} 			/*			else if ( isClassFileName( name ) )				map( looseClass( name ), url );			*/			else {				String s = "Not a classpath component: "+ name ;				errorWhileMapping( s );			}		}	
private void map( String [] classes, Object source ) {			for(int i=0; i< classes.length; i++) {				//System.out.println( classes[i] +": "+ source );				mapClass( classes[i], source );			}		}	
private void mapClass( String className, Object source ) 		{			// add to package map			String [] sa = splitClassname( className );			String pack = sa[0];			String clas = sa[1];			Set set = (Set)packageMap.get( pack );			if ( set == null ) {				set = new HashSet();				packageMap.put( pack, set );			}			set.add( className );				// Add to classSource map			Object obj = classSource.get( className );			// don't replace previously set (found earlier in classpath or			// explicitly set via setClassSource() )			if ( obj == null )				classSource.put( className, source );		}	
/**			Clear everything and reset the path to empty.		*/		synchronized private void reset() {			path = new ArrayList();			compPaths = null;			clearCachedStructures();		}	
/**			Clear anything cached.  All will be reconstructed as necessary.		*/		synchronized private void clearCachedStructures() {			mapsInitialized = false;			packageMap = new HashMap();			classSource = new HashMap();			unqNameTable = null;			nameSpaceChanged();		}	
public void classPathChanged() {			clearCachedStructures();			notifyListeners();			}	
static String [] traverseDirForClasses( File dir ) 			throws IOException			{			List list = traverseDirForClassesAux( dir, dir );			return (String[])list.toArray( new String[0] );		}	
static List traverseDirForClassesAux( File topDir, File dir ) 			throws IOException		{			List list = new ArrayList();			String top = topDir.getAbsolutePath();				File [] children = dir.listFiles();			for (int i=0; i< children.length; i++)	{				File child = children[i];				if ( child.isDirectory() )					list.addAll( traverseDirForClassesAux( topDir, child ) );				else {					String name = child.getAbsolutePath();					if ( isClassFileName( name ) ) {						/* 							Remove absolute (topdir) portion of path and leave 							package-class part 						*/						if ( name.startsWith( top ) )							name = name.substring( top.length()+1 );						else							throw new IOException( "problem parsing paths" );							name = canonicalizeClassName(name);						list.add( name );					}				}			}									return list;		}	
/**			Get the class file entries from the Jar		*/		static String [] searchJarForClasses( URL jar ) 			throws IOException 		{			Vector v = new Vector();			InputStream in = jar.openStream(); 			ZipInputStream zin = new ZipInputStream(in);				ZipEntry ze;			while( (ze= zin.getNextEntry()) != null ) {				String name=ze.getName();				if ( isClassFileName( name ) )					v.addElement( canonicalizeClassName(name) );			}			zin.close();				String [] sa = new String [v.size()];			v.copyInto(sa);			return sa;		}	
public static boolean isClassFileName( String name ){			return ( name.toLowerCase().endsWith(".class") );				//&& (name.indexOf('$')==-1) );		}	
public static boolean isArchiveFileName( String name ){			name = name.toLowerCase();			return ( name.endsWith(".jar") || name.endsWith(".zip") );		}	
/**			Create a proper class name from a messy thing.			Turn / or \ into .,  remove leading class and trailing .class				Note: this makes lots of strings... could be faster.		*/		public static String canonicalizeClassName( String name ) 		{			String classname=name.replace('/', '.');			classname=classname.replace('\\', '.');			if ( classname.startsWith("class ") )				classname=classname.substring(6);			if ( classname.endsWith(".class") )				classname=classname.substring(0,classname.length()-6);			return classname;		}	
/**			Split class name into package and name		*/		public static String [] splitClassname ( String classname ) {			classname = canonicalizeClassName( classname );				int i=classname.lastIndexOf(".");			String classn, packn;			if ( i == -1 )  {				// top level class				classn = classname;				packn="<unpackaged>";			} else {				packn = classname.substring(0,i);				classn = classname.substring(i+1);			}			return new String [] { packn, classn };		}	
/**			Return a new collection without any inner class names		*/		public static Collection removeInnerClassNames( Collection col ) {			List list = new ArrayList();			list.addAll(col);			Iterator it = list.iterator();			while(it.hasNext()) {				String name =(String)it.next();				if (name.indexOf("$") != -1 )					it.remove();			}			return list;		}	
public static URL [] getUserClassPathComponents() 			throws ClassPathException		{			if ( userClassPathComp != null )				return userClassPathComp;				String cp=System.getProperty("java.class.path");			String [] paths=StringUtil.split(cp, File.pathSeparator);				URL [] urls = new URL[ paths.length ];			try {				for ( int i=0; i<paths.length; i++)					// We take care to get the canonical path first.					// Java deals with relative paths for it's bootstrap loader					// but JARClassLoader doesn't.					urls[i] = new File( 						new File(paths[i]).getCanonicalPath() ).toURL();			} catch ( IOException e ) {				throw new ClassPathException("can't parse class path: "+e);			}				userClassPathComp = urls;			return urls;		}	
/**			Get a list of all of the known packages		*/		public Set getPackagesSet() 		{			insureInitialized();			Set set = new HashSet();			set.addAll( packageMap.keySet() );				if ( compPaths != null )				for (int i=0; i<compPaths.size(); i++)					set.addAll( 						((BshClassPath)compPaths.get(i)).packageMap.keySet() );			return set;		}	
public void addListener( ClassPathListener l ) {			listeners.addElement( new WeakReference(l) );		}	
public void removeListener( ClassPathListener l ) {			listeners.removeElement( l );		}	
/**		*/		void notifyListeners() {			for (Enumeration e = listeners.elements(); e.hasMoreElements(); ) {				WeakReference wr = (WeakReference)e.nextElement();				ClassPathListener l = (ClassPathListener)wr.get();				if ( l == null )  // garbage collected					listeners.removeElement( wr );				else					l.classPathChanged();			}		}	
/**			A BshClassPath initialized to the user path			from java.class.path		*/		public static BshClassPath getUserClassPath() 			throws ClassPathException		{			if ( userClassPath == null )				userClassPath = new BshClassPath( 					"User Class Path", getUserClassPathComponents() );			return userClassPath;		}	
/**			Get the boot path including the lib/rt.jar if possible.		*/		public static BshClassPath getBootClassPath() 			throws ClassPathException		{			if ( bootClassPath == null )			{				try 				{					//String rtjar = System.getProperty("java.home")+"/lib/rt.jar";					String rtjar = getRTJarPath();					URL url = new File( rtjar ).toURL();					bootClassPath = new BshClassPath( 						"Boot Class Path", new URL[] { url } );				} catch ( MalformedURLException e ) {					throw new ClassPathException(" can't find boot jar: "+e);				}			}			return bootClassPath;		}	
private static String getRTJarPath()		{			String urlString =				Class.class.getResource("/java/lang/String.class").toExternalForm();				if ( !urlString.startsWith("jar:file:") )				return null;				int i = urlString.indexOf("!");			if ( i == -1 )				return null;				return urlString.substring( "jar:file:".length(), i );		}	
JarClassSource( URL url ) { source = url; }	
public URL getURL() { return (URL)source; }	
public byte [] getCode( String className ) {				throw new Error("Unimplemented");			}	
public String toString() { return "Jar: "+source; }	
DirClassSource( File dir ) { source = dir; }	
public File getDir() { return (File)source; }	
public String toString() { return "Dir: "+source; }	
public byte [] getCode( String className ) {				return readBytesFromFile( getDir(), className );			}	
public static byte [] readBytesFromFile( File base, String className ) 			{				String n = className.replace( '.', File.separatorChar ) + ".class";				File file = new File( base, n );					if ( file == null || !file.exists() )					return null;					byte [] bytes;				try {					FileInputStream fis = new FileInputStream(file);					DataInputStream dis = new DataInputStream( fis );			 					bytes = new byte [ (int)file.length() ];						dis.readFully( bytes );					dis.close();				} catch(IOException ie ) {					throw new RuntimeException("Couldn't load file: "+file);				}					return bytes;			}	
GeneratedClassSource( byte [] bytecode ) { source = bytecode; }	
public byte [] getCode( String className ) {				return (byte [])source; 			}	
public static void main( String [] args ) throws Exception {			URL [] urls = new URL [ args.length ];			for(int i=0; i< args.length; i++)				urls[i] =  new File(args[i]).toURL();			BshClassPath bcp = new BshClassPath( "Test", urls );		}	
public String toString() {			return "BshClassPath "+name+"("+super.toString()+") path= "+path +"\n"				+ "compPaths = {" + compPaths +" }";		}	
void add( String fullname ) {				String name = splitClassname( fullname )[1];				Object have = super.get( name );					if ( have == null )					super.put( name, fullname );				else					if ( have instanceof AmbiguousName )						((AmbiguousName)have).add( fullname );					else  // String					{						AmbiguousName an = new AmbiguousName();						an.add( (String)have );						an.add( fullname );						super.put( name, an );					}			}	
public void add( String name ) { 				list.add( name ); 			}	
public List get() {				//return (String[])list.toArray(new String[0]);				return list;			}	
/**			Fire the NameSourceListeners		*/		void nameSpaceChanged() 		{			if ( nameSourceListeners == null )				return;				for(int i=0; i<nameSourceListeners.size(); i++)				((NameSource.Listener)(nameSourceListeners.get(i)))					.nameSourceChanged( this );		}	
/**			Implements NameSource			Add a listener who is notified upon changes to names in this space.		*/		public void addNameSourceListener( NameSource.Listener listener ) {			if ( nameSourceListeners == null )				nameSourceListeners = new ArrayList();			nameSourceListeners.add( listener );		}	
/**		*/		public static void addMappingFeedback( MappingFeedback mf ) 		{			if ( mappingFeedbackListener != null )				throw new RuntimeException("Unimplemented: already a listener");			mappingFeedbackListener = mf;		}	
void startClassMapping() {			if ( mappingFeedbackListener != null )				mappingFeedbackListener.startClassMapping();			else				System.err.println( "Start ClassPath Mapping" );		}	
void classMapping( String msg ) {			if ( mappingFeedbackListener != null ) {				mappingFeedbackListener.classMapping( msg );			} else				System.err.println( "Mapping: "+msg );		}	
void errorWhileMapping( String s ) {			if ( mappingFeedbackListener != null )				mappingFeedbackListener.errorWhileMapping( s );			else				System.err.println( s );		}	
void endClassMapping() {			if ( mappingFeedbackListener != null )				mappingFeedbackListener.endClassMapping();			else				System.err.println( "End ClassPath Mapping" );		}	
BSHEnhancedForStatement(int id) { super(id); }	
public Object eval( CallStack callstack , Interpreter interpreter )			throws EvalError 		{			Class elementType = null;			SimpleNode expression, statement=null;				NameSpace enclosingNameSpace = callstack.top();			SimpleNode firstNode =((SimpleNode)jjtGetChild(0));			int nodeCount = jjtGetNumChildren();						if ( firstNode instanceof BSHType ) 			{				elementType=((BSHType)firstNode).getType( callstack, interpreter );				expression=((SimpleNode)jjtGetChild(1));				if ( nodeCount>2 )					statement=((SimpleNode)jjtGetChild(2));			} else 			{				expression=firstNode;				if ( nodeCount>1 )					statement=((SimpleNode)jjtGetChild(1));			}				BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );			callstack.swap( eachNameSpace );				final Object iteratee = expression.eval( callstack, interpreter );				if ( iteratee == Primitive.NULL )				throw new EvalError("The collection, array, map, iterator, or " +					"enumeration portion of a for statement cannot be null.", 					this, callstack );				CollectionManager cm = CollectionManager.getCollectionManager();			if ( !cm.isBshIterable( iteratee ) )				throw new EvalError("Can't iterate over type: "					+iteratee.getClass(), this, callstack );			BshIterator iterator = cm.getBshIterator( iteratee );						Object returnControl = Primitive.VOID;	        while( iterator.hasNext() )	        {				try {				if ( elementType != null )					eachNameSpace.setTypedVariable(						varName/*name*/, elementType/*type*/,						iterator.next()/*value*/, new Modifiers()/*none*/ );				else					eachNameSpace.setVariable( varName, iterator.next(), false );				} catch ( UtilEvalError e ) {					throw e.toEvalError(						"for loop iterator variable:"+ varName, this, callstack );				}		            boolean breakout = false; // switch eats a multi-level break here?	            if ( statement != null ) // not empty statement	            {	                Object ret = statement.eval( callstack, interpreter );		                if (ret instanceof ReturnControl)	                {	                    switch(((ReturnControl)ret).kind)	                    {	                        case RETURN:								returnControl = ret;								breakout = true;	                            break;		                        case CONTINUE:	                            break;		                        case BREAK:	                            breakout = true;	                            break;	                    }	                }	            }		            if (breakout)	                break;	        }				callstack.swap(enclosingNameSpace);	        return returnControl;	    }	
public BSHFormalComment(int id) {			super(id);		}	
BSHFormalParameter(int id) { super(id); }	
public String getTypeDescriptor( 			CallStack callstack, Interpreter interpreter, String defaultPackage ) 		{			if ( jjtGetNumChildren() > 0 )				return ((BSHType)jjtGetChild(0)).getTypeDescriptor( 					callstack, interpreter, defaultPackage );			else				// this will probably not get used				return "Ljava/lang/Object;";  // Object type		}	
/**			Evaluate the type.		*/		public Object eval( CallStack callstack, Interpreter interpreter) 			throws EvalError		{			if ( jjtGetNumChildren() > 0 )				type = ((BSHType)jjtGetChild(0)).getType( callstack, interpreter );			else				type = UNTYPED;				return type;		}	
BSHFormalParameters(int id) { super(id); }	
void insureParsed() 		{			if ( paramNames != null )				return;				this.numArgs = jjtGetNumChildren();			String [] paramNames = new String[numArgs];				for(int i=0; i<numArgs; i++)			{				BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);				paramNames[i] = param.name;			}				this.paramNames = paramNames;		}	
public String [] getParamNames() { 			insureParsed();			return paramNames;		}	
public String [] getTypeDescriptors( 			CallStack callstack, Interpreter interpreter, String defaultPackage )		{			if ( typeDescriptors != null )				return typeDescriptors;				insureParsed();			String [] typeDesc = new String[numArgs];				for(int i=0; i<numArgs; i++)			{				BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);				typeDesc[i] = param.getTypeDescriptor( 					callstack, interpreter, defaultPackage );			}				this.typeDescriptors = typeDesc;			return typeDesc;		}	
/**			Evaluate the types.  			Note that type resolution does not require the interpreter instance.		*/		public Object eval( CallStack callstack, Interpreter interpreter )  			throws EvalError		{			if ( paramTypes != null )				return paramTypes;				insureParsed();			Class [] paramTypes = new Class[numArgs];				for(int i=0; i<numArgs; i++)			{				BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);				paramTypes[i] = (Class)param.eval( callstack, interpreter );			}				this.paramTypes = paramTypes;				return paramTypes;		}	
BSHForStatement(int id) { super(id); }	
public Object eval(CallStack callstack , Interpreter interpreter)  			throws EvalError	    {	        int i = 0;	        if(hasForInit)	            forInit = ((SimpleNode)jjtGetChild(i++));	        if(hasExpression)	            expression = ((SimpleNode)jjtGetChild(i++));	        if(hasForUpdate)	            forUpdate = ((SimpleNode)jjtGetChild(i++));	        if(i < jjtGetNumChildren()) // should normally be	            statement = ((SimpleNode)jjtGetChild(i));				NameSpace enclosingNameSpace= callstack.top();			BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );				/*				Note: some interesting things are going on here.					1) We swap instead of push...  The primary mode of operation 				acts like we are in the enclosing namespace...  (super must be 				preserved, etc.)					2) We do *not* call the body block eval with the namespace 				override.  Instead we allow it to create a second subordinate 				BlockNameSpace child of the forNameSpace.  Variable propogation 				still works through the chain, but the block's child cleans the 				state between iteration.  				(which is correct Java behavior... see forscope4.bsh)			*/				// put forNameSpace it on the top of the stack			// Note: it's important that there is only one exit point from this			// method so that we can swap back the namespace.			callstack.swap( forNameSpace );		        // Do the for init	        if ( hasForInit ) 	            forInit.eval( callstack, interpreter );				Object returnControl = Primitive.VOID;	        while(true)	        {	            if ( hasExpression ) 				{					boolean cond = BSHIfStatement.evaluateCondition(						expression, callstack, interpreter );						if ( !cond ) 						break;				}		            boolean breakout = false; // switch eats a multi-level break here?	            if ( statement != null ) // not empty statement	            {					// do *not* invoke special override for block... (see above)	                Object ret = statement.eval( callstack, interpreter );		                if (ret instanceof ReturnControl)	                {	                    switch(((ReturnControl)ret).kind)	                    {	                        case RETURN:								returnControl = ret;								breakout = true;	                            break;		                        case CONTINUE:	                            break;		                        case BREAK:	                            breakout = true;	                            break;	                    }	                }	            }		            if ( breakout )	                break;		            if ( hasForUpdate )	                forUpdate.eval( callstack, interpreter );	        }				callstack.swap( enclosingNameSpace );  // put it back	        return returnControl;	    }	
BSHIfStatement(int id) { super(id); }	
public Object eval(CallStack callstack, Interpreter interpreter)  			throws EvalError	    {	        Object ret = null;		        if( evaluateCondition( 				(SimpleNode)jjtGetChild(0), callstack, interpreter ) )	            ret = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);	        else	            if(jjtGetNumChildren() > 2)	                ret = ((SimpleNode)jjtGetChild(2)).eval(callstack, interpreter);		        if(ret instanceof ReturnControl)	            return ret;	        else    	            return Primitive.VOID;	    }	
public static boolean evaluateCondition(			SimpleNode condExp, CallStack callstack, Interpreter interpreter) 			throws EvalError	    {	        Object obj = condExp.eval(callstack, interpreter);	        if(obj instanceof Primitive) {				if ( obj == Primitive.VOID )					throw new EvalError("Condition evaluates to void type", 						condExp, callstack );	            obj = ((Primitive)obj).getValue();			}		        if(obj instanceof Boolean)	            return ((Boolean)obj).booleanValue();	        else	            throw new EvalError(					"Condition must evaluate to a Boolean or boolean.", 					condExp, callstack );	    }	
BSHImportDeclaration(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter) 			throws EvalError		{			NameSpace namespace = callstack.top();			if ( superImport )				try {					namespace.doSuperImport();				} catch ( UtilEvalError e ) {					throw e.toEvalError( this, callstack  );				}			else 			{				if ( staticImport )				{					if ( importPackage )					{						Class clas = ((BSHAmbiguousName)jjtGetChild(0)).toClass( 							callstack, interpreter );						namespace.importStatic( clas );					} else						throw new EvalError( 							"static field imports not supported yet", 							this, callstack );				} else 				{					String name = ((BSHAmbiguousName)jjtGetChild(0)).text;					if ( importPackage )						namespace.importPackage(name);					else						namespace.importClass(name);				}			}		        return Primitive.VOID;		}	
BSHLiteral(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError	    {			if ( value == null )				throw new InterpreterError("Null in bsh literal: "+value);		        return value;	    }	
private char getEscapeChar(char ch)	    {	        switch(ch)	        {	            case 'b':	                ch = '\b';	                break;		            case 't':	                ch = '\t';	                break;		            case 'n':	                ch = '\n';	                break;		            case 'f':	                ch = '\f';	                break;		            case 'r':	                ch = '\r';	                break;		            // do nothing - ch already contains correct character	            case '"':	            case '\'':	            case '\\':	                break;	        }		        return ch;	    }	
public void charSetup(String str)	    {	        char ch = str.charAt(0);	        if(ch == '\\')	        {	            // get next character	            ch = str.charAt(1);		            if(Character.isDigit(ch))	                ch = (char)Integer.parseInt(str.substring(1), 8);	            else	                ch = getEscapeChar(ch);	        }		        value = new Primitive(new Character(ch).charValue());	    }	
void stringSetup(String str)	    {	        StringBuilder buffer = new StringBuilder();	        for(int i = 0; i < str.length(); i++)	        {	            char ch = str.charAt(i);	            if(ch == '\\')	            {	                // get next character	                ch = str.charAt(++i);		                if(Character.isDigit(ch))	                {	                    int endPos = i;		                    // check the next two characters	                    while(endPos < i + 2)	                    {	                        if(Character.isDigit(str.charAt(endPos + 1)))	                            endPos++;	                        else	                            break;	                    }		                    ch = (char)Integer.parseInt(str.substring(i, endPos + 1), 8);	                    i = endPos;	                }	                else	                    ch = getEscapeChar(ch);	            }		            buffer.append(ch);	        }		        value = buffer.toString().intern();	    }	
BshMethod( 			BSHMethodDeclaration method, 			NameSpace declaringNameSpace, Modifiers modifiers ) 		{			this( method.name, method.returnType, method.paramsNode.getParamNames(),				method.paramsNode.paramTypes, method.blockNode, declaringNameSpace,				modifiers );		}	
BshMethod( 			String name, Class returnType, String [] paramNames,			Class [] paramTypes, BSHBlock methodBody, 			NameSpace declaringNameSpace, Modifiers modifiers		) {			this.name = name;			this.creturnType = returnType;			this.paramNames = paramNames;			if ( paramNames != null )				this.numArgs = paramNames.length;			this.cparamTypes = paramTypes;			this.methodBody = methodBody;			this.declaringNameSpace = declaringNameSpace;			this.modifiers = modifiers;		}	
BshMethod( Method method, Object object )		{			this( method.getName(), method.getReturnType(), null/*paramNames*/,				method.getParameterTypes(), null/*method.block*/, 				null/*declaringNameSpace*/, null/*modifiers*/ );				this.javaMethod = method;			this.javaObject = object;		}	
/**			Get the argument types of this method.			loosely typed (untyped) arguments will be represented by null argument			types.		*/		/*			Note: bshmethod needs to re-evaluate arg types here			This is broken.		*/		public Class [] getParameterTypes() { return cparamTypes; }	
public String [] getParameterNames() { return paramNames; }	
/**			Get the return type of the method.			@return Returns null for a loosely typed return value, 				Void.TYPE for a void return type, or the Class of the type.		*/		/*			Note: bshmethod needs to re-evaluate the method return type here.			This is broken.		*/		public Class getReturnType() { return creturnType; }	
public Modifiers getModifiers() { return modifiers; }	
public String getName() { return name; }	
/**			Invoke the declared method with the specified arguments and interpreter			reference.  This is the simplest form of invoke() for BshMethod 			intended to be used in reflective style access to bsh scripts.		*/		public Object invoke( 			Object[] argValues, Interpreter interpreter ) 			throws EvalError 		{			return invoke( argValues, interpreter, null, null, false );		}	
/**			Invoke the bsh method with the specified args, interpreter ref,			and callstack.			callerInfo is the node representing the method invocation			It is used primarily for debugging in order to provide access to the 			text of the construct that invoked the method through the namespace.			@param callerInfo is the BeanShell AST node representing the method 				invocation.  It is used to print the line number and text of 				errors in EvalError exceptions.  If the node is null here error				messages may not be able to point to the precise location and text				of the error.			@param callstack is the callstack.  If callstack is null a new one				will be created with the declaring namespace of the method on top				of the stack (i.e. it will look for purposes of the method 				invocation like the method call occurred in the declaring 				(enclosing) namespace in which the method is defined).		*/		public Object invoke( 			Object[] argValues, Interpreter interpreter, CallStack callstack,				SimpleNode callerInfo ) 			throws EvalError 		{			return invoke( argValues, interpreter, callstack, callerInfo, false );		}	
/**			Invoke the bsh method with the specified args, interpreter ref,			and callstack.			callerInfo is the node representing the method invocation			It is used primarily for debugging in order to provide access to the 			text of the construct that invoked the method through the namespace.			@param callerInfo is the BeanShell AST node representing the method 				invocation.  It is used to print the line number and text of 				errors in EvalError exceptions.  If the node is null here error				messages may not be able to point to the precise location and text				of the error.			@param callstack is the callstack.  If callstack is null a new one				will be created with the declaring namespace of the method on top				of the stack (i.e. it will look for purposes of the method 				invocation like the method call occurred in the declaring 				(enclosing) namespace in which the method is defined).			@param overrideNameSpace 				When true the method is executed in the namespace on the top of the				stack instead of creating its own local namespace.  This allows it				to be used in constructors.		*/		Object invoke( 			Object[] argValues, Interpreter interpreter, CallStack callstack,				SimpleNode callerInfo, boolean overrideNameSpace ) 			throws EvalError 		{			if ( argValues != null )				for (int i=0; i<argValues.length; i++)					if ( argValues[i] == null )						throw new Error("HERE!");				if ( javaMethod != null )				try {					return Reflect.invokeMethod(						javaMethod, javaObject, argValues ); 				} catch ( ReflectError e ) {					throw new EvalError(						"Error invoking Java method: "+e, callerInfo, callstack );				} catch ( InvocationTargetException e2 ) {					throw new TargetError( 						"Exception invoking imported object method.", 						e2, callerInfo, callstack, true/*isNative*/ );				}				// is this a syncrhonized method?			if ( modifiers != null && modifiers.hasModifier("synchronized") )			{				// The lock is our declaring namespace's This reference				// (the method's 'super').  Or in the case of a class it's the				// class instance.				Object lock;				if ( declaringNameSpace.isClass )				{					try {						lock = declaringNameSpace.getClassInstance();					} catch ( UtilEvalError e ) {						throw new InterpreterError(							"Can't get class instance for synchronized method.");					}				} else					lock = declaringNameSpace.getThis(interpreter); // ???					synchronized( lock ) 				{					return invokeImpl( 						argValues, interpreter, callstack, 						callerInfo, overrideNameSpace );				}			} else				return invokeImpl( argValues, interpreter, callstack, callerInfo,					overrideNameSpace );		}	
private Object invokeImpl( 			Object[] argValues, Interpreter interpreter, CallStack callstack,				SimpleNode callerInfo, boolean overrideNameSpace ) 			throws EvalError 		{			Class returnType = getReturnType();			Class [] paramTypes = getParameterTypes();				// If null callstack			if ( callstack == null )				callstack = new CallStack( declaringNameSpace );				if ( argValues == null )				argValues = new Object [] { };				// Cardinality (number of args) mismatch			if ( argValues.length != numArgs ) 			{			/*				// look for help string				try {					// should check for null namespace here					String help = 						(String)declaringNameSpace.get(						"bsh.help."+name, interpreter );						interpreter.println(help);					return Primitive.VOID;				} catch ( Exception e ) {					throw eval error				}			*/				throw new EvalError( 					"Wrong number of arguments for local method: " 					+ name, callerInfo, callstack );			}				// Make the local namespace for the method invocation			NameSpace localNameSpace;			if ( overrideNameSpace )				localNameSpace = callstack.top();			else			{				localNameSpace = new NameSpace( declaringNameSpace, name );				localNameSpace.isMethod = true;			}			// should we do this for both cases above?			localNameSpace.setNode( callerInfo );				// set the method parameters in the local namespace			for(int i=0; i<numArgs; i++)			{				// Set typed variable				if ( paramTypes[i] != null ) 				{					try {						argValues[i] =							//Types.getAssignableForm( argValues[i], paramTypes[i] );							Types.castObject( argValues[i], paramTypes[i], Types.ASSIGNMENT );					}					catch( UtilEvalError e) {						throw new EvalError(							"Invalid argument: " 							+ "`"+paramNames[i]+"'" + " for method: " 							+ name + " : " + 							e.getMessage(), callerInfo, callstack );					}					try {						localNameSpace.setTypedVariable( paramNames[i], 							paramTypes[i], argValues[i], null/*modifiers*/);					} catch ( UtilEvalError e2 ) {						throw e2.toEvalError( "Typed method parameter assignment", 							callerInfo, callstack  );					}				} 				// Set untyped variable				else  // untyped param				{					// getAssignable would catch this for typed param					if ( argValues[i] == Primitive.VOID)						throw new EvalError(							"Undefined variable or class name, parameter: " +							paramNames[i] + " to method: " 							+ name, callerInfo, callstack );					else						try {							localNameSpace.setLocalVariable(								paramNames[i], argValues[i],								interpreter.getStrictJava() );						} catch ( UtilEvalError e3 ) {							throw e3.toEvalError( callerInfo, callstack );						}				}			}				// Push the new namespace on the call stack			if ( !overrideNameSpace )				callstack.push( localNameSpace );				// Invoke the block, overriding namespace with localNameSpace			Object ret = methodBody.eval( 				callstack, interpreter, true/*override*/ );				// save the callstack including the called method, just for error mess			CallStack returnStack = callstack.copy();				// Get back to caller namespace			if ( !overrideNameSpace )				callstack.pop();				ReturnControl retControl = null;			if ( ret instanceof ReturnControl )			{				retControl = (ReturnControl)ret;					// Method body can only use 'return' statment type return control.				if ( retControl.kind == retControl.RETURN )					ret = ((ReturnControl)ret).value;				else 					// retControl.returnPoint is the Node of the return statement					throw new EvalError("'continue' or 'break' in method body", 						retControl.returnPoint, returnStack );					// Check for explicit return of value from void method type.				// retControl.returnPoint is the Node of the return statement				if ( returnType == Void.TYPE && ret != Primitive.VOID )					throw new EvalError( "Cannot return value from void method", 					retControl.returnPoint, returnStack);			}				if ( returnType != null )			{				// If return type void, return void as the value.				if ( returnType == Void.TYPE )					return Primitive.VOID;					// return type is a class				try {					ret =						// Types.getAssignableForm( ret, (Class)returnType );						Types.castObject( ret, returnType, Types.ASSIGNMENT );				} catch( UtilEvalError e )				{					// Point to return statement point if we had one.					// (else it was implicit return? What's the case here?)					SimpleNode node = callerInfo;					if ( retControl != null )						node = retControl.returnPoint;					throw e.toEvalError(						"Incorrect type returned from method: " 						+ name + e.getMessage(), node, callstack );				}			}				return ret;		}	
public boolean hasModifier( String name ) {			return modifiers != null && modifiers.hasModifier(name);		}	
public String toString() {			return "Scripted Method: "				+ StringUtil.methodString( name, getParameterTypes() ); 		}	
BSHMethodDeclaration(int id) { super(id); }	
/**			Set the returnTypeNode, paramsNode, and blockNode based on child			node structure.  No evaluation is done here.		*/		synchronized void insureNodesParsed() 		{			if ( paramsNode != null ) // there is always a paramsNode				return;				Object firstNode = jjtGetChild(0);			firstThrowsClause = 1;			if ( firstNode instanceof BSHReturnType )			{				returnTypeNode = (BSHReturnType)firstNode;				paramsNode = (BSHFormalParameters)jjtGetChild(1);				if ( jjtGetNumChildren() > 2+numThrows )					blockNode = (BSHBlock)jjtGetChild(2+numThrows); // skip throws				++firstThrowsClause;			}			else			{				paramsNode = (BSHFormalParameters)jjtGetChild(0);				blockNode = (BSHBlock)jjtGetChild(1+numThrows); // skip throws			}		}	
/**			Evaluate the return type node.			@return the type or null indicating loosely typed return		*/		Class evalReturnType( CallStack callstack, Interpreter interpreter )			throws EvalError		{			insureNodesParsed();			if ( returnTypeNode != null )				return returnTypeNode.evalReturnType( callstack, interpreter );			else 				return null;		}	
String getReturnTypeDescriptor( 			CallStack callstack, Interpreter interpreter, String defaultPackage )		{			insureNodesParsed();			if ( returnTypeNode == null )				return null;			else				return returnTypeNode.getTypeDescriptor( 					callstack, interpreter, defaultPackage );		}	
BSHReturnType getReturnTypeNode() {			insureNodesParsed();			return returnTypeNode;		}	
/**			Evaluate the declaration of the method.  That is, determine the			structure of the method and install it into the caller's namespace.		*/		public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError		{			returnType = evalReturnType( callstack, interpreter );			evalNodes( callstack, interpreter );				// Install an *instance* of this method in the namespace.			// See notes in BshMethod 		// This is not good...	// need a way to update eval without re-installing...	// so that we can re-eval params, etc. when classloader changes	// look into this				NameSpace namespace = callstack.top();			BshMethod bshMethod = new BshMethod( this, namespace, modifiers );			try {				namespace.setMethod( name, bshMethod );			} catch ( UtilEvalError e ) {				throw e.toEvalError(this,callstack);			}				return Primitive.VOID;		}	
private void evalNodes( CallStack callstack, Interpreter interpreter ) 			throws EvalError		{			insureNodesParsed();						// validate that the throws names are class names			for(int i=firstThrowsClause; i<numThrows+firstThrowsClause; i++)				((BSHAmbiguousName)jjtGetChild(i)).toClass( 					callstack, interpreter );				paramsNode.eval( callstack, interpreter );				// if strictJava mode, check for loose parameters and return type			if ( interpreter.getStrictJava() )			{				for(int i=0; i<paramsNode.paramTypes.length; i++)					if ( paramsNode.paramTypes[i] == null )						// Warning: Null callstack here.  Don't think we need						// a stack trace to indicate how we sourced the method.						throw new EvalError(					"(Strict Java Mode) Undeclared argument type, parameter: " +						paramsNode.getParamNames()[i] + " in method: " 						+ name, this, null );					if ( returnType == null )					// Warning: Null callstack here.  Don't think we need					// a stack trace to indicate how we sourced the method.					throw new EvalError(					"(Strict Java Mode) Undeclared return type for method: "						+ name, this, null );			}		}	
public String toString() {			return "MethodDeclaration: "+name;		}	
BSHMethodInvocation (int id) { super(id); }	
BSHAmbiguousName getNameNode() {			return (BSHAmbiguousName)jjtGetChild(0);		}	
BSHArguments getArgsNode() {			return (BSHArguments)jjtGetChild(1);		}	
/**			Evaluate the method invocation with the specified callstack and 			interpreter		*/		public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError		{			NameSpace namespace = callstack.top();			BSHAmbiguousName nameNode = getNameNode();				// Do not evaluate methods this() or super() in class instance space			// (i.e. inside a constructor)			if ( namespace.getParent() != null && namespace.getParent().isClass				&& ( nameNode.text.equals("super") || nameNode.text.equals("this") )			)				return Primitive.VOID;	 			Name name = nameNode.getName(namespace);			Object[] args = getArgsNode().getArguments(callstack, interpreter);		// This try/catch block is replicated is BSHPrimarySuffix... need to	// factor out common functionality...	// Move to Reflect?			try {				return name.invokeMethod( interpreter, args, callstack, this);			} catch ( ReflectError e ) {				throw new EvalError(					"Error in method invocation: " + e.getMessage(), 					this, callstack );			} catch ( InvocationTargetException e ) 			{				String msg = "Method Invocation "+name;				Throwable te = e.getTargetException();					/*					Try to squeltch the native code stack trace if the exception					was caused by a reflective call back into the bsh interpreter					(e.g. eval() or source()				*/				boolean isNative = true;				if ( te instanceof EvalError ) 					if ( te instanceof TargetError )						isNative = ((TargetError)te).inNativeCode();					else						isNative = false;								throw new TargetError( msg, te, this, callstack, isNative );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}		}	
public BSHPackageDeclaration(int id) {	    super(id);	  }	
public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError		{			BSHAmbiguousName name = (BSHAmbiguousName)jjtGetChild(0);			NameSpace namespace = callstack.top();			namespace.setPackage( name.text );			// import the package we're in by default...			namespace.importPackage( name.text );			return Primitive.VOID;		}	
BSHPrimaryExpression(int id) { super(id); }	
/**			Evaluate to a value object.		*/		public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError		{			return eval( false, callstack, interpreter );		}	
/**			Evaluate to a value object.		*/		public LHS toLHS( CallStack callstack, Interpreter interpreter)  			throws EvalError		{			Object obj = eval( true, callstack, interpreter );				if ( ! (obj instanceof LHS) )				throw new EvalError("Can't assign to:", this, callstack );			else				return (LHS)obj;		}	
private Object eval( boolean toLHS, 			CallStack callstack, Interpreter interpreter)  			throws EvalError		{			Object obj = jjtGetChild(0);			int numChildren = jjtGetNumChildren(); 				for(int i=1; i<numChildren; i++)				obj = ((BSHPrimarySuffix)jjtGetChild(i)).doSuffix(					obj, toLHS, callstack, interpreter);				/*				If the result is a Node eval() it to an object or LHS				(as determined by toLHS)			*/			if ( obj instanceof SimpleNode )				if ( obj instanceof BSHAmbiguousName )					if ( toLHS )						obj = ((BSHAmbiguousName)obj).toLHS(							callstack, interpreter);					else						obj = ((BSHAmbiguousName)obj).toObject(							callstack, interpreter);				else 					// Some arbitrary kind of node					if ( toLHS )						// is this right?						throw new EvalError("Can't assign to prefix.", 							this, callstack );					else						obj = ((SimpleNode)obj).eval(callstack, interpreter);					// return LHS or value object as determined by toLHS			if ( obj instanceof LHS )				if ( toLHS )					return obj;				else					try {						return ((LHS)obj).getValue();					} catch ( UtilEvalError e ) {						throw e.toEvalError( this, callstack );					}			else				return obj;		}	
BSHPrimarySuffix(int id) { super(id); }	
public Object doSuffix(			Object obj, boolean toLHS, 			CallStack callstack, Interpreter interpreter) 			throws EvalError		{			// Handle ".class" suffix operation			// Prefix must be a BSHType			if ( operation == CLASS )				if ( obj instanceof BSHType ) {					if ( toLHS )						throw new EvalError("Can't assign .class", 							this, callstack );					NameSpace namespace = callstack.top();					return ((BSHType)obj).getType( callstack, interpreter );				} else					throw new EvalError(						"Attempt to use .class suffix on non class.", 						this, callstack );				/*				Evaluate our prefix if it needs evaluating first.				If this is the first evaluation our prefix mayb be a Node 				(directly from the PrimaryPrefix) - eval() it to an object.  				If it's an LHS, resolve to a value.					Note: The ambiguous name construct is now necessary where the node 				may be an ambiguous name.  If this becomes common we might want to 				make a static method nodeToObject() or something.  The point is 				that we can't just eval() - we need to direct the evaluation to 				the context sensitive type of result; namely object, class, etc.			*/			if ( obj instanceof SimpleNode )				if ( obj instanceof BSHAmbiguousName )					obj = ((BSHAmbiguousName)obj).toObject(callstack, interpreter);				else					obj = ((SimpleNode)obj).eval(callstack, interpreter);				else				if ( obj instanceof LHS )					try {						obj = ((LHS)obj).getValue();					} catch ( UtilEvalError e ) {						throw e.toEvalError( this, callstack );					}				try			{				switch(operation)				{					case INDEX:						return doIndex( obj, toLHS, callstack, interpreter );						case NAME:						return doName( obj, toLHS, callstack, interpreter );						case PROPERTY:						return doProperty( toLHS, obj, callstack, interpreter );						default:						throw new InterpreterError( "Unknown suffix type" );				} 			}			catch(ReflectError e)			{				throw new EvalError("reflection error: " + e, this, callstack );			}			catch(InvocationTargetException e)			{				throw new TargetError( "target exception", e.getTargetException(), 					this, callstack, true);			}		}	
private Object doName(			Object obj, boolean toLHS, 			CallStack callstack, Interpreter interpreter) 			throws EvalError, ReflectError, InvocationTargetException		{			try {				// .length on array				if ( field.equals("length") && obj.getClass().isArray() )					if ( toLHS )						throw new EvalError(							"Can't assign array length", this, callstack );					else						return new Primitive(Array.getLength(obj));								// field access				if ( jjtGetNumChildren() == 0 ) 					if ( toLHS )						return Reflect.getLHSObjectField(obj, field);					else						return Reflect.getObjectFieldValue( obj, field );					// Method invocation				// (LHS or non LHS evaluation can both encounter method calls)				Object[] oa = ((BSHArguments)jjtGetChild(0)).getArguments(					callstack, interpreter);				// TODO:			// Note: this try/catch block is copied from BSHMethodInvocation			// we need to factor out this common functionality and make sure			// we handle all cases ... (e.g. property style access, etc.)			// maybe move this to Reflect ?				try {					return Reflect.invokeObjectMethod( 						obj, field, oa, interpreter, callstack, this );				} catch ( ReflectError e ) {					throw new EvalError(						"Error in method invocation: " + e.getMessage(), 						this, callstack );				} catch ( InvocationTargetException e ) 				{					String msg = "Method Invocation "+field;					Throwable te = e.getTargetException();						/*						Try to squeltch the native code stack trace if the exception						was caused by a reflective call back into the bsh interpreter						(e.g. eval() or source()					*/					boolean isNative = true;					if ( te instanceof EvalError ) 						if ( te instanceof TargetError )							isNative = ((TargetError)te).inNativeCode();						else							isNative = false;										throw new TargetError( msg, te, this, callstack, isNative );				} 				} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}		}	
/**		*/		static int getIndexAux(			Object obj, CallStack callstack, Interpreter interpreter, 			SimpleNode callerInfo ) 			throws EvalError		{			if ( !obj.getClass().isArray() )				throw new EvalError("Not an array", callerInfo, callstack );				int index;			try {				Object indexVal = 					((SimpleNode)callerInfo.jjtGetChild(0)).eval( 						callstack, interpreter );				if ( !(indexVal instanceof Primitive) )					indexVal = Types.castObject(						indexVal, Integer.TYPE, Types.ASSIGNMENT );				index = ((Primitive)indexVal).intValue();			} catch( UtilEvalError e ) {				Interpreter.debug("doIndex: "+e);				throw e.toEvalError( 					"Arrays may only be indexed by integer types.", 					callerInfo, callstack );			}				return index;		}	
/**			array index.			Must handle toLHS case.		*/		private Object doIndex( 			Object obj, boolean toLHS, 			CallStack callstack, Interpreter interpreter ) 			throws EvalError, ReflectError		{			int index = getIndexAux( obj, callstack, interpreter, this );			if ( toLHS )				return new LHS(obj, index);			else				try {					return Reflect.getIndex(obj, index);				} catch ( UtilEvalError e ) {					throw e.toEvalError( this, callstack );				}		}	
/**			Property access.			Must handle toLHS case.		*/		private Object doProperty( boolean toLHS,			Object obj, CallStack callstack, Interpreter interpreter ) 			throws EvalError		{			if(obj == Primitive.VOID)				throw new EvalError( 				"Attempt to access property on undefined variable or class name", 					this, callstack );				if ( obj instanceof Primitive )				throw new EvalError("Attempt to access property on a primitive", 					this, callstack );				Object value = ((SimpleNode)jjtGetChild(0)).eval(				callstack, interpreter);				if ( !( value instanceof String ) )				throw new EvalError(					"Property expression must be a String or identifier.", 					this, callstack );				if ( toLHS )				return new LHS(obj, (String)value);				// Property style access to Hashtable or Map			CollectionManager cm = CollectionManager.getCollectionManager();			if ( cm.isMap( obj ) )			{				Object val = cm.getFromMap( obj, value/*key*/ );				return ( val == null ?  val = Primitive.NULL : val );			}				try {				return Reflect.getObjectProperty( obj, (String)value );			}			catch ( UtilEvalError e)  			{				throw e.toEvalError( "Property: "+value, this, callstack );			}			catch (ReflectError e) 			{				throw new EvalError("No such property: " + value, this, callstack );			}		}	
BSHPrimitiveType(int id) { super(id); }	
public Class getType() { return type; }	
BSHReturnStatement(int id) { super(id); }	
public Object eval(CallStack callstack, Interpreter interpreter)  			throws EvalError		{			Object value;			if(jjtGetNumChildren() > 0)				value = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);			else				value = Primitive.VOID;				return new ReturnControl( kind, value, this );		}	
BSHReturnType(int id) { super(id); }	
BSHType getTypeNode() { 			return (BSHType)jjtGetChild(0);		}	
public String getTypeDescriptor( 			CallStack callstack, Interpreter interpreter, String defaultPackage ) 		{			if ( isVoid )				return "V";			else				return getTypeNode().getTypeDescriptor( 					callstack, interpreter, defaultPackage );		}	
public Class evalReturnType( 			CallStack callstack, Interpreter interpreter ) throws EvalError		{			if ( isVoid )				return Void.TYPE;			else				return getTypeNode().getType( callstack, interpreter );		}	
BSHStatementExpressionList(int id) { super(id); }	
public Object eval(CallStack callstack, Interpreter interpreter)  			throws EvalError		{			int n = jjtGetNumChildren();			for(int i=0; i<n; i++)			{				SimpleNode node = ((SimpleNode)jjtGetChild(i));				node.eval(callstack, interpreter);			}			return Primitive.VOID;		}	
public BSHSwitchLabel(int id) { super(id); }	
public Object eval(			CallStack callstack, Interpreter interpreter) throws EvalError		{			if ( isDefault )				return null; // should probably error			SimpleNode label = ((SimpleNode)jjtGetChild(0));			return label.eval( callstack, interpreter );		}	
public BSHSwitchStatement(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter )			throws EvalError		{			int numchild = jjtGetNumChildren();			int child = 0;			SimpleNode switchExp = ((SimpleNode)jjtGetChild(child++));			Object switchVal = switchExp.eval( callstack, interpreter );				/*				Note: this could be made clearer by adding an inner class for the				cases and an object context for the child traversal.			*/			// first label			BSHSwitchLabel label;			Object node;			ReturnControl returnControl=null;				// get the first label			if ( child >= numchild )				throw new EvalError("Empty switch statement.", this, callstack );			label = ((BSHSwitchLabel)jjtGetChild(child++));				// while more labels or blocks and haven't hit return control			while ( child < numchild && returnControl == null ) 			{				// if label is default or equals switchVal				if ( label.isDefault 					|| primitiveEquals( 						switchVal, label.eval( callstack, interpreter ), 						callstack, switchExp )					)				{					// execute nodes, skipping labels, until a break or return					while ( child < numchild ) 					{						node = jjtGetChild(child++);						if ( node instanceof BSHSwitchLabel )							continue;						// eval it						Object value = 							((SimpleNode)node).eval( callstack, interpreter ); 							// should check to disallow continue here?						if ( value instanceof ReturnControl ) {							returnControl = (ReturnControl)value;							break;						}					}				} else 				{					// skip nodes until next label					while ( child < numchild ) 					{						node = jjtGetChild(child++);						if ( node instanceof BSHSwitchLabel ) {							label = (BSHSwitchLabel)node;							break;						}					}				}			}				if ( returnControl != null && returnControl.kind == RETURN )				return returnControl;			else				return Primitive.VOID;		}	
/**			Helper method for testing equals on two primitive or boxable objects.			yuck: factor this out into Primitive.java		*/		private boolean primitiveEquals( 			Object switchVal, Object targetVal, 			CallStack callstack, SimpleNode switchExp  ) 			throws EvalError		{			if ( switchVal instanceof Primitive || targetVal instanceof Primitive )				try {					// binaryOperation can return Primitive or wrapper type 					Object result = Primitive.binaryOperation( 						switchVal, targetVal, ParserConstants.EQ );					result = Primitive.unwrap( result ); 					return result.equals( Boolean.TRUE ); 				} catch ( UtilEvalError e ) {					throw e.toEvalError(						"Switch value: "+switchExp.getText()+": ", 						this, callstack );				}			else				return switchVal.equals( targetVal );		}	
BSHTernaryExpression(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter) 			throws EvalError	    {	        SimpleNode				cond = (SimpleNode)jjtGetChild(0),				evalTrue = (SimpleNode)jjtGetChild(1),				evalFalse = (SimpleNode)jjtGetChild(2);				if ( BSHIfStatement.evaluateCondition( cond, callstack, interpreter ) )				return evalTrue.eval( callstack, interpreter );			else				return evalFalse.eval( callstack, interpreter );	    }	
BSHThrowStatement(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError		{			Object obj = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);				// need to loosen this to any throwable... do we need to handle			// that in interpreter somewhere?  check first...			if(!(obj instanceof Exception))				throw new EvalError("Expression in 'throw' must be Exception type",					this, callstack );				// wrap the exception in a TargetException to propogate it up			throw new TargetError( (Exception)obj, this, callstack );		}	
BSHTryStatement(int id)		{			super(id);		}	
public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError		{			BSHBlock tryBlock = ((BSHBlock)jjtGetChild(0));				Vector catchParams = new Vector();			Vector catchBlocks = new Vector();				int nchild = jjtGetNumChildren();			Node node = null;			int i=1;			while((i < nchild) && ((node = jjtGetChild(i++)) instanceof BSHFormalParameter))			{				catchParams.addElement(node);				catchBlocks.addElement(jjtGetChild(i++));				node = null;			}			// finaly block			BSHBlock finallyBlock = null;			if(node != null)				finallyBlock = (BSHBlock)node;		// Why both of these?				TargetError target = null;			Throwable thrown = null;			Object ret = null;				/*				Evaluate the contents of the try { } block and catch any resulting				TargetErrors generated by the script.				We save the callstack depth and if an exception is thrown we pop				back to that depth before contiuing.  The exception short circuited				any intervening method context pops.					Note: we the stack info... what do we do with it?  append				to exception message?			*/			int callstackDepth = callstack.depth();			try {				ret = tryBlock.eval(callstack, interpreter);			}			catch( TargetError e ) {				target = e;				String stackInfo = "Bsh Stack: ";				while ( callstack.depth() > callstackDepth )					stackInfo += "\t" + callstack.pop() +"\n";			}				// unwrap the target error			if ( target != null )				thrown = target.getTarget();							// If we have an exception, find a catch			if (thrown != null) 			{				int n = catchParams.size();				for(i=0; i<n; i++)				{					// Get catch block					BSHFormalParameter fp = 						(BSHFormalParameter)catchParams.elementAt(i);						// Should cache this subject to classloader change message					// Evaluation of the formal parameter simply resolves its					// type via the specified namespace.. it doesn't modify the					// namespace.					fp.eval( callstack, interpreter );						if ( fp.type == null && interpreter.getStrictJava() )						throw new EvalError(							"(Strict Java) Untyped catch block", this, callstack );						// If the param is typed check assignability					if ( fp.type != null ) 						try {							thrown = (Throwable)Types.castObject(								thrown/*rsh*/, fp.type/*lhsType*/, Types.ASSIGNMENT );						} catch( UtilEvalError e ) {							/*								Catch the mismatch and continue to try the next								Note: this is innefficient, should have an								isAssignableFrom() that doesn't throw								// TODO: we do now have a way to test assignment								// 	in castObject(), use it?							*/							continue;						}						// Found match, execute catch block					BSHBlock cb = (BSHBlock)(catchBlocks.elementAt(i));						// Prepare to execute the block.					// We must create a new BlockNameSpace to hold the catch					// parameter and swap it on the stack after initializing it.						NameSpace enclosingNameSpace = callstack.top();					BlockNameSpace cbNameSpace = 						new BlockNameSpace( enclosingNameSpace );						try {						if ( fp.type == BSHFormalParameter.UNTYPED )							// set an untyped variable directly in the block							cbNameSpace.setBlockVariable( fp.name, thrown );						else						{							// set a typed variable (directly in the block)							Modifiers modifiers = new Modifiers();							cbNameSpace.setTypedVariable(								fp.name, fp.type, thrown, new Modifiers()/*none*/ );						}					} catch ( UtilEvalError e ) {						throw new InterpreterError(							"Unable to set var in catch block namespace." );					}						// put cbNameSpace on the top of the stack					callstack.swap( cbNameSpace );					try {						ret = cb.eval( callstack, interpreter );					} finally {						// put it back						callstack.swap( enclosingNameSpace );					}						target = null;  // handled target					break;				}			}				// evaluate finally block			if(finallyBlock != null)				ret = finallyBlock.eval(callstack, interpreter);				// exception fell through, throw it upward...			if(target != null)				throw target;				if(ret instanceof ReturnControl)				return ret;			else					return Primitive.VOID;		}	
BSHType(int id) { 			super(id); 		}	
/**			Used by the grammar to indicate dimensions of array types 			during parsing.		*/	    public void addArrayDimension() { 			arrayDims++; 		}	
SimpleNode getTypeNode() {	        return (SimpleNode)jjtGetChild(0);		}	
/**			 Returns a class descriptor for this type.			 If the type is an ambiguous name (object type) evaluation is 			 attempted through the namespace in order to resolve imports.			 If it is not found and the name is non-compound we assume the default			 package for the name.		*/	    public String getTypeDescriptor( 			CallStack callstack, Interpreter interpreter, String defaultPackage ) 	    {	        // return cached type if available			if ( descriptor != null )				return descriptor;				String descriptor;	        //  first node will either be PrimitiveType or AmbiguousName	        SimpleNode node = getTypeNode();	        if ( node instanceof BSHPrimitiveType )	            descriptor = getTypeDescriptor( ((BSHPrimitiveType)node).type );	        else 			{	            String clasName = ((BSHAmbiguousName)node).text;				BshClassManager bcm = interpreter.getClassManager();				// Note: incorrect here - we are using the hack in bsh class				// manager that allows lookup by base name.  We need to eliminate				// this limitation by working through imports.  See notes in class				// manager.				String definingClass = bcm.getClassBeingDefined( clasName );		            Class clas = null;				if ( definingClass == null )				{					try {						clas = ((BSHAmbiguousName)node).toClass( 							callstack, interpreter );					} catch ( EvalError e ) {						//throw new InterpreterError("unable to resolve type: "+e);						// ignore and try default package						//System.out.println("BSHType: "+node+" class not found");					}				} else					clasName = definingClass;					if ( clas != null )				{					//System.out.println("found clas: "+clas);	            	descriptor = getTypeDescriptor( clas );				}else				{					if ( defaultPackage == null || Name.isCompound( clasName ) )	            		descriptor = "L" + clasName.replace('.','/') + ";";					else	            		descriptor = 							"L"+defaultPackage.replace('.','/')+"/"+clasName + ";";				}			}				for(int i=0; i<arrayDims; i++)				descriptor = "["+descriptor;				this.descriptor = descriptor;		//System.out.println("BSHType: returning descriptor: "+descriptor);	        return descriptor;	    }	
public Class getType( CallStack callstack, Interpreter interpreter ) 			throws EvalError	    {	        // return cached type if available			if ( type != null )				return type;		        //  first node will either be PrimitiveType or AmbiguousName	        SimpleNode node = getTypeNode();	        if ( node instanceof BSHPrimitiveType )	            baseType = ((BSHPrimitiveType)node).getType();	        else 	            baseType = ((BSHAmbiguousName)node).toClass( 					callstack, interpreter );		        if ( arrayDims > 0 ) {	            try {	                // Get the type by constructing a prototype array with					// arbitrary (zero) length in each dimension.	                int[] dims = new int[arrayDims]; // int array default zeros	                Object obj = Array.newInstance(baseType, dims);	                type = obj.getClass(); 	            } catch(Exception e) {	                throw new EvalError("Couldn't construct array type", 						this, callstack );	            }	        } else	            type = baseType;				// hack... sticking to first interpreter that resolves this			// see comments on type instance variable			interpreter.getClassManager().addListener(this);		        return type;	    }	
/**			baseType is used during evaluation of full type and retained for the			case where we are an array type.			In the case where we are not an array this will be the same as type.		*/		public Class getBaseType() {			return baseType;		}	
/** 			If we are an array type this will be non zero and indicate the 			dimensionality of the array.  e.g. 2 for String[][];		*/		public int getArrayDims() {			return arrayDims;		}	
public void classLoaderChanged() {			type = null;			baseType = null;		}	
public static String getTypeDescriptor( Class clas ) 		{			if ( clas == Boolean.TYPE ) return "Z";			if ( clas == Character.TYPE ) return "C"; 			if ( clas == Byte.TYPE ) return "B";			if ( clas == Short.TYPE ) return "S";			if ( clas == Integer.TYPE ) return "I";			if ( clas == Long.TYPE ) return "J";			if ( clas == Float.TYPE ) return "F";			if ( clas == Double.TYPE ) return "D";			if ( clas == Void.TYPE ) return "V";		// Is getName() ok?  test with 1.1			String name = clas.getName().replace('.','/');				if ( name.startsWith("[") || name.endsWith(";") )				return name;			else				return "L"+ name.replace('.','/') +";";		}	
BSHTypedVariableDeclaration(int id) { super(id); }	
private BSHType getTypeNode() {			return ((BSHType)jjtGetChild(0));		}	
Class evalType( CallStack callstack, Interpreter interpreter )			throws EvalError		{			BSHType typeNode = getTypeNode();			return typeNode.getType( callstack, interpreter );		}	
BSHVariableDeclarator [] getDeclarators() 		{			int n = jjtGetNumChildren();			int start=1;			BSHVariableDeclarator [] bvda = new BSHVariableDeclarator[ n-start ];			for (int i = start; i < n; i++)			{				bvda[i-start] = (BSHVariableDeclarator)jjtGetChild(i);			}			return bvda;		}	
/**			evaluate the type and one or more variable declarators, e.g.:				int a, b=5, c;		*/	    public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError	    {			try {				NameSpace namespace = callstack.top();				BSHType typeNode = getTypeNode();				Class type = typeNode.getType( callstack, interpreter );					BSHVariableDeclarator [] bvda = getDeclarators();				for (int i = 0; i < bvda.length; i++)				{					BSHVariableDeclarator dec = bvda[i];						// Type node is passed down the chain for array initializers					// which need it under some circumstances					Object value = dec.eval( typeNode, callstack, interpreter);						try {						namespace.setTypedVariable( 							dec.name, type, value, modifiers );					} catch ( UtilEvalError e ) { 						throw e.toEvalError( this, callstack ); 					}				}			} catch ( EvalError e ) {				e.reThrow( "Typed variable declaration" );			}		        return Primitive.VOID;	    }	
public String getTypeDescriptor( 			CallStack callstack, Interpreter interpreter, String defaultPackage ) 		{ 			return getTypeNode().getTypeDescriptor( 				callstack, interpreter, defaultPackage );		}	
BSHUnaryExpression(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError	    {	        SimpleNode node = (SimpleNode)jjtGetChild(0);				// If this is a unary increment of decrement (either pre or postfix)			// then we need an LHS to which to assign the result.  Otherwise			// just do the unary operation for the value.			try {				if ( kind == INCR || kind == DECR ) {					LHS lhs = ((BSHPrimaryExpression)node).toLHS( 						callstack, interpreter );					return lhsUnaryOperation( lhs, interpreter.getStrictJava() );				} else					return 						unaryOperation( node.eval(callstack, interpreter), kind );			} catch ( UtilEvalError e ) {				throw e.toEvalError( this, callstack );			}	    }	
private Object lhsUnaryOperation( LHS lhs, boolean strictJava ) 			throws UtilEvalError	    {	        if ( Interpreter.DEBUG ) Interpreter.debug("lhsUnaryOperation");	        Object prevalue, postvalue;	        prevalue = lhs.getValue();	        postvalue = unaryOperation(prevalue, kind);				Object retVal;			if ( postfix )				retVal = prevalue;			else				retVal = postvalue;				lhs.assign( postvalue, strictJava );			return retVal;	    }	
private Object unaryOperation( Object op, int kind ) throws UtilEvalError	    {	        if (op instanceof Boolean || op instanceof Character 				|| op instanceof Number)	            return primitiveWrapperUnaryOperation( op, kind );		        if ( !(op instanceof Primitive) )	            throw new UtilEvalError( "Unary operation " + tokenImage[kind]	                + " inappropriate for object" );					        return Primitive.unaryOperation((Primitive)op, kind);	    }	
private Object primitiveWrapperUnaryOperation(Object val, int kind)	        throws UtilEvalError	    {	        Class operandType = val.getClass();	        Object operand = Primitive.promoteToInteger(val);		        if ( operand instanceof Boolean )				return new Boolean(					Primitive.booleanUnaryOperation((Boolean)operand, kind));	        else 			if ( operand instanceof Integer )	        {	            int result = Primitive.intUnaryOperation((Integer)operand, kind);		            // ++ and -- must be cast back the original type	            if(kind == INCR || kind == DECR)	            {	                if(operandType == Byte.TYPE)	                    return new Byte((byte)result);	                if(operandType == Short.TYPE)	                    return new Short((short)result);	                if(operandType == Character.TYPE)	                    return new Character((char)result);	            }		            return new Integer(result);	        }	        else if(operand instanceof Long)	            return new Long(Primitive.longUnaryOperation((Long)operand, kind));	        else if(operand instanceof Float)	            return new Float(Primitive.floatUnaryOperation((Float)operand, kind));	        else if(operand instanceof Double)	            return new Double(Primitive.doubleUnaryOperation((Double)operand, kind));	        else	            throw new InterpreterError("An error occurred.  Please call technical support.");	    }	
BSHVariableDeclarator(int id) { super(id); }	
/**			Evaluate the optional initializer value.  			(The name was set at parse time.)				A variable declarator can be evaluated with or without preceding			type information. Currently the type info is only used by array 			initializers in the case where there is no explicitly declared type.				@param typeNode is the BSHType node.  Its info is passed through to any			variable intializer children for the case where the array initializer			does not declare the type explicitly. e.g.				int [] a = { 1, 2 };			typeNode may be null to indicate no type information available.		*/	    public Object eval( 			BSHType typeNode, CallStack callstack, Interpreter interpreter)  			throws EvalError	    {			// null value means no value			Object value = null;		        if ( jjtGetNumChildren() > 0 ) 			{	            SimpleNode initializer = (SimpleNode)jjtGetChild(0);					/*					If we have type info and the child is an array initializer					pass it along...  Else use the default eval style.					(This allows array initializer to handle the problem... 					allowing for future enhancements in loosening types there).					*/				if ( (typeNode != null) 					&& initializer instanceof BSHArrayInitializer 				)	            	value = ((BSHArrayInitializer)initializer).eval( 						typeNode.getBaseType(), typeNode.getArrayDims(), 						callstack, interpreter);				else					value = initializer.eval( callstack, interpreter);			}				if ( value == Primitive.VOID )	            throw new EvalError("Void initializer.", this, callstack );		        return value;	    }	
public String toString() { return "BSHVariableDeclarator "+name; }	
BSHWhileStatement(int id) { super(id); }	
public Object eval( CallStack callstack, Interpreter interpreter)  			throws EvalError	    {			int numChild = jjtGetNumChildren();				// Order of body and condition is swapped for do / while	        SimpleNode condExp, body = null;				if ( isDoStatement ) {				condExp = (SimpleNode)jjtGetChild(1);				body =(SimpleNode)jjtGetChild(0);			} else {				condExp = (SimpleNode)jjtGetChild(0);				if ( numChild > 1 )	// has body, else just for side effects					body =(SimpleNode)jjtGetChild(1);			}				boolean doOnceFlag = isDoStatement;	        while( 				doOnceFlag || 				BSHIfStatement.evaluateCondition(condExp, callstack, interpreter )			)			{				if ( body == null ) // no body?					continue;					Object ret = body.eval(callstack, interpreter);					boolean breakout = false;				if(ret instanceof ReturnControl)				{					switch(((ReturnControl)ret).kind )					{						case RETURN:							return ret;							case CONTINUE:							continue;							case BREAK:							breakout = true;							break;					}				}				if(breakout)					break;					doOnceFlag = false;			}		        return Primitive.VOID;	    }	
/**		 * Reloads the buffer from disk, asking for confirmation if the buffer		 * has unsaved changes.		 * @param view The view		 * @since jEdit 2.7pre2		 */		public void reload(View view)		{			if (getFlag(UNTITLED))				return;			if(isDirty())			{				String[] args = { path };				int result = GUIUtilities.confirm(view,"changedreload",					args,JOptionPane.YES_NO_OPTION,					JOptionPane.WARNING_MESSAGE);				if(result != JOptionPane.YES_OPTION)					return;			}			view.visit(new SaveCaretInfoVisitor());			load(view,true);		}	
/**		 * Loads the buffer from disk.		 * @param view The view		 * @param reload If true, user will not be asked to recover autosave		 * file, if any		 *		 * @since 2.5pre1		 */		public boolean load(final View view, final boolean reload)		{			if(isPerformingIO())			{				GUIUtilities.error(view,"buffer-multiple-io",null);				return false;			}				setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);				setLoading(true);				// view text areas temporarily blank out while a buffer is			// being loaded, to indicate to the user that there is no			// data available yet.			if(!getFlag(TEMPORARY))				EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));				final boolean loadAutosave;				if(reload || !getFlag(NEW_FILE))			{				if(file != null)					modTime = file.lastModified();					// Only on initial load				if(!reload && autosaveFile != null && autosaveFile.exists())					loadAutosave = recoverAutosave(view);				else				{					if(autosaveFile != null)						autosaveFile.delete();					loadAutosave = false;				}					if(!loadAutosave)				{					VFS vfs = VFSManager.getVFSForPath(path);						if(!checkFileForLoad(view,vfs,path))					{						setLoading(false);						return false;					}						// have to check again since above might set					// NEW_FILE flag					if(reload || !getFlag(NEW_FILE))					{						if(!vfs.load(view,this,path))						{							setLoading(false);							return false;						}					}				}			}			else				loadAutosave = false;				//{{{ Do some stuff once loading is finished			Runnable runnable = new Runnable()			{				public void run()				{					String newPath = getStringProperty(						BufferIORequest.NEW_PATH);					Segment seg = (Segment)getProperty(						BufferIORequest.LOAD_DATA);					IntegerArray endOffsets = (IntegerArray)						getProperty(BufferIORequest.END_OFFSETS);						loadText(seg,endOffsets);						unsetProperty(BufferIORequest.LOAD_DATA);					unsetProperty(BufferIORequest.END_OFFSETS);					unsetProperty(BufferIORequest.NEW_PATH);						undoMgr.clear();					undoMgr.setLimit(jEdit.getIntegerProperty(						"buffer.undoCount",100));						if(!getFlag(TEMPORARY))						finishLoading();						setLoading(false);						// if reloading a file, clear dirty flag					if(reload)						setDirty(false);						if(!loadAutosave && newPath != null)						setPath(newPath);						// if loadAutosave is false, we loaded an					// autosave file, so we set 'dirty' to true						// note that we don't use setDirty(),					// because a) that would send an unnecessary					// message, b) it would also set the					// AUTOSAVE_DIRTY flag, which will make					// the autosave thread write out a					// redundant autosave file					if(loadAutosave)						Buffer.super.setDirty(true);						// send some EditBus messages					if(!getFlag(TEMPORARY))					{						fireBufferLoaded();						EditBus.send(new BufferUpdate(Buffer.this,							view,BufferUpdate.LOADED));						//EditBus.send(new BufferUpdate(Buffer.this,						//	view,BufferUpdate.MARKERS_CHANGED));					}				}			}; //}}}				if(getFlag(TEMPORARY))				runnable.run();			else				VFSManager.runInAWTThread(runnable);				return true;		}	
/**		 * Loads a file from disk, and inserts it into this buffer.		 * @param view The view		 * @param path the path of the file to insert		 *		 * @since 4.0pre1		 */		public boolean insertFile(View view, String path)		{			if(isPerformingIO())			{				GUIUtilities.error(view,"buffer-multiple-io",null);				return false;			}				setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);				path = MiscUtilities.constructPath(this.path,path);				Buffer buffer = jEdit.getBuffer(path);			if(buffer != null)			{				view.getTextArea().setSelectedText(					buffer.getText(0,buffer.getLength()));				return true;			}				VFS vfs = VFSManager.getVFSForPath(path);				// this returns false if initial sanity			// checks (if the file is a directory, etc)			// fail			return vfs.insert(view,this,path);		}	
/**		 * Autosaves this buffer.		 */		public void autosave()		{			if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)				|| !isDirty() || isPerformingIO() ||				!autosaveFile.getParentFile().exists())				return;				setFlag(AUTOSAVE_DIRTY,false);				VFSManager.runInWorkThread(new BufferAutosaveRequest(				null,this,null,VFSManager.getFileVFS(),				autosaveFile.getPath()));		}	
/**		 * Prompts the user for a file to save this buffer to.		 * @param view The view		 * @param rename True if the buffer's path should be changed, false		 * if only a copy should be saved to the specified filename		 * @since jEdit 2.6pre5		 */		public boolean saveAs(View view, boolean rename)		{			String[] files = GUIUtilities.showVFSFileDialog(view,path,				VFSBrowser.SAVE_DIALOG,false);				// files[] should have length 1, since the dialog type is			// SAVE_DIALOG			if(files == null)				return false;				return save(view,files[0],rename);		}	
/**		 * Saves this buffer to the specified path name, or the current path		 * name if it's null.		 * @param view The view		 * @param path The path name to save the buffer to, or null to use		 * the existing path		 */		public boolean save(View view, String path)		{			return save(view,path,true,false);		}	
/**		 * Saves this buffer to the specified path name, or the current path		 * name if it's null.		 * @param view The view		 * @param path The path name to save the buffer to, or null to use		 * the existing path		 * @param rename True if the buffer's path should be changed, false		 * if only a copy should be saved to the specified filename		 * @since jEdit 2.6pre5		 */		public boolean save(View view, String path, boolean rename)		{			return save(view,path,rename,false);		}	
/**		 * Saves this buffer to the specified path name, or the current path		 * name if it's null.		 * @param view The view		 * @param path The path name to save the buffer to, or null to use		 * the existing path		 * @param rename True if the buffer's path should be changed, false		 * if only a copy should be saved to the specified filename		 * @param disableFileStatusCheck  Disables file status checking		 * regardless of the state of the checkFileStatus property		 */		public boolean save(final View view, String path, final boolean rename, boolean disableFileStatusCheck)		{			if(isPerformingIO())			{				GUIUtilities.error(view,"buffer-multiple-io",null);				return false;			}				setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);				if(path == null && getFlag(NEW_FILE))				return saveAs(view,rename);				if(path == null && file != null)			{				long newModTime = file.lastModified();					if(newModTime != modTime					&& jEdit.getBooleanProperty("view.checkModStatus"))				{					Object[] args = { this.path };					int result = GUIUtilities.confirm(view,						"filechanged-save",args,						JOptionPane.YES_NO_OPTION,						JOptionPane.WARNING_MESSAGE);					if(result != JOptionPane.YES_OPTION)						return false;				}			}				EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));				setPerformingIO(true);				final String oldPath = this.path;			final String oldSymlinkPath = symlinkPath;			final String newPath = path == null ? this.path : path;				VFS vfs = VFSManager.getVFSForPath(newPath);				if(!checkFileForSave(view,vfs,newPath))			{				setPerformingIO(false);				return false;			}				Object session = vfs.createVFSSession(newPath,view);			if (session == null)			{				setPerformingIO(false);				return false;			}				unsetProperty("overwriteReadonly");			unsetProperty("forbidTwoStageSave");			try			{				VFSFile file = vfs._getFile(session,newPath,view);				if (file != null)				{					boolean vfsRenameCap = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0;					if (!file.isWriteable())					{						Log.log(Log.WARNING, this, "Buffer saving : File " + file + " is readOnly");						if (vfsRenameCap)						{							Log.log(Log.DEBUG, this, "Buffer saving : VFS can rename files");							String savePath = vfs._canonPath(session,newPath,view);							if(!MiscUtilities.isURL(savePath))								savePath = MiscUtilities.resolveSymlinks(savePath);							savePath = vfs.getTwoStageSaveName(savePath);							if (savePath == null)							{								Log.log(Log.DEBUG, this, "Buffer saving : two stage save impossible because path is null");								VFSManager.error(view,									newPath,									"ioerror.save-readonly-twostagefail",									null);								setPerformingIO(false);								return false;							}							else							{								int result = GUIUtilities.confirm(									view, "vfs.overwrite-readonly",									new Object[]{newPath},									JOptionPane.YES_NO_OPTION,									JOptionPane.WARNING_MESSAGE);								if (result == JOptionPane.YES_OPTION)								{									Log.log(Log.WARNING, this, "Buffer saving : two stage save will be used to save buffer");									setBooleanProperty("overwriteReadonly",true);								}								else								{									Log.log(Log.DEBUG,this, "Buffer not saved");									setPerformingIO(false);									return false;								}							}						}						else						{							Log.log(Log.WARNING, this, "Buffer saving : file is readonly and vfs cannot do two stage save");							VFSManager.error(view,								newPath,								"ioerror.write-error-readonly",								null);							setPerformingIO(false);							return false;						}					}					else					{						String savePath = vfs._canonPath(session,newPath,view);						if(!MiscUtilities.isURL(savePath))							savePath = MiscUtilities.resolveSymlinks(savePath);						savePath = vfs.getTwoStageSaveName(savePath);						if (jEdit.getBooleanProperty("twoStageSave") && (!vfsRenameCap || savePath == null))						{							// the file is writeable but the vfs cannot do two stage. We must overwrite							// readonly flag									int result = GUIUtilities.confirm(									view, "vfs.twostageimpossible",									new Object[]{newPath},									JOptionPane.YES_NO_OPTION,									JOptionPane.WARNING_MESSAGE);							if (result == JOptionPane.YES_OPTION)							{								Log.log(Log.WARNING, this, "Buffer saving : two stage save cannot be used");								setBooleanProperty("forbidTwoStageSave",true);							}							else							{								Log.log(Log.DEBUG,this, "Buffer not saved");								setPerformingIO(false);								return false;							}							}					}				}			}			catch(IOException io)			{				VFSManager.error(view,newPath,"ioerror",					new String[] { io.toString() });				setPerformingIO(false);				return false;			}			finally			{				try				{					vfs._endVFSSession(session,view);				}				catch(IOException io)				{					VFSManager.error(view,newPath,"ioerror",						new String[] { io.toString() });					setPerformingIO(false);					return false;				}			}				if(!vfs.save(view,this,newPath))			{				setPerformingIO(false);				return false;			}				// Once save is complete, do a few other things			VFSManager.runInAWTThread(new Runnable()				{					public void run()					{						setPerformingIO(false);						setProperty("overwriteReadonly",null);						finishSaving(view,oldPath,oldSymlinkPath,							newPath,rename,getBooleanProperty(								BufferIORequest.ERROR_OCCURRED));						updateMarkersFile(view);					}				});				int check = jEdit.getIntegerProperty("checkFileStatus");			if(!disableFileStatusCheck && (check == GeneralOptionPane.checkFileStatus_all ||						       check == GeneralOptionPane.checkFileStatus_operations))				jEdit.checkBufferStatus(view,false);				return true;		}	
/**		 * Check if the buffer has changed on disk.		 * @return One of <code>NOT_CHANGED</code>, <code>CHANGED</code>, or		 * <code>DELETED</code>.		 *		 * @since jEdit 4.2pre1		 */		public int checkFileStatus(View view)		{			// - don't do these checks while a save is in progress,			// because for a moment newModTime will be greater than			// oldModTime, due to the multithreading			// - only supported on local file system			if(!isPerformingIO() && file != null && !getFlag(NEW_FILE))			{				boolean newReadOnly = file.exists() && !file.canWrite();				if(newReadOnly != isFileReadOnly())				{					setFileReadOnly(newReadOnly);					EditBus.send(new BufferUpdate(this,null,						BufferUpdate.DIRTY_CHANGED));				}					long oldModTime = modTime;				long newModTime = file.lastModified();					if(newModTime != oldModTime)				{					modTime = newModTime;						if(!file.exists())					{						setFlag(NEW_FILE,true);						setDirty(true);						return FILE_DELETED;					}					else					{						return FILE_CHANGED;					}				}			}				return FILE_NOT_CHANGED;		}	
/**		 * Returns the last time jEdit modified the file on disk.		 * This method is thread-safe.		 */		public long getLastModified()		{			return modTime;		}	
/**		 * Sets the last time jEdit modified the file on disk.		 * @param modTime The new modification time		 */		public void setLastModified(long modTime)		{			this.modTime = modTime;		}	
/**		 * Returns the status of the AUTORELOAD flag		 * If true, reload changed files automatically		 */		public boolean getAutoReload()		{			return getFlag(AUTORELOAD);		}	
/**		 * Sets the status of the AUTORELOAD flag		 * @param value # If true, reload changed files automatically		 */		public void setAutoReload(boolean value)		{			setFlag(AUTORELOAD, value);		}	
/**		 * Returns the status of the AUTORELOAD_DIALOG flag		 * If true, prompt for reloading or notify user		 * when the file has changed on disk		 */		public boolean getAutoReloadDialog()		{			return getFlag(AUTORELOAD_DIALOG);		}	
/**		 * Sets the status of the AUTORELOAD_DIALOG flag		 * @param value # If true, prompt for reloading or notify user		 * when the file has changed on disk			 */		public void setAutoReloadDialog(boolean value)		{			setFlag(AUTORELOAD_DIALOG, value);		}	
/**		 * Returns the virtual filesystem responsible for loading and		 * saving this buffer. This method is thread-safe.		 */		public VFS getVFS()		{			return VFSManager.getVFSForPath(path);		}	
/**		 * Returns the autosave file for this buffer. This may be null if		 * the file is non-local.		 */		public File getAutosaveFile()		{			return autosaveFile;		}	
/**		 * Remove the autosave file.		 * @since jEdit 4.3pre12		 */		public void removeAutosaveFile()		{			if (autosaveFile != null)			{				autosaveFile.delete();				setFlag(AUTOSAVE_DIRTY,true);			}		}	
/**		 * Returns the name of this buffer. This method is thread-safe.		 */		public String getName()		{			return name;		}	
/**		 * Returns the path name of this buffer. This method is thread-safe.		 */		public String getPath()		{			return path;		}	
/**		  * @param shortVersion if true, replaces home path with ~/ on unix		  */		public String getPath(Boolean shortVersion)		{			return shortVersion ? MiscUtilities.abbreviate(path) : getPath();		}	
/**		 * If this file is a symbolic link, returns the link destination.		 * Otherwise returns the file's path. This method is thread-safe.		 * @since jEdit 4.2pre1		 */		public String getSymlinkPath()		{			return symlinkPath;		}	
/**		 * Returns the directory containing this buffer.		 * @since jEdit 4.1pre11		 */		public String getDirectory()		{			return directory;		}	
/**		 * Returns true if this buffer has been closed with		 * {@link org.gjt.sp.jedit.jEdit#closeBuffer(View,Buffer)}.		 * This method is thread-safe.		 */		public boolean isClosed()		{			return getFlag(CLOSED);		}	
/**		 * Returns true if the buffer is loaded. This method is thread-safe.		 */		public boolean isLoaded()		{			return !isLoading();		}	
/**		 * Returns whether this buffer lacks a corresponding version on disk.		 * This method is thread-safe.		 */		public boolean isNewFile()		{			return getFlag(NEW_FILE);		}	
/**		 * Sets the new file flag.		 * @param newFile The new file flag		 */		public void setNewFile(boolean newFile)		{			setFlag(NEW_FILE,newFile);			if(!newFile)				setFlag(UNTITLED,false);		}	
/**		 * Returns true if this file is 'untitled'. This method is thread-safe.		 */		public boolean isUntitled()		{			return getFlag(UNTITLED);		}	
/**		 * Sets the 'dirty' (changed since last save) flag of this buffer.		 */		@Override		public void setDirty(boolean d)		{			boolean old_d = isDirty();			if (isUntitled() && jEdit.getBooleanProperty("suppressNotSavedConfirmUntitled"))				d = false;			if (d && getLength() == initialLength)			{				if (jEdit.getBooleanProperty("useMD5forDirtyCalculation")) 					d = !Arrays.equals(calculateHash(), md5hash);			}			super.setDirty(d);			boolean editable = isEditable();				if(d)			{				if(editable)					setFlag(AUTOSAVE_DIRTY,true);			}			else			{				setFlag(AUTOSAVE_DIRTY,false);					if(autosaveFile != null)					autosaveFile.delete();			}				if(d != old_d && editable)			{				EditBus.send(new BufferUpdate(this,null,					BufferUpdate.DIRTY_CHANGED));			}		}	
/**		 * Returns if this is a temporary buffer. This method is thread-safe.		 * @see jEdit#openTemporary(View,String,String,boolean)		 * @see jEdit#commitTemporary(Buffer)		 * @since jEdit 2.2pre7		 */		public boolean isTemporary()		{			return getFlag(TEMPORARY);		}	
/**		 * Returns this buffer's icon.		 * @since jEdit 2.6pre6		 */		public Icon getIcon()		{			if(isDirty())				return GUIUtilities.loadIcon("dirty.gif");			else if(isReadOnly())				return GUIUtilities.loadIcon("readonly.gif");			else if(getFlag(NEW_FILE))				return GUIUtilities.loadIcon("new.gif");			else				return GUIUtilities.loadIcon("normal.gif");		}	
/**		 * @deprecated Call {@link JEditBuffer#addBufferListener(BufferListener,int)}.		 */		@Deprecated		public void addBufferChangeListener(BufferChangeListener listener,			int priority)		{			addBufferListener(new BufferChangeListener.Adapter(listener),priority);		}	
/**		 * @deprecated Call {@link JEditBuffer#addBufferListener(BufferListener)}.		 */		@Deprecated		public void addBufferChangeListener(BufferChangeListener listener)		{			addBufferListener(new BufferChangeListener.Adapter(listener), NORMAL_PRIORITY);		}	
/**		 * @deprecated Call {@link JEditBuffer#removeBufferListener(BufferListener)}.		 */		@Deprecated		public void removeBufferChangeListener(BufferChangeListener listener)		{			BufferListener[] listeners = getBufferListeners();				for(int i = 0; i < listeners.length; i++)			{				BufferListener l = listeners[i];				if(l instanceof BufferChangeListener.Adapter)				{					if(((BufferChangeListener.Adapter)l).getDelegate() == listener)					{						removeBufferListener(l);						return;					}				}			}		}	
/**		 * Reloads settings from the properties. This should be called		 * after the <code>syntax</code> or <code>folding</code>		 * buffer-local properties are changed.		 */		@Override		public void propertiesChanged()		{			super.propertiesChanged();			setAutoReloadDialog(jEdit.getBooleanProperty("autoReloadDialog"));			setAutoReload(jEdit.getBooleanProperty("autoReload"));			EditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));		}	
@Override		public Object getDefaultProperty(String name)		{			Object retVal;				if(mode != null)			{				retVal = mode.getProperty(name);				if(retVal == null)					return null;					setDefaultProperty(name,retVal);				return retVal;			}			// Now try buffer.<property>			String value = jEdit.getProperty("buffer." + name);			if(value == null)				return null;				// Try returning it as an integer first			try			{				retVal = new Integer(value);			}			catch(NumberFormatException nf)			{				retVal = value;			}				return retVal;		}	
/**		 * Toggles word wrap between the three available modes. This is used		 * by the status bar.		 * @param view We show a message in the view's status bar		 * @since jEdit 4.1pre3		 */		public void toggleWordWrap(View view)		{			String wrap = getStringProperty("wrap");			if(wrap.equals("none"))				wrap = "soft";			else if(wrap.equals("soft"))				wrap = "hard";			else if(wrap.equals("hard"))				wrap = "none";			view.getStatus().setMessageAndClear(jEdit.getProperty(				"view.status.wrap-changed",new String[] {				wrap }));			setProperty("wrap",wrap);			propertiesChanged();		}	
/**		 * Toggles the line separator between the three available settings.		 * This is used by the status bar.		 * @param view We show a message in the view's status bar		 * @since jEdit 4.1pre3		 */		public void toggleLineSeparator(View view)		{			String status = null;			String lineSep = getStringProperty(LINESEP);			if("\n".equals(lineSep))			{				status = "windows";				lineSep = "\r\n";			}			else if("\r\n".equals(lineSep))			{				status = "mac";				lineSep = "\r";			}			else if("\r".equals(lineSep))			{				status = "unix";				lineSep = "\n";			}			view.getStatus().setMessageAndClear(jEdit.getProperty(				"view.status.linesep-changed",new String[] {				jEdit.getProperty("lineSep." + status) }));			setProperty(LINESEP, lineSep);			setDirty(true);			propertiesChanged();		}	
/**		 * Some settings, like comment start and end strings, can		 * vary between different parts of a buffer (HTML text and inline		 * JavaScript, for example).		 * @param offset The offset		 * @param name The property name		 * @since jEdit 4.0pre3		 */		@Override		public String getContextSensitiveProperty(int offset, String name)		{			Object value = super.getContextSensitiveProperty(offset,name);				if(value == null)			{				ParserRuleSet rules = getRuleSetAtOffset(offset);					value = jEdit.getMode(rules.getModeName())					.getProperty(name);					if(value == null)					value = mode.getProperty(name);			}				if(value == null)				return null;			else				return String.valueOf(value);		}	
/**		 * Sets this buffer's edit mode by calling the accept() method		 * of each registered edit mode.		 */		public void setMode()		{			String userMode = getStringProperty("mode");			if(userMode != null)			{				unsetProperty("mode");				Mode m = ModeProvider.instance.getMode(userMode);				if(m != null)				{					setMode(m);					return;				}			}				String firstLine = getLineText(0);				Mode mode = ModeProvider.instance.getModeForFile(name, firstLine);			if (mode != null)			{				setMode(mode);				return;			}				Mode defaultMode = jEdit.getMode(jEdit.getProperty("buffer.defaultMode"));			if(defaultMode == null)				defaultMode = jEdit.getMode("text");				if (defaultMode != null)				setMode(defaultMode);		}	
/**		 * @deprecated Call <code>setProperty()</code> instead.		 */		@Deprecated		public void putProperty(Object name, Object value)		{			// for backwards compatibility			if(!(name instanceof String))				return;				setProperty((String)name,value);		}	
/**		 * @deprecated Call <code>setBooleanProperty()</code> instead		 */		@Deprecated		public void putBooleanProperty(String name, boolean value)		{			setBooleanProperty(name,value);		}	
public Token getFirstToken()			{				return getTokens();			}	
/**		 * @deprecated Use the other form of <code>markTokens()</code> instead		 */		@Deprecated		public TokenList markTokens(int lineIndex)		{			TokenList list = new TokenList();			markTokens(lineIndex,list);			return list;		}	
/**		 * Insert a string into the buffer		 * @param offset The offset		 * @param str The string		 * @param attr ignored		 * @deprecated Call <code>insert()</code> instead.		 */		@Deprecated		public void insertString(int offset, String str, AttributeSet attr)		{			insert(offset,str);		}	
/**		 * @deprecated Do not call this method, use {@link #getPath()}		 * instead.		 */		@Deprecated		public File getFile()		{			return file;		}	
/**		 * Returns a vector of markers.		 * @since jEdit 3.2pre1		 */		public Vector<Marker> getMarkers()		{			return markers;		}	
/**		 * Returns the status prompt for the given marker action. Only		 * intended to be called from <code>actions.xml</code>.		 * @since jEdit 4.2pre2		 */		public String getMarkerStatusPrompt(String action)		{			return jEdit.getProperty("view.status." + action,				new String[] { getMarkerNameString() });		}	
/**		 * Returns a string of all set markers, used by the status bar		 * (eg, "a b $ % ^").		 * @since jEdit 4.2pre2		 */		public String getMarkerNameString()		{			StringBuilder buf = new StringBuilder();			for(int i = 0; i < markers.size(); i++)			{				Marker marker = markers.get(i);				if(marker.getShortcut() != '\0')				{					if(buf.length() != 0)						buf.append(' ');					buf.append(marker.getShortcut());				}			}				if(buf.length() == 0)				return jEdit.getProperty("view.status.no-markers");			else				return buf.toString();		}	
/**		 * If a marker is set on the line of the position, it is removed. Otherwise		 * a new marker with the specified shortcut is added.		 * @param pos The position of the marker		 * @param shortcut The shortcut ('\0' if none)		 * @since jEdit 3.2pre5		 */		public void addOrRemoveMarker(char shortcut, int pos)		{			int line = getLineOfOffset(pos);			if(getMarkerAtLine(line) != null)				removeMarker(line);			else				addMarker(shortcut,pos);		}	
/**		 * Adds a marker to this buffer.		 * @param pos The position of the marker		 * @param shortcut The shortcut ('\0' if none)		 * @since jEdit 3.2pre1		 */		public void addMarker(char shortcut, int pos)		{			Marker markerN = new Marker(this,shortcut,pos);			boolean added = false;				// don't sort markers while buffer is being loaded			if(isLoaded())			{				setFlag(MARKERS_CHANGED,true);					markerN.createPosition();					for(int i = 0; i < markers.size(); i++)				{					Marker marker = markers.get(i);					if(shortcut != '\0' && marker.getShortcut() == shortcut)						marker.setShortcut('\0');						if(marker.getPosition() == pos)					{						markers.removeElementAt(i);						i--;					}				}					for(int i = 0; i < markers.size(); i++)				{					Marker marker = markers.get(i);					if(marker.getPosition() > pos)					{						markers.insertElementAt(markerN,i);						added = true;						break;					}				}			}				if(!added)				markers.addElement(markerN);				if(isLoaded() && !getFlag(TEMPORARY))			{				EditBus.send(new BufferUpdate(this,null,					BufferUpdate.MARKERS_CHANGED));			}		}	
/**		 * Returns the first marker within the specified range.		 * @param start The start offset		 * @param end The end offset		 * @since jEdit 4.0pre4		 */		public Marker getMarkerInRange(int start, int end)		{			for(int i = 0; i < markers.size(); i++)			{				Marker marker = markers.get(i);				int pos = marker.getPosition();				if(pos >= start && pos < end)					return marker;			}				return null;		}	
/**		 * Returns the first marker at the specified line, or <code>null</code>		 * if there is none.		 * @param line The line number		 * @since jEdit 3.2pre2		 */		public Marker getMarkerAtLine(int line)		{			for(int i = 0; i < markers.size(); i++)			{				Marker marker = markers.get(i);				if(getLineOfOffset(marker.getPosition()) == line)					return marker;			}				return null;		}	
/**		 * Removes all markers at the specified line.		 * @param line The line number		 * @since jEdit 3.2pre2		 */		public void removeMarker(int line)		{			for(int i = 0; i < markers.size(); i++)			{				Marker marker = markers.get(i);				if(getLineOfOffset(marker.getPosition()) == line)				{					setFlag(MARKERS_CHANGED,true);					marker.removePosition();					markers.removeElementAt(i);					i--;				}			}				EditBus.send(new BufferUpdate(this,null,				BufferUpdate.MARKERS_CHANGED));		}	
/**		 * Removes all defined markers.		 * @since jEdit 2.6pre1		 */		public void removeAllMarkers()		{			setFlag(MARKERS_CHANGED,true);				for(int i = 0; i < markers.size(); i++)				markers.get(i).removePosition();				markers.removeAllElements();				if(isLoaded())			{				EditBus.send(new BufferUpdate(this,null,					BufferUpdate.MARKERS_CHANGED));			}		}	
/**		 * Returns the marker with the specified shortcut.		 * @param shortcut The shortcut		 * @since jEdit 3.2pre2		 */		public Marker getMarker(char shortcut)		{			for (Marker marker : markers)			{				if(marker.getShortcut() == shortcut)					return marker;			}			return null;		}	
/**		 * Returns the path for this buffer's markers file		 * @param vfs The appropriate VFS		 * @since jEdit 4.3pre7		 * @deprecated it will fail if you save to another VFS. use {@link #getMarkersPath(VFS, String)}		 */		@Deprecated		public String getMarkersPath(VFS vfs)		{			return getMarkersPath(vfs, path);		}	
/**		 * Returns the path for this buffer's markers file		 * @param vfs The appropriate VFS		 * @param path the path of the buffer, it can be different from the field		 * when using save-as		 * @since jEdit 4.3pre10		 */		public static String getMarkersPath(VFS vfs, String path)		{			return vfs.getParentOfPath(path)				+ '.' + vfs.getFileName(path)				+ ".marks";		}	
/**		 * Save the markers file, or delete it when there are mo markers left		 * Handling markers is now independent from saving the buffer.		 * Changing markers will not set the buffer dirty any longer.		 * @param view The current view		 * @since jEdit 4.3pre7		 */		public boolean updateMarkersFile(View view)		{			if(!markersChanged())				return true;			// adapted from VFS.save			VFS vfs = VFSManager.getVFSForPath(getPath());			if (((vfs.getCapabilities() & VFS.WRITE_CAP) == 0) ||			    !vfs.isMarkersFileSupported())			{				VFSManager.error(view, path, "vfs.not-supported.save",					new String[] { "markers file" });				return false;			}			Object session = vfs.createVFSSession(path, view);			if(session == null)				return false;			VFSManager.runInWorkThread(				new MarkersSaveRequest(					view, this, session, vfs, path));			return true;		}	
/**		 * Return true when markers have changed and the markers file needs		 * to be updated		 * @since jEdit 4.3pre7		 */		public boolean markersChanged()		{			return getFlag(MARKERS_CHANGED);		}	
/**		 * Sets/unsets the MARKERS_CHANGED flag		 * @since jEdit 4.3pre7		 */		public void setMarkersChanged(boolean changed)		{			setFlag(MARKERS_CHANGED, changed);		}	
/**		 * This socket is closed when the buffer is closed.		 */		public void setWaitSocket(Socket waitSocket)		{			this.waitSocket = waitSocket;		}	
/**		 * Returns the next buffer in the list.		 */		public Buffer getNext()		{			return next;		}	
/**		 * Returns the previous buffer in the list.		 */		public Buffer getPrev()		{			return prev;		}	
/**		 * Returns the position of this buffer in the buffer list.		 */		public int getIndex()		{			int count = 0;			Buffer buffer = prev;			while (true)			{				if(buffer == null)					break;				count++;				buffer = buffer.prev;			}			return count;		}	
/**		 * Returns a string representation of this buffer.		 * This simply returns the path name.		 */		@Override		public String toString()		{			return name + " (" + MiscUtilities.abbreviate(directory) + ')';		}	
Buffer(String path, boolean newFile, boolean temp, Map props)		{			super(props);				markers = new Vector<Marker>();				setFlag(TEMPORARY,temp);				// this must be called before any EditBus messages are sent			setPath(path);				/* Magic: UNTITLED is only set if newFile param to			 * constructor is set, NEW_FILE is also set if file			 * doesn't exist on disk.			 *			 * This is so that we can tell apart files created			 * with jEdit.newFile(), and those that just don't			 * exist on disk.			 *			 * Why do we need to tell the difference between the			 * two? jEdit.addBufferToList() checks if the only			 * opened buffer is an untitled buffer, and if so,			 * replaces it with the buffer to add. We don't want			 * this behavior to occur with files that don't			 * exist on disk; only untitled ones.			 */			setFlag(UNTITLED,newFile);			setFlag(NEW_FILE,newFile);			setFlag(AUTORELOAD,jEdit.getBooleanProperty("autoReload"));			setFlag(AUTORELOAD_DIALOG,jEdit.getBooleanProperty("autoReloadDialog"));		}	
void commitTemporary()		{			setFlag(TEMPORARY,false);				finishLoading();		}	
void close()		{			setFlag(CLOSED,true);				if(autosaveFile != null)				autosaveFile.delete();				// notify clients with -wait			if(waitSocket != null)			{				try				{					waitSocket.getOutputStream().write('\0');					waitSocket.getOutputStream().flush();					waitSocket.getInputStream().close();					waitSocket.getOutputStream().close();					waitSocket.close();				}				catch(IOException io)				{					//Log.log(Log.ERROR,this,io);				}			}		}	
private void setFlag(int flag, boolean value)		{			if(value)				flags |= 1 << flag;			else				flags &= ~(1 << flag);		}	
private boolean getFlag(int flag)		{			int mask = 1 << flag;			return (flags & mask) == mask;		}	
private void setPath(final String path)		{			jEdit.visit(new JEditVisitorAdapter()			{				@Override				public void visit(EditPane editPane)				{					editPane.bufferRenamed(Buffer.this.path, path);				}			});				this.path = path;			VFS vfs = VFSManager.getVFSForPath(path);			if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)				setFileReadOnly(true);			name = vfs.getFileName(path);			directory = vfs.getParentOfPath(path);				if(vfs instanceof FileVFS)			{				file = new File(path);				symlinkPath = MiscUtilities.resolveSymlinks(path);					// if we don't do this, the autosave file won't be				// deleted after a save as				if(autosaveFile != null)					autosaveFile.delete();				autosaveFile = new File(file.getParent(),'#' + name + '#');			}			else			{				// I wonder if the lack of this broke anything in the				// past?				file = null;				autosaveFile = null;				symlinkPath = path;			}		}	
private boolean recoverAutosave(final View view)		{			if(!autosaveFile.canRead())				return false;				// this method might get called at startup			GUIUtilities.hideSplashScreen();				final Object[] args = { autosaveFile.getPath() };			int result = GUIUtilities.confirm(view,"autosave-found",args,				JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);				if(result == JOptionPane.YES_OPTION)			{				VFSManager.getFileVFS().load(view,this,autosaveFile.getPath());					// show this message when all I/O requests are				// complete				VFSManager.runInAWTThread(new Runnable()				{					public void run()					{						GUIUtilities.message(view,"autosave-loaded",args);					}				});					return true;			}			else				return false;		}	
private boolean checkFileForLoad(View view, VFS vfs, String path)		{			if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)			{				Object session = vfs.createVFSSession(path, view);				if(session == null)					return false;					try				{					VFSFile file = vfs._getFile(session,path,view);					if(file == null)					{						setNewFile(true);						return true;					}						if(!file.isReadable())					{						VFSManager.error(view,path,"ioerror.no-read",null);						setNewFile(false);						return false;					}						setFileReadOnly(!file.isWriteable());						if(file.getType() != VFSFile.FILE)					{						VFSManager.error(view,path,							"ioerror.open-directory",null);						setNewFile(false);						return false;					}				}				catch(IOException io)				{					VFSManager.error(view,path,"ioerror",						new String[] { io.toString() });					return false;				}				finally				{					try					{						vfs._endVFSSession(session,view);					}					catch(IOException io)					{						VFSManager.error(view,path,"ioerror",							new String[] { io.toString() });						return false;					}				}			}				return true;		}	
private static boolean checkFileForSave(View view, VFS vfs, String path)		{			if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)			{				Object session = vfs.createVFSSession(path,view);				if(session == null)					return false;					try				{					VFSFile file = vfs._getFile(session,path,view);					if(file == null)						return true;						if(file.getType() != VFSFile.FILE)					{						VFSManager.error(view,path,							"ioerror.save-directory",null);						return false;					}				}				catch(IOException io)				{					VFSManager.error(view,path,"ioerror",						new String[] { io.toString() });					return false;				}				finally				{					try					{						vfs._endVFSSession(session,view);					}					catch(IOException io)					{						VFSManager.error(view,path,"ioerror",							new String[] { io.toString() });						return false;					}				}			}				return true;		}	
/** @return an MD5 hash of the contents of the buffer */		private byte[] calculateHash()		{			final byte[] dummy = new byte[1]; 			if (!jEdit.getBooleanProperty("useMD5forDirtyCalculation"))				return dummy;			ByteBuffer bb = null;			readLock();			try 			{				// Log.log(Log.NOTICE, this, "calculateHash()");				int length = getLength();				bb = ByteBuffer.allocate(length * 2);	// Chars are 2 bytes				CharBuffer cb = bb.asCharBuffer();				cb.append( getSegment(0, length) );			}			finally 			{				readUnlock();			} 			try 			{				MessageDigest digest = java.security.MessageDigest.getInstance("MD5");				digest.update( bb );				return digest.digest();			}			catch (NoSuchAlgorithmException nsae) 			{				Log.log(Log.ERROR, this, "Can't Calculate MD5 hash!", nsae);				return dummy;			}					}	
/** Update the buffer's members with the current hash and length,		 *  for later comparison.		 */		private void updateHash() 		{			initialLength = getLength();			md5hash = calculateHash();		}	
private void finishLoading()		{			updateHash();							parseBufferLocalProperties();			// AHA!			// this is probably the only way to fix this			FoldHandler oldFoldHandler = getFoldHandler();			setMode();				if(getFoldHandler() == oldFoldHandler)			{				// on a reload, the fold handler doesn't change, but				// we still need to re-collapse folds.				// don't do this on initial fold handler creation				invalidateFoldLevels();					fireFoldHandlerChanged();			}				// Create marker positions			for(int i = 0; i < markers.size(); i++)			{				Marker marker = markers.get(i);				marker.removePosition();				int pos = marker.getPosition();				if(pos > getLength())					marker.setPosition(getLength());				else if(pos < 0)					marker.setPosition(0);				marker.createPosition();			}		}	
private void finishSaving(View view, String oldPath,			String oldSymlinkPath, String path,			boolean rename, boolean error)		{						//{{{ Set the buffer's path			// Caveat: won't work if save() called with a relative path.			// But I don't think anyone calls it like that anyway.			if(!error && !path.equals(oldPath))			{				Buffer buffer = jEdit.getBuffer(path);					if(rename)				{					/* if we save a file with the same name as one					 * that's already open, we presume that we can					 * close the existing file, since the user					 * would have confirmed the overwrite in the					 * 'save as' dialog box anyway */					if(buffer != null && /* can't happen? */						!buffer.getPath().equals(oldPath))					{						buffer.setDirty(false);						jEdit.closeBuffer(view,buffer);					}						setPath(path);					final HashSet<BufferSet> bufferSets = new HashSet<BufferSet>();					final HashSet<EditPane> editPanesCurrent = new HashSet<EditPane>();					jEdit.visit(new JEditVisitorAdapter()					{						@Override						public void visit(EditPane editPane)						{							BufferSet bufferSet = editPane.getBufferSet(); 							if (bufferSet.indexOf(Buffer.this) != -1)							{								bufferSets.add(bufferSet);								if (editPane.getBuffer() == Buffer.this)									editPanesCurrent.add(editPane);							}						}					});					jEdit.getBufferSetManager().removeBuffer(this);					for (BufferSet bufferSet: bufferSets)						jEdit.getBufferSetManager().addBuffer(bufferSet, this);					for (EditPane editPane: editPanesCurrent)						editPane.setBuffer(this);				}				else				{					/* if we saved over an already open file using					 * 'save a copy as', then reload the existing					 * buffer */					if(buffer != null && /* can't happen? */						!buffer.getPath().equals(oldPath))					{						buffer.load(view,true);					}				}			} //}}}				//{{{ Update this buffer for the new path			if(rename)			{				if(file != null)					modTime = file.lastModified();					if(!error)				{					// we do a write lock so that the					// autosave, which grabs a read lock,					// is not executed between the					// deletion of the autosave file					// and clearing of the dirty flag					try					{						writeLock();							if(autosaveFile != null)							autosaveFile.delete();							setFlag(AUTOSAVE_DIRTY,false);						setFileReadOnly(false);						setFlag(NEW_FILE,false);						setFlag(UNTITLED,false);						super.setDirty(false);						if(jEdit.getBooleanProperty("resetUndoOnSave"))						{							undoMgr.clear();						}					}					finally					{						writeUnlock();					}						parseBufferLocalProperties();						if(!getPath().equals(oldPath))					{						if (!isTemporary())							jEdit.updatePosition(oldSymlinkPath,this);						setMode();					}					else					{						// if user adds mode buffer-local property						String newMode = getStringProperty("mode");						if(newMode != null &&							!newMode.equals(getMode()							.getName()))							setMode();						else							propertiesChanged();					}						updateHash();										if (!isTemporary())					{						EditBus.send(new BufferUpdate(this,									      view,BufferUpdate.DIRTY_CHANGED));							// new message type introduced in 4.0pre4						EditBus.send(new BufferUpdate(this,									      view,BufferUpdate.SAVED));					}				}			} //}}}		}	
/**		 * Edit the syntax style of the token under the caret.		 *		 * @param textArea the textarea where your caret is		 * @since jEdit 4.3pre11		 */		public void editSyntaxStyle(JEditTextArea textArea)		{			int lineNum = textArea.getCaretLine();			int start = getLineStartOffset(lineNum);			int position = textArea.getCaretPosition();				DefaultTokenHandler tokenHandler = new DefaultTokenHandler();			markTokens(lineNum,tokenHandler);			Token token = tokenHandler.getTokens();				while(token.id != Token.END)			{				int next = start + token.length;				if (start <= position && next > position)					break;				start = next;				token = token.next;			}			if (token.id == Token.END || token.id == Token.NULL)			{				JOptionPane.showMessageDialog(jEdit.getActiveView(),					jEdit.getProperty("syntax-style-no-token.message"),					jEdit.getProperty("syntax-style-no-token.title"),					JOptionPane.PLAIN_MESSAGE);				return;			}			String typeName = Token.tokenToString(token.id);			String property = "view.style." + typeName.toLowerCase();			SyntaxStyle currentStyle = GUIUtilities.parseStyle(					jEdit.getProperty(property), "Dialog",12);			SyntaxStyle style = new StyleEditor(jEdit.getActiveView(),					currentStyle, typeName).getStyle();			if(style != null)			{				jEdit.setProperty(property, GUIUtilities.getStyleString(style));				jEdit.propertiesChanged();			}		}	
/**		 * Called when line fold levels change.		 * @param buffer The buffer in question		 * @param start The start line number		 * @param end The end line number		 * @since jEdit 4.3pre3		 */		public void foldLevelChanged(JEditBuffer buffer, int start, int end)		{		}	
/**		 * Called when text is inserted into the buffer.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines inserted		 * @param length The number of characters inserted		 * @since jEdit 4.3pre3		 */		public void contentInserted(JEditBuffer buffer, int startLine, int offset,			int numLines, int length) {}	
/**		 * Called when text is about to be inserted in the buffer.		 *		 * @param buffer    The buffer in question		 * @param startLine The first line		 * @param offset    The start offset, from the beginning of the buffer		 * @param numLines  The number of lines inserted		 * @param length    The number of characters inserted		 * @since jEdit 4.3pre11		 */		public void preContentInserted(JEditBuffer buffer, int startLine, int offset, int numLines, int length)		{		}	
/**		 * Called when text is about to be removed from the buffer, but is		 * still present.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines to be removed		 * @param length The number of characters to be removed		 * @since jEdit 4.3pre3		 */		public void preContentRemoved(JEditBuffer buffer, int startLine, int offset,			int numLines, int length) {}	
/**		 * Called when text is removed from the buffer.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines removed		 * @param length The number of characters removed		 * @since jEdit 4.3pre3		 */		public void contentRemoved(JEditBuffer buffer, int startLine, int offset,			int numLines, int length) {}	
/**		 * Called after an undo or compound edit has finished. The text area		 * uses this event to queue up and collapse cleanup operations so they		 * are only run once during a long transaction (such as a "Replace All"		 * operation.)		 *		 * @param buffer The buffer in question		 * @since jEdit 4.3pre3		 */		public void transactionComplete(JEditBuffer buffer) {}	
/**		 * Called to notify the text area that folds need to be collapsed if		 * the "collapseFolds" property is set. This method is called after the		 * buffer has been loaded, and also if the user changes the fold		 * handler.		 *		 * @param buffer The buffer in question		 * @since jEdit 4.3pre3		 */		public void foldHandlerChanged(JEditBuffer buffer) {}	
/**		 * Called to notify the text area that the buffer has been reloaded.		 *		 * @param buffer The buffer in question		 * @since jEdit 4.3pre3		 */		public void bufferLoaded(JEditBuffer buffer) {}	
/**		 * Creates a new buffer I/O request.		 * @param view The view		 * @param buffer The buffer		 * @param session The VFS session		 * @param vfs The VFS		 * @param path The path		 */		public BufferAutosaveRequest(View view, Buffer buffer,			Object session, VFS vfs, String path)		{			super(view,buffer,session,vfs,path);		}	
public void run()		{			OutputStream out = null;				try			{				String[] args = { vfs.getFileName(path) };				setStatus(jEdit.getProperty("vfs.status.autosave",args));					// the entire save operation can be aborted...				setAbortable(true);					try				{					//buffer.readLock();						if(!buffer.isDirty())					{						// buffer has been saved while we						// were waiting.						return;					}						out = vfs._createOutputStream(session,path,view);					if(out == null)						return;						write(buffer,out);				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);					String[] pp = { e.toString() };					VFSManager.error(view,path,"ioerror.write-error",pp);						// Incomplete autosave file should not exist.					if(out != null)					{						try						{							out.close();							out = null;							vfs._delete(session,path,view);						}						catch(IOException ioe)						{							Log.log(Log.ERROR,this,ioe);						}					}				}				//finally				//{					//buffer.readUnlock();				//}			}			catch(WorkThread.Abort a)			{			}			finally			{				IOUtilities.closeQuietly(out);			}		}	
/**		 * Called when line fold levels change.		 * @param buffer The buffer in question		 * @param start The start line number		 * @param end The end line number		 * @since jEdit 4.0pre1		 */		public void foldLevelChanged(Buffer buffer, int start, int end)		{		}	
/**		 * Called when text is inserted into the buffer.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines inserted		 * @param length The number of characters inserted		 * @since jEdit 4.0pre1		 */		public void contentInserted(Buffer buffer, int startLine, int offset,			int numLines, int length) {}	
/**		 * Called when text is about to be removed from the buffer, but is		 * still present.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines to be removed		 * @param length The number of characters to be removed		 * @since jEdit 4.2pre1		 */		public void preContentRemoved(Buffer buffer, int startLine, int offset,			int numLines, int length) {}	
/**		 * Called when text is removed from the buffer.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines removed		 * @param length The number of characters removed		 * @since jEdit 4.0pre1		 */		public void contentRemoved(Buffer buffer, int startLine, int offset,			int numLines, int length) {}	
/**		 * Called after an undo or compound edit has finished. The text area		 * uses this event to queue up and collapse cleanup operations so they		 * are only run once during a long transaction (such as a "Replace All"		 * operation.)		 *		 * @param buffer The buffer in question		 * @since jEdit 4.0pre6		 */		public void transactionComplete(Buffer buffer) {}	
/**		 * Called to notify the text area that folds need to be collapsed if		 * the "collapseFolds" property is set. This method is called after the		 * buffer has been loaded, and also if the user changes the fold		 * handler.		 *		 * @param buffer The buffer in question		 * @since jEdit 4.2pre2		 */		public void foldHandlerChanged(Buffer buffer) {}	
/**		 * Called to notify the text area that the buffer has been reloaded.		 *		 * @param buffer The buffer in question		 * @since jEdit 4.3pre1		 */		public void bufferLoaded(Buffer buffer) {}	
public Adapter(BufferChangeListener delegate)			{				this.delegate = delegate;			}	
public BufferChangeListener getDelegate()			{				return delegate;			}	
/**			 * Called when line fold levels change.			 * @param buffer The buffer in question			 * @param startLine The start line number			 * @param endLine The end line number			 * @since jEdit 4.3pre3			 */			public void foldLevelChanged(JEditBuffer buffer, int startLine, int endLine)			{				delegate.foldLevelChanged((Buffer)buffer,startLine,endLine);			}	
/**			 * Called when text is inserted into the buffer.			 * @param buffer The buffer in question			 * @param startLine The first line			 * @param offset The start offset, from the beginning of the buffer			 * @param numLines The number of lines inserted			 * @param length The number of characters inserted			 * @since jEdit 4.3pre3			 */			public void contentInserted(JEditBuffer buffer, int startLine, int offset,				int numLines, int length)			{				delegate.contentInserted((Buffer)buffer,startLine,offset,numLines,length);			}	
/**			 * Called when text is removed from the buffer.			 * @param buffer The buffer in question			 * @param startLine The first line			 * @param offset The start offset, from the beginning of the buffer			 * @param numLines The number of lines removed			 * @param length The number of characters removed			 * @since jEdit 4.3pre3			 */			public void contentRemoved(JEditBuffer buffer, int startLine, int offset,				int numLines, int length)			{				delegate.contentRemoved((Buffer)buffer,startLine,offset,numLines,length);			}	
/**			 * Called when text is about to be inserted in the buffer.			 *			 * @param buffer    The buffer in question			 * @param startLine The first line			 * @param offset    The start offset, from the beginning of the buffer			 * @param numLines  The number of lines inserted			 * @param length    The number of characters inserted			 * @since jEdit 4.3pre11			 */			public void preContentInserted(JEditBuffer buffer, int startLine, int offset, int numLines, int length)			{			}	
/**			 * Called when text is about to be removed from the buffer, but is			 * still present.			 * @param buffer The buffer in question			 * @param startLine The first line			 * @param offset The start offset, from the beginning of the buffer			 * @param numLines The number of lines to be removed			 * @param length The number of characters to be removed			 * @since jEdit 4.3pre3			 */			public void preContentRemoved(JEditBuffer buffer, int startLine, int offset,				int numLines, int length)			{				delegate.preContentRemoved((Buffer)buffer,startLine,offset,numLines,length);			}	
/**			 * Called after an undo or compound edit has finished. The text area			 * uses this event to queue up and collapse cleanup operations so they			 * are only run once during a long transaction (such as a "Replace All"			 * operation.)			 *			 * @param buffer The buffer in question			 * @since jEdit 4.3pre3			 */			public void transactionComplete(JEditBuffer buffer)			{				delegate.transactionComplete((Buffer)buffer);			}	
/**			 * Called to notify the text area that folds need to be collapsed if			 * the "collapseFolds" property is set. This method is called after the			 * buffer has been loaded, and also if the user changes the fold			 * handler.			 *			 * @param buffer The buffer in question			 * @since jEdit 4.3pre3			 */			public void foldHandlerChanged(JEditBuffer buffer)			{				delegate.foldHandlerChanged((Buffer)buffer);			}	
/**			 * Called to notify the text area that the buffer has been reloaded.			 *			 * @param buffer The buffer in question			 * @since jEdit 4.3pre3			 */			public void bufferLoaded(JEditBuffer buffer)			{				delegate.bufferLoaded((Buffer)buffer);			}	
/**		 * @param editPane the editPane that sent the message		 * @param newBuffer the buffer that will soon be displayed.		 */		public BufferChanging(EditPane editPane, Buffer newBuffer)		{			super(editPane, EditPaneUpdate.BUFFER_CHANGING);			if (newBuffer == null)			{				String s = Arrays.toString(Thread.currentThread().getStackTrace());				Log.log (Log.ERROR, this, "BufferChanging to null Buffer? Emit PositionChanging instead." + s);			}			m_buffer = newBuffer;		}	
/**		 * @return the new buffer that is about to be displayed		 */		public Buffer getBuffer()		{			return m_buffer;		}	
BufferHandler(DisplayManager displayManager,			TextArea textArea,			JEditBuffer buffer)		{			this.displayManager = displayManager;			this.textArea = textArea;			this.buffer = buffer;		}	
public void bufferLoaded(JEditBuffer buffer)		{			displayManager.bufferLoaded();		}	
public void foldHandlerChanged(JEditBuffer buffer)		{			displayManager.foldHandlerChanged();		}	
public void foldLevelChanged(JEditBuffer buffer, int start, int end)		{			//System.err.println("foldLevelChanged " + (start-1) + " to " + textArea.getLastPhysicalLine() + "," + end);				if(textArea.getDisplayManager() == displayManager				&& end != 0 && !buffer.isLoading())			{				textArea.invalidateLineRange(start - 1,					textArea.getLastPhysicalLine());			}		}	
public void contentInserted(JEditBuffer buffer, int startLine,			int offset, int numLines, int length)		{			if(buffer.isLoading())				return;				displayManager.screenLineMgr.contentInserted(startLine,numLines);				int endLine = startLine + numLines;				if(numLines != 0)				delayedMultilineUpdate = true;				displayManager.folds.contentInserted(startLine,numLines);				FirstLine firstLine = displayManager.firstLine;			ScrollLineCount scrollLineCount = displayManager.scrollLineCount;				if(textArea.getDisplayManager() == displayManager)			{				if(numLines != 0)				{					firstLine.contentInserted(startLine,numLines);					scrollLineCount.contentInserted(startLine,numLines);				}					if(delayedUpdateEnd >= startLine)					delayedUpdateEnd += numLines;				delayUpdate(startLine,endLine);					//{{{ resize selections if necessary								Iterator<Selection> iter = textArea.getSelectionIterator();				while(iter.hasNext())				{					Selection s = iter.next();						if(s.contentInserted(buffer,startLine,offset,						numLines,length))					{						delayUpdate(s.startLine,s.endLine);					}				} //}}}					int caret = textArea.getCaretPosition();				if(caret >= offset)				{					int scrollMode = textArea.caretAutoScroll()						? TextArea.ELECTRIC_SCROLL						: TextArea.NO_SCROLL;					textArea.moveCaretPosition(						caret + length,scrollMode);				}				else				{					int scrollMode = textArea.caretAutoScroll()						? TextArea.NORMAL_SCROLL						: TextArea.NO_SCROLL;					textArea.moveCaretPosition(						caret,scrollMode);				}			}			else			{				firstLine.callReset = true;				scrollLineCount.callReset = true;			}		}	
/**		 * Called when text is about to be inserted in the buffer.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines inserted		 * @param length The number of characters inserted		 * @since jEdit 4.3pre11		 */		public void preContentInserted(JEditBuffer buffer, int startLine, int offset, int numLines, int length)		{			if(textArea.getDisplayManager() == displayManager)			{				getReadyToBreakFold(startLine);			}		}	
/**		 * Called when text is about to be removed from the buffer, but is		 * still present.		 * @param buffer The buffer in question		 * @param startLine The first line		 * @param offset The start offset, from the beginning of the buffer		 * @param numLines The number of lines to be removed		 * @param length The number of characters to be removed		 * @since jEdit 4.3pre3		 */		public void preContentRemoved(JEditBuffer buffer, int startLine,			int offset, int numLines, int length)		{			if(buffer.isLoading())				return;				FirstLine firstLine = displayManager.firstLine;			ScrollLineCount scrollLineCount = displayManager.scrollLineCount;				if(textArea.getDisplayManager() == displayManager)			{				if(numLines == 0)				{					getReadyToBreakFold(startLine);				}				else				{					int lastLine = startLine + numLines;					if(!displayManager.isLineVisible(startLine)					 || !displayManager.isLineVisible(lastLine)				 	 || offset != buffer.getLineStartOffset(startLine)					 || offset + length != buffer.getLineStartOffset(lastLine))					{						getReadyToBreakFold(startLine);						getReadyToBreakFold(lastLine);					}					else					{						// The removal will not touch						// inside of folds and wll not						// modify any remaining lines.					}				}					if(numLines != 0)				{					firstLine.preContentRemoved(startLine,offset, numLines);					scrollLineCount.preContentRemoved(startLine, offset, numLines);				}					if(delayedUpdateEnd >= startLine)					delayedUpdateEnd -= numLines;				delayUpdate(startLine,startLine);			}			else			{				firstLine.callReset = true;				scrollLineCount.callReset = true;			}				displayManager.screenLineMgr.contentRemoved(startLine,numLines);				if(numLines == 0)				return;				delayedMultilineUpdate = true;				if(displayManager.folds.preContentRemoved(startLine,numLines))			{				displayManager.folds.reset(buffer.getLineCount());				firstLine.callReset = true;				scrollLineCount.callReset = true;			}				if(firstLine.physicalLine				> displayManager.getLastVisibleLine()				|| firstLine.physicalLine				< displayManager.getFirstVisibleLine())			{				// will be handled later.				// see comments at the end of				// transactionComplete().			}			// very subtle... if we leave this for			// ensurePhysicalLineIsVisible(), an			// extra line will be added to the			// scroll line count.			else if(!displayManager.isLineVisible(				firstLine.physicalLine))			{				firstLine.physicalLine =					displayManager.getNextVisibleLine(					firstLine.physicalLine);			}		}	
public void contentRemoved(JEditBuffer buffer, int startLine,			int start, int numLines, int length)		{			if(buffer.isLoading())				return;				if(textArea.getDisplayManager() == displayManager)			{				//{{{ resize selections if necessary				int nSel = textArea.getSelectionCount();				Iterator<Selection> iter = textArea.getSelectionIterator();				while(iter.hasNext())				{					Selection s = iter.next();						if(s.contentRemoved(buffer,startLine,						start,numLines,length))					{						delayUpdate(s.startLine,s.endLine);						if(nSel == 1 && s.start == s.end)							iter.remove();					}				} //}}}					int caret = textArea.getCaretPosition();					if(caret >= start + length)				{					int scrollMode = textArea.caretAutoScroll()						? TextArea.ELECTRIC_SCROLL						: TextArea.NO_SCROLL;					textArea.moveCaretPosition(						caret - length,						scrollMode);				}				else if(caret >= start)				{					int scrollMode = textArea.caretAutoScroll()						? TextArea.ELECTRIC_SCROLL						: TextArea.NO_SCROLL;					textArea.moveCaretPosition(						start,scrollMode);				}				else				{					int scrollMode = textArea.caretAutoScroll()						? TextArea.NORMAL_SCROLL						: TextArea.NO_SCROLL;					textArea.moveCaretPosition(caret,scrollMode);				}			}		}	
public void transactionComplete(JEditBuffer buffer)		{			if(textArea.getDisplayManager() != displayManager)			{				delayedUpdate = false;				return;			}				if(delayedUpdate)				doDelayedUpdate();				textArea._finishCaretUpdate();				delayedUpdate = false;				//{{{ Debug code			if(Debug.SCROLL_VERIFY)			{				int line = delayedUpdateStart;				if(!displayManager.isLineVisible(line))					line = displayManager.getNextVisibleLine(line);				System.err.println(delayedUpdateStart + ":" + delayedUpdateEnd + ':' + textArea.getLineCount());				int scrollLineCount = 0;				while(line != -1 && line <= delayedUpdateEnd)				{					scrollLineCount += displayManager.getScreenLineCount(line);					line = displayManager.getNextVisibleLine(line);				}					if(scrollLineCount != displayManager.getScrollLineCount())				{					throw new InternalError(scrollLineCount						+ " != "						+ displayManager.getScrollLineCount());				}			} //}}}		}	
private void doDelayedUpdate()		{			// must update screen line counts before we call			// notifyScreenLineChanges() since that calls			// updateScrollBar() which needs valid info			int line = delayedUpdateStart;			if(!displayManager.isLineVisible(line))				line = displayManager.getNextVisibleLine(line);			while(line != -1 && line <= delayedUpdateEnd)			{				displayManager.updateScreenLineCount(line);				line = displayManager.getNextVisibleLine(line);			}				// must be before the below call			// so that the chunk cache is not			// updated with an invisible first			// line (see above)			displayManager.notifyScreenLineChanges();				if(delayedMultilineUpdate)			{				textArea.invalidateScreenLineRange(					textArea.chunkCache					.getScreenLineOfOffset(					delayedUpdateStart,0),					textArea.getVisibleLines());				delayedMultilineUpdate = false;			}			else			{				textArea.invalidateLineRange(					delayedUpdateStart,					delayedUpdateEnd);			}				// update visible lines			int visibleLines = textArea.getVisibleLines();			if(visibleLines != 0)			{				textArea.chunkCache.getLineInfo(					visibleLines - 1);			}				// force the fold levels to be			// updated.				// when painting the last line of			// a buffer, Buffer.isFoldStart()			// doesn't call getFoldLevel(),			// hence the foldLevelChanged()			// event might not be sent for the			// previous line.				buffer.getFoldLevel(delayedUpdateEnd);		}	
private void delayUpdate(int startLine, int endLine)		{			textArea.chunkCache.invalidateChunksFromPhys(startLine);				if(!delayedUpdate)			{				delayedUpdateStart = startLine;				delayedUpdateEnd = endLine;				delayedUpdate = true;			}			else			{				delayedUpdateStart = Math.min(					delayedUpdateStart,					startLine);				delayedUpdateEnd = Math.max(					delayedUpdateEnd,					endLine);			}		}	
private void getReadyToBreakFold(int line)		{			displayManager.expandFold(line, false);		}	
public Selection[] getSelection()			{				return stringToSelection(selection);			}	
public Entry(String path, int caret, String selection, String encoding, String mode)			{				this.path = path;				this.caret = caret;				this.selection = selection;				this.encoding = encoding;				this.mode = mode;			}	
public String toString()			{				return path + ": " + caret;			}	
public static Entry getEntry(String path)		{			historyLock.readLock().lock();			try			{				for (Entry entry : history)				{					if(MiscUtilities.pathsEqual(entry.path,path))						return entry;				}			}			finally			{				historyLock.readLock().unlock();			}				return null;		}	
public static void setEntry(String path, int caret, Selection[] selection,			String encoding, String mode)		{			Entry entry = new Entry(path,caret,				selectionToString(selection), encoding, mode);			historyLock.writeLock().lock();			try			{				removeEntry(path);				addEntry(entry);			}			finally			{				historyLock.writeLock().unlock();			}			notifyChange();		}	
/**		 * Clear the BufferHistory.		 * @since 4.3pre6		 */		public static void clear()		{			historyLock.writeLock().lock();			try			{				history.clear();			}			finally			{				historyLock.writeLock().unlock();			}			notifyChange();		}	
/**		 * Returns the Buffer list.		 * @return the buffer history list		 * @since jEdit 4.2pre2		 */		public static List<Entry> getHistory()		{			// Returns a snapshot to avoid concurrent access to the			// history. This requires O(n) time, but it should be ok			// because this method should be used only by external			// O(n) operation.				historyLock.readLock().lock();			try			{				return (List<Entry>)history.clone();			}			finally			{				historyLock.readLock().unlock();			}		}	
public static void load()		{			if(recentXML == null)				return;				if(!recentXML.fileExists())				return;				Log.log(Log.MESSAGE,BufferHistory.class,"Loading " + recentXML);				RecentHandler handler = new RecentHandler();			try			{				recentXML.load(handler);			}			catch(IOException e)			{				Log.log(Log.ERROR,BufferHistory.class,e);			}			trimToLimit(handler.result);			history = handler.result;		}	
public static void save()		{			if(recentXML == null)				return;				if(recentXML.hasChangedOnDisk())			{				Log.log(Log.WARNING,BufferHistory.class,recentXML					+ " changed on disk; will not save recent"					+ " files");				return;			}				Log.log(Log.MESSAGE,BufferHistory.class,"Saving " + recentXML);				String lineSep = System.getProperty("line.separator");				SettingsXML.Saver out = null;				try			{				out = recentXML.openSaver();				out.writeXMLDeclaration();					out.write("<!DOCTYPE RECENT SYSTEM \"recent.dtd\">");				out.write(lineSep);				out.write("<RECENT>");				out.write(lineSep);					// Make a snapshot to avoid long locking period				// which may be required by file I/O.				List<Entry> snapshot = getHistory();					for (Entry entry : snapshot)				{					out.write("<ENTRY>");					out.write(lineSep);						out.write("<PATH>");					out.write(XMLUtilities.charsToEntities(entry.path,false));					out.write("</PATH>");					out.write(lineSep);						out.write("<CARET>");					out.write(String.valueOf(entry.caret));					out.write("</CARET>");					out.write(lineSep);						if(entry.selection != null						&& entry.selection.length() > 0)					{						out.write("<SELECTION>");						out.write(entry.selection);						out.write("</SELECTION>");						out.write(lineSep);					}						if(entry.encoding != null)					{						out.write("<ENCODING>");						out.write(entry.encoding);						out.write("</ENCODING>");						out.write(lineSep);					}						if (entry.mode != null)					{						out.write("<MODE>");						out.write(entry.mode);						out.write("</MODE>");						out.write(lineSep);					}						out.write("</ENTRY>");					out.write(lineSep);				}					out.write("</RECENT>");				out.write(lineSep);					out.finish();			}			catch(Exception e)			{				Log.log(Log.ERROR,BufferHistory.class,e);			}			finally			{				IOUtilities.closeQuietly(out);			}		}	
private static void addEntry(Entry entry)		{			historyLock.writeLock().lock();			try			{				history.addFirst(entry);				trimToLimit(history);			}			finally			{				historyLock.writeLock().unlock();			}		}	
private static void removeEntry(String path)		{			historyLock.writeLock().lock();			try			{				Iterator<Entry> iter = history.iterator();				while(iter.hasNext())				{					Entry entry = iter.next();					if(MiscUtilities.pathsEqual(path,entry.path))					{						iter.remove();						return;					}				}			}			finally			{				historyLock.writeLock().unlock();			}		}	
private static String selectionToString(Selection[] s)		{			if(s == null)				return null;				StringBuilder buf = new StringBuilder();				for(int i = 0; i < s.length; i++)			{				if(i != 0)					buf.append(' ');					Selection sel = s[i];				if(sel instanceof Selection.Range)					buf.append("range ");				else //if(sel instanceof Selection.Rect)					buf.append("rect ");				buf.append(sel.getStart());				buf.append(' ');				buf.append(sel.getEnd());			}				return buf.toString();		}	
private static Selection[] stringToSelection(String s)		{			if(s == null)				return null;				List<Selection> selection = new ArrayList<Selection>();			StringTokenizer st = new StringTokenizer(s);				while(st.hasMoreTokens())			{				String type = st.nextToken();				int start = Integer.parseInt(st.nextToken());				int end = Integer.parseInt(st.nextToken());				if(end < start)				{					// I'm not sure when this can happen,					// but it does sometimes, witness the					// jEdit bug tracker.					continue;				}					Selection sel;				if(type.equals("range"))					sel = new Selection.Range(start,end);				else //if(type.equals("rect"))					sel = new Selection.Rect(start,end);					selection.add(sel);			}				Selection[] returnValue = new Selection[selection.size()];			returnValue = selection.toArray(returnValue);			return returnValue;		}	
private static void trimToLimit(LinkedList<Entry> list)		{			int max = jEdit.getIntegerProperty("recentFiles",50);			while(list.size() > max)				list.removeLast();		}	
private static void notifyChange()		{			EditBus.send(new DynamicMenuChanged("recent-files"));		}	
public InputSource resolveEntity(String publicId, String systemId)			{				return XMLUtilities.findEntity(systemId, "recent.dtd", getClass());			}	
public void endElement(String uri, String localName, String name)			{				if(name.equals("ENTRY"))				{					result.addLast(new Entry(						path,caret,selection,						encoding,						mode));					path = null;					caret = 0;					selection = null;					encoding = null;					mode = null;				}				else if(name.equals("PATH"))					path = charData.toString();				else if(name.equals("CARET"))					caret = Integer.parseInt(charData.toString());				else if(name.equals("SELECTION"))					selection = charData.toString();				else if(name.equals("ENCODING"))					encoding = charData.toString();				else if(name.equals("MODE"))					mode = charData.toString();				charData.setLength(0);			}	
public void characters(char[] ch, int start, int length)			{				charData.append(ch,start,length);			}	
/**		 * Creates a new buffer I/O request.		 * @param view The view		 * @param buffer The buffer		 * @param session The VFS session		 * @param vfs The VFS		 * @param path The path		 */		public BufferInsertRequest(View view, Buffer buffer,			Object session, VFS vfs, String path)		{			super(view,buffer,session,vfs,path);		}	
public void run()		{			InputStream in = null;			try			{				String[] args = { vfs.getFileName(path) };				setStatus(jEdit.getProperty("vfs.status.load",args));				setAbortable(true);					path = vfs._canonPath(session,path,view);					VFSFile entry = vfs._getFile(					session,path,view);				long length;				if(entry != null)					length = entry.getLength();				else					length = 0L;					in = vfs._createInputStream(session,path,false,view);				if(in == null)					return;					final SegmentBuffer seg = read(					autodetect(in),length,true);					/* we don't do this in Buffer.insert() so that				   we can insert multiple files at once */				VFSManager.runInAWTThread(new Runnable()				{					public void run()					{						view.getTextArea().setSelectedText(							seg.toString());					}				});			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);				String[] pp = { e.toString() };				VFSManager.error(view,path,"ioerror.read-error",pp);					buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			catch(WorkThread.Abort a)			{				buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			finally			{				IOUtilities.closeQuietly(in);				try				{					vfs._endVFSSession(session,view);				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);					String[] pp = { e.toString() };					VFSManager.error(view,path,"ioerror.read-error",pp);						buffer.setBooleanProperty(ERROR_OCCURRED,true);				}				catch(WorkThread.Abort a)				{					buffer.setBooleanProperty(ERROR_OCCURRED,true);				}			}		}	
/**		 * Creates a new buffer I/O request.		 * @param view The view		 * @param buffer The buffer		 * @param session The VFS session		 * @param vfs The VFS		 * @param path The path		 */		protected BufferIORequest(View view, Buffer buffer,			Object session, VFS vfs, String path)		{			this.view = view;			this.buffer = buffer;			this.session = session;			this.vfs = vfs;			this.path = path;				markersPath = Buffer.getMarkersPath(vfs, path);		}	
public String toString()		{			return getClass().getName() + '[' + buffer + ']';		}	
/**		 * Size of character I/O buffers.		 */		public static int getCharIOBufferSize()		{			return IOBUFSIZE;		}	
/**		 * Size of byte I/O buffers.		 */		public static int getByteIOBufferSize()		{			// 2 is sizeof char in byte;			return IOBUFSIZE * 2;		}	
/**		 * Tries to detect if the stream is gzipped, and if it has an encoding		 * specified with an XML PI.		 */		protected Reader autodetect(InputStream in) throws IOException		{			return MiscUtilities.autodetect(in, buffer);		}	
protected SegmentBuffer read(Reader in, long length,			boolean insert) throws IOException		{			/* we guess an initial size for the array */			IntegerArray endOffsets = new IntegerArray(				Math.max(1,(int)(length / 50)));				// only true if the file size is known			boolean trackProgress = !buffer.isTemporary() && length != 0;				if(trackProgress)			{				setMaximum(length);				setValue(0);			}				// if the file size is not known, start with a resonable			// default buffer size			if(length == 0)				length = IOBUFSIZE;				SegmentBuffer seg = new SegmentBuffer((int)length + 1);				char[] buf = new char[IOBUFSIZE];				/* Number of characters in 'buf' array.			 InputStream.read() doesn't always fill the			 array (eg, the file size is not a multiple of			 IOBUFSIZE, or it is a GZipped file, etc) */	 		int len;				// True if a \n was read after a \r. Usually			// means this is a DOS/Windows file			boolean CRLF = false;				// A \r was read, hence a MacOS file			boolean CROnly = false;				// Was the previous read character a \r?			// If we read a \n and this is true, we assume			// we have a DOS/Windows file			boolean lastWasCR = false;				// Number of lines read. Every 100 lines, we update the			// progress bar			int lineCount = 0;				while((len = in.read(buf,0,buf.length)) != -1)			{				// Offset of previous line, relative to				// the start of the I/O buffer (NOT				// relative to the start of the document)				int lastLine = 0;					for(int i = 0; i < len; i++)				{					// Look for line endings.					switch(buf[i])					{					case '\r':						// If we read a \r and						// lastWasCR is also true,						// it is probably a Mac file						// (\r\r in stream)						if(lastWasCR)						{							CROnly = true;							CRLF = false;						}						// Otherwise set a flag,						// so that \n knows that last						// was a \r						else						{							lastWasCR = true;						}							// Insert a line						seg.append(buf,lastLine,i -							lastLine);						seg.append('\n');						endOffsets.add(seg.count);						if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)							setValue(seg.count);							// This is i+1 to take the						// trailing \n into account						lastLine = i + 1;						break;					case '\n':						/* If lastWasCR is true, we just read a \r followed						 by a \n. We specify that this is a Windows file,						 but take no further action and just ignore the \r. */						if(lastWasCR)						{							CROnly = false;							CRLF = true;							lastWasCR = false;							/* Bump lastLine so that the next line doesn't erronously							  pick up the \r */							lastLine = i + 1;						}						/* Otherwise, we found a \n that follows some other						 *  character, hence we have a Unix file */						else						{							CROnly = false;							CRLF = false;							seg.append(buf,lastLine,								i - lastLine);							seg.append('\n');							endOffsets.add(seg.count);							if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)								setValue(seg.count);							lastLine = i + 1;						}						break;					default:						/*  If we find some other character that follows						 a \r, so it is not a Windows file, and probably						 a Mac file */						if(lastWasCR)						{							CROnly = true;							CRLF = false;							lastWasCR = false;						}						break;					}				}					if(trackProgress)					setValue(seg.count);					// Add remaining stuff from buffer				seg.append(buf,lastLine,len - lastLine);			}				setAbortable(false);				String lineSeparator;			if(seg.count == 0)			{				// fix for "[ 865589 ] 0-byte files should open using				// the default line seperator"				lineSeparator = jEdit.getProperty(					"buffer.lineSeparator",					System.getProperty("line.separator"));			}			else if(CRLF)				lineSeparator = "\r\n";			else if(CROnly)				lineSeparator = "\r";			else				lineSeparator = "\n";				// Chop trailing newline and/or ^Z (if any)			int bufferLength = seg.count;			if(bufferLength != 0)			{				char ch = seg.array[bufferLength - 1];				if(ch == 0x1a /* DOS ^Z */)					seg.count--;			}				buffer.setBooleanProperty(Buffer.TRAILING_EOL,false);			if(bufferLength != 0 && jEdit.getBooleanProperty("stripTrailingEOL"))			{				char ch = seg.array[bufferLength - 1];				if(ch == '\n')				{					buffer.setBooleanProperty(Buffer.TRAILING_EOL,true);					seg.count--;					endOffsets.setSize(endOffsets.getSize() - 1);				}			}				// add a line marker at the end for proper offset manager			// operation			endOffsets.add(seg.count + 1);				// to avoid having to deal with read/write locks and such,			// we insert the loaded data into the buffer in the			// post-load cleanup runnable, which runs in the AWT thread.			if(!insert)			{				buffer.setProperty(LOAD_DATA,seg);				buffer.setProperty(END_OFFSETS,endOffsets);				buffer.setProperty(NEW_PATH,path);				if(lineSeparator != null)					buffer.setProperty(JEditBuffer.LINESEP,lineSeparator);			}				// used in insert()			return seg;		}	
protected void write(Buffer buffer, OutputStream out)			throws IOException		{			String encodingName				= buffer.getStringProperty(JEditBuffer.ENCODING);			Encoding encoding = EncodingServer.getEncoding(encodingName);			Writer writer = encoding.getTextWriter(				new BufferedOutputStream(out, getByteIOBufferSize()));				Segment lineSegment = new Segment();			String newline = buffer.getStringProperty(JEditBuffer.LINESEP);			if(newline == null)				newline = System.getProperty("line.separator");				final int bufferLineCount = buffer.getLineCount();			setMaximum(bufferLineCount / PROGRESS_INTERVAL);			setValue(0);				int i = 0;			while(i < bufferLineCount)			{				buffer.getLineText(i,lineSegment);				try				{					writer.write(lineSegment.array,						lineSegment.offset,						lineSegment.count);					if(i < bufferLineCount - 1						|| (jEdit.getBooleanProperty("stripTrailingEOL")							&& buffer.getBooleanProperty(Buffer.TRAILING_EOL)))					{						writer.write(newline);					}				}				catch(CharacterCodingException e)				{					String message = getWriteEncodingErrorMessage(						encodingName, encoding,						lineSegment, i);					IOException wrapping = new CharConversionException(message);					wrapping.initCause(e);					throw wrapping;				}					if(++i % PROGRESS_INTERVAL == 0)					setValue(i / PROGRESS_INTERVAL);			}			writer.flush();		}	
private static String getWriteEncodingErrorMessage(			String encodingName, Encoding encoding,			Segment line, int lineIndex)		{			String args[] = {				encodingName,				Integer.toString(lineIndex + 1),				"UNKNOWN", // column				"UNKNOWN"  // the character			};			try			{				int charIndex = getFirstGuiltyCharacterIndex(encoding, line);				if(0 <= charIndex && charIndex < line.count)				{					char c = line.array[line.offset + charIndex];					args[2] = Integer.toString(charIndex + 1);					args[3] = "'" + c + "' (U+" + Integer.toHexString(c).toUpperCase() + ")";				}			}			catch(Exception e)			{				// Ignore.			}			return jEdit.getProperty("ioerror.write-encoding-error", args);		}	
private static int getFirstGuiltyCharacterIndex(Encoding encoding,			Segment line) throws IOException		{			if(line.count < 1)			{				return -1;			}			else if(line.count == 1)			{				return 0;			}				Writer tester = encoding.getTextWriter(				new OutputStream()				{					public void write(int b) {}				});			for(int i = 0; i < line.count; ++i)			{				try				{					tester.write(line.array[line.offset + i]);				}				catch(CharacterCodingException e)				{					return i;				}			}			return -1;		}	
public synchronized String getFirstFile(View view)		{			if(files == null)				files = _getFiles(view);				if(files == null || files.length == 0)				return null;			else				return files[0];		}	
public synchronized String getNextFile(View view, String path)		{			if(files == null)				files = _getFiles(view);				if(files == null || files.length == 0)				return null;				if(path == null)			{				path = view.getBuffer().getSymlinkPath();				VFS vfs = VFSManager.getVFSForPath(path);				boolean ignoreCase = ((vfs.getCapabilities()					& VFS.CASE_INSENSITIVE_CAP) != 0);					for(int i = 0; i < files.length; i++)				{					if(StandardUtilities.compareStrings(						files[i],path,ignoreCase) == 0)					{						return path;					}				}					return getFirstFile(view);			}			else			{				// -1 so that the last isn't checked				VFS vfs = VFSManager.getVFSForPath(path);				boolean ignoreCase = ((vfs.getCapabilities()					& VFS.CASE_INSENSITIVE_CAP) != 0);					for(int i = 0; i < files.length - 1; i++)				{					if(StandardUtilities.compareStrings(						files[i],path,ignoreCase) == 0)					{						return files[i+1];					}				}					return null;			}		}	
public synchronized String[] getFiles(View view)		{			if(files == null)				files = _getFiles(view);				if(files == null || files.length == 0)				return null;			else				return files;		}	
public synchronized int getFileCount(View view)		{			if(files == null)				files = _getFiles(view);				if(files == null)				return 0;			else				return files.length;		}	
public String getCode()		{			// not supported for arbitriary filesets			return null;		}	
public void invalidateCachedList()		{			files = null;		}	
/**		 * Creates a new buffer I/O request.		 * @param view The view		 * @param buffer The buffer		 * @param session The VFS session		 * @param vfs The VFS		 * @param path The path		 */		public BufferLoadRequest(View view, Buffer buffer,			Object session, VFS vfs, String path)		{			super(view,buffer,session,vfs,path);		}	
public void run()		{			try			{				setAbortable(true);				if(!buffer.isTemporary())				{					String[] args = { vfs.getFileName(path) };					setStatus(jEdit.getProperty("vfs.status.load",args));					setValue(0L);				}					path = vfs._canonPath(session,path,view);					readContents();				buffer.setNewFile(false);					if (jEdit.getBooleanProperty("persistentMarkers") &&				    (vfs.isMarkersFileSupported()))				{					InputStream markers = null;					try					{						String[] args = { vfs.getFileName(path) };						if(!buffer.isTemporary())							setStatus(jEdit.getProperty("vfs.status.load-markers",args));						setAbortable(true);							markers = vfs._createInputStream(session,markersPath,true,view);						if(markers != null)							readMarkers(buffer,markers);					}					catch(Exception e)					{						// ignore					}					finally					{						IOUtilities.closeQuietly(markers);					}				}			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);				Object[] pp = { e.toString() };				VFSManager.error(view,path,"ioerror.read-error",pp);					buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			catch(OutOfMemoryError oom)			{				Log.log(Log.ERROR,this,oom);				VFSManager.error(view,path,"out-of-memory-error",null);					buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			catch(WorkThread.Abort a)			{				buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			finally			{				try				{					vfs._endVFSSession(session,view);				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);					String[] pp = { e.toString() };					VFSManager.error(view,path,"ioerror.read-error",pp);						buffer.setBooleanProperty(ERROR_OCCURRED,true);				}				catch(WorkThread.Abort a)				{					buffer.setBooleanProperty(ERROR_OCCURRED,true);				}			}		}	
/**		 * Returns the raw contents stream for this load request.		 * This stream is not buffered or unzipped.		 */		private InputStream getNakedStream() throws IOException		{			InputStream in = vfs._createInputStream(session,path,false,view);			if(in != null)			{				return in;			}			throw new IOException("Unable to get a Stream for " + path);		}	
/**		 * Returns content length of this load request.		 */		private long getContentLength() throws IOException		{			VFSFile entry = vfs._getFile(session,path,view);			if(entry != null)				return entry.getLength();			else				return 0L;		}	
/**		 * Returns rewinded contents stream.		 * This method assumes the marked stream was made by		 * getMarkedStream() method. The stream may be reopened if reset()		 * failed.		 */		private BufferedInputStream rewindContentsStream(BufferedInputStream markedStream, boolean gzipped)			throws IOException		{			try			{				markedStream.reset();				return markedStream;			}			catch(IOException e)			{				Log.log(Log.NOTICE, this					, path + ": Reopening to rewind the stream");				// Reopen the stream because the mark has been				// invalidated while previous reading.				markedStream.close();				InputStream in = getNakedStream();				try				{					if(gzipped)					{						in = new GZIPInputStream(in);					}					BufferedInputStream result						= AutoDetection.getMarkedStream(in);					in = null;					return result;				}				finally				{					IOUtilities.closeQuietly(in);				}			}		}	
/**		 * Read the contents of this load request.		 * Some auto detection is performed if enabled.		 *   - GZIPed file		 *   - The encoding		 * If fallback encodings are specified, they are used on		 * encoding errors.		 */		private void readContents() throws IOException		{			long length = getContentLength();				BufferedInputStream markedStream				= AutoDetection.getMarkedStream(getNakedStream());			try			{				boolean gzipped = false;				// encodingProviders is consist of given				// encodings as String or contents-aware				// detectors as EncodingDetector.				List<Object> encodingProviders					= new ArrayList<Object>();					boolean autodetect = buffer.getBooleanProperty(Buffer.ENCODING_AUTODETECT);				if(autodetect)				{					gzipped = AutoDetection.isGzipped(markedStream);					markedStream.reset();						encodingProviders.addAll(AutoDetection.getEncodingDetectors());					// If the detected encoding fail, fallback to					// the original encoding.					encodingProviders.add(buffer.getStringProperty(Buffer.ENCODING));						String fallbackEncodings = jEdit.getProperty("fallbackEncodings");					if(fallbackEncodings != null && fallbackEncodings.length() > 0)					{						for(String encoding: fallbackEncodings.split("\\s+"))						{							encodingProviders.add(encoding);						}					}				}				else				{					gzipped = buffer.getBooleanProperty(Buffer.GZIPPED);					encodingProviders.add(buffer.getStringProperty(Buffer.ENCODING));				}					if(gzipped)				{					Log.log(Log.DEBUG, this, path + ": Stream is gzipped.");					markedStream = AutoDetection.getMarkedStream(						new GZIPInputStream(markedStream));				}					Set<String> failedEncodings = new HashSet<String>();				Exception encodingError = null;				for(Object encodingProvider: encodingProviders)				{					String encoding = null;					if (encodingProvider instanceof String)					{						encoding = (String)encodingProvider;					}					else if(encodingProvider instanceof EncodingDetector)					{						markedStream = rewindContentsStream(markedStream, gzipped);						encoding = ((EncodingDetector)encodingProvider).detectEncoding(new BufferedInputStream(markedStream));					}					else					{						Log.log(Log.DEBUG, this, "Strange encodingProvider: " + encodingProvider);					}						if(encoding == null || encoding.length() <= 0						|| failedEncodings.contains(encoding))					{						continue;					}						markedStream = rewindContentsStream(markedStream, gzipped);					try					{						read(EncodingServer.getTextReader(markedStream, encoding)							, length, false);						if(autodetect)						{							// Store the successful properties.							if(gzipped)							{								buffer.setBooleanProperty(Buffer.GZIPPED,true);							}							buffer.setProperty(Buffer.ENCODING, encoding);						}						return;					}					catch(CharConversionException e)					{						encodingError = e;					}					catch(CharacterCodingException e)					{						encodingError = e;					}					catch(UnsupportedEncodingException e)					{						encodingError = e;					}					catch(UnsupportedCharsetException e)					{						encodingError = e;					}					Log.log(Log.NOTICE, this, path + ": " + encoding						+ ": " + encodingError);					failedEncodings.add(encoding);				}				// All possible detectors and encodings failed.				Object[] pp = { TextUtilities.join(failedEncodings,","), "" };				if(failedEncodings.size() < 2)				{					pp[1] = encodingError.toString();				}				else				{					pp[1] = "See details in Activity Log";				}				VFSManager.error(view,path,"ioerror.encoding-error",pp);				markedStream = rewindContentsStream(markedStream, gzipped);				read(EncodingServer.getEncoding(					buffer.getStringProperty(Buffer.ENCODING)					).getPermissiveTextReader(markedStream)					, length, false);				if(autodetect && gzipped)				{					buffer.setBooleanProperty(Buffer.GZIPPED,true);				}			}			finally			{				markedStream.close();			}		}	
private static void readMarkers(Buffer buffer, InputStream _in)			throws IOException		{			// For `reload' command			buffer.removeAllMarkers();				BufferedReader in = new BufferedReader(new InputStreamReader(_in));				try			{				String line;				while((line = in.readLine()) != null)				{					// malformed marks file?					if(line.length() == 0)						continue;										// compatibility kludge for jEdit 3.1 and earlier					if(line.charAt(0) != '!')						continue;							char shortcut = line.charAt(1);					int start = line.indexOf(';');					int end = line.indexOf(';',start + 1);					int position = Integer.parseInt(line.substring(start + 1,end));					buffer.addMarker(shortcut,position);				}				buffer.setMarkersChanged(false);			}			finally			{				in.close();			}		}	
public BufferOptionPane()		{			super("Buffer Options");			init();		}	
@Override		protected void _init()		{			buffer = jEdit.getActiveView().getBuffer();			String filename = buffer.getName();			setName("Buffer: " + filename);			addComponent(GUIUtilities.createMultilineLabel(				jEdit.getProperty("buffer-options.caption")));				addSeparator("buffer-options.loading-saving");				//{{{ Line separator			String[] lineSeps = { jEdit.getProperty("lineSep.unix"),				jEdit.getProperty("lineSep.windows"),				jEdit.getProperty("lineSep.mac") };			lineSeparator = new JComboBox(lineSeps);			String lineSep = buffer.getStringProperty(JEditBuffer.LINESEP);			if(lineSep == null)				lineSep = System.getProperty("line.separator");			if("\n".equals(lineSep))				lineSeparator.setSelectedIndex(0);			else if("\r\n".equals(lineSep))				lineSeparator.setSelectedIndex(1);			else if("\r".equals(lineSep))				lineSeparator.setSelectedIndex(2);			addComponent(jEdit.getProperty("buffer-options.lineSeparator"),				lineSeparator);			//}}}				//{{{ Encoding			String[] encodings = MiscUtilities.getEncodings(true);			Arrays.sort(encodings,new StandardUtilities.StringCompare<String>(true));			encoding = new JComboBox(encodings);			encoding.setEditable(true);			encoding.setSelectedItem(buffer.getStringProperty(JEditBuffer.ENCODING));			addComponent(jEdit.getProperty("buffer-options.encoding"),				encoding);			//}}}				//{{{ GZipped setting			gzipped = new JCheckBox(jEdit.getProperty(				"buffer-options.gzipped"));			gzipped.setSelected(buffer.getBooleanProperty(Buffer.GZIPPED));			addComponent(gzipped);			//}}}				//{{{ Autoreload settings			/* Check mod status on focus */			String[] modCheckOptions = {				jEdit.getProperty("options.general.checkModStatus.nothing"),				jEdit.getProperty("options.general.checkModStatus.prompt"),				jEdit.getProperty("options.general.checkModStatus.reload"),				jEdit.getProperty("options.general.checkModStatus.silentReload")			};			checkModStatus = new JComboBox(modCheckOptions);			if(buffer.getAutoReload())			{				if(buffer.getAutoReloadDialog())					// reload and notify					checkModStatus.setSelectedIndex(2);				else	// reload silently					checkModStatus.setSelectedIndex(3);			}			else			{				if(buffer.getAutoReloadDialog())					// prompt					checkModStatus.setSelectedIndex(1);				else	// do nothing					checkModStatus.setSelectedIndex(0);			}			addComponent(jEdit.getProperty("options.general.checkModStatus"),				checkModStatus);				// }}}				addSeparator("buffer-options.editing");				//{{{ Edit mode			modes = jEdit.getModes();			Arrays.sort(modes,new StandardUtilities.StringCompare<Mode>(true));			mode = new JComboBox(modes);			mode.setSelectedItem(buffer.getMode());			ActionHandler actionListener = new ActionHandler();			mode.addActionListener(actionListener);			addComponent(jEdit.getProperty("buffer-options.mode"),mode);			//}}}				//{{{ Fold mode			String[] foldModes = FoldHandler.getFoldModes();				folding = new JComboBox(foldModes);			folding.setSelectedItem(buffer.getStringProperty("folding"));			addComponent(jEdit.getProperty("options.editing.folding"),				folding);			//}}}				//{{{ Wrap mode			String[] wrapModes = {				"none",				"soft",				"hard"			};				wrap = new JComboBox(wrapModes);			wrap.setSelectedItem(buffer.getStringProperty("wrap"));			addComponent(jEdit.getProperty("options.editing.wrap"),				wrap);			//}}}				//{{{ Max line length			String[] lineLengths = { "0", "72", "76", "80" };				maxLineLen = new JComboBox(lineLengths);			maxLineLen.setEditable(true);			maxLineLen.setSelectedItem(buffer.getStringProperty("maxLineLen"));			addComponent(jEdit.getProperty("options.editing.maxLineLen"),				maxLineLen);			//}}}				//{{{ Tab size			String[] tabSizes = { "2", "4", "8" };			tabSize = new JComboBox(tabSizes);			tabSize.setEditable(true);			tabSize.setSelectedItem(buffer.getStringProperty("tabSize"));			addComponent(jEdit.getProperty("options.editing.tabSize"),tabSize);			//}}}				//{{{ Indent size			indentSize = new JComboBox(tabSizes);			indentSize.setEditable(true);			indentSize.setSelectedItem(buffer.getStringProperty("indentSize"));			addComponent(jEdit.getProperty("options.editing.indentSize"),				indentSize);			//}}}				//{{{ Soft tabs			noTabs = new JCheckBox(jEdit.getProperty(				"options.editing.noTabs"));			noTabs.setSelected(buffer.getBooleanProperty("noTabs"));			addComponent(noTabs);			//}}}		}	
@Override		protected void _save()		{			int index = lineSeparator.getSelectedIndex();			String lineSep;			if(index == 0)				lineSep = "\n";			else if(index == 1)				lineSep = "\r\n";			else if(index == 2)				lineSep = "\r";			else				throw new InternalError();				String oldLineSep = buffer.getStringProperty(JEditBuffer.LINESEP);			if(oldLineSep == null)				oldLineSep = System.getProperty("line.separator");			if(!oldLineSep.equals(lineSep))			{				buffer.setStringProperty(JEditBuffer.LINESEP, lineSep);				buffer.setDirty(true);			}				String encoding = (String)this.encoding.getSelectedItem();			String oldEncoding = buffer.getStringProperty(JEditBuffer.ENCODING);			if(!oldEncoding.equals(encoding))			{				buffer.setStringProperty(JEditBuffer.ENCODING,encoding);				buffer.setDirty(true);				// Disable auto-detect because user explicitly				// specify an encoding.				buffer.setBooleanProperty(Buffer.ENCODING_AUTODETECT,false);			}				boolean gzippedValue = gzipped.isSelected();			boolean oldGzipped = buffer.getBooleanProperty(				Buffer.GZIPPED);			if(gzippedValue != oldGzipped)			{				buffer.setBooleanProperty(Buffer.GZIPPED,gzippedValue);				buffer.setDirty(true);			}				buffer.setStringProperty("folding",(String)folding.getSelectedItem());				buffer.setStringProperty("wrap",(String)wrap.getSelectedItem());				try			{				buffer.setProperty("maxLineLen",new Integer(					maxLineLen.getSelectedItem().toString()));			}			catch(NumberFormatException nf)			{			}				try			{				buffer.setProperty("tabSize",new Integer(					tabSize.getSelectedItem().toString()));			}			catch(NumberFormatException nf)			{			}				try			{				buffer.setProperty("indentSize",new Integer(					indentSize.getSelectedItem().toString()));			}			catch(NumberFormatException nf)			{			}				buffer.setBooleanProperty("noTabs",noTabs.isSelected());				index = mode.getSelectedIndex();			buffer.setMode(modes[index]);			switch(checkModStatus.getSelectedIndex())			{			case 0:				buffer.setAutoReloadDialog(false);				buffer.setAutoReload(false);				break;			case 1:				buffer.setAutoReloadDialog(true);				buffer.setAutoReload(false);				break;			case 2:				buffer.setAutoReloadDialog(true);				buffer.setAutoReload(true);				break;			case 3:				buffer.setAutoReloadDialog(false);				buffer.setAutoReload(true);				break;			}		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == mode)				{					Mode _mode = (Mode)mode.getSelectedItem();					folding.setSelectedItem(_mode.getProperty(						"folding"));					wrap.setSelectedItem(_mode.getProperty(						"wrap"));					maxLineLen.setSelectedItem(_mode.getProperty(						"maxLineLen"));					tabSize.setSelectedItem(_mode.getProperty(						"tabSize"));					indentSize.setSelectedItem(_mode.getProperty(						"indentSize"));					noTabs.setSelected(_mode.getBooleanProperty(						"noTabs"));				}			}	
public BufferOptions(View view, Buffer buffer)		{			super(view,jEdit.getProperty("buffer-options.title"),true);			this.view = view;			this.buffer = buffer;				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				ActionHandler actionListener = new ActionHandler();			panel = new BufferOptionPane();				content.add(BorderLayout.NORTH,panel);				//{{{ Buttons				JPanel buttons = new JPanel();			buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));			buttons.setBorder(new EmptyBorder(12,0,0,0));			buttons.add(Box.createGlue());				ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(actionListener);			getRootPane().setDefaultButton(ok);			buttons.add(ok);				buttons.add(Box.createHorizontalStrut(6));				cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(actionListener);			buttons.add(cancel);				buttons.add(Box.createGlue());			content.add(BorderLayout.SOUTH,buttons);				//}}}				pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public void ok()		{			panel.save();			dispose();		}	
public void cancel()		{			dispose();		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == ok)					ok();				else if(source == cancel)					cancel();			}	
BufferPrintable(PrinterJob job, Object format,			View view, Buffer buffer, Font font, boolean header,			boolean footer, boolean lineNumbers, boolean color)		{			this.job = job;			this.format = format;			this.view = view;			this.buffer = buffer;			this.font = font;			this.header = header;			this.footer = footer;			this.lineNumbers = lineNumbers;				styles = org.gjt.sp.util.SyntaxUtilities.loadStyles(jEdit.getProperty("print.font"),				jEdit.getIntegerProperty("print.fontsize",10),color);			styles[Token.NULL] = new SyntaxStyle(textColor,null,font);				// Change any white text to black			for(int i = 0; i < styles.length; i++)			{				SyntaxStyle s = styles[i];				if(s.getForegroundColor().equals(Color.WHITE)					&& s.getBackgroundColor() == null)				{					styles[i] = new SyntaxStyle(						Color.BLACK,						styles[i].getBackgroundColor(),						styles[i].getFont());				}			}				lineList = new ArrayList<Chunk>();				tokenHandler = new DisplayTokenHandler();		}	
public void print()		{			try			{				//buffer.readLock();					if(format == null)					job.print();				else				{					Method method = PrinterJob.class.getMethod(						"print",new Class[] { Class.forName(						"javax.print.attribute.PrintRequestAttributeSet") });					method.invoke(job,new Object[] { format });				}			}			catch(PrinterAbortException ae)			{				Log.log(Log.DEBUG,this,ae);			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);				final String[] args = { e.toString() };				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						GUIUtilities.error(view,"print-error",args);					}				});			}			finally			{				//buffer.readUnlock();			}		}	
public int print(Graphics _gfx, PageFormat pageFormat, int pageIndex)			throws PrinterException		{			// we keep the first non-null frc we get, since sometimes			// we get invalid ones on subsequent pages on Windows			if(frc == null)			{				frc = ((Graphics2D)_gfx).getFontRenderContext();				Log.log(Log.DEBUG,this,"Font render context is " + frc);			}				Log.log(Log.DEBUG,this,"Asked to print page " + pageIndex);			Log.log(Log.DEBUG,this,"Current page is " + currentPage);				if(pageIndex > currentPage)			{				for(int i = currentPage; i < pageIndex; i++)				{					Log.log(Log.DEBUG,this,"Current physical line is now " + currentPageStart);					currentPhysicalLine = currentPageStart;					printPage(_gfx,pageFormat,i,true);				}					currentPage = pageIndex - 1;				Log.log(Log.DEBUG,this,"Current page is now " + currentPage);			}				if(pageIndex == currentPage + 1)			{				if(end)				{					Log.log(Log.DEBUG,this,"The end");					return NO_SUCH_PAGE;				}					currentPageStart = currentPhysicalLine;				Log.log(Log.DEBUG,this,"#2 - Current physical line is now " + currentPageStart);				currentPage = pageIndex;				Log.log(Log.DEBUG,this,"#2 - Current page is now " + currentPage);			}			else if(pageIndex == currentPage)			{				currentPhysicalLine = currentPageStart;				Log.log(Log.DEBUG,this,"#3 - Current physical line is now " + currentPageStart);			}				printPage(_gfx,pageFormat,pageIndex,true);				return PAGE_EXISTS;		}	
private void printPage(Graphics _gfx, PageFormat pageFormat, int pageIndex,			boolean actuallyPaint)		{			Log.log(Log.DEBUG,this,"printPage(" + pageIndex + ',' + actuallyPaint + ')');			Graphics2D gfx = (Graphics2D)_gfx;			gfx.setFont(font);				double pageX = pageFormat.getImageableX();			double pageY = pageFormat.getImageableY();			double pageWidth = pageFormat.getImageableWidth();			double pageHeight = pageFormat.getImageableHeight();				Log.log(Log.DEBUG,this,"#1 - Page dimensions: " + pageWidth				+ 'x' + pageHeight);				if(header)			{				double headerHeight = paintHeader(gfx,pageX,pageY,pageWidth,					actuallyPaint);				pageY += headerHeight;				pageHeight -= headerHeight;			}				if(footer)			{				double footerHeight = paintFooter(gfx,pageX,pageY,pageWidth,					pageHeight,pageIndex,actuallyPaint);				pageHeight -= footerHeight;			}				boolean glyphVector = jEdit.getBooleanProperty("print.glyphVector");			double lineNumberWidth;				//{{{ determine line number width			if(lineNumbers)			{				// the +1's ensure that 99 gets 3 digits, 103 gets 4 digits,				// and so on.				int lineNumberDigits = (int)Math.ceil(Math.log(buffer.getLineCount() + 1)					/ Math.log(10)) + 1;					// now that we know how many chars there are, get the width.				char[] chars = new char[lineNumberDigits];				for(int i = 0; i < chars.length; i++)					chars[i] = ' ';				lineNumberWidth = font.getStringBounds(chars,					0,lineNumberDigits,frc).getWidth();			}			else				lineNumberWidth = 0.0;			//}}}				Log.log(Log.DEBUG,this,"#2 - Page dimensions: "				+ (pageWidth - lineNumberWidth)				+ 'x' + pageHeight);				//{{{ calculate tab size			int tabSize = jEdit.getIntegerProperty("print.tabSize",8);			char[] chars = new char[tabSize];			for(int i = 0; i < chars.length; i++)				chars[i] = ' ';			double tabWidth = font.getStringBounds(chars,				0,tabSize,frc).getWidth();			PrintTabExpander e = new PrintTabExpander(tabWidth);			//}}}				lm = font.getLineMetrics("gGyYX",frc);			Log.log(Log.DEBUG,this,"Line height is " + lm.getHeight());				double y = 0.0;	print_loop:	for(;;)			{				if(currentPhysicalLine == buffer.getLineCount())				{					Log.log(Log.DEBUG,this,"Finished buffer");					end = true;					break print_loop;				}				if (!jEdit.getBooleanProperty("print.folds",true) &&					!view.getTextArea().getDisplayManager().isLineVisible(currentPhysicalLine))				{										Log.log(Log.DEBUG,this,"Skipping invisible line");					currentPhysicalLine++;					continue;				}									lineList.clear();					tokenHandler.init(styles,frc,e,lineList,					(float)(pageWidth - lineNumberWidth));					buffer.markTokens(currentPhysicalLine,tokenHandler);				if(lineList.isEmpty())					lineList.add(null);					if(y + (lm.getHeight() * lineList.size()) >= pageHeight)				{					Log.log(Log.DEBUG,this,"Finished page before line " + currentPhysicalLine);					break print_loop;				}					if(lineNumbers && actuallyPaint)				{					gfx.setFont(font);					gfx.setColor(lineNumberColor);					gfx.drawString(String.valueOf(currentPhysicalLine + 1),						(float)pageX,(float)(pageY + y + lm.getHeight()));				}					for(int i = 0; i < lineList.size(); i++)				{					y += lm.getHeight();					Chunk chunks = lineList.get(i);					if(chunks != null && actuallyPaint)					{						Chunk.paintChunkBackgrounds(chunks,gfx,							(float)(pageX + lineNumberWidth),							(float)(pageY + y));						Chunk.paintChunkList(chunks,gfx,							(float)(pageX + lineNumberWidth),							(float)(pageY + y),glyphVector);					}				}					currentPhysicalLine++;			}		}	
private double paintHeader(Graphics2D gfx, double pageX, double pageY,			double pageWidth, boolean actuallyPaint)		{			String headerText = jEdit.getProperty("print.headerText",				new String[] { buffer.getName() });			FontRenderContext frc = gfx.getFontRenderContext();			lm = font.getLineMetrics(headerText,frc);				Rectangle2D bounds = font.getStringBounds(headerText,frc);			Rectangle2D headerBounds = new Rectangle2D.Double(				pageX,pageY,pageWidth,bounds.getHeight());				if(actuallyPaint)			{				gfx.setColor(headerColor);				gfx.fill(headerBounds);				gfx.setColor(headerTextColor);				gfx.drawString(headerText,					(float)(pageX + (pageWidth - bounds.getWidth()) / 2),					(float)(pageY + lm.getAscent()));			}				return headerBounds.getHeight();		}	
private double paintFooter(Graphics2D gfx, double pageX, double pageY,			double pageWidth, double pageHeight, int pageIndex,			boolean actuallyPaint)		{			String footerText = jEdit.getProperty("print.footerText",				new Object[] { new Date(), Integer.valueOf(pageIndex + 1)});			FontRenderContext frc = gfx.getFontRenderContext();			lm = font.getLineMetrics(footerText,frc);				Rectangle2D bounds = font.getStringBounds(footerText,frc);			Rectangle2D footerBounds = new Rectangle2D.Double(				pageX,pageY + pageHeight - bounds.getHeight(),				pageWidth,bounds.getHeight());				if(actuallyPaint)			{				gfx.setColor(footerColor);				gfx.fill(footerBounds);				gfx.setColor(footerTextColor);				gfx.drawString(footerText,					(float)(pageX + (pageWidth - bounds.getWidth()) / 2),					(float)(pageY + pageHeight - bounds.getHeight()					+ lm.getAscent()));			}				return footerBounds.getHeight();		}	
PrintTabExpander(double tabWidth)			{				this.tabWidth = tabWidth;			}	
public float nextTabStop(float x, int tabOffset)			{				int ntabs = (int)((x + 1) / tabWidth);				return (float)((ntabs + 1) * tabWidth);			}	
private static PrinterJob getPrintJob()		{			job = PrinterJob.getPrinterJob();				int orientation = jEdit.getIntegerProperty("print.orientation",PageFormat.PORTRAIT);			double width = jEdit.getDoubleProperty("print.width",0);			double height = jEdit.getDoubleProperty("print.height",0);			double x = jEdit.getDoubleProperty("print.x",0);			double y = jEdit.getDoubleProperty("print.y",0);			double pagewidth = jEdit.getDoubleProperty("print.pagewidth",0);			double pageheight = jEdit.getDoubleProperty("print.pageheight",0);				format = job.defaultPage();			//format.setOrientation(PageFormat.PORTRAIT);			if(width!=0 && height!=0 )			{				Paper pap = format.getPaper();				pap.setImageableArea(x,y,width,height);				pap.setSize(pagewidth,pageheight);				format.setPaper(pap);			}			format.setOrientation(orientation);			return job;			}	
public static void pageSetup(View view)		{			job = getPrintJob();				PageFormat newFormat = job.pageDialog(format);			if(newFormat != null)			{				format = newFormat;				jEdit.setIntegerProperty("print.orientation",format.getOrientation());				Paper paper=format.getPaper();					jEdit.setDoubleProperty("print.width",paper.getImageableWidth());				jEdit.setDoubleProperty("print.height",paper.getImageableHeight());				jEdit.setDoubleProperty("print.x",paper.getImageableX());				jEdit.setDoubleProperty("print.y",paper.getImageableY());				jEdit.setDoubleProperty("print.pagewidth",paper.getWidth());				jEdit.setDoubleProperty("print.pageheight",paper.getHeight());			}		}	
public static void print(final View view, final Buffer buffer, boolean selection)		{			job = getPrintJob();			job.setJobName(buffer.getPath());			boolean header = jEdit.getBooleanProperty("print.header");			boolean footer = jEdit.getBooleanProperty("print.footer");			boolean lineNumbers = jEdit.getBooleanProperty("print.lineNumbers");			boolean color = jEdit.getBooleanProperty("print.color");			Font font = jEdit.getFontProperty("print.font");				BufferPrintable printable = new BufferPrintable(job,null,view,				buffer,font,header,footer,lineNumbers,color);			job.setPrintable(printable,format);				if(!job.printDialog())				return;				printable.print();		}	
public static PageFormat getPageFormat()		{			return format;		}	
private static PrinterJob getPrintJob(String jobName)		{			job = PrinterJob.getPrinterJob();				format = new HashPrintRequestAttributeSet();				String settings = jEdit.getSettingsDirectory();			if(settings != null)			{				String printSpecPath = MiscUtilities.constructPath(					settings, "printspec");				File filePrintSpec = new File(printSpecPath);					if (filePrintSpec.exists())				{					try					{						FileInputStream fileIn = new FileInputStream(filePrintSpec);						ObjectInputStream obIn = new ObjectInputStream(fileIn);						format = (HashPrintRequestAttributeSet)obIn.readObject();					}					catch(Exception e)					{						Log.log(Log.ERROR,BufferPrinter1_4.class,e);					}					//for backwards compatibility, the color variable is stored also as a property					if(jEdit.getBooleanProperty("print.color"))						format.add(Chromaticity.COLOR);					else						format.add(Chromaticity.MONOCHROME);						//no need to always keep the same job name for every printout.					format.add(new JobName(jobName, null));				}			}				return job;		}	
public static void pageSetup(View view)		{			PrinterJob prnJob = getPrintJob("PageSetupOnly");			if(prnJob.pageDialog(format)!=null)				savePrintSpec();		}	
public static void print(final View view, final Buffer buffer, boolean selection)		{			job = getPrintJob(buffer.getPath());				boolean header = jEdit.getBooleanProperty("print.header");			boolean footer = jEdit.getBooleanProperty("print.footer");			boolean lineNumbers = jEdit.getBooleanProperty("print.lineNumbers");			boolean color = jEdit.getBooleanProperty("print.color");			Font font = jEdit.getFontProperty("print.font");				BufferPrintable printable = new BufferPrintable(job,format,view,				buffer,font,header,footer,lineNumbers,color);			job.setPrintable(printable);				if(!job.printDialog(format))				return;				savePrintSpec();				printable.print();		}	
public static PageFormat getPageFormat()		{			//convert from PrintRequestAttributeSet to the pageFormat			PrinterJob prnJob=getPrintJob(" ");			PageFormat pf=prnJob.defaultPage();			Paper pap=pf.getPaper();				MediaSizeName media=(MediaSizeName)format.get(			                            Media.class);			MediaSize ms=MediaSize.getMediaSizeForName(media);				MediaPrintableArea mediaarea=(MediaPrintableArea)format.get(			                                     MediaPrintableArea.class);			if(mediaarea!=null)				pap.setImageableArea((mediaarea.getX(MediaPrintableArea.INCH)*72),				                     (mediaarea.getY(MediaPrintableArea.INCH)*72),				                     (mediaarea.getWidth(MediaPrintableArea.INCH)*72),				                     (mediaarea.getHeight(MediaPrintableArea.INCH)*72));			if(ms!=null)				pap.setSize((ms.getX(MediaSize.INCH)*72),				            (ms.getY(MediaSize.INCH)*72));			pf.setPaper(pap);				OrientationRequested orientation=(OrientationRequested)format.get(			                                         OrientationRequested.class);			if(orientation!=null)			{				if(orientation.getValue()==OrientationRequested.LANDSCAPE.getValue())				{					pf.setOrientation(PageFormat.LANDSCAPE);				}				else if(orientation.getValue()==OrientationRequested.REVERSE_LANDSCAPE.getValue())				{					pf.setOrientation(PageFormat.REVERSE_LANDSCAPE);				}				else if(orientation.getValue()==OrientationRequested.PORTRAIT.getValue())				{					pf.setOrientation(PageFormat.PORTRAIT);				}				else if(orientation.getValue()==OrientationRequested.REVERSE_PORTRAIT.getValue())				{					//doesnt exist??					//pf.setOrientation(PageFormat.REVERSE_PORTRAIT);					//then just do the next best thing					pf.setOrientation(PageFormat.PORTRAIT);				}			}			return pf;		}	
private static void savePrintSpec()		{			String settings = jEdit.getSettingsDirectory();			if(settings == null)				return;				String printSpecPath = MiscUtilities.constructPath(				settings, "printspec");			File filePrintSpec = new File(printSpecPath);				try			{				FileOutputStream fileOut=new FileOutputStream(filePrintSpec);				ObjectOutputStream obOut=new ObjectOutputStream(fileOut);				obOut.writeObject(format);				//for backwards compatibility, the color variable is stored also as a property				Chromaticity cc=(Chromaticity)format.get(Chromaticity.class);				if (cc!=null)					jEdit.setBooleanProperty("print.color",						cc.getValue()==Chromaticity.COLOR.getValue());			}			catch(Exception e)			{				e.printStackTrace();			}		}	
/**		 * Creates a new buffer I/O request.		 * @param view The view		 * @param buffer The buffer		 * @param session The VFS session		 * @param vfs The VFS		 * @param path The path		 */		public BufferSaveRequest(View view, Buffer buffer,			Object session, VFS vfs, String path)		{			super(view,buffer,session,vfs,path);		}	
public void run()		{			/* if the VFS supports renaming files, we first			 * save to #<filename>#save#, then rename that			 * to <filename>, so that if the save fails,			 * data will not be lost.			 *			 * as of 4.1pre7 we now call vfs.getTwoStageSaveName()			 * instead of constructing the path directly			 * since some VFS's might not allow # in filenames.			 */				boolean vfsRenameCap = (vfs.getCapabilities() &				VFS.RENAME_CAP) != 0;				boolean wantTwoStage = wantTwoStageSave(buffer);			boolean twoStageSave = vfsRenameCap && wantTwoStage;				try			{				String[] args = { vfs.getFileName(path) };				setStatus(jEdit.getProperty("vfs.status.save",args));					// the entire save operation can be aborted...				setAbortable(true);					path = vfs._canonPath(session,path,view);				if(!MiscUtilities.isURL(path))					path = MiscUtilities.resolveSymlinks(path);					String savePath;				if(twoStageSave)				{					savePath = vfs.getTwoStageSaveName(path);					if (savePath == null)					{						throw new IOException(							"Can't get a temporary path for two-stage save: "							+ path);					}				}				else				{					makeBackup();					savePath = path;				}					OutputStream out = vfs._createOutputStream(session,savePath,view);				if(out == null)				{					buffer.setBooleanProperty(ERROR_OCCURRED,true);					return;				}				try				{					// this must be after the stream is created or					// we deadlock with SSHTools.					buffer.readLock();					try					{						// Can't use buffer.getName() here because						// it is not changed until the save is						// complete						if(path.endsWith(".gz"))							buffer.setBooleanProperty(Buffer.GZIPPED,true);						else if (buffer.getName().endsWith(".gz"))						{							// The path do not ends with gz.							// The buffer name was .gz.							// So it means it's blabla.txt.gz -> blabla.txt, I remove							// the gz property							buffer.setBooleanProperty(Buffer.GZIPPED, false);						}							if(buffer.getBooleanProperty(Buffer.GZIPPED))							out = new GZIPOutputStream(out);							write(buffer,out);					}					finally					{						buffer.readUnlock();					}				}				finally				{					IOUtilities.closeQuietly(out);				}					if(twoStageSave)				{					makeBackup();					if(!vfs._rename(session,savePath,path,view))						throw new IOException("Rename failed: " + savePath);				}					if(!twoStageSave)					VFSManager.sendVFSUpdate(vfs,path,true);			}			catch(UnsupportedCharsetException e)			{				Log.log(Log.ERROR, this, e, e);				String[] pp = { e.getCharsetName() };				VFSManager.error(view,path,"ioerror.unsupported-encoding-error",pp);					buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);				String[] pp = { e.toString() };				VFSManager.error(view,path,"ioerror.write-error",pp);					buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			catch(WorkThread.Abort a)			{				buffer.setBooleanProperty(ERROR_OCCURRED,true);			}			finally			{				try				{					vfs._saveComplete(session,buffer,path,view);					if( twoStageSave )					{						vfs._finishTwoStageSave(session,buffer,path,view);					}					// clean up left-over markers file					if(!jEdit.getBooleanProperty("persistentMarkers"))						vfs._delete(session,Buffer.getMarkersPath(vfs, path),view);					vfs._endVFSSession(session,view);				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);					String[] pp = { e.toString() };					VFSManager.error(view,path,"ioerror.write-error",pp);						buffer.setBooleanProperty(ERROR_OCCURRED,true);				}				catch(WorkThread.Abort a)				{					buffer.setBooleanProperty(ERROR_OCCURRED,true);				}			}		}	
/**		 * Make the backup.		 */		private void makeBackup() throws IOException		{			// Only backup once per session			if(buffer.getProperty(Buffer.BACKED_UP) == null				|| jEdit.getBooleanProperty("backupEverySave"))			{				vfs._backup(session,path,view);				buffer.setBooleanProperty(Buffer.BACKED_UP,true);			}		}	
private static boolean wantTwoStageSave(Buffer buffer)		{			return !buffer.getBooleanProperty("forbidTwoStageSave") &&				(buffer.getBooleanProperty("overwriteReadonly") ||				jEdit.getBooleanProperty("twoStageSave"));		}	
public BufferSegment(char[] data,				     int offset,				     int len)		{			this(data,offset,len,null);		}	
public BufferSegment(char[] data,				      int offset,				      int len,				      BufferSegment next)		{			this.data = data;			this.offset = offset;			this.len = len;			this.next = next;		}	
public char charAt(int index)		{			if (index < len)				return data[offset+index];			else if (next != null)				return next.charAt(index-len);			else				throw new ArrayIndexOutOfBoundsException(index);		}	
public int length()		{			return len + ((next != null) ? next.length() : 0);		}	
public CharSequence subSequence(int start,						int end)		{			return subSegment(start, end);		}	
public String toString()		{			StringBuilder sb = new StringBuilder();			toString(sb);			return sb.toString();		}	
private void toString(StringBuilder sb)		{			sb.append(data,offset,len);			if (next != null)				next.toString(sb);		}	
private BufferSegment subSegment(int start,						int end)		{			if (0 <= start && start <= end)				if (end <= len)					return new BufferSegment(data,offset+start,						end-start);				else if (next != null)					if (start < len)						return new BufferSegment(data,							offset+start,len-start,							next.subSegment(0,end-len));					else						return next.subSegment(start-len,							end-len);				else					throw new ArrayIndexOutOfBoundsException();			else				throw new ArrayIndexOutOfBoundsException();		}	
public static Scope fromString(String s)			{				Scope[] scopes = values();				for (Scope scope: scopes)				{					if (scope.toString().equals(s))						return scope;				}					return global;			}	
/**		 * Create a new BufferSet.		 */		public BufferSet()		{			buffers = Collections.synchronizedList(new ArrayList<Buffer>());			listeners = new EventListenerList();				if (jEdit.getBooleanProperty("sortBuffers"))			{				if (jEdit.getBooleanProperty("sortByName"))					sorter = nameSorter;				else					sorter = pathSorter;			}		}	
public void addBufferAt(Buffer buffer, int position)		{			Log.log(Log.DEBUG, this, hashCode() + " addBufferAt("+buffer+','+position+')');				Buffer untitledBuffer = null;			synchronized (buffers)			{				if (buffers.size() == 1)				{					Buffer buf = buffers.get(0);					if (buf.isUntitled() && !buf.isDirty())					{						untitledBuffer = buf;					}				}					if (sorter != null)				{					if (buffers.contains(buffer))						return;					buffers.add(buffer);					Collections.sort(buffers, sorter);					position = buffers.indexOf(buffer);				}				else				{					int oldPos = buffers.indexOf(buffer);					if (oldPos != -1)					{						if (position == -1)						{							return;						}						moveBuffer(oldPos, position);						return;					}					int size = buffers.size();					if (position == -1 || position > size)					{						position = size;					}					buffers.add(position, buffer);				}			}			BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);			Log.log(Log.DEBUG, this, hashCode() + ": Buffer added " + buffer + " at " + position);			for (BufferSetListener listener : listeners)			{				listener.bufferAdded(buffer, position);			}				// I don't like this reverse control			if (untitledBuffer != null)			{				jEdit.getBufferSetManager().removeBuffer(this, untitledBuffer);			}		}	
/**		 * Returns the Buffer at the given index.		 * @param index the index. The index must exists		 * @return the buffer at the index.		 */		public Buffer getBuffer(int index)		{			return buffers.get(index);		}	
public Buffer getPreviousBuffer(int index)		{			if (buffers.isEmpty())				return null;			if (buffers.size() < 2)				return buffers.get(0);			if (index <= 0)				return buffers.get(buffers.size() - 1);			return buffers.get(index - 1);		}	
public Buffer getNextBuffer(int index)		{			if (buffers.isEmpty())				return null;			if (buffers.size() < 2)				return buffers.get(buffers.size()-1);			if (index >= buffers.size() - 1)				return buffers.get(0);			return buffers.get(index + 1);		}	
public int indexOf(Buffer buffer)		{			return buffers.indexOf(buffer);		}	
public int size()		{			return buffers.size();		}	
public void getAllBuffers(BufferSetListener listener)		{			synchronized (buffers)			{				for (int i = 0;i<buffers.size();i++)				{					Buffer buffer = buffers.get(i);					Log.log(Log.DEBUG, this, hashCode() + ": Buffer added " + buffer + " at " + i);					listener.bufferAdded(buffer, i);				}			}		}	
/**		 * Returns an array of all buffers in this bufferSet.		 *		 * @return an array of all Buffers		 */		public Buffer[] getAllBuffers()		{			Buffer[] buffers = new Buffer[this.buffers.size()];			return this.buffers.toArray(buffers);		}	
/**		 * Add a BufferSetListener.		 * @param listener the new BufferSetListener		 */		public void addBufferSetListener(BufferSetListener listener)		{			Log.log(Log.DEBUG, this, hashCode() + ": addBufferSetListener " + listener);			listeners.add(BufferSetListener.class, listener);		}	
/**		 * Remove a BufferSetListener.		 * If there are no listeners anymore, remove all buffers from the bufferSet.		 * @param listener the removed BufferSetListener		 */		public void removeBufferSetListener(BufferSetListener listener)		{			Log.log(Log.DEBUG, this, hashCode() + ": removeBufferSetListener " + listener);			listeners.remove(BufferSetListener.class, listener);			if (!hasListeners())			{				// must empty the bufferSet				Buffer[] buffers = getAllBuffers();				BufferSetManager bufferSetManager = jEdit.getBufferSetManager();				for (Buffer buffer : buffers)				{					bufferSetManager.removeBuffer(this, buffer);				}			}		}	
/**		 * Check if the BufferSet has listeners.		 *		 * @return true if the bufferSet has listeners		 */		public boolean hasListeners()		{			return listeners.getListenerCount() != 0;		}	
@Override		public String toString()		{			return "BufferSet[nbBuffers="+size()+']';		}	
void addBuffer(Buffer buffer)		{			addBufferAt(buffer,  -1);		}	
/**		 * This method is called by BufferSetManager to signal that this		 * BufferSet needs to react to a change in the sorting properties.		 */		void handleMessage()		{			if (jEdit.getBooleanProperty("sortBuffers"))			{				// set the appropriate sorter				if (jEdit.getBooleanProperty("sortByName"))					sorter = nameSorter;				else					sorter = pathSorter;					// do the sort				Collections.sort(buffers, sorter);					// notify the listeners so they can repaint themselves				BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);				for (BufferSetListener listener : listeners)				{					listener.bufferSetSorted();				}			}			else			{				// user has elected not to sort BufferSets				sorter = null;			}		}	
void moveBuffer(int oldPosition, int newPosition)		{			if (sorter != null)			{				// Buffers are sorted, do nothing				return;			}			Buffer buffer;			synchronized (buffers)			{				buffer = buffers.remove(oldPosition);				int size = buffers.size();				if (newPosition == -1 || newPosition > size)				{					newPosition = size;				}				buffers.add(newPosition, buffer);			}			BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);			Log.log(Log.DEBUG, this, hashCode() + ": Buffer moved " + buffer + " from " + oldPosition + " to " + newPosition);			for (BufferSetListener listener : listeners)			{				listener.bufferMoved(buffer, oldPosition, newPosition);			}		}	
void removeBuffer(Buffer buffer)		{			int index;			synchronized (buffers)			{				index = buffers.indexOf(buffer);				if (index == -1)					return;					buffers.remove(index);			}			BufferSetListener[] listeners = this.listeners.getListeners(BufferSetListener.class);			Log.log(Log.DEBUG, this, hashCode() + ": Buffer removed " + buffer);			for (BufferSetListener listener : listeners)			{				listener.bufferRemoved(buffer, index);			}		}	
public int compare(Buffer o1, Buffer o2)			{					int ret = StandardUtilities.compareStrings(o1.getName(), o2.getName(), true);				if (ret == 0)				{					ret = StandardUtilities.compareStrings(o1.getPath(), o2.getPath(), true);				}				return ret;			}	
public int compare(Buffer o1, Buffer o2)			{				return StandardUtilities.compareStrings(o1.getPath(), o2.getPath(), true);			}	
public void bufferAdded(Buffer buffer, int index)		{		}	
public void bufferRemoved(Buffer buffer, int index)		{		}	
public void bufferMoved(Buffer buffer, int oldIndex, int newIndex)		{		}	
public void bufferSetSorted()		{		}	
public static NewBufferSetAction fromString(String s)			{				NewBufferSetAction[] newBufferSetActions = values();				for (NewBufferSetAction newBufferSetAction : newBufferSetActions)				{					if (newBufferSetAction.getName().equals(s))						return newBufferSetAction;				}					return currentbuffer;			}	
public String getName()			{				return super.toString();			}	
@Override			public String toString()			{				return jEdit.getProperty("options.editpane.bufferset.newbufferset." + getName());			}	
public BufferSetManager()		{			EditBus.addToBus(this);		}	
public void handleMessage(EBMessage message)		{			if (message instanceof ViewUpdate)			{				ViewUpdate viewUpdate = (ViewUpdate) message;				if (viewUpdate.getWhat() == ViewUpdate.CLOSED)				{					View view = viewUpdate.getView();					// Unlink the buffer from this bufferSet.					BufferSet viewBufferSet = view.getLocalBufferSet();					viewBufferSet.getAllBuffers(new BufferSetClosed(viewBufferSet));				}			}			else if (message instanceof EditPaneUpdate)			{				EditPaneUpdate editPaneUpdate = (EditPaneUpdate) message;				if (editPaneUpdate.getWhat() == EditPaneUpdate.DESTROYED)				{					EditPane editPane = editPaneUpdate.getEditPane();					// If the editPane has own BufferSet, unlink the buffer from this bufferSet.					if (editPane.getBufferSetScope() == BufferSet.Scope.editpane)					{						BufferSet editPaneBufferSet = editPane.getBufferSet();						editPaneBufferSet.getAllBuffers(new BufferSetClosed(editPaneBufferSet));					}				}			}			else if (message instanceof PropertiesChanged)			{				// pass on PropertiesChanged message to BufferSets so				// they can resort themselves as needed.				visit(new BufferSetVisitor()				{					public void visit(BufferSet bufferSet)					{						bufferSet.handleMessage();					}				});			}			}	
/**		 * Merge the content of the source bufferSet into the target bufferSet		 * @param target the target bufferSet		 * @param source the source bufferSet		 * @see org.gjt.sp.jedit.EditPane#setBuffer(org.gjt.sp.jedit.Buffer)		 */		public void mergeBufferSet(BufferSet target, BufferSet source)		{			Buffer[] buffers = source.getAllBuffers();			for (Buffer buffer : buffers)			{				addBuffer(target, buffer);			}		}	
/**		 * Count the bufferSets in which the buffer is.		 * @param buffer the buffer		 * @return the number of buffersets in which buffer is		 * @see org.gjt.sp.jedit.jEdit#closeBuffer(org.gjt.sp.jedit.EditPane, org.gjt.sp.jedit.Buffer)		 */		public int countBufferSets(Buffer buffer)		{			return getOwners(buffer).size();		}	
/**		 * Add a buffer into the current editPane of the given view.		 * If the view is null, it will be added to the global bufferSet		 * @param view a view (or null)		 * @param buffer the buffer to add		 */		public void addBuffer(View view, Buffer buffer)		{			EditPane editPane = view == null ? null : view.getEditPane();			addBuffer(editPane, buffer);		}	
/**		 * Add a buffer into the current editPane of the given editPane.		 * If the editPane is null, it will be added to the global bufferSet		 * @param editPane an EditPane (or null)		 * @param buffer the buffer to add		 */		public void addBuffer(EditPane editPane, Buffer buffer)		{			if (editPane == null)			{				addBuffer(jEdit.getGlobalBufferSet(), buffer);			}			else			{				BufferSet bufferSet = editPane.getBufferSet();				addBuffer(bufferSet, buffer);			}		}	
/**		 * Add a buffer in the given bufferSet.		 *		 * @param bufferSet the bufferSet		 * @param buffer the buffer to add		 */		public void addBuffer(BufferSet bufferSet, Buffer buffer)		{			bufferSet.addBuffer(buffer);		}	
/**		 * Add all buffers to the bufferSet.		 *		 * @param bufferSet the bufferSet		 */		public void addAllBuffers(BufferSet bufferSet)		{			Buffer[] buffers = jEdit.getBuffers();			for (Buffer buffer : buffers)			{				if (!buffer.isClosed())					addBuffer(bufferSet, buffer);			}		}	
/**		 * Moves a buffer from a old position to a new position in the		 * BufferSet used in an EditPane.		 */		public void moveBuffer(EditPane editPane,			int oldPosition, int newPosition)		{			editPane.getBufferSet().moveBuffer(oldPosition, newPosition);		}	
/**		 * Remove a buffer from the EditPane's bufferSet.		 *		 * @param editPane the editPane It cannot be null		 * @param buffer the buffer		 */		public void removeBuffer(EditPane editPane, Buffer buffer)		{			BufferSet bufferSet = editPane.getBufferSet();			removeBuffer(bufferSet, buffer);		}	
/**		 * Remove a buffer from a View's BufferSet.		 *		 * @param bufferSet the bufferSet		 * @param buffer the buffer that will be removed		 */		void removeBuffer(BufferSet bufferSet, Buffer buffer)		{			Log.log(Log.DEBUG, this, "removeBuffer("+bufferSet+','+buffer+')');			Set<BufferSet> owners = getOwners(buffer);			owners.remove(bufferSet);			bufferSet.removeBuffer(buffer);				if (owners.isEmpty())			{				Log.log(Log.DEBUG, this, "Buffer:"+buffer+" is in no bufferSet anymore, closing it");				jEdit._closeBuffer(null, buffer);			}			if (bufferSet.size() == 0 && bufferSet.hasListeners())			{				int untitledCount = jEdit.getNextUntitledBufferId();				Buffer newEmptyBuffer = jEdit.openTemporary(jEdit.getActiveView(), null,									    "Untitled-" + untitledCount,true, null);				jEdit.commitTemporary(newEmptyBuffer);				jEdit.getBufferSetManager().addBuffer(bufferSet, newEmptyBuffer);			}		}	
/**		 * remove a buffer from all bufferSets.		 *		 * @param buffer the buffer that must be removed		 */		public void removeBuffer(Buffer buffer)		{			for (BufferSet bufferSet : getOwners(buffer))			{				bufferSet.removeBuffer(buffer);				if (bufferSet.size() == 0 && bufferSet.hasListeners())				{					int untitledCount = jEdit.getNextUntitledBufferId();					Buffer newEmptyBuffer = jEdit.openTemporary(jEdit.getActiveView(), null,										    "Untitled-" + untitledCount,true, null);					jEdit.commitTemporary(newEmptyBuffer);					jEdit.getBufferSetManager().addBuffer(bufferSet, newEmptyBuffer);				}			}			}	
/**		 * This method will visit all buffersets.		 *		 * @param visitor the bufferset visitor		 */		public void visit(BufferSetVisitor visitor)		{			BufferSet global = jEdit.getGlobalBufferSet();			visitor.visit(jEdit.getGlobalBufferSet());			for (View view: jEdit.getViews())			{				BufferSet viewLocal = view.getLocalBufferSet();				if (viewLocal != null)				{					visitor.visit(viewLocal);				}				for (EditPane editPane: view.getEditPanes())				{					BufferSet used = editPane.getBufferSet();					if (used != global && used != viewLocal)					{						visitor.visit(used);					}				}			}		}	
/**		    @return set of BufferSets that contain buffer	        */		private Set<BufferSet> getOwners(Buffer buffer)		{			final Set<BufferSet> candidates = new HashSet<BufferSet>();			// Collect all BufferSets.			visit(new BufferSetVisitor()			{				public void visit(BufferSet bufferSet)				{					candidates.add(bufferSet);				}			});			// Remove all that doesn't contain the buffer.			Iterator<BufferSet> i = candidates.iterator();			while (i.hasNext())			{				if (i.next().indexOf(buffer) == -1)				{					i.remove();				}			}			// Remaining are the result.			return candidates;		}	
private BufferSetClosed(BufferSet closedBufferSet)			{				this.closedBufferSet = closedBufferSet;			}	
@Override			public void bufferAdded(Buffer buffer, int index)			{				Set<BufferSet> owners = getOwners(buffer);				owners.remove(closedBufferSet);				if (owners.isEmpty())				{					Log.log(Log.MESSAGE, this, "The buffer " +						buffer + " was removed from a BufferSet, closing it");					jEdit._closeBuffer(null, buffer);				}			}	
public Widget getWidget(View view)		{			Widget bufferSetWidget = new BufferSetWidget(view);			return bufferSetWidget;		}	
BufferSetWidget(final View view)			{				bufferSetLabel = new ToolTipLabel()				{					@Override					public void addNotify()					{						super.addNotify();						EditBus.addToBus(BufferSetWidget.this);					}						@Override					public void removeNotify()					{						super.removeNotify();						EditBus.removeFromBus(BufferSetWidget.this);					}				};				this.view = view;				update();				bufferSetLabel.addMouseListener(new MouseAdapter()				{					@Override					public void mouseClicked(MouseEvent evt)					{						if (evt.getClickCount() == 2)						{							EditPane editPane = view.getEditPane();							BufferSet.Scope scope = editPane.getBufferSetScope();							switch (scope)							{								case global:									scope = BufferSet.Scope.view;									break;								case view:									scope = BufferSet.Scope.editpane;									break;								case editpane:									scope = BufferSet.Scope.global;									break;							}							editPane.setBufferSetScope(scope);						}					}				});			}	
public JComponent getComponent()			{				return bufferSetLabel;			}	
public void update()			{				BufferSet.Scope scope = view.getEditPane().getBufferSetScope();				if (currentScope == null || !currentScope.equals(scope))				{					bufferSetLabel.setText(scope.toString().substring(0,1).toUpperCase());					bufferSetLabel.setToolTipText(jEdit.getProperty("view.status.bufferset-tooltip", new Object[] {scope}));					currentScope = scope;				}			}	
public void propertiesChanged()			{				// retarded GTK look and feel!				Font font = new JLabel().getFont();				//UIManager.getFont("Label.font");				FontMetrics fm = bufferSetLabel.getFontMetrics(font);				Dimension dim = new Dimension(Math.max(fm.charWidth('E'),Math.max(fm.charWidth('V'),									fm.charWidth('G'))),									fm.getHeight());				bufferSetLabel.setPreferredSize(dim);				bufferSetLabel.setMaximumSize(dim);			}	
public void handleMessage(EBMessage message)			{				if (message instanceof ViewUpdate)				{					ViewUpdate viewUpdate = (ViewUpdate) message;					if (viewUpdate.getWhat() == ViewUpdate.EDIT_PANE_CHANGED)					{						update();					}				}				else if (message instanceof EditPaneUpdate)				{					EditPaneUpdate editPaneUpdate = (EditPaneUpdate) message;					if (editPaneUpdate.getEditPane() == view.getEditPane() &&						editPaneUpdate.getWhat() == EditPaneUpdate.BUFFERSET_CHANGED)					{						update();					}				}			}	
public BufferSwitcher(final EditPane editPane)		{			this.editPane = editPane;				//setFont(new Font("Dialog",Font.BOLD,10));			setRenderer(new BufferCellRenderer());			setMaximumRowCount(jEdit.getIntegerProperty("bufferSwitcher.maxRowCount",10));			addActionListener(new ActionHandler());			addPopupMenuListener(new PopupMenuListener()			{				public void popupMenuWillBecomeVisible(					PopupMenuEvent e) {}					public void popupMenuWillBecomeInvisible(					PopupMenuEvent e)				{					editPane.getTextArea().requestFocus();				}					public void popupMenuCanceled(PopupMenuEvent e)				{					editPane.getTextArea().requestFocus();				}			});		}	
public void updateBufferList()		{			// if the buffer count becomes 0, then it is guaranteed to			// become 1 very soon, so don't do anything in that case.			BufferSet bufferSet = editPane.getBufferSet();			if(bufferSet.size() == 0)				return;				updating = true;			setMaximumRowCount(jEdit.getIntegerProperty("bufferSwitcher.maxRowCount",10));			setModel(new DefaultComboBoxModel(bufferSet.getAllBuffers()));			setSelectedItem(editPane.getBuffer());			setToolTipText(editPane.getBuffer().getPath(true));			updating = false;		}	
public void actionPerformed(ActionEvent evt)			{				if(!updating)				{					Buffer buffer = (Buffer)getSelectedItem();					if(buffer != null) 						editPane.setBuffer(buffer);				}			}	
public Component getListCellRendererComponent(				JList list, Object value, int index,				boolean isSelected, boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,index,					isSelected,cellHasFocus);				Buffer buffer = (Buffer)value;								if(buffer == null)					setIcon(null);				else				{					setIcon(buffer.getIcon());					setToolTipText(buffer.getPath());				}				return this;			}	
/**		 * Creates a new buffer update message.		 * @param buffer The buffer		 * @param what What happened		 */		public BufferUpdate(Buffer buffer, View view, Object what)		{			super(buffer);				this.view = view;				if(what == null)				throw new NullPointerException("What must be non-null");				this.what = what;		}	
/**		 * Returns what caused this buffer update.		 */		public Object getWhat()		{			return what;		}	
/**		 * Returns the buffer involved.		 */		public Buffer getBuffer()		{			return (Buffer)getSource();		}	
/**		 * Returns the view involved, which may be null.		 */		public View getView()		{			return view;		}	
public String paramString()		{			return "what=" + what + ",view=" + view + ","				+ super.paramString();		}	
/**	   * Constructs a new {@link ByteVector ByteVector} with a default initial size.	   */		  public ByteVector () {	    data = new byte[64];	  }	
/**	   * Constructs a new {@link ByteVector ByteVector} with the given initial size.	   *	   * @param initialSize the initial size of the byte vector to be constructed.	   */		  public ByteVector (final int initialSize) {	    data = new byte[initialSize];	  }	
/**	   * Puts a byte into this byte vector. The byte vector is automatically	   * enlarged if necessary.	   *	   * @param b a byte.	   * @return this byte vector.	   */		  public ByteVector put1 (final int b) {	    int length = this.length;	    if (length + 1 > data.length) {	      enlarge(1);	    }	    data[length++] = (byte)b;	    this.length = length;	    return this;	  }	
/**	   * Puts two bytes into this byte vector. The byte vector is automatically	   * enlarged if necessary.	   *	   * @param b1 a byte.	   * @param b2 another byte.	   * @return this byte vector.	   */		  public ByteVector put11 (final int b1, final int b2) {	    int length = this.length;	    if (length + 2 > data.length) {	      enlarge(2);	    }	    byte[] data = this.data;	    data[length++] = (byte)b1;	    data[length++] = (byte)b2;	    this.length = length;	    return this;	  }	
/**	   * Puts a short into this byte vector. The byte vector is automatically	   * enlarged if necessary.	   *	   * @param s a short.	   * @return this byte vector.	   */		  public ByteVector put2 (final int s) {	    int length = this.length;	    if (length + 2 > data.length) {	      enlarge(2);	    }	    byte[] data = this.data;	    data[length++] = (byte)(s >>> 8);	    data[length++] = (byte)s;	    this.length = length;	    return this;	  }	
/**	   * Puts a byte and a short into this byte vector. The byte vector is	   * automatically enlarged if necessary.	   *	   * @param b a byte.	   * @param s a short.	   * @return this byte vector.	   */		  public ByteVector put12 (final int b, final int s) {	    int length = this.length;	    if (length + 3 > data.length) {	      enlarge(3);	    }	    byte[] data = this.data;	    data[length++] = (byte)b;	    data[length++] = (byte)(s >>> 8);	    data[length++] = (byte)s;	    this.length = length;	    return this;	  }	
/**	   * Puts an int into this byte vector. The byte vector is automatically	   * enlarged if necessary.	   *	   * @param i an int.	   * @return this byte vector.	   */		  public ByteVector put4 (final int i) {	    int length = this.length;	    if (length + 4 > data.length) {	      enlarge(4);	    }	    byte[] data = this.data;	    data[length++] = (byte)(i >>> 24);	    data[length++] = (byte)(i >>> 16);	    data[length++] = (byte)(i >>> 8);	    data[length++] = (byte)i;	    this.length = length;	    return this;	  }	
/**	   * Puts a long into this byte vector. The byte vector is automatically	   * enlarged if necessary.	   *	   * @param l a long.	   * @return this byte vector.	   */		  public ByteVector put8 (final long l) {	    int length = this.length;	    if (length + 8 > data.length) {	      enlarge(8);	    }	    byte[] data = this.data;	    int i = (int)(l >>> 32);	    data[length++] = (byte)(i >>> 24);	    data[length++] = (byte)(i >>> 16);	    data[length++] = (byte)(i >>> 8);	    data[length++] = (byte)i;	    i = (int)l;	    data[length++] = (byte)(i >>> 24);	    data[length++] = (byte)(i >>> 16);	    data[length++] = (byte)(i >>> 8);	    data[length++] = (byte)i;	    this.length = length;	    return this;	  }	
/**	   * Puts a String in UTF format into this byte vector. The byte vector is	   * automatically enlarged if necessary.	   *	   * @param s a String.	   * @return this byte vector.	   */		  public ByteVector putUTF (final String s) {	    int charLength = s.length();	    int byteLength = 0;	    for (int i = 0; i < charLength; ++i) {	      char c = s.charAt(i);	      if (c >= '\001' && c <= '\177') {	        byteLength++;	      } else if (c > '\u07FF') {	        byteLength += 3;	      } else {	        byteLength += 2;	      }	    }	    if (byteLength > 65535) {	      throw new IllegalArgumentException();	    }	    int length = this.length;	    if (length + 2 + byteLength > data.length) {	      enlarge(2 + byteLength);	    }	    byte[] data = this.data;	    data[length++] = (byte)(byteLength >>> 8);	    data[length++] = (byte)(byteLength);	    for (int i = 0; i < charLength; ++i) {	      char c = s.charAt(i);	      if (c >= '\001' && c <= '\177') {	        data[length++] = (byte)c;	      } else if (c > '\u07FF') {	        data[length++] = (byte)(0xE0 | c >> 12 & 0xF);	        data[length++] = (byte)(0x80 | c >> 6 & 0x3F);	        data[length++] = (byte)(0x80 | c & 0x3F);	      } else {	        data[length++] = (byte)(0xC0 | c >> 6 & 0x1F);	        data[length++] = (byte)(0x80 | c & 0x3F);	      }	    }	    this.length = length;	    return this;	  }	
/**	   * Puts an array of bytes into this byte vector. The byte vector is	   * automatically enlarged if necessary.	   *	   * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt> null	   *      bytes into this byte vector.	   * @param off index of the fist byte of b that must be copied.	   * @param len number of bytes of b that must be copied.	   * @return this byte vector.	   */		  public ByteVector putByteArray (	    final byte[] b,	    final int off,	    final int len)	  {	    if (length + len > data.length) {	      enlarge(len);	    }	    if (b != null) {	      System.arraycopy(b, off, data, length, len);	    }	    length += len;	    return this;	  }	
/**	   * Enlarge this byte vector so that it can receive n more bytes.	   *	   * @param size number of additional bytes that this byte vector should be	   *      able to receive.	   */		  private void enlarge (final int size) {	    byte[] newData = new byte[Math.max(2*data.length, length + size)];	    System.arraycopy(data, 0, newData, 0, length);	    data = newData;	  }	
public CallStack() { }	
public CallStack( NameSpace namespace ) { 			push( namespace );		}	
public void clear() {			stack.removeAllElements();		}	
public void push( NameSpace ns ) {			stack.insertElementAt( ns, 0 );		}	
public NameSpace top() {			return get(0);		}	
/**			zero based.		*/		public NameSpace get(int depth) {			if ( depth >= depth() )				return NameSpace.JAVACODE;			else				return (NameSpace)(stack.elementAt(depth));		}	
/**			This is kind of crazy, but used by the setNameSpace command.			zero based.		*/		public void set(int depth, NameSpace ns) {			stack.setElementAt(ns, depth );		}	
public NameSpace pop() {			if ( depth() < 1 )				throw new InterpreterError("pop on empty CallStack");			NameSpace top = top();			stack.removeElementAt(0);			return top;		}	
/**			Swap in the value as the new top of the stack and return the old			value.		*/		public NameSpace swap( NameSpace newTop ) {			NameSpace oldTop = (NameSpace)(stack.elementAt(0));			stack.setElementAt( newTop, 0 );			return oldTop;		}	
public int depth() {			return stack.size();		}	
public NameSpace [] toArray() {			NameSpace [] nsa = new NameSpace [ depth() ];			stack.copyInto( nsa );			return nsa;		}	
public String toString() {			StringBuilder sb = new StringBuilder();			sb.append("CallStack:\n");			NameSpace [] nsa = toArray();			for(int i=0; i<nsa.length; i++)				sb.append("\t"+nsa[i]+"\n");				return sb.toString();		}	
/**			Occasionally we need to freeze the callstack for error reporting			purposes, etc.		*/		@SuppressWarnings("unchecked")		public CallStack copy() {			CallStack cs = new CallStack();			cs.stack = (Vector<NameSpace>) stack.clone();			return cs;		}	
public static boolean haveSwing() {			// classExists caches info for us			return classExists( "javax.swing.JButton" );		}	
public static boolean canGenerateInterfaces() {			// classExists caches info for us			return classExists( "java.lang.reflect.Proxy" );		}	
/**			If accessibility is enabled			determine if the accessibility mechanism exists and if we have			the optional bsh package to use it.			Note that even if both are true it does not necessarily mean that we 			have runtime permission to access the fields... Java security has		 	a say in it.			@see org.gjt.sp.jedit.bsh.ReflectManager		*/		public static boolean haveAccessibility() 		{			return accessibility;		}	
public static void setAccessibility( boolean b ) 			throws Unavailable		{ 			if ( b == false )			{				accessibility = false;				return;			}				if ( !classExists( "java.lang.reflect.AccessibleObject" )				|| !classExists("org.gjt.sp.jedit.bsh.reflect.ReflectManagerImpl")  			)				throw new Unavailable( "Accessibility unavailable" );				// test basic access			try {				String.class.getDeclaredMethods();			} catch ( SecurityException e ) {				throw new Unavailable("Accessibility unavailable: "+e);			}				accessibility = true; 		}	
/**			Use direct Class.forName() to test for the existence of a class.			We should not use BshClassManager here because:				a) the systems using these tests would probably not load the				classes through it anyway.				b) bshclassmanager is heavy and touches other class files.  				this capabilities code must be light enough to be used by any				system **including the remote applet**.		*/		public static boolean classExists( String name ) 		{			Object c = classes.get( name );				if ( c == null ) {				try {					/*						Note: do *not* change this to 						BshClassManager plainClassForName() or equivalent.						This class must not touch any other bsh classes.					*/					c = Class.forName( name );				} catch ( ClassNotFoundException e ) { }					if ( c != null )					classes.put(c,"unused");			}				return c != null;		}	
public Unavailable(String s ){ super(s); }	
public CharsetEncoding(String name)		{			body = Charset.forName(name);		}	
public Reader getTextReader(InputStream in) throws IOException		{			// Pass the decoder explicitly to report a decode error			// as an exception instead of replacing with "\uFFFD".			// The form "InputStreamReader(in, encoding)" seemed to use			// CodingErrorAction.REPLACE internally.			return new InputStreamReader(in, body.newDecoder());		}	
public Writer getTextWriter(OutputStream out) throws IOException		{			// Pass the encoder explicitly because of same reason			// in getTextReader();			return new OutputStreamWriter(out, body.newEncoder());		}	
public Reader getPermissiveTextReader(InputStream in) throws IOException		{			// Use REPLACE action to indicate where the coding error			// happened by the replacement character "\uFFFD".			CharsetDecoder permissive = body.newDecoder();			permissive.onMalformedInput(CodingErrorAction.REPLACE);			permissive.onUnmappableCharacter(CodingErrorAction.REPLACE);			return new InputStreamReader(in, permissive);		}	
/**		 * Paints a chunk list.		 * @param chunks The chunk list		 * @param gfx The graphics context		 * @param x The x co-ordinate		 * @param y The y co-ordinate		 * @param glyphVector true if we want to use glyphVector, false if we		 * want to use drawString		 * @return The width of the painted text		 * @since jEdit 4.2pre1		 */		public static float paintChunkList(Chunk chunks,			Graphics2D gfx, float x, float y, boolean glyphVector)		{			Rectangle clipRect = gfx.getClipBounds();				float _x = 0.0f;				while(chunks != null)			{				// only paint visible chunks				if(x + _x + chunks.width > clipRect.x					&& x + _x < clipRect.x + clipRect.width)				{					// Useful for debugging purposes					if(Debug.CHUNK_PAINT_DEBUG)					{						gfx.draw(new Rectangle2D.Float(x + _x,y - 10,							chunks.width,10));					}						if(chunks.accessable && chunks.visible)					{						gfx.setFont(chunks.style.getFont());						gfx.setColor(chunks.style.getForegroundColor());							if(glyphVector && chunks.gv != null)							gfx.drawGlyphVector(chunks.gv,x + _x,y);						else if(chunks.str != null)						{							gfx.drawString(chunks.str,								(int)(x + _x),(int)y);						}					}				}					_x += chunks.width;				chunks = (Chunk)chunks.next;			}				return _x;		}	
/**		 * Paints the background highlights of a chunk list.		 * @param chunks The chunk list		 * @param gfx The graphics context		 * @param x The x co-ordinate		 * @param y The y co-ordinate		 * @return The width of the painted backgrounds		 * @since jEdit 4.2pre1		 */		public static float paintChunkBackgrounds(Chunk chunks,			Graphics2D gfx, float x, float y)		{			Rectangle clipRect = gfx.getClipBounds();				float _x = 0.0f;				FontMetrics forBackground = gfx.getFontMetrics();				int ascent = forBackground.getAscent();			int height = forBackground.getHeight();				while(chunks != null)			{				// only paint visible chunks				if(x + _x + chunks.width > clipRect.x					&& x + _x < clipRect.x + clipRect.width)				{					if(chunks.accessable)					{						//{{{ Paint token background color if necessary						Color bgColor = chunks.background;						if(bgColor != null)						{							gfx.setColor(bgColor);								gfx.fill(new Rectangle2D.Float(								x + _x,y - ascent,								_x + chunks.width - _x,								height));						} //}}}					}				}					_x += chunks.width;				chunks = (Chunk)chunks.next;			}				return _x;		}	
/**		 * Converts an offset in a chunk list into an x co-ordinate.		 * @param chunks The chunk list		 * @param offset The offset		 * @since jEdit 4.1pre1		 */		public static float offsetToX(Chunk chunks, int offset)		{			if(chunks != null && offset < chunks.offset)			{				throw new ArrayIndexOutOfBoundsException(offset + " < "					+ chunks.offset);			}				float x = 0.0f;				while(chunks != null)			{				if(chunks.accessable && offset < chunks.offset + chunks.length)					return x + chunks.offsetToX(offset - chunks.offset);					x += chunks.width;				chunks = (Chunk)chunks.next;			}				return x;		}	
/**		 * Converts an x co-ordinate in a chunk list into an offset.		 * @param chunks The chunk list		 * @param x The x co-ordinate		 * @param round Round up to next letter if past the middle of a letter?		 * @return The offset within the line, or -1 if the x co-ordinate is too		 * far to the right		 * @since jEdit 4.1pre1		 */		public static int xToOffset(Chunk chunks, float x, boolean round)		{			float _x = 0.0f;				while(chunks != null)			{				if(chunks.accessable && x < _x + chunks.width)					return chunks.xToOffset(x - _x,round);					_x += chunks.width;				chunks = (Chunk)chunks.next;			}				return -1;		}	
public Chunk(float width, int offset, ParserRuleSet rules)		{			super(Token.NULL,offset,0,rules);			this.width = width;		}	
public Chunk(byte id, int offset, int length, ParserRuleSet rules,			SyntaxStyle[] styles, byte defaultID)		{			super(id,offset,length,rules);			accessable = true;			style = styles[id];			background = style.getBackgroundColor();			if(background == null)				background = styles[defaultID].getBackgroundColor();		}	
public final float[] getPositions()		{			if(gv == null)				return null;				if(positions == null)				positions = gv.getGlyphPositions(0,length,null);				return positions;		}	
public final float offsetToX(int offset)		{			if(!visible)				return 0.0f;			else				return getPositions()[offset * 2];		}	
public final int xToOffset(float x, boolean round)		{			if (!visible)			{				if (round && width - x < x)					return offset + length;				else					return offset;			}						float[] pos = getPositions();				for(int i = 0; i < length; i++)			{				float glyphX = pos[i*2];				float nextX = (i == length - 1					? width : pos[i*2+2]);					if(nextX > x)				{					if(!round || nextX - x > x - glyphX)						return offset + i;					else						return offset + i + 1;				}			}				// wtf?			return -1;		}	
public void init(Segment seg, TabExpander expander, float x,			FontRenderContext fontRenderContext)		{			initialized = true;				if(!accessable)			{				// do nothing			}			else if(length == 1 && seg.array[seg.offset + offset] == '\t')			{				visible = false;				float newX = expander.nextTabStop(x,offset + length);				width = newX - x;			}			else			{				visible = true;					str = new String(seg.array,seg.offset + offset,length);					char[] textArray = seg.array;				int textStart = seg.offset + offset;				// {{{ Workaround for a bug in Sun Java 5				// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6266084				if (SUN_JAVA_5)				{					// textLimit is used as a text count in					// layoutGlyphVector(). So it works only the					// case textStart is 0.					char[] copy = new char[length];					System.arraycopy(textArray, textStart,						copy, 0, length);					textArray = copy;					textStart = 0;				} //}}}				int textLimit = textStart + length;				// FIXME: Need BiDi support.				int layoutFlags = Font.LAYOUT_LEFT_TO_RIGHT					| Font.LAYOUT_NO_START_CONTEXT					| Font.LAYOUT_NO_LIMIT_CONTEXT;				gv = style.getFont().layoutGlyphVector(					fontRenderContext,					textArray, textStart, textLimit, layoutFlags);				Rectangle2D logicalBounds = gv.getLogicalBounds();					width = (float)logicalBounds.getWidth();			}		}	
ChunkCache(TextArea textArea)		{			this.textArea = textArea;			out = new ArrayList<Chunk>();			tokenHandler = new DisplayTokenHandler();		}	
/**		 * Returns the max line width of the textarea.		 * It will check all lines the first invalid line.		 *		 * @return the max line width		 */		int getMaxHorizontalScrollWidth()		{			int max = 0;			for(int i = 0; i < firstInvalidLine; i++)			{				LineInfo info = lineInfo[i];				if(info.width > max)					max = info.width;			}			return max;		}	
/**		 * @param line physical line number of document 		 * @param offset number of characters from the left of the line. 		 * @return returns the screen line number where the line and offset are.		 * It returns -1 if this position is not currently visible		 */		int getScreenLineOfOffset(int line, int offset)		{			if(lineInfo.length == 0)				return -1;			if(line < textArea.getFirstPhysicalLine())				return -1;			if(line == textArea.getFirstPhysicalLine()				&& offset < getLineInfo(0).offset)				return -1;			if(line > textArea.getLastPhysicalLine())				return -1;						if(line == lastScreenLineP)			{				LineInfo last = getLineInfo(lastScreenLine);					if(offset >= last.offset					&& offset < last.offset + last.length)				{					return lastScreenLine;				}			}				int screenLine = -1;				// Find the screen line containing this offset			for(int i = 0; i < textArea.getVisibleLines(); i++)			{				LineInfo info = getLineInfo(i);				if(info.physicalLine > line)				{					// line is invisible?					return i - 1;					//return -1;				}				if(info.physicalLine == line)				{					if(offset >= info.offset						&& offset < info.offset + info.length)					{						screenLine = i;						break;					}				}			}				if(screenLine == -1)				return -1;					lastScreenLineP = line;			lastScreenLine = screenLine;				return screenLine;		}	
/**		 * Recalculate visible lines.		 * This is called when the TextArea geometry is changed or when the font is changed.		 */		void recalculateVisibleLines()		{			LineInfo[] newLineInfo = new LineInfo[textArea.getVisibleLines()];				int start;			if(lineInfo == null)				start = 0;			else			{				start = Math.min(lineInfo.length,newLineInfo.length);				System.arraycopy(lineInfo,0,newLineInfo,0,start);			}				for(int i = start; i < newLineInfo.length; i++)				newLineInfo[i] = new LineInfo();				lineInfo = newLineInfo;				lastScreenLine = lastScreenLineP = -1;		}	
void setBuffer(JEditBuffer buffer)		{			this.buffer = buffer;			lastScreenLine = lastScreenLineP = -1;		}	
void scrollDown(int amount)		{			int visibleLines = textArea.getVisibleLines();				System.arraycopy(lineInfo,amount,lineInfo,0,visibleLines - amount);				for(int i = visibleLines - amount; i < visibleLines; i++)			{				lineInfo[i] = new LineInfo();			}				firstInvalidLine -= amount;			if(firstInvalidLine < 0)				firstInvalidLine = 0;				if(Debug.CHUNK_CACHE_DEBUG)			{				System.err.println("f > t.f: only " + amount					+ " need updates");			}				lastScreenLine = lastScreenLineP = -1;		}	
void scrollUp(int amount)		{			System.arraycopy(lineInfo,0,lineInfo,amount,				textArea.getVisibleLines() - amount);				for(int i = 0; i < amount; i++)			{				lineInfo[i] = new LineInfo();			}				// don't try this at home			int oldFirstInvalidLine = firstInvalidLine;			firstInvalidLine = 0;			updateChunksUpTo(amount);			firstInvalidLine = oldFirstInvalidLine + amount;			if(firstInvalidLine > textArea.getVisibleLines())				firstInvalidLine = textArea.getVisibleLines();				if(Debug.CHUNK_CACHE_DEBUG)			{				Log.log(Log.DEBUG,this,"f > t.f: only " + amount					+ " need updates");			}				lastScreenLine = lastScreenLineP = -1;		}	
void invalidateAll()		{			firstInvalidLine = 0;			lastScreenLine = lastScreenLineP = -1;		}	
void invalidateChunksFromPhys(int physicalLine)		{			for(int i = 0; i < firstInvalidLine; i++)			{				LineInfo info = lineInfo[i];				if(info.physicalLine == -1 || info.physicalLine >= physicalLine)				{					firstInvalidLine = i;					if(i <= lastScreenLine)						lastScreenLine = lastScreenLineP = -1;					break;				}			}		}	
/**		 * Returns the line informations for a given screen line		 * @param screenLine the screen line		 * @return the LineInfo for the screenLine		 */		LineInfo getLineInfo(int screenLine)		{			updateChunksUpTo(screenLine);			return lineInfo[screenLine];		}	
/**		 * Returns the number of subregions of a physical line		 * @param physicalLine a physical line		 * @return the number of subregions of this physical line		 */		int getLineSubregionCount(int physicalLine)		{			if(!textArea.softWrap)				return 1;				out.clear();			lineToChunkList(physicalLine,out);				int size = out.size();			if(size == 0)				return 1;			else				return size;		}	
/**		 * Returns the subregion containing the specified offset. A subregion		 * is a subset of a physical line. Each screen line corresponds to one		 * subregion. Unlike the {@link #getScreenLineOfOffset(int, int)} method,		 * this method works with non-visible lines too.		 *		 * @param offset the offset		 * @param lineInfos a lineInfos array. Usualy the array is the result of		 *	{@link #getLineInfosForPhysicalLine(int)} call		 *		 * @return the subregion of the offset, or -1 if the offset was not in one of the given lineInfos		 */		static int getSubregionOfOffset(int offset, LineInfo[] lineInfos)		{			for(int i = 0; i < lineInfos.length; i++)			{				LineInfo info = lineInfos[i];				if(offset >= info.offset && offset < info.offset + info.length)					return i;			}				return -1;		}	
/**		 * Converts an x co-ordinate within a subregion into an offset from the		 * start of that subregion.		 * @param physicalLine The physical line number		 * @param subregion The subregion; if -1, then this is the last		 * subregion.		 * @param x The x co-ordinate		 * @param round Round up to next character if x is past the middle of a		 * character?		 * @return the offset from the start of the subregion		 */		int xToSubregionOffset(int physicalLine, int subregion, int x,			boolean round)		{			LineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);			if(subregion == -1)				subregion += infos.length;			return xToSubregionOffset(infos[subregion],x,round);		}	
/**		 * Converts an x co-ordinate within a subregion into an offset from the		 * start of that subregion.		 * @param info The line info object		 * @param x The x co-ordinate		 * @param round Round up to next character if x is past the middle of a		 * character?		 * @return the offset from the start of the subregion		 */		static int xToSubregionOffset(LineInfo info, int x,			boolean round)		{			int offset = Chunk.xToOffset(info.chunks,x,round);			if(offset == -1 || offset == info.offset + info.length)				offset = info.offset + info.length - 1;				return offset;		}	
/**		 * Converts an offset within a subregion into an x co-ordinate.		 * @param physicalLine The physical line		 * @param offset The offset		 * @return the x co-ordinate of the offset within a subregion		 */		int subregionOffsetToX(int physicalLine, int offset)		{			LineInfo[] infos = getLineInfosForPhysicalLine(physicalLine);			LineInfo info = infos[getSubregionOfOffset(offset,infos)];			return subregionOffsetToX(info,offset);		}	
/**		 * Converts an offset within a subregion into an x co-ordinate.		 * @param info The line info object		 * @param offset The offset		 * @return the x co-ordinate of the offset within a subregion		 */		static int subregionOffsetToX(LineInfo info, int offset)		{			return (int)Chunk.offsetToX(info.chunks,offset);		}	
/**		 * Returns the start offset of the specified subregion of the specified		 * physical line.		 * @param line The physical line number		 * @param offset An offset		 * @return the start offset of the subregion of the line		 */		int getSubregionStartOffset(int line, int offset)		{			LineInfo[] lineInfos = getLineInfosForPhysicalLine(line);			LineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];			return textArea.getLineStartOffset(info.physicalLine)				+ info.offset;		}	
/**		 * Returns the end offset of the specified subregion of the specified		 * physical line.		 * @param line The physical line number		 * @param offset An offset		 * @return the end offset of the subregion of the line		 */		int getSubregionEndOffset(int line, int offset)		{			LineInfo[] lineInfos = getLineInfosForPhysicalLine(line);			LineInfo info = lineInfos[getSubregionOfOffset(offset,lineInfos)];			return textArea.getLineStartOffset(info.physicalLine)				+ info.offset + info.length;		}	
/**		 * @param physicalLine The physical line number		 * @param offset The offset		 * @param x The location		 * @param ignoreWrap If true, behave as if soft wrap is off even if it		 * is on		 */		int getBelowPosition(int physicalLine, int offset, int x,			boolean ignoreWrap)		{			LineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);				int subregion = getSubregionOfOffset(offset,lineInfos);				if(subregion != lineInfos.length - 1 && !ignoreWrap)			{				return textArea.getLineStartOffset(physicalLine)					+ xToSubregionOffset(lineInfos[subregion + 1],					x,true);			}			else			{				int nextLine = textArea.displayManager					.getNextVisibleLine(physicalLine);					if(nextLine == -1)					return -1;				else				{					return textArea.getLineStartOffset(nextLine)						+ xToSubregionOffset(nextLine,0,						x,true);				}			}		}	
/**		 * @param physicalLine The physical line number		 * @param offset The offset		 * @param x The location		 * @param ignoreWrap If true, behave as if soft wrap is off even if it		 * is on		 */		int getAbovePosition(int physicalLine, int offset, int x,			boolean ignoreWrap)		{			LineInfo[] lineInfos = getLineInfosForPhysicalLine(physicalLine);				int subregion = getSubregionOfOffset(offset,lineInfos);				if(subregion != 0 && !ignoreWrap)			{				return textArea.getLineStartOffset(physicalLine)					+ xToSubregionOffset(lineInfos[subregion - 1],					x,true);			}			else			{				int prevLine = textArea.displayManager					.getPrevVisibleLine(physicalLine);					if(prevLine == -1)					return -1;				else				{					return textArea.getLineStartOffset(prevLine)						+ xToSubregionOffset(prevLine,-1,						x,true);				}			}		}	
/**		 * The needFullRepaint variable becomes true when the number of screen		 * lines in a physical line changes.		 * @return true if the TextArea needs full repaint		 */		boolean needFullRepaint()		{			boolean retVal = needFullRepaint;			needFullRepaint = false;			return retVal;		}	
LineInfo[] getLineInfosForPhysicalLine(int physicalLine)		{			out.clear();				if(!buffer.isLoading())				lineToChunkList(physicalLine,out);				if(out.isEmpty())				out.add(null);				List<LineInfo> returnValue = new ArrayList<LineInfo>(out.size());			getLineInfosForPhysicalLine(physicalLine,returnValue);			return returnValue.toArray(new LineInfo[out.size()]);		}	
private void getLineInfosForPhysicalLine(int physicalLine, List<LineInfo> list)		{			for(int i = 0; i < out.size(); i++)			{				Chunk chunks = out.get(i);				LineInfo info = new LineInfo();				info.physicalLine = physicalLine;				if(i == 0)				{					info.firstSubregion = true;					info.offset = 0;				}				else					info.offset = chunks.offset;					if(i == out.size() - 1)				{					info.lastSubregion = true;					info.length = textArea.getLineLength(physicalLine)						- info.offset + 1;				}				else				{					info.length = out.get(i + 1).offset						- info.offset;				}					info.chunks = chunks;					list.add(info);			}		}	
/**		 * Find a valid line closest to the last screen line.		 */		private int getFirstScreenLine()		{			for(int i = firstInvalidLine - 1; i >= 0; i--)			{				if(lineInfo[i].lastSubregion)					return i + 1;			}				return 0;		}	
/**		 * Return a physical line number.		 */		private int getUpdateStartLine(int firstScreenLine)		{			// for the first line displayed, take its physical line to be			// the text area's first physical line			if(firstScreenLine == 0)			{				return textArea.getFirstPhysicalLine();			}			// otherwise, determine the next visible line			else			{				int prevPhysLine = lineInfo[					firstScreenLine - 1]					.physicalLine;				// if -1, the empty space at the end of the text area				// when the buffer has less lines than are visible				if(prevPhysLine == -1)					return -1;				else				{					return textArea.displayManager						.getNextVisibleLine(prevPhysLine);				}			}		}	
private void updateChunksUpTo(int lastScreenLine)		{			// this method is a nightmare			if(lastScreenLine >= lineInfo.length)				throw new ArrayIndexOutOfBoundsException(lastScreenLine);				// if one line's chunks are invalid, remaining lines are also			// invalid			if(lastScreenLine < firstInvalidLine)				return;				int firstScreenLine = getFirstScreenLine();			int physicalLine = getUpdateStartLine(firstScreenLine);				if(Debug.CHUNK_CACHE_DEBUG)			{				Log.log(Log.DEBUG,this,"Updating chunks from " + firstScreenLine					+ " to " + lastScreenLine);			}				// Note that we rely on the fact that when a physical line is			// invalidated, all screen lines/subregions of that line are			// invalidated as well. See below comment for code that tries			// to uphold this assumption.				out.clear();				int offset;			int length;				for(int i = firstScreenLine; i <= lastScreenLine; i++)			{				LineInfo info = lineInfo[i];					Chunk chunks;					// get another line of chunks				if(out.isEmpty())				{					// unless this is the first time, increment					// the line number					if(physicalLine != -1 && i != firstScreenLine)					{						physicalLine = textArea.displayManager							.getNextVisibleLine(physicalLine);					}						// empty space					if(physicalLine == -1)					{						info.chunks = null;						info.physicalLine = -1;						// fix the bug where the horiz.						// scroll bar was not updated						// after creating a new file.						info.width = 0;						continue;					}						// chunk the line.					lineToChunkList(physicalLine,out);						info.firstSubregion = true;						// if the line has no text, out.size() == 0					if(out.isEmpty())					{						if(i == 0)						{							if(textArea.displayManager.firstLine.skew > 0)							{								Log.log(Log.ERROR,this,"BUG: skew=" + textArea.displayManager.firstLine.skew + ",out.size()=" + out.size());								textArea.displayManager.firstLine.skew = 0;								needFullRepaint = true;								lastScreenLine = lineInfo.length - 1;							}						}						chunks = null;						offset = 0;						length = 1;					}					// otherwise, the number of subregions					else					{						if(i == 0)						{							int skew = textArea.displayManager.firstLine.skew;							if(skew >= out.size())							{								// The skew cannot be greater than the chunk count of the line								// we need at least one chunk per subregion in a line 								Log.log(Log.ERROR,this,"BUG: skew=" + skew + ",out.size()=" + out.size());								needFullRepaint = true;								lastScreenLine = lineInfo.length - 1;							}							else if(skew > 0)							{								info.firstSubregion = false;								for(int j = 0; j < skew; j++)									out.remove(0);							}						}						chunks = out.remove(0);						offset = chunks.offset;						if (!out.isEmpty())							length = out.get(0).offset - offset;						else							length = textArea.getLineLength(physicalLine) - offset + 1;					}				}				else				{					info.firstSubregion = false;						chunks = out.remove(0);					offset = chunks.offset;					if (!out.isEmpty())						length = out.get(0).offset - offset;					else						length = textArea.getLineLength(physicalLine) - offset + 1;				}					boolean lastSubregion = out.isEmpty();					if(i == lastScreenLine					&& lastScreenLine != lineInfo.length - 1)				{					/* if the user changes the syntax token at the					 * end of a line, need to do a full repaint. */					if(tokenHandler.getLineContext() !=						info.lineContext)					{						lastScreenLine++;						needFullRepaint = true;					}					/* If this line has become longer or shorter					 * (in which case the new physical line number					 * is different from the cached one) we need to:					 * - continue updating past the last line					 * - advise the text area to repaint					 * On the other hand, if the line wraps beyond					 * lastScreenLine, we need to keep updating the					 * chunk list to ensure proper alignment of					 * invalidation flags (see start of method) */					else if(info.physicalLine != physicalLine						|| info.lastSubregion != lastSubregion)					{						lastScreenLine++;						needFullRepaint = true;					}					/* We only cache entire physical lines at once;					 * don't want to split a physical line into					 * screen lines and only have some valid. */					else if (!out.isEmpty())						lastScreenLine++;				}					info.physicalLine = physicalLine;				info.lastSubregion = lastSubregion;				info.offset = offset;				info.length = length;				info.chunks = chunks;				info.lineContext = tokenHandler.getLineContext();			}				firstInvalidLine = Math.max(lastScreenLine + 1,firstInvalidLine);		}	
private void lineToChunkList(int physicalLine, List<Chunk> out)		{			TextAreaPainter painter = textArea.getPainter();				tokenHandler.init(painter.getStyles(),				painter.getFontRenderContext(),				painter,out,				textArea.softWrap				? textArea.wrapMargin : 0.0f);			buffer.markTokens(physicalLine,tokenHandler);		}	
@Override			public String toString()			{				return "LineInfo[" + physicalLine + ',' + offset + ','				       + length + ',' + firstSubregion + ',' +				       lastSubregion + "]";			}	
@Override		protected void paintFoldShape(Graphics2D gfx, int top, int bottom)		{			gfx.drawArc(1,top,8,(bottom - top),0,360);		}	
public static ClassGenerator getClassGenerator() 			throws UtilEvalError		{			if ( cg == null ) 			{				try {					Class clas = Class.forName( "org.gjt.sp.jedit.bsh.ClassGeneratorImpl" );					cg = (ClassGenerator)clas.newInstance();				} catch ( Exception e ) {					throw new Unavailable("ClassGenerator unavailable: "+e);				}			}					return cg;		}	
public Class generateClass( 			String name, Modifiers modifiers, 			Class [] interfaces, Class superClass, BSHBlock block, 			boolean isInterface, CallStack callstack, Interpreter interpreter 		)			throws EvalError		{			// Delegate to the static method			return generateClassImpl( name, modifiers, interfaces, superClass,				block, isInterface, callstack, interpreter );		}	
public Object invokeSuperclassMethod(			BshClassManager bcm, Object instance, String methodName, Object [] args		)	        throws UtilEvalError, ReflectError, InvocationTargetException		{			// Delegate to the static method			return invokeSuperclassMethodImpl( bcm, instance, methodName, args );		}	
/**			Change the parent of the class instance namespace.			This is currently used for inner class support.			Note: This method will likely be removed in the future.		*/		// This could be static		public void setInstanceNameSpaceParent( 			Object instance, String className, NameSpace parent )		{			This ithis = 				ClassGeneratorUtil.getClassInstanceThis( instance, className );			ithis.getNameSpace().setParent( parent );		}	
/**			Parse the BSHBlock for for the class definition and generate the class			using ClassGenerator.		*/		public static Class generateClassImpl( 			String name, Modifiers modifiers, 			Class [] interfaces, Class superClass, BSHBlock block, 			boolean isInterface, CallStack callstack, Interpreter interpreter 		)			throws EvalError		{			// Scripting classes currently requires accessibility			// This can be eliminated with a bit more work.			try {				Capabilities.setAccessibility( true );			} catch ( Capabilities.Unavailable e )			{				throw new EvalError( 					"Defining classes currently requires reflective Accessibility.",					block, callstack );			}				NameSpace enclosingNameSpace = callstack.top();			String packageName = enclosingNameSpace.getPackage();			String className =  enclosingNameSpace.isClass ?  				( enclosingNameSpace.getName()+"$"+name ) : name;			String fqClassName = 				packageName == null ? className : packageName + "." + className;				BshClassManager bcm = interpreter.getClassManager();			// Race condition here...			bcm.definingClass( fqClassName );				// Create the class static namespace			NameSpace classStaticNameSpace = 				new NameSpace( enclosingNameSpace, className);			classStaticNameSpace.isClass = true;				callstack.push( classStaticNameSpace );				// Evaluate any inner class class definitions in the block 			// effectively recursively call this method for contained classes first			block.evalBlock( 				callstack, interpreter, true/*override*/, 				ClassNodeFilter.CLASSCLASSES );				// Generate the type for our class			Variable [] variables = 				getDeclaredVariables( block, callstack, interpreter, packageName );			DelayedEvalBshMethod [] methods =				getDeclaredMethods( block, callstack, interpreter, packageName );				ClassGeneratorUtil classGenerator = new ClassGeneratorUtil( 				modifiers, className, packageName, superClass, interfaces, 				variables, methods, classStaticNameSpace, isInterface );			byte [] code = classGenerator.generateClass();				// if debug, write out the class file to debugClasses directory			String dir = System.getProperty("debugClasses");			if ( dir != null )			try {				FileOutputStream out= 					new FileOutputStream( dir+"/"+className+".class" );				out.write(code);				out.close();			} catch ( IOException e ) { }				// Define the new class in the classloader			Class genClass = bcm.defineClass( fqClassName, code );				// import the unq name into parent			enclosingNameSpace.importClass( fqClassName.replace('$','.') );				try {				classStaticNameSpace.setLocalVariable( 					ClassGeneratorUtil.BSHINIT, block, false/*strictJava*/ );			} catch ( UtilEvalError e ) {				throw new InterpreterError("unable to init static: "+e );			}				// Give the static space its class static import			// important to do this after all classes are defined			classStaticNameSpace.setClassStatic( genClass );				// evaluate the static portion of the block in the static space			block.evalBlock( 				callstack, interpreter, true/*override*/, 				ClassNodeFilter.CLASSSTATIC );				callstack.pop();				if ( !genClass.isInterface() )			{			// Set the static bsh This callback 			String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC+className;			try {				LHS lhs = Reflect.getLHSStaticField( genClass, bshStaticFieldName );				lhs.assign( 					classStaticNameSpace.getThis( interpreter ), false/*strict*/ );			} catch ( Exception e ) {				throw new InterpreterError("Error in class gen setup: "+e );			}			}				bcm.doneDefiningClass( fqClassName );			return genClass;		}	
static Variable [] getDeclaredVariables( 			BSHBlock body, CallStack callstack, Interpreter interpreter, 			String defaultPackage 		) 		{			List vars = new ArrayList();			for( int child=0; child<body.jjtGetNumChildren(); child++ )			{				SimpleNode node = (SimpleNode)body.jjtGetChild(child);				if ( node instanceof BSHTypedVariableDeclaration )				{					BSHTypedVariableDeclaration tvd = 						(BSHTypedVariableDeclaration)node;					Modifiers modifiers = tvd.modifiers;						String type = tvd.getTypeDescriptor( 						callstack, interpreter, defaultPackage );						BSHVariableDeclarator [] vardec = tvd.getDeclarators();					for( int i = 0; i< vardec.length; i++)					{						String name = vardec[i].name;						try {							Variable var = new Variable( 								name, type, null/*value*/, modifiers );							vars.add( var );						} catch ( UtilEvalError e ) {							// value error shouldn't happen						}					}				}			}				return (Variable [])vars.toArray( new Variable[0] );		}	
static DelayedEvalBshMethod [] getDeclaredMethods( 			BSHBlock body, CallStack callstack, Interpreter interpreter,			String defaultPackage 		)			throws EvalError		{			List methods = new ArrayList();			for( int child=0; child<body.jjtGetNumChildren(); child++ )			{				SimpleNode node = (SimpleNode)body.jjtGetChild(child);				if ( node instanceof BSHMethodDeclaration )				{					BSHMethodDeclaration md = (BSHMethodDeclaration)node;					md.insureNodesParsed();					Modifiers modifiers = md.modifiers;					String name = md.name;					String returnType = md.getReturnTypeDescriptor( 						callstack, interpreter, defaultPackage );					BSHReturnType returnTypeNode = md.getReturnTypeNode();					BSHFormalParameters paramTypesNode = md.paramsNode;					String [] paramTypes = paramTypesNode.getTypeDescriptors( 						callstack, interpreter, defaultPackage );						DelayedEvalBshMethod bm = new DelayedEvalBshMethod( 						name, 						returnType, returnTypeNode,						md.paramsNode.getParamNames(), 						paramTypes, paramTypesNode,						md.blockNode, null/*declaringNameSpace*/,						modifiers, callstack, interpreter 					);						methods.add( bm );				}			}				return (DelayedEvalBshMethod [])methods.toArray( 				new DelayedEvalBshMethod[0] );		}	
private ClassNodeFilter( int context ) { this.context = context; }	
public boolean isVisible( SimpleNode node ) 			{				if ( context == CLASSES )					return node instanceof BSHClassDeclaration;					// Only show class decs in CLASSES				if ( node instanceof BSHClassDeclaration )					return false;					if ( context == STATIC )					return isStatic( node );					if ( context == INSTANCE )					return !isStatic( node );					// ALL				return true;			}	
boolean isStatic( SimpleNode node ) 			{				if ( node instanceof BSHTypedVariableDeclaration )					return ((BSHTypedVariableDeclaration)node).modifiers != null						&& ((BSHTypedVariableDeclaration)node).modifiers							.hasModifier("static");					if ( node instanceof BSHMethodDeclaration )					return ((BSHMethodDeclaration)node).modifiers != null						&& ((BSHMethodDeclaration)node).modifiers							.hasModifier("static");					// need to add static block here				if ( node instanceof BSHBlock)					return false;					return false;			}	
public static Object invokeSuperclassMethodImpl(			BshClassManager bcm, Object instance, String methodName, Object [] args		)	        throws UtilEvalError, ReflectError, InvocationTargetException		{			String superName = ClassGeneratorUtil.BSHSUPER+methodName;						// look for the specially named super delegate method			Class clas = instance.getClass();			Method superMethod = Reflect.resolveJavaMethod(				bcm, clas, superName, Types.getTypes(args), false/*onlyStatic*/ );			if ( superMethod != null )				return Reflect.invokeMethod(					superMethod, instance, args );				// No super method, try to invoke regular method			// could be a superfluous "super." which is legal.			Class superClass = clas.getSuperclass();			superMethod = Reflect.resolveExpectedJavaMethod(				bcm, superClass, instance, methodName, args, 				false/*onlyStatic*/ );			return Reflect.invokeMethod( superMethod, instance, args );		}	
/**			@param packageName e.g. "com.foo.bar"		*/		public ClassGeneratorUtil(			Modifiers classModifiers, String className, String packageName, 			Class superClass, Class [] interfaces, Variable [] vars, 			DelayedEvalBshMethod [] bshmethods, NameSpace classStaticNameSpace,			boolean isInterface		) 		{			this.classModifiers = classModifiers;			this.className = className;			if ( packageName != null ) 				this.fqClassName = packageName.replace('.','/') + "/" + className;			else				this.fqClassName = className;			if ( superClass == null )				superClass = Object.class;			this.superClass = superClass;			this.superClassName = Type.getInternalName( superClass );			if ( interfaces == null )				interfaces = new Class[0];			this.interfaces = interfaces;			this.vars = vars;			this.classStaticNameSpace = classStaticNameSpace;			this.superConstructors = superClass.getDeclaredConstructors();				// Split the methods into constructors and regular method lists			List consl = new ArrayList();			List methodsl = new ArrayList();			String classBaseName = getBaseName( className ); // for inner classes			for( int i=0; i< bshmethods.length; i++ )				if ( bshmethods[i].getName().equals( classBaseName ) )					consl.add( bshmethods[i] );				else					methodsl.add( bshmethods[i] );				this.constructors = (DelayedEvalBshMethod [])consl.toArray( 				new DelayedEvalBshMethod[0] );			this.methods = (DelayedEvalBshMethod [])methodsl.toArray( 				new DelayedEvalBshMethod[0] );				try {				classStaticNameSpace.setLocalVariable( 					BSHCONSTRUCTORS, constructors, false/*strict*/ );			} catch ( UtilEvalError e ) {				throw new InterpreterError("can't set cons var");			}				this.isInterface = isInterface;		}	
/**			Generate the class bytecode for this class.		*/		public byte [] generateClass() 		{			// Force the class public for now...			int classMods = getASMModifiers( classModifiers ) | ACC_PUBLIC;			if ( isInterface )				classMods |= ACC_INTERFACE;				String [] interfaceNames = new String [interfaces.length];			for(int i=0; i<interfaces.length; i++)				interfaceNames[i]=Type.getInternalName( interfaces[i] );				String sourceFile = "BeanShell Generated via ASM (www.objectweb.org)";			ClassWriter cw = new ClassWriter(false);			cw.visit( classMods, fqClassName, superClassName, 				interfaceNames, sourceFile );				if ( !isInterface )			{				// Generate the bsh instance 'This' reference holder field				generateField( 					BSHTHIS+className, "Lorg/gjt/sp/jedit/bsh/This;", ACC_PUBLIC, cw);					// Generate the static bsh static reference holder field				generateField( 					BSHSTATIC+className, "Lorg/gjt/sp/jedit/bsh/This;", ACC_PUBLIC+ACC_STATIC, cw);			}				// Generate the fields			for( int i=0; i<vars.length; i++)			{				String type = vars[i].getTypeDescriptor();					// Don't generate private or loosely typed fields				// Note: loose types aren't currently parsed anyway...				if ( vars[i].hasModifier("private") || type == null )					continue;							int modifiers;				if ( isInterface )					modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;				else					modifiers = getASMModifiers( vars[i].getModifiers() );					generateField( vars[i].getName(), type, modifiers , cw );			}				// Generate the constructors			boolean hasConstructor = false;			for( int i=0; i<constructors.length; i++)			{				// Don't generate private constructors				if ( constructors[i].hasModifier("private") )					continue;					int modifiers = getASMModifiers( constructors[i].getModifiers() );				generateConstructor( 					i, constructors[i].getParamTypeDescriptors(), modifiers, cw );				hasConstructor = true;			}				// If no other constructors, generate a default constructor			if ( !isInterface && !hasConstructor )				generateConstructor( 					DEFAULTCONSTRUCTOR/*index*/, new String [0], ACC_PUBLIC, cw );				// Generate the delegate methods			for( int i=0; i<methods.length; i++)			{				String returnType = methods[i].getReturnTypeDescriptor();					// Don't generate private /*or loosely return typed */ methods				if ( methods[i].hasModifier("private") /*|| returnType == null*/ )					continue;					int modifiers = getASMModifiers( methods[i].getModifiers() );				if ( isInterface )					modifiers |= ( ACC_PUBLIC | ACC_ABSTRACT );					generateMethod( className, fqClassName, 					methods[i].getName(), returnType,					methods[i].getParamTypeDescriptors(), modifiers, cw );					boolean isStatic = (modifiers & ACC_STATIC) > 0 ;				boolean overridden = classContainsMethod( 					superClass, methods[i].getName(), 					methods[i].getParamTypeDescriptors() ) ;				if ( !isStatic && overridden )					generateSuperDelegateMethod( superClassName,						methods[i].getName(), returnType,						methods[i].getParamTypeDescriptors(), modifiers, cw );			}				return cw.toByteArray();		}	
/**			Translate bsh.Modifiers into ASM modifier bitflags.		*/		static int getASMModifiers( Modifiers modifiers ) 		{			int mods = 0;			if ( modifiers == null )				return mods;				if ( modifiers.hasModifier("public") )				mods += ACC_PUBLIC;			if ( modifiers.hasModifier("protected") )				mods += ACC_PROTECTED;			if ( modifiers.hasModifier("static") )				mods += ACC_STATIC;			if ( modifiers.hasModifier("synchronized") )				mods += ACC_SYNCHRONIZED;			if ( modifiers.hasModifier("abstract") )				mods += ACC_ABSTRACT;				return mods;		}	
/**			Generate a field - static or instance.		*/		static void generateField( 			String fieldName, String type, int modifiers, ClassWriter cw ) 		{			cw.visitField( modifiers, fieldName, type, null/*value*/ );		}	
/**			Generate a delegate method - static or instance.			The generated code packs the method arguments into an object array			(wrapping primitive types in bsh.Primitive), invokes the static or			instance namespace invokeMethod() method, and then unwraps / returns			the result.		*/		static void generateMethod( 			String className, String fqClassName, String methodName, 			String returnType, String[] paramTypes, int modifiers, ClassWriter cw ) 		{			String [] exceptions = null;			boolean isStatic = (modifiers & ACC_STATIC) != 0 ;				if ( returnType == null ) // map loose return type to Object				returnType = OBJECT;				String methodDescriptor = getMethodDescriptor( returnType, paramTypes );				// Generate method body			CodeVisitor cv = cw.visitMethod( 				modifiers, methodName, methodDescriptor, exceptions );				if ( (modifiers & ACC_ABSTRACT) != 0 )				return;				// Generate code to push the BSHTHIS or BSHSTATIC field 			if ( isStatic )			{				cv.visitFieldInsn( 					GETSTATIC, fqClassName, BSHSTATIC+className, "Lorg/gjt/sp/jedit/bsh/This;" );			}else			{				// Push 'this'				cv.visitVarInsn( ALOAD, 0 );					// Get the instance field				cv.visitFieldInsn( 					GETFIELD, fqClassName, BSHTHIS+className, "Lorg/gjt/sp/jedit/bsh/This;" );			}				// Push the name of the method as a constant	    	cv.visitLdcInsn( methodName );				// Generate code to push arguments as an object array			generateParameterReifierCode( paramTypes, isStatic, cv );				// Push nulls for various args of invokeMethod			cv.visitInsn(ACONST_NULL); // interpreter			cv.visitInsn(ACONST_NULL); // callstack			cv.visitInsn(ACONST_NULL); // callerinfo				// Push the boolean constant 'true' (for declaredOnly)			cv.visitInsn(ICONST_1);				// Invoke the method This.invokeMethod( name, Class [] sig, boolean )			cv.visitMethodInsn(				INVOKEVIRTUAL, "org/gjt/sp/jedit/bsh/This", "invokeMethod",				Type.getMethodDescriptor( 					Type.getType(Object.class),					new Type [] { 						Type.getType(String.class), 						Type.getType(Object [].class),						Type.getType(Interpreter.class),						Type.getType(CallStack.class),						Type.getType(SimpleNode.class),						Type.getType(Boolean.TYPE) 					} 				)			);				// Generate code to unwrap bsh Primitive types			cv.visitMethodInsn(			  INVOKESTATIC, "org/gjt/sp/jedit/bsh/Primitive", "unwrap",			  "(Ljava/lang/Object;)Ljava/lang/Object;" );				// Generate code to return the value			generateReturnCode( returnType, cv );				// Need to calculate this... just fudging here for now.			cv.visitMaxs( 20, 20 );		}	
/**			Generate a constructor.		*/		void generateConstructor( 			int index, String [] paramTypes, int modifiers, ClassWriter cw ) 		{			/** offset after params of the args object [] var */			final int argsVar = paramTypes.length+1;			/** offset after params of the ConstructorArgs var */			final int consArgsVar = paramTypes.length+2;				String [] exceptions = null;			String methodDescriptor = getMethodDescriptor( "V", paramTypes );				// Create this constructor method			CodeVisitor cv = 				cw.visitMethod( modifiers, "<init>", methodDescriptor, exceptions );				// Generate code to push arguments as an object array			generateParameterReifierCode( paramTypes, false/*isStatic*/, cv );			cv.visitVarInsn( ASTORE, argsVar );				// Generate the code implementing the alternate constructor switch			generateConstructorSwitch( index, argsVar, consArgsVar, cv );				// Generate code to invoke the ClassGeneratorUtil initInstance() method				// push 'this' 			cv.visitVarInsn( ALOAD, 0 );				// Push the class/constructor name as a constant	    	cv.visitLdcInsn( className );				// Push arguments as an object array			cv.visitVarInsn( ALOAD, argsVar );				// invoke the initInstance() method			cv.visitMethodInsn(				INVOKESTATIC, "org/gjt/sp/jedit/bsh/ClassGeneratorUtil", "initInstance",				"(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V");				cv.visitInsn( RETURN );				// Need to calculate this... just fudging here for now.			cv.visitMaxs( 20, 20 );		}	
/**			Generate a switch with a branch for each possible alternate			constructor.  This includes all superclass constructors and all 			constructors of this class.  The default branch of this switch is the			default superclass constructor.			<p>			This method also generates the code to call the static			ClassGeneratorUtil			getConstructorArgs() method which inspects the scripted constructor to			find the alternate constructor signature (if any) and evalute the			arguments at runtime.  The getConstructorArgs() method returns the			actual arguments as well as the index of the constructor to call. 		*/		void generateConstructorSwitch( 			int consIndex, int argsVar, int consArgsVar, CodeVisitor cv )		{			Label defaultLabel = new Label();			Label endLabel = new Label();			int cases = superConstructors.length + constructors.length ;				Label [] labels = new Label[ cases ];			for(int i=0; i<cases; i++)				labels[i]=new Label();				// Generate code to call ClassGeneratorUtil to get our switch index 			// and give us args...				// push super class name	    	cv.visitLdcInsn( superClass.getName() ); // use superClassName var?				// push class static This object			cv.visitFieldInsn( 				GETSTATIC, fqClassName, BSHSTATIC+className, "Lorg/gjt/sp/jedit/bsh/This;" );				// push args			cv.visitVarInsn( ALOAD, argsVar );				// push this constructor index number onto stack			cv.visitIntInsn( BIPUSH, consIndex );				// invoke the ClassGeneratorUtil getConstructorsArgs() method			cv.visitMethodInsn(				INVOKESTATIC, "org/gjt/sp/jedit/bsh/ClassGeneratorUtil", "getConstructorArgs",				"(Ljava/lang/String;Lorg/gjt/sp/jedit/bsh/This;[Ljava/lang/Object;I)"				+"Lorg/gjt/sp/jedit/bsh/ClassGeneratorUtil$ConstructorArgs;"			);				// store ConstructorArgs in consArgsVar			cv.visitVarInsn( ASTORE, consArgsVar );				// Get the ConstructorArgs selector field from ConstructorArgs				// push ConstructorArgs 			cv.visitVarInsn( ALOAD, consArgsVar );			cv.visitFieldInsn( 				GETFIELD, "org/gjt/sp/jedit/bsh/ClassGeneratorUtil$ConstructorArgs", "selector", "I" );				// start switch			cv.visitTableSwitchInsn( 				0/*min*/, cases-1/*max*/, defaultLabel, labels );				// generate switch body			int index = 0;			for( int i=0; i< superConstructors.length; i++, index++)				doSwitchBranch( index, superClassName, 					getTypeDescriptors( superConstructors[i].getParameterTypes() ), 					endLabel, labels, consArgsVar, cv );			for( int i=0; i< constructors.length; i++, index++)				doSwitchBranch( index, fqClassName, 					constructors[i].getParamTypeDescriptors(), 					endLabel, labels, consArgsVar, cv );					// generate the default branch of switch			cv.visitLabel( defaultLabel );			// default branch always invokes no args super			cv.visitVarInsn( ALOAD, 0 ); // push 'this' 			cv.visitMethodInsn( INVOKESPECIAL, superClassName, "<init>", "()V" );				// done with switch			cv.visitLabel( endLabel );		}	
static void doSwitchBranch( 			int index, String targetClassName, String [] paramTypes,			Label endLabel, Label [] labels, int consArgsVar, CodeVisitor cv		)		{			cv.visitLabel( labels[index] );			//cv.visitLineNumber( index, labels[index] );			cv.visitVarInsn( ALOAD, 0 ); // push this before args				// Unload the arguments from the ConstructorArgs object			for (int i=0; i<paramTypes.length; i++)			{				String type = paramTypes[i];				String method = null;				if      ( type.equals("Z") )					method = "getBoolean";				else if ( type.equals("B") )					method = "getByte";				else if ( type.equals("C") )					method = "getChar";				else if ( type.equals("S") )					method = "getShort";				else if ( type.equals("I") )					method = "getInt";				else if ( type.equals("J") )					method = "getLong";				else if ( type.equals("D") )					method = "getDouble";				else if ( type.equals("F") )					method = "getFloat";				else 					method = "getObject";					// invoke the iterator method on the ConstructorArgs				cv.visitVarInsn( ALOAD, consArgsVar ); // push the ConstructorArgs				String className = "org/gjt/sp/jedit/bsh/ClassGeneratorUtil$ConstructorArgs";				String retType;				if ( method.equals("getObject") )					retType = OBJECT;				else					retType = type; 				cv.visitMethodInsn(INVOKEVIRTUAL, className, method, "()"+retType);				// if it's an object type we must do a check cast				if ( method.equals("getObject") )					cv.visitTypeInsn( CHECKCAST, descriptorToClassName(type) ); 			}				// invoke the constructor for this branch			String descriptor = getMethodDescriptor( "V", paramTypes );			cv.visitMethodInsn( 				INVOKESPECIAL, targetClassName, "<init>", descriptor );			cv.visitJumpInsn( GOTO, endLabel );		}	
static String getMethodDescriptor( String returnType, String [] paramTypes )		{			StringBuilder sb = new StringBuilder("(");			for(int i=0; i<paramTypes.length; i++)				sb.append(paramTypes[i]);			sb.append(")"+returnType);			return sb.toString();		}	
/**			Generate a superclass method delegate accessor method.			These methods are specially named methods which allow access to			overridden methods of the superclass (which the Java reflection API			normally does not allow).		*/		// Maybe combine this with generateMethod()		static void generateSuperDelegateMethod( String superClassName, String methodName,												 String returnType, String[] paramTypes, int modifiers, ClassWriter cw )		{			String [] exceptions = null;				if ( returnType == null ) // map loose return to Object				returnType = OBJECT;				String methodDescriptor = getMethodDescriptor( returnType, paramTypes );				// Add method body			CodeVisitor cv = cw.visitMethod( 				modifiers, "_bshSuper"+methodName, methodDescriptor, exceptions );				cv.visitVarInsn(ALOAD, 0);			// Push vars			int localVarIndex = 1;			for (int i = 0; i < paramTypes.length; ++i) 			{				if ( isPrimitive( paramTypes[i]) )					cv.visitVarInsn(ILOAD, localVarIndex);				else					cv.visitVarInsn(ALOAD, localVarIndex);				localVarIndex += 					( (paramTypes[i].equals("D") || paramTypes[i].equals("J")) 						? 2 : 1 );			}				cv.visitMethodInsn( INVOKESPECIAL, 				superClassName, methodName, methodDescriptor );				generatePlainReturnCode( returnType, cv );				// Need to calculate this... just fudging here for now.			cv.visitMaxs( 20, 20 );		}	
boolean classContainsMethod(			Class clas, String methodName, String [] paramTypes )		{			while( clas != null )			{				Method [] methods = clas.getDeclaredMethods();				for( int i =0; i<methods.length; i++ )				{					if ( methods[i].getName().equals(methodName) )					{						String [] methodParamTypes = 							getTypeDescriptors( methods[i].getParameterTypes() );						boolean found = true;						for( int j=0; j<methodParamTypes.length; j++)						{							if ( ! paramTypes[j].equals( methodParamTypes[j] ) ) {								found = false;								break;							}						}						if ( found )							return true;					}				}					clas = clas.getSuperclass();			}				return false;		}	
/**			Generate return code for a normal bytecode		*/		static void generatePlainReturnCode( String returnType, CodeVisitor cv )		{			if ( returnType.equals("V") )				cv.visitInsn( RETURN );			else 			if ( isPrimitive( returnType ) )			{				int opcode = IRETURN;				if ( returnType.equals("D") )					opcode = DRETURN;				else if ( returnType.equals("F") )					opcode = FRETURN;				else if ( returnType.equals("J") )  //long					opcode = LRETURN;					cv.visitInsn(opcode);			}			else {				cv.visitTypeInsn( CHECKCAST, descriptorToClassName(returnType) );				cv.visitInsn( ARETURN );			}		}	
/**			Generates the code to reify the arguments of the given method.			For a method "int m (int i, String s)", this code is the bytecode			corresponding to the "new Object[] { new bsh.Primitive(i), s }" 			expression.			 	@author Eric Bruneton		 	@author Pat Niemeyer			@param cv the code visitor to be used to generate the bytecode.			@param isStatic the enclosing methods is static		*/		public static void generateParameterReifierCode (			String [] paramTypes, boolean isStatic, final CodeVisitor cv )		{			cv.visitIntInsn(SIPUSH, paramTypes.length);			cv.visitTypeInsn(ANEWARRAY, "java/lang/Object");			int localVarIndex = isStatic ? 0 : 1;			for (int i = 0; i < paramTypes.length; ++i) 			{				String param = paramTypes[i];				cv.visitInsn(DUP);				cv.visitIntInsn(SIPUSH, i);				if ( isPrimitive( param ) ) 				{	                int opcode;	                if (param.equals("F")) {	                    opcode = FLOAD;	                } else if (param.equals("D")) {	                    opcode = DLOAD;	                } else if (param.equals("J")) {	                    opcode = LLOAD;	                } else {	                    opcode = ILOAD;	                }						String type = "org/gjt/sp/jedit/bsh/Primitive";					cv.visitTypeInsn( NEW, type );					cv.visitInsn(DUP);					cv.visitVarInsn(opcode, localVarIndex);					String desc = param; // ok?					cv.visitMethodInsn(						INVOKESPECIAL, type, "<init>", "(" + desc + ")V");				} else {					// Technically incorrect here - we need to wrap null values					// as bsh.Primitive.NULL.  However the This.invokeMethod()					// will do that much for us.					// We need to generate a conditional here to test for null					// and return Primitive.NULL					cv.visitVarInsn( ALOAD, localVarIndex );				}				cv.visitInsn(AASTORE);				localVarIndex += 					( (param.equals("D") || param.equals("J")) ? 2 : 1 );			}	  }	
/**			Generates the code to unreify the result of the given method.  For a			method "int m (int i, String s)", this code is the bytecode			corresponding to the "((Integer)...).intValue()" expression.		   			@param cv the code visitor to be used to generate the bytecode.			@author Eric Bruneton			@author Pat Niemeyer	   */		public static void generateReturnCode (			String returnType, CodeVisitor cv ) 		{			if ( returnType.equals("V") ) 			{				cv.visitInsn(POP);				cv.visitInsn(RETURN);			} 			else if ( isPrimitive( returnType ) ) 			{				int opcode = IRETURN;				String type;				String meth;				if ( returnType.equals("B") ) {					type = "java/lang/Byte";					meth = "byteValue";			 	} else if (returnType.equals("I") ) {					type = "java/lang/Integer";					meth = "intValue";				} else if (returnType.equals("Z") ) {					type = "java/lang/Boolean";					meth = "booleanValue";				} else if (returnType.equals("D") ) {					opcode = DRETURN;					type = "java/lang/Double";					meth = "doubleValue";			 	} else if (returnType.equals("F") ) {					opcode = FRETURN;					type = "java/lang/Float";					meth = "floatValue";				} else if (returnType.equals("J") ) {					opcode = LRETURN;					type = "java/lang/Long";					meth = "longValue";				} else if (returnType.equals("C") ) {					type = "java/lang/Character";					meth = "charValue";				} else /*if (returnType.equals("S") )*/ {					type = "java/lang/Short";					meth = "shortValue";				}					String desc = returnType;				cv.visitTypeInsn( CHECKCAST, type ); // type is correct here				cv.visitMethodInsn( INVOKEVIRTUAL, type, meth, "()" + desc );				cv.visitInsn(opcode);			} else 			{				cv.visitTypeInsn( CHECKCAST, descriptorToClassName(returnType) );				cv.visitInsn(ARETURN);			}	  }	
/**			Evaluate the arguments (if any) for the constructor specified by			the constructor index.  Return the ConstructorArgs object which			contains the actual arguments to the alternate constructor and also the			index of that constructor for the constructor switch.				@param consArgs the arguments to the constructor.  These are necessary in			the evaluation of the alt constructor args.  e.g. Foo(a) { super(a); }			@return the ConstructorArgs object containing a constructor selector				and evaluated arguments for the alternate constructor		*/		public static ConstructorArgs getConstructorArgs( 			String superClassName, This classStaticThis, 			Object [] consArgs, int index )		{			DelayedEvalBshMethod [] constructors;			try {				constructors = 					(DelayedEvalBshMethod [])classStaticThis.getNameSpace()					.getVariable( BSHCONSTRUCTORS );			} catch ( Exception e ) {				throw new InterpreterError(					"unable to get instance initializer: "+e );			}				if ( index == DEFAULTCONSTRUCTOR ) // auto-gen default constructor				return ConstructorArgs.DEFAULT; // use default super constructor				DelayedEvalBshMethod constructor = constructors[index];				if ( constructor.methodBody.jjtGetNumChildren() == 0 )				return ConstructorArgs.DEFAULT; // use default super constructor				// Determine if the constructor calls this() or super()			String altConstructor = null;			BSHArguments argsNode = null;			SimpleNode firstStatement = 				(SimpleNode)constructor.methodBody.jjtGetChild(0);			if ( firstStatement instanceof BSHPrimaryExpression )				firstStatement = (SimpleNode)firstStatement.jjtGetChild(0);			if ( firstStatement instanceof BSHMethodInvocation )			{				BSHMethodInvocation methodNode = 					(BSHMethodInvocation)firstStatement;				BSHAmbiguousName methodName = methodNode.getNameNode();				if ( methodName.text.equals("super") 					|| methodName.text.equals("this") 				) {					altConstructor = methodName.text;					argsNode = methodNode.getArgsNode();				}			}				if ( altConstructor == null )				return ConstructorArgs.DEFAULT; // use default super constructor				// Make a tmp namespace to hold the original constructor args for			// use in eval of the parameters node			NameSpace consArgsNameSpace = 				new NameSpace( classStaticThis.getNameSpace(), "consArgs" );			String [] consArgNames = constructor.getParameterNames();			Class [] consArgTypes = constructor.getParameterTypes();			for( int i=0; i<consArgs.length; i++ )			{				try {					consArgsNameSpace.setTypedVariable( 						consArgNames[i], consArgTypes[i], consArgs[i], 						null/*modifiers*/);				} catch ( UtilEvalError e ) {					throw new InterpreterError("err setting local cons arg:"+e);				}			}				// evaluate the args				CallStack callstack = new CallStack();			callstack.push( consArgsNameSpace);			Object [] args = null;			Interpreter interpreter = classStaticThis.declaringInterpreter;				try {				args = argsNode.getArguments( callstack, interpreter );			} catch ( EvalError e ) {				throw new InterpreterError(					"Error evaluating constructor args: "+e );			}				Class [] argTypes  = Types.getTypes( args );			args = Primitive.unwrap( args );			Class superClass = 				interpreter.getClassManager().classForName( superClassName );			if ( superClass == null )				throw new InterpreterError(					"can't find superclass: "+superClassName );			Constructor [] superCons = superClass.getDeclaredConstructors();				// find the matching super() constructor for the args			if ( altConstructor.equals("super") )			{				int i = Reflect.findMostSpecificConstructorIndex( 					argTypes , superCons );				if ( i == -1 )					throw new InterpreterError("can't find constructor for args!");				return new ConstructorArgs( i, args );			}				// find the matching this() constructor for the args			Class [][] candidates = new Class [ constructors.length ] [];			for(int i=0; i< candidates.length; i++ )				candidates[i] = constructors[i].getParameterTypes();			int i = Reflect.findMostSpecificSignature( argTypes, candidates );			if ( i == -1 )				throw new InterpreterError("can't find constructor for args 2!");			// this() constructors come after super constructors in the table				int selector = i+superCons.length;			int ourSelector = index+superCons.length;				// Are we choosing ourselves recursively through a this() reference?			if ( selector == ourSelector )				throw new InterpreterError( "Recusive constructor call.");				return new ConstructorArgs( selector, args );		}	
/**			Initialize an instance of the class.			This method is called from the generated class constructor to evaluate			the instance initializer and scripted constructor in the instance			namespace.		*/		public static void initInstance( 			Object instance, String className, Object [] args )		{			Class [] sig = Types.getTypes( args );			CallStack callstack = new CallStack();			Interpreter interpreter;			NameSpace instanceNameSpace;				// check to see if the instance has already been initialized			// (the case if using a this() alternate constuctor)			This instanceThis = getClassInstanceThis( instance, className );		// XXX clean up this conditional			if ( instanceThis == null )			{				// Create the instance 'This' namespace, set it on the object				// instance and invoke the instance initializer					// Get the static This reference from the proto-instance				This classStaticThis = 					getClassStaticThis( instance.getClass(), className );				interpreter = classStaticThis.declaringInterpreter;					// Get the instance initializer block from the static This 				BSHBlock instanceInitBlock;				try {					instanceInitBlock = (BSHBlock)classStaticThis.getNameSpace()						.getVariable( BSHINIT );				} catch ( Exception e ) {					throw new InterpreterError(						"unable to get instance initializer: "+e );				}					// Create the instance namespace				instanceNameSpace = 					new NameSpace( classStaticThis.getNameSpace(), className );				instanceNameSpace.isClass = true;					// Set the instance This reference on the instance				instanceThis = instanceNameSpace.getThis( interpreter );				try {					LHS lhs = 						Reflect.getLHSObjectField( instance, BSHTHIS+className );					lhs.assign( instanceThis, false/*strict*/ );				} catch ( Exception e ) {					throw new InterpreterError("Error in class gen setup: "+e );				}					// Give the instance space its object import				instanceNameSpace.setClassInstance( instance );					// should use try/finally here to pop ns				callstack.push( instanceNameSpace );					// evaluate the instance portion of the block in it				try { // Evaluate the initializer block					instanceInitBlock.evalBlock( 						callstack, interpreter, true/*override*/, 						ClassGeneratorImpl.ClassNodeFilter.CLASSINSTANCE );				} catch ( Exception e ) {					throw new InterpreterError("Error in class initialization: "+e);				}					callstack.pop();				} else			{				// The object instance has already been initialzed by another				// constructor.  Fall through to invoke the constructor body below.				interpreter = instanceThis.declaringInterpreter;				instanceNameSpace = instanceThis.getNameSpace();			}				// invoke the constructor method from the instanceThis 				String constructorName = getBaseName( className );			try {				// Find the constructor (now in the instance namespace)				BshMethod constructor = instanceNameSpace.getMethod( 					constructorName, sig, true/*declaredOnly*/ );					// if args, we must have constructor				if ( args.length > 0 && constructor == null )					throw new InterpreterError(						"Can't find constructor: "+ className );					// Evaluate the constructor				if ( constructor != null )					constructor.invoke( args, interpreter, callstack,						null/*callerInfo*/, false/*overrideNameSpace*/ ) ;			} catch ( Exception e ) {				if ( e instanceof TargetError )					e =(Exception)((TargetError)e).getTarget();				if ( e instanceof InvocationTargetException )					e = (Exception)((InvocationTargetException)e)						.getTargetException();				e.printStackTrace( System.err );				throw new InterpreterError("Error in class initialization: "+e );			} 		}	
/**			Get the static bsh namespace field from the class.			@param className may be the name of clas itself or a superclass of clas.		*/		static This getClassStaticThis( Class clas, String className )		{			try {				return (This)Reflect.getStaticFieldValue(					clas, BSHSTATIC + className );			} catch ( Exception e ) {				throw new InterpreterError("Unable to get class static space: "+e);			}		}	
/**			Get the instance bsh namespace field from the object instance.			@return the class instance This object or null if the object has not			been initialized.		*/		static This getClassInstanceThis( Object instance, String className )		{			try {				Object o = Reflect.getObjectFieldValue( instance, BSHTHIS+className );				return (This)Primitive.unwrap(o); // unwrap Primitive.Null to null			} catch ( Exception e ) {				throw new InterpreterError(					"Generated class: Error getting This"+e );			}		}	
/**			Does the type descriptor string describe a primitive type?		*/		private static boolean isPrimitive( String typeDescriptor )		{			return typeDescriptor.length() == 1; // right?		}	
static String[] getTypeDescriptors( Class [] cparams )		{			String [] sa = new String [cparams.length];			for(int i=0; i<sa.length; i++)				sa[i] = BSHType.getTypeDescriptor( cparams[i] );			return sa;		}	
/**			If a non-array object type, remove the prefix "L" and suffix ";".		*/		// Can this be factored out...?  		// Should be be adding the L...; here instead?		private static String descriptorToClassName( String s ) 		{			if ( s.startsWith("[") || !s.startsWith("L") )				return s;			return s.substring( 1, s.length()-1 );		}	
private static String getBaseName( String className ) 		{			int i = className.indexOf("$");			if ( i == -1 )				return className;				return className.substring(i+1);		}	
/**				The index of the constructor to call.			*/				ConstructorArgs() {  }	
ConstructorArgs( int selector, Object [] args ) { 				this.selector = selector;				this.args = args; 			}	
Object next() { return args[arg++]; }	
public boolean getBoolean() { return ((Boolean)next()).booleanValue(); }	
public byte getByte() { return ((Byte)next()).byteValue(); }	
public char getChar() { return ((Character)next()).charValue(); }	
public short getShort() { return ((Short)next()).shortValue(); }	
public int getInt() { return ((Integer)next()).intValue(); }	
public long getLong() { return ((Long)next()).longValue(); }	
public double getDouble() { return ((Double)next()).doubleValue(); }	
public float getFloat() { return ((Float)next()).floatValue(); }	
public Object getObject() { return next(); }	
public ClassIdentifier( Class clas ) {			this.clas = clas;		}	
public Class getTargetClass() {			return clas;		}	
public String toString() {			return "Class Identifier: "+clas.getName();		}	
/**			Used by BshClassManager singleton constructor		*/		public ClassManagerImpl() {			reset();		}	
/**			@return the class or null		*/		public Class classForName( String name )		{			// check positive cache			Class c = (Class)absoluteClassCache.get(name);			if (c != null )				return c;				// check negative cache			if ( absoluteNonClasses.get(name)!=null ) {				if ( Interpreter.DEBUG )					Interpreter.debug("absoluteNonClass list hit: "+name);				return null;			}				if ( Interpreter.DEBUG )				Interpreter.debug("Trying to load class: "+name);				// Check explicitly mapped (reloaded) class...			ClassLoader overlayLoader = getLoaderForClass( name );			if ( overlayLoader != null )			{				try {					c = overlayLoader.loadClass(name);				} catch ( Exception e ) {				// used to squeltch this... changed for 1.3				// see BshClassManager				} catch ( NoClassDefFoundError e2 ) {					throw noClassDefFound( name, e2 );				}					// Should be there since it was explicitly mapped				// throw an error?			}				// insure that core classes are loaded from the same loader			if ( c == null ) {				if ( name.startsWith( BSH_PACKAGE ) )					try {						c = Interpreter.class.getClassLoader().loadClass( name );					} catch ( ClassNotFoundException e ) {}			}				// Check classpath extension / reloaded classes			if ( c == null ) {				if ( baseLoader != null )					try {						c = baseLoader.loadClass( name );					} catch ( ClassNotFoundException e ) {}			}				// Optionally try external classloader			if ( c == null ) {				if ( externalClassLoader != null )					try {						c = externalClassLoader.loadClass( name );					} catch ( ClassNotFoundException e ) {}			}				// Optionally try context classloader			// Note that this might be a security violation			// is catching the SecurityException sufficient for all environments?			// or do we need a way to turn this off completely?			if ( c ==  null )			{				try {					ClassLoader contextClassLoader = 						Thread.currentThread().getContextClassLoader();					if ( contextClassLoader != null )						c = Class.forName( name, true, contextClassLoader );				} catch ( ClassNotFoundException e ) { // fall through				} catch ( SecurityException e ) { } // fall through			}				// try plain class forName()			if ( c == null )				try {					c = plainClassForName( name );				} catch ( ClassNotFoundException e ) {}				// Try scripted class			if ( c == null )				c = loadSourceClass( name );				// Cache result (or null for not found)			// Note: plainClassForName already caches, so it will be redundant			// in that case, however this process only happens once			cacheClassInfo( name, c );				return c;		}	
/**			Get a resource URL using the BeanShell classpath			@param path should be an absolute path		*/		public URL getResource( String path ) 		{			URL url = null;			if ( baseLoader != null )				// classloader wants no leading slash				url = baseLoader.getResource( path.substring(1) );			if ( url == null )				url = super.getResource( path );			return url;		}	
/**			Get a resource stream using the BeanShell classpath			@param path should be an absolute path		*/		public InputStream getResourceAsStream( String path ) 		{			InputStream in = null;			if ( baseLoader != null )			{				// classloader wants no leading slash				in = baseLoader.getResourceAsStream( path.substring(1) );			}			if ( in == null )			{				in = super.getResourceAsStream( path );			}			return in;		}	
ClassLoader getLoaderForClass( String name ) {			return (ClassLoader)loaderMap.get( name );		}	
/**		*/		public void addClassPath( URL path ) 			throws IOException 		{			if ( baseLoader == null )				setClassPath( new URL [] { path } );			else {				// opportunity here for listener in classpath				baseLoader.addURL( path );				baseClassPath.add( path );				classLoaderChanged();			}		}	
/**			Clear all classloading behavior and class caches and reset to 			initial state.		*/		public void reset()		{			baseClassPath = new BshClassPath("baseClassPath");			baseLoader = null;			loaderMap = new HashMap();			classLoaderChanged(); // calls clearCaches() for us.		}	
/**			Set a new base classpath and create a new base classloader.			This means all types change. 		*/		public void setClassPath( URL [] cp ) {			baseClassPath.setPath( cp );			initBaseLoader();			loaderMap = new HashMap();			classLoaderChanged();		}	
/**			Overlay the entire path with a new class loader.			Set the base path to the user path + base path.				No point in including the boot class path (can't reload thos).		*/		public void reloadAllClasses() throws ClassPathException 		{			BshClassPath bcp = new BshClassPath("temp");			bcp.addComponent( baseClassPath );			bcp.addComponent( BshClassPath.getUserClassPath() );			setClassPath( bcp.getPathComponents() );		}	
/**			init the baseLoader from the baseClassPath		*/		private void initBaseLoader() {			baseLoader = new BshClassLoader( this, baseClassPath );		}	
/**			Reloading classes means creating a new classloader and using it			whenever we are asked for classes in the appropriate space.			For this we use a DiscreteFilesClassLoader		*/		public void reloadClasses( String [] classNames ) 			throws ClassPathException		{			// validate that it is a class here?				// init base class loader if there is none...			if ( baseLoader == null )				initBaseLoader();				DiscreteFilesClassLoader.ClassSourceMap map = 				new DiscreteFilesClassLoader.ClassSourceMap();				for (int i=0; i< classNames.length; i++) {				String name = classNames[i];					// look in baseLoader class path 				ClassSource classSource = baseClassPath.getClassSource( name );					// look in user class path 				if ( classSource == null ) {					BshClassPath.getUserClassPath().insureInitialized();					classSource = BshClassPath.getUserClassPath().getClassSource( 						name );				}					// No point in checking boot class path, can't reload those.				// else we could have used fullClassPath above.									if ( classSource == null )					throw new ClassPathException("Nothing known about class: "						+name );					// JarClassSource is not working... just need to implement it's				// getCode() method or, if we decide to, allow the BshClassManager				// to handle it... since it is a URLClassLoader and can handle JARs				if ( classSource instanceof JarClassSource )					throw new ClassPathException("Cannot reload class: "+name+						" from source: "+ classSource );					map.put( name, classSource );			}				// Create classloader for the set of classes			ClassLoader cl = new DiscreteFilesClassLoader( this, map );				// map those classes the loader in the overlay map			Iterator it = map.keySet().iterator();			while ( it.hasNext() )				loaderMap.put( (String)it.next(), cl );				classLoaderChanged();		}	
/**			Reload all classes in the specified package: e.g. "com.sun.tools"				The special package name "<unpackaged>" can be used to refer 			to unpackaged classes.		*/		public void reloadPackage( String pack ) 			throws ClassPathException 		{			Collection classes = 				baseClassPath.getClassesForPackage( pack );				if ( classes == null )				classes = 					BshClassPath.getUserClassPath().getClassesForPackage( pack );				// no point in checking boot class path, can't reload those				if ( classes == null )				throw new ClassPathException("No classes found for package: "+pack);				reloadClasses( (String[])classes.toArray( new String[0] ) );		}	
/**			Get the full blown classpath.		*/		public BshClassPath getClassPath() throws ClassPathException		{			if ( fullClassPath != null )				return fullClassPath;					fullClassPath = new BshClassPath("BeanShell Full Class Path");			fullClassPath.addComponent( BshClassPath.getUserClassPath() );			try {				fullClassPath.addComponent( BshClassPath.getBootClassPath() );			} catch ( ClassPathException e ) { 				System.err.println("Warning: can't get boot class path");			}			fullClassPath.addComponent( baseClassPath );				return fullClassPath;		}	
/**			Support for "import *;"			Hide details in here as opposed to NameSpace.		*/		public void doSuperImport() 			throws UtilEvalError		{			// Should we prevent it from happening twice?				try {				getClassPath().insureInitialized();				// prime the lookup table				getClassNameByUnqName( "" ) ;					// always true now				//getClassPath().setNameCompletionIncludeUnqNames(true);				} catch ( ClassPathException e ) {				throw new UtilEvalError("Error importing classpath "+ e );			}				superImport = true;		}	
protected boolean hasSuperImport() { return superImport; }	
/**			Return the name or null if none is found,			Throw an ClassPathException containing detail if name is ambigous.		*/		public String getClassNameByUnqName( String name ) 			throws ClassPathException		{			return getClassPath().getClassNameByUnqName( name );		}	
public void addListener( Listener l ) {			listeners.addElement( new WeakReference( l, refQueue) );				// clean up old listeners			Reference deadref;			while ( (deadref = refQueue.poll()) != null ) {				boolean ok = listeners.removeElement( deadref );				if ( ok ) {					//System.err.println("cleaned up weak ref: "+deadref);				} else {					if ( Interpreter.DEBUG ) Interpreter.debug(						"tried to remove non-existent weak ref: "+deadref);				}			}		}	
public void removeListener( Listener l ) {			throw new Error("unimplemented");		}	
public ClassLoader getBaseLoader() {			return baseLoader;		}	
/**			Get the BeanShell classloader.		public ClassLoader getClassLoader() {		}		*/			/*			Impl Notes:			We add the bytecode source and the "reload" the class, which causes the			BshClassLoader to be initialized and create a DiscreteFilesClassLoader			for the bytecode.				@exception ClassPathException can be thrown by reloadClasses		*/		public Class defineClass( String name, byte [] code ) 		{			baseClassPath.setClassSource( name, new GeneratedClassSource( code ) );			try {				reloadClasses( new String [] { name } );			} catch ( ClassPathException e ) {				throw new org.gjt.sp.jedit.bsh.InterpreterError("defineClass: "+e);			}			return classForName( name );		}	
/**			Clear global class cache and notify namespaces to clear their 			class caches.				The listener list is implemented with weak references so that we 			will not keep every namespace in existence forever.		*/		protected void classLoaderChanged() 		{			// clear the static caches in BshClassManager			clearCaches();				Vector toRemove = new Vector(); // safely remove			for ( Enumeration e = listeners.elements(); e.hasMoreElements(); ) 			{				WeakReference wr = (WeakReference)e.nextElement();				Listener l = (Listener)wr.get();				if ( l == null )  // garbage collected				  toRemove.add( wr );				else				  l.classLoaderChanged();			}			for( Enumeration e = toRemove.elements(); e.hasMoreElements(); ) 				listeners.removeElement( e.nextElement() );		}	
public void dump( PrintWriter i ) 		{			i.println("Bsh Class Manager Dump: ");			i.println("----------------------- ");			i.println("baseLoader = "+baseLoader);			i.println("loaderMap= "+loaderMap);			i.println("----------------------- ");			i.println("baseClassPath = "+baseClassPath);		}	
public ClassPathException( String msg ) { super(msg); }	
/**	   * Constructs a new {@link ClassWriter ClassWriter} object.	   *	   * @param computeMaxs <tt>true</tt> if the maximum stack size and the maximum	   *      number of local variables must be automatically computed. If this flag	   *      is <tt>true</tt>, then the arguments of the {@link	   *      CodeVisitor#visitMaxs visitMaxs} method of the {@link CodeVisitor	   *      CodeVisitor} returned by the {@link #visitMethod visitMethod} method	   *      will be ignored, and computed automatically from the signature and	   *      the bytecode of each method.	   */		  public ClassWriter (final boolean computeMaxs) {	    index = 1;	    pool = new ByteVector();	    table = new Item[64];	    threshold = (int)(0.75d*table.length);	    key = new Item();	    key2 = new Item();	    key3 = new Item();	    this.computeMaxs = computeMaxs;	  }	
public void visit (	    final int access,	    final String name,	    final String superName,	    final String[] interfaces,	    final String sourceFile)	  {	    this.access = access;	    this.name = newClass(name).index;	    this.superName = superName == null ? 0 : newClass(superName).index;	    if (interfaces != null && interfaces.length > 0) {	      interfaceCount = interfaces.length;	      this.interfaces = new int[interfaceCount];	      for (int i = 0; i < interfaceCount; ++i) {	        this.interfaces[i] = newClass(interfaces[i]).index;	      }	    }	    if (sourceFile != null) {	      newUTF8("SourceFile");	      this.sourceFile = newUTF8(sourceFile);	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      newUTF8("Deprecated");	    }	  }	
public void visitInnerClass (	    final String name,	    final String outerName,	    final String innerName,	    final int access)	  {	    if (innerClasses == null) {	      newUTF8("InnerClasses");	      innerClasses = new ByteVector();	    }	    ++innerClassesCount;	    innerClasses.put2(name == null ? 0 : newClass(name).index);	    innerClasses.put2(outerName == null ? 0 : newClass(outerName).index);	    innerClasses.put2(innerName == null ? 0 : newUTF8(innerName).index);	    innerClasses.put2(access);	  }	
public void visitField (	    final int access,	    final String name,	    final String desc,	    final Object value)	  {	    ++fieldCount;	    if (fields == null) {	      fields = new ByteVector();	    }	    fields.put2(access).put2(newUTF8(name).index).put2(newUTF8(desc).index);	    int attributeCount = 0;	    if (value != null) {	      ++attributeCount;	    }	    if ((access & Constants.ACC_SYNTHETIC) != 0) {	      ++attributeCount;	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      ++attributeCount;	    }	    fields.put2(attributeCount);	    if (value != null) {	      fields.put2(newUTF8("ConstantValue").index);	      fields.put4(2).put2(newCst(value).index);	    }	    if ((access & Constants.ACC_SYNTHETIC) != 0) {	      fields.put2(newUTF8("Synthetic").index).put4(0);	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      fields.put2(newUTF8("Deprecated").index).put4(0);	    }	  }	
public CodeVisitor visitMethod (	    final int access,	    final String name,	    final String desc,	    final String[] exceptions)	  {	    CodeWriter cw = new CodeWriter(this, computeMaxs);	    cw.init(access, name, desc, exceptions);	    return cw;	  }	
public void visitEnd () {	  }	
/**	   * Returns the bytecode of the class that was build with this class writer.	   *	   * @return the bytecode of the class that was build with this class writer.	   */		  public byte[] toByteArray () {	    // computes the real size of the bytecode of this class	    int size = 24 + 2*interfaceCount;	    if (fields != null) {	      size += fields.length;	    }	    int nbMethods = 0;	    CodeWriter cb = firstMethod;	    while (cb != null) {	      ++nbMethods;	      size += cb.getSize();	      cb = cb.next;	    }	    size += pool.length;	    int attributeCount = 0;	    if (sourceFile != null) {	      ++attributeCount;	      size += 8;	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      ++attributeCount;	      size += 6;	    }	    if (innerClasses != null) {	      ++attributeCount;	      size += 8 + innerClasses.length;	    }	    // allocates a byte vector of this size, in order to avoid unnecessary	    // arraycopy operations in the ByteVector.enlarge() method	    ByteVector out = new ByteVector(size);	    out.put4(0xCAFEBABE).put2(3).put2(45);	    out.put2(index).putByteArray(pool.data, 0, pool.length);	    out.put2(access).put2(name).put2(superName);	    out.put2(interfaceCount);	    for (int i = 0; i < interfaceCount; ++i) {	      out.put2(interfaces[i]);	    }	    out.put2(fieldCount);	    if (fields != null) {	      out.putByteArray(fields.data, 0, fields.length);	    }	    out.put2(nbMethods);	    cb = firstMethod;	    while (cb != null) {	      cb.put(out);	      cb = cb.next;	    }	    out.put2(attributeCount);	    if (sourceFile != null) {	      out.put2(newUTF8("SourceFile").index).put4(2).put2(sourceFile.index);	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      out.put2(newUTF8("Deprecated").index).put4(0);	    }	    if (innerClasses != null) {	      out.put2(newUTF8("InnerClasses").index);	      out.put4(innerClasses.length + 2).put2(innerClassesCount);	      out.putByteArray(innerClasses.data, 0, innerClasses.length);	    }	    return out.data;	  }	
/**	   * Adds a number or string constant to the constant pool of the class being	   * build. Does nothing if the constant pool already contains a similar item.	   *	   * @param cst the value of the constant to be added to the constant pool. This	   *      parameter must be an {@link java.lang.Integer Integer}, a {@link	   *      java.lang.Float Float}, a {@link java.lang.Long Long}, a {@link	          java.lang.Double Double} or a {@link String String}.	   * @return a new or already existing constant item with the given value.	   */		  Item newCst (final Object cst) {	    if (cst instanceof Integer) {	      int val = ((Integer)cst).intValue();	      return newInteger(val);	    } else if (cst instanceof Float) {	      float val = ((Float)cst).floatValue();	      return newFloat(val);	    } else if (cst instanceof Long) {	      long val = ((Long)cst).longValue();	      return newLong(val);	    } else if (cst instanceof Double) {	      double val = ((Double)cst).doubleValue();	      return newDouble(val);	    } else if (cst instanceof String) {	      return newString((String)cst);	    } else {	      throw new IllegalArgumentException("value " + cst);	    }	  }	
/**	   * Adds an UTF string to the constant pool of the class being build. Does	   * nothing if the constant pool already contains a similar item.	   *	   * @param value the String value.	   * @return a new or already existing UTF8 item.	   */		  Item newUTF8 (final String value) {	    key.set(UTF8, value, null, null);	    Item result = get(key);	    if (result == null) {	      pool.put1(UTF8).putUTF(value);	      result = new Item(index++, key);	      put(result);	    }	    return result;	  }	
/**	   * Adds a class reference to the constant pool of the class being build. Does	   * nothing if the constant pool already contains a similar item.	   *	   * @param value the internal name of the class.	   * @return a new or already existing class reference item.	   */		  Item newClass (final String value) {	    key2.set(CLASS, value, null, null);	    Item result = get(key2);	    if (result == null) {	      pool.put12(CLASS, newUTF8(value).index);	      result = new Item(index++, key2);	      put(result);	    }	    return result;	  }	
/**	   * Adds a field reference to the constant pool of the class being build. Does	   * nothing if the constant pool already contains a similar item.	   *	   * @param owner the internal name of the field's owner class.	   * @param name the field's name.	   * @param desc the field's descriptor.	   * @return a new or already existing field reference item.	   */		  Item newField (	    final String owner,	    final String name,	    final String desc)	  {	    key3.set(FIELD, owner, name, desc);	    Item result = get(key3);	    if (result == null) {	      put122(FIELD, newClass(owner).index, newNameType(name, desc).index);	      result = new Item(index++, key3);	      put(result);	    }	    return result;	  }	
/**	   * Adds a method reference to the constant pool of the class being build. Does	   * nothing if the constant pool already contains a similar item.	   *	   * @param owner the internal name of the method's owner class.	   * @param name the method's name.	   * @param desc the method's descriptor.	   * @return a new or already existing method reference item.	   */		  Item newMethod (	    final String owner,	    final String name,	    final String desc)	  {	    key3.set(METH, owner, name, desc);	    Item result = get(key3);	    if (result == null) {	      put122(METH, newClass(owner).index, newNameType(name, desc).index);	      result = new Item(index++, key3);	      put(result);	    }	    return result;	  }	
/**	   * Adds an interface method reference to the constant pool of the class being	   * build. Does nothing if the constant pool already contains a similar item.	   *	   * @param ownerItf the internal name of the method's owner interface.	   * @param name the method's name.	   * @param desc the method's descriptor.	   * @return a new or already existing interface method reference item.	   */		  Item newItfMethod (	    final String ownerItf,	    final String name,	    final String desc)	  {	    key3.set(IMETH, ownerItf, name, desc);	    Item result = get(key3);	    if (result == null) {	      put122(IMETH, newClass(ownerItf).index, newNameType(name, desc).index);	      result = new Item(index++, key3);	      put(result);	    }	    return result;	  }	
/**	   * Adds an integer to the constant pool of the class being build. Does nothing	   * if the constant pool already contains a similar item.	   *	   * @param value the int value.	   * @return a new or already existing int item.	   */		  private Item newInteger (final int value) {	    key.set(value);	    Item result = get(key);	    if (result == null) {	      pool.put1(INT).put4(value);	      result = new Item(index++, key);	      put(result);	    }	    return result;	  }	
/**	   * Adds a float to the constant pool of the class being build. Does nothing if	   * the constant pool already contains a similar item.	   *	   * @param value the float value.	   * @return a new or already existing float item.	   */		  private Item newFloat (final float value) {	    key.set(value);	    Item result = get(key);	    if (result == null) {	      pool.put1(FLOAT).put4(Float.floatToIntBits(value));	      result = new Item(index++, key);	      put(result);	    }	    return result;	  }	
/**	   * Adds a long to the constant pool of the class being build. Does nothing if	   * the constant pool already contains a similar item.	   *	   * @param value the long value.	   * @return a new or already existing long item.	   */		  private Item newLong (final long value) {	    key.set(value);	    Item result = get(key);	    if (result == null) {	      pool.put1(LONG).put8(value);	      result = new Item(index, key);	      put(result);	      index += 2;	    }	    return result;	  }	
/**	   * Adds a double to the constant pool of the class being build. Does nothing	   * if the constant pool already contains a similar item.	   *	   * @param value the double value.	   * @return a new or already existing double item.	   */		  private Item newDouble (final double value) {	    key.set(value);	    Item result = get(key);	    if (result == null) {	      pool.put1(DOUBLE).put8(Double.doubleToLongBits(value));	      result = new Item(index, key);	      put(result);	      index += 2;	    }	    return result;	  }	
/**	   * Adds a string to the constant pool of the class being build. Does nothing	   * if the constant pool already contains a similar item.	   *	   * @param value the String value.	   * @return a new or already existing string item.	   */		  private Item newString (final String value) {	    key2.set(STR, value, null, null);	    Item result = get(key2);	    if (result == null) {	      pool.put12(STR, newUTF8(value).index);	      result = new Item(index++, key2);	      put(result);	    }	    return result;	  }	
/**	   * Adds a name and type to the constant pool of the class being build. Does	   * nothing if the constant pool already contains a similar item.	   *	   * @param name a name.	   * @param desc a type descriptor.	   * @return a new or already existing name and type item.	   */		  private Item newNameType (final String name, final String desc) {	    key2.set(NAME_TYPE, name, desc, null);	    Item result = get(key2);	    if (result == null) {	      put122(NAME_TYPE, newUTF8(name).index, newUTF8(desc).index);	      result = new Item(index++, key2);	      put(result);	    }	    return result;	  }	
/**	   * Returns the constant pool's hash table item which is equal to the given	   * item.	   *	   * @param key a constant pool item.	   * @return the constant pool's hash table item which is equal to the given	   *      item, or <tt>null</tt> if there is no such item.	   */		  private Item get (final Item key) {	    Item tab[] = table;	    int hashCode = key.hashCode;	    int index = (hashCode & 0x7FFFFFFF) % tab.length;	    for (Item i = tab[index]; i != null; i = i.next) {	      if (i.hashCode == hashCode && key.isEqualTo(i)) {	        return i;	      }	    }	    return null;	  }	
/**	   * Puts the given item in the constant pool's hash table. The hash table	   * <i>must</i> not already contains this item.	   *	   * @param i the item to be added to the constant pool's hash table.	   */		  private void put (final Item i) {	    if (index > threshold) {	      int oldCapacity = table.length;	      Item oldMap[] = table;	      int newCapacity = oldCapacity * 2 + 1;	      Item newMap[] = new Item[newCapacity];	      threshold = (int)(newCapacity * 0.75);	      table = newMap;	      for (int j = oldCapacity; j-- > 0; ) {	        for (Item old = oldMap[j]; old != null; ) {	          Item e = old;	          old = old.next;	          int index = (e.hashCode & 0x7FFFFFFF) % newCapacity;	          e.next = newMap[index];	          newMap[index] = e;	        }	      }	    }	    int index = (i.hashCode & 0x7FFFFFFF) % table.length;	    i.next = table[index];	    table[index] = i;	  }	
/**	   * Puts one byte and two shorts into the constant pool.	   *	   * @param b a byte.	   * @param s1 a short.	   * @param s2 another short.	   */		  private void put122 (final int b, final int s1, final int s2) {	    pool.put12(b, s1).put2(s2);	  }	
public Widget getWidget(View view) 		{			Widget clock = new ClockWidget();			return clock;		}	
ClockWidget()			{				clock = new Clock();			}	
public JComponent getComponent() 			{				return clock;			}	
public void update() 			{			}	
public void propertiesChanged()			{			}	
Clock()			{				setForeground(jEdit.getColorProperty("view.status.foreground"));				setBackground(jEdit.getColorProperty("view.status.background"));			}	
@Override			public void addNotify()			{				super.addNotify();				update();					int millisecondsPerMinute = 1000 * 60;					timer = new Timer(millisecondsPerMinute,this);				timer.setInitialDelay((int)(					millisecondsPerMinute					- System.currentTimeMillis()					% millisecondsPerMinute) + 500);				timer.start();				ToolTipManager.sharedInstance().registerComponent(this);			}	
@Override			public void removeNotify()			{				timer.stop();				ToolTipManager.sharedInstance().unregisterComponent(this);				super.removeNotify();			}	
@Override			public String getToolTipText()			{				return new Date().toString();			}	
@Override			public Point getToolTipLocation(MouseEvent event)			{				return new Point(event.getX(),-20);			}	
public void actionPerformed(ActionEvent e)			{				update();			}	
private static String getTime()			{				return DateFormat.getTimeInstance(					DateFormat.SHORT).format(new Date());			}	
private void update()			{				setText(getTime());			}	
public CloseBracketIndentRule(char closeBracket, boolean aligned)		{			super(TextUtilities.getComplementaryBracket(closeBracket,null),				closeBracket);			this.aligned = aligned;		}	
public void apply(JEditBuffer buffer, int thisLineIndex,			int prevLineIndex, int prevPrevLineIndex,			List<IndentAction> indentActions)		{			int index;			if(aligned)				index = thisLineIndex;			else				index = prevLineIndex;				if(index == -1)				return;				CharSequence lineText = buffer.getLineSegment(index);			int offset;			for (offset = lineText.length() - 1; offset >= 0; offset--)			{				if (lineText.charAt(offset) == closeBracket)					break;			}			if(offset == -1)				return;				int closeCount = getBrackets(buffer, index).closeCount;			if(closeCount != 0)			{				AlignBracket alignBracket					= new AlignBracket(buffer,index,offset);				/*				Consider the following Common Lisp code (with one more opening				bracket than closing):					(defun emit-push-long (arg)				  (cond ((eql arg 0)				      (emit 'lconst_0))				    ((eql arg 1)				      (emit 'lconst_1)))					even though we have a closing bracket match on line 3,				the next line must be indented relative to the				corresponding opening bracket from line 1.				*/				int openLine = alignBracket.getOpenBracketLine();				if(openLine != -1)				{					int column = alignBracket.getOpenBracketColumn();					alignBracket.setExtraIndent(						getBrackets(buffer, openLine,							0, column).openCount);				}					indentActions.add(alignBracket);			}		}	
/**		 * @deprecated		 *   This method calls BracketIndentRule#getBrackets(String)		 *   which has been deprecated.		 */		@Deprecated		public boolean isMatch(String line)		{			return getBrackets(line).closeCount != 0;		}	
public AlignBracket(JEditBuffer buffer, int line, int offset)			{				this.line = line;				this.offset = offset;					int openBracketIndex = TextUtilities.findMatchingBracket(					buffer,this.line,this.offset);				if(openBracketIndex == -1)					openBracketLine = -1;				else				{					openBracketLine = buffer.getLineOfOffset(openBracketIndex);					openBracketColumn = openBracketIndex -						buffer.getLineStartOffset(openBracketLine);					openBracketLineText = buffer.getLineSegment(openBracketLine);				}			}	
public int getExtraIndent()			{				return extraIndent;			}	
public void setExtraIndent(int extraIndent)			{				this.extraIndent = extraIndent;			}	
public int getOpenBracketColumn()			{				return openBracketColumn;			}	
public int getOpenBracketLine()			{				return openBracketLine;			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,				int newIndent)			{				if(openBracketLineText == null)					return newIndent;				else				{					return StandardUtilities.getLeadingWhiteSpaceWidth(						openBracketLineText,buffer.getTabSize())						+ (extraIndent * buffer.getIndentSize());				}			}	
public boolean keepChecking()			{				return false;			}	
public CloseDialog(View view)		{			this(view, Arrays.asList(jEdit.getBuffers()));		}	
public CloseDialog(View view, Collection<Buffer> buffers)		{			super(view,jEdit.getProperty("close.title"),true);				this.view = view;				JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				Box iconBox = new Box(BoxLayout.Y_AXIS);			iconBox.add(new JLabel(UIManager.getIcon("OptionPane.warningIcon")));			iconBox.add(Box.createGlue());			content.add(BorderLayout.WEST,iconBox);				JPanel centerPanel = new JPanel(new BorderLayout());				JLabel label = new JLabel(jEdit.getProperty("close.caption"));			label.setBorder(new EmptyBorder(0,0,6,0));			centerPanel.add(BorderLayout.NORTH,label);				bufferList = new JList(bufferModel = new DefaultListModel());			bufferList.setVisibleRowCount(10);			bufferList.addListSelectionListener(new ListHandler());				for(Buffer buffer: buffers)			{				if(buffer.isDirty()) 					bufferModel.addElement(buffer.getPath()); 			}				centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferList));				content.add(BorderLayout.CENTER,centerPanel);				ActionHandler actionListener = new ActionHandler();				Box buttons = new Box(BoxLayout.X_AXIS);			buttons.add(Box.createGlue());			buttons.add(selectAll = new JButton(jEdit.getProperty("close.selectAll")));			selectAll.setMnemonic(jEdit.getProperty("close.selectAll.mnemonic").charAt(0));			selectAll.addActionListener(actionListener);			buttons.add(Box.createHorizontalStrut(6));			buttons.add(save = new JButton(jEdit.getProperty("close.save")));			save.setMnemonic(jEdit.getProperty("close.save.mnemonic").charAt(0));			save.addActionListener(actionListener);			buttons.add(Box.createHorizontalStrut(6));			buttons.add(discard = new JButton(jEdit.getProperty("close.discard")));			discard.setMnemonic(jEdit.getProperty("close.discard.mnemonic").charAt(0));			discard.addActionListener(actionListener);			buttons.add(Box.createHorizontalStrut(6));			buttons.add(cancel = new JButton(jEdit.getProperty("common.cancel")));			cancel.addActionListener(actionListener);			buttons.add(Box.createGlue());			bufferList.setSelectedIndex(0);			content.add(BorderLayout.SOUTH,buttons);			content.getRootPane().setDefaultButton(cancel);			GUIUtilities.requestFocus(this,bufferList);			pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public boolean isOK()		{			return ok;		}	
@Override		public void ok()		{			// do nothing		}	
@Override		public void cancel()		{			dispose();		}	
private void updateButtons()		{			int index = bufferList.getSelectedIndex();			save.getModel().setEnabled(index != -1);			discard.getModel().setEnabled(index != -1);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == selectAll)				{					// I'm too tired to think of a better way					// to handle this right now.					try					{						selectAllFlag = true;							bufferList.setSelectionInterval(0,							bufferModel.getSize() - 1);					}					finally					{						selectAllFlag = false;					}					bufferList.requestFocus();				}				else if(source == save)				{					Object[] paths = bufferList.getSelectedValues();						for(int i = 0; i < paths.length; i++)					{						String path = (String)paths[i];						Buffer buffer = jEdit.getBuffer(path);						if(!buffer.save(view,null,true,true))							return;						VFSManager.waitForRequests();						if(buffer.getBooleanProperty(BufferIORequest							.ERROR_OCCURRED))							return;						jEdit._closeBuffer(view,buffer);						bufferModel.removeElement(path);					}						if(bufferModel.getSize() == 0)					{						ok = true;						dispose();					}					else					{						bufferList.setSelectedIndex(0);						bufferList.requestFocus();					}				}				else if(source == discard)				{					Object[] paths = bufferList.getSelectedValues();						for(int i = 0; i < paths.length; i++)					{						String path = (String)paths[i];						Buffer buffer = jEdit.getBuffer(path);						jEdit._closeBuffer(view,buffer);						bufferModel.removeElement(path);					}						if(bufferModel.getSize() == 0)					{						ok = true;						dispose();					}					else					{						bufferList.setSelectedIndex(0);						bufferList.requestFocus();					}				}				else if(source == cancel)					cancel();			}	
public void valueChanged(ListSelectionEvent evt)			{				if(selectAllFlag)					return;					int index = bufferList.getSelectedIndex();				if(index != -1)				{					String path = (String) bufferModel.getElementAt(index);					Buffer buffer = jEdit.getBuffer(path);					if (buffer == null)					{						// it seems this buffer was already closed						Log.log(Log.DEBUG, this, "Buffer " + path + " is already closed");						bufferModel.removeElementAt(index);					}					else					{						view.showBuffer(buffer);					}				}					updateButtons();			}	
/**	   * Constructs a CodeWriter.	   *	   * @param cw the class writer in which the method must be added.	   * @param computeMaxs <tt>true</tt> if the maximum stack size and number of	   *      local variables must be automatically computed.	   */		  protected CodeWriter (final ClassWriter cw, final boolean computeMaxs) {	    if (cw.firstMethod == null) {	      cw.firstMethod = this;	      cw.lastMethod = this;	    } else {	      cw.lastMethod.next = this;	      cw.lastMethod = this;	    }	    this.cw = cw;	    this.computeMaxs = computeMaxs;	    if (computeMaxs) {	      // pushes the first block onto the stack of blocks to be visited	      currentBlock = new Label();	      currentBlock.pushed = true;	      blockStack = currentBlock;	    }	  }	
/**	   * Initializes this CodeWriter to define the bytecode of the specified method.	   *	   * @param access the method's access flags (see {@link Constants}).	   * @param name the method's name.	   * @param desc the method's descriptor (see {@link Type Type}).	   * @param exceptions the internal names of the method's exceptions. May be	   *      <tt>null</tt>.	   */		  protected void init (	    final int access,	    final String name,	    final String desc,	    final String[] exceptions)	  {	    this.access = access;	    this.name = cw.newUTF8(name);	    this.desc = cw.newUTF8(desc);	    if (exceptions != null && exceptions.length > 0) {	      exceptionCount = exceptions.length;	      this.exceptions = new int[exceptionCount];	      for (int i = 0; i < exceptionCount; ++i) {	        this.exceptions[i] = cw.newClass(exceptions[i]).index;	      }	    }	    if (computeMaxs) {	      // updates maxLocals	      int size = getArgumentsAndReturnSizes(desc) >> 2;	      if ((access & Constants.ACC_STATIC) != 0) {	        --size;	      }	      if (size > maxLocals) {	        maxLocals = size;	      }	    }	  }	
public void visitInsn (final int opcode) {	    if (computeMaxs) {	      // updates current and max stack sizes	      int size = stackSize + SIZE[opcode];	      if (size > maxStackSize) {	        maxStackSize = size;	      }	      stackSize = size;	      // if opcode == ATHROW or xRETURN, ends current block (no successor)	      if ((opcode >= Constants.IRETURN && opcode <= Constants.RETURN) ||	          opcode == Constants.ATHROW)	      {	        if (currentBlock != null) {	          currentBlock.maxStackSize = maxStackSize;	          currentBlock = null;	        }	      }	    }	    // adds the instruction to the bytecode of the method	    code.put1(opcode);	  }	
public void visitIntInsn (final int opcode, final int operand) {	    if (computeMaxs && opcode != Constants.NEWARRAY) {	      // updates current and max stack sizes only if opcode == NEWARRAY	      // (stack size variation = 0 for BIPUSH or SIPUSH)	      int size = stackSize + 1;	      if (size > maxStackSize) {	        maxStackSize = size;	      }	      stackSize = size;	    }	    // adds the instruction to the bytecode of the method	    if (opcode == Constants.SIPUSH) {	      code.put12(opcode, operand);	    } else { // BIPUSH or NEWARRAY	      code.put11(opcode, operand);	    }	  }	
public void visitVarInsn (final int opcode, final int var) {	    if (computeMaxs) {	      // updates current and max stack sizes	      if (opcode == Constants.RET) {	        // no stack change, but end of current block (no successor)	        if (currentBlock != null) {	          currentBlock.maxStackSize = maxStackSize;	          currentBlock = null;	        }	      } else { // xLOAD or xSTORE	        int size = stackSize + SIZE[opcode];	        if (size > maxStackSize) {	          maxStackSize = size;	        }	        stackSize = size;	      }	      // updates max locals	      int n;	      if (opcode == Constants.LLOAD || opcode == Constants.DLOAD ||	          opcode == Constants.LSTORE || opcode == Constants.DSTORE)	      {	        n = var + 2;	      } else {	        n = var + 1;	      }	      if (n > maxLocals) {	        maxLocals = n;	      }	    }	    // adds the instruction to the bytecode of the method	    if (var < 4 && opcode != Constants.RET) {	      int opt;	      if (opcode < Constants.ISTORE) {	        opt = 26 /*ILOAD_0*/ + ((opcode - Constants.ILOAD) << 2) + var;	      } else {	        opt = 59 /*ISTORE_0*/ + ((opcode - Constants.ISTORE) << 2) + var;	      }	      code.put1(opt);	    } else if (var >= 256) {	      code.put1(196 /*WIDE*/).put12(opcode, var);	    } else {	      code.put11(opcode, var);	    }	  }	
public void visitTypeInsn (final int opcode, final String desc) {	    if (computeMaxs && opcode == Constants.NEW) {	      // updates current and max stack sizes only if opcode == NEW	      // (stack size variation = 0 for ANEWARRAY, CHECKCAST, INSTANCEOF)	      int size = stackSize + 1;	      if (size > maxStackSize) {	        maxStackSize = size;	      }	      stackSize = size;	    }	    // adds the instruction to the bytecode of the method	    code.put12(opcode, cw.newClass(desc).index);	  }	
public void visitFieldInsn (	    final int opcode,	    final String owner,	    final String name,	    final String desc)	  {	    if (computeMaxs) {	      int size;	      // computes the stack size variation	      char c = desc.charAt(0);	      switch (opcode) {	        case Constants.GETSTATIC:	          size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);	          break;	        case Constants.PUTSTATIC:	          size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);	          break;	        case Constants.GETFIELD:	          size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);	          break;	        //case Constants.PUTFIELD:	        default:	          size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);	          break;	      }	      // updates current and max stack sizes	      if (size > maxStackSize) {	        maxStackSize = size;	      }	      stackSize = size;	    }	    // adds the instruction to the bytecode of the method	    code.put12(opcode, cw.newField(owner, name, desc).index);	  }	
public void visitMethodInsn (	    final int opcode,	    final String owner,	    final String name,	    final String desc)	  {	    Item i;	    if (opcode == Constants.INVOKEINTERFACE) {	      i = cw.newItfMethod(owner, name, desc);	    } else {	      i = cw.newMethod(owner, name, desc);	    }	    int argSize = i.intVal;	    if (computeMaxs) {	      // computes the stack size variation. In order not to recompute several	      // times this variation for the same Item, we use the intVal field of	      // this item to store this variation, once it has been computed. More	      // precisely this intVal field stores the sizes of the arguments and of	      // the return value corresponding to desc.	      if (argSize == 0) {	        // the above sizes have not been computed yet, so we compute them...	        argSize = getArgumentsAndReturnSizes(desc);	        // ... and we save them in order not to recompute them in the future	        i.intVal = argSize;	      }	      int size;	      if (opcode == Constants.INVOKESTATIC) {	        size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;	      } else {	        size = stackSize - (argSize >> 2) + (argSize & 0x03);	      }	      // updates current and max stack sizes	      if (size > maxStackSize) {	        maxStackSize = size;	      }	      stackSize = size;	    }	    // adds the instruction to the bytecode of the method	    if (opcode == Constants.INVOKEINTERFACE) {	      if (!computeMaxs) {	        if (argSize == 0) {	          argSize = getArgumentsAndReturnSizes(desc);	          i.intVal = argSize;	        }	      }	      code.put12(Constants.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);	    } else {	      code.put12(opcode, i.index);	    }	  }	
public void visitJumpInsn (final int opcode, final Label label) {	    if (CHECK) {	      if (label.owner == null) {	        label.owner = this;	      } else if (label.owner != this) {	        throw new IllegalArgumentException();	      }	    }	    if (computeMaxs) {	      if (opcode == Constants.GOTO) {	        // no stack change, but end of current block (with one new successor)	        if (currentBlock != null) {	          currentBlock.maxStackSize = maxStackSize;	          addSuccessor(stackSize, label);	          currentBlock = null;	        }	      } else if (opcode == Constants.JSR) {	        if (currentBlock != null) {	          addSuccessor(stackSize + 1, label);	        }	      } else {	        // updates current stack size (max stack size unchanged because stack	        // size variation always negative in this case)	        stackSize += SIZE[opcode];	        if (currentBlock != null) {	          addSuccessor(stackSize, label);	        }	      }	    }	    // adds the instruction to the bytecode of the method	    if (label.resolved && label.position - code.length < Short.MIN_VALUE) {	      // case of a backward jump with an offset < -32768. In this case we	      // automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx <l>	      // with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the "opposite" opcode	      // of IFxxx (i.e., IFNE for IFEQ) and where <l'> designates the	      // instruction just after the GOTO_W.	      if (opcode == Constants.GOTO) {	        code.put1(200); // GOTO_W	      } else if (opcode == Constants.JSR) {	        code.put1(201); // JSR_W	      } else {	        code.put1(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);	        code.put2(8);   // jump offset	        code.put1(200); // GOTO_W	      }	      label.put(this, code, code.length - 1, true);	    } else {	      // case of a backward jump with an offset >= -32768, or of a forward jump	      // with, of course, an unknown offset. In these cases we store the offset	      // in 2 bytes (which will be increased in resizeInstructions, if needed).	      code.put1(opcode);	      label.put(this, code, code.length - 1, false);	    }	  }	
public void visitLabel (final Label label) {	    if (CHECK) {	      if (label.owner == null) {	        label.owner = this;	      } else if (label.owner != this) {	        throw new IllegalArgumentException();	      }	    }	    if (computeMaxs) {	      if (currentBlock != null) {	        // ends current block (with one new successor)	        currentBlock.maxStackSize = maxStackSize;	        addSuccessor(stackSize, label);	      }	      // begins a new current block,	      // resets the relative current and max stack sizes	      currentBlock = label;	      stackSize = 0;	      maxStackSize = 0;	    }	    // resolves previous forward references to label, if any	    resize |= label.resolve(this, code.length, code.data);	  }	
public void visitLdcInsn (final Object cst) {	    Item i = cw.newCst(cst);	    if (computeMaxs) {	      int size;	      // computes the stack size variation	      if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {	        size = stackSize + 2;	      } else {	        size = stackSize + 1;	      }	      // updates current and max stack sizes	      if (size > maxStackSize) {	        maxStackSize = size;	      }	      stackSize = size;	    }	    // adds the instruction to the bytecode of the method	    int index = i.index;	    if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {	      code.put12(20 /*LDC2_W*/, index);	    } else if (index >= 256) {	      code.put12(19 /*LDC_W*/, index);	    } else {	      code.put11(Constants.LDC, index);	    }	  }	
public void visitIincInsn (final int var, final int increment) {	    if (computeMaxs) {	      // updates max locals only (no stack change)	      int n = var + 1;	      if (n > maxLocals) {	        maxLocals = n;	      }	    }	    // adds the instruction to the bytecode of the method	    if ((var > 255) || (increment > 127) || (increment < -128)) {	      code.put1(196 /*WIDE*/).put12(Constants.IINC, var).put2(increment);	    } else {	      code.put1(Constants.IINC).put11(var, increment);	    }	  }	
public void visitTableSwitchInsn (	    final int min,	    final int max,	    final Label dflt,	    final Label labels[])	  {	    if (computeMaxs) {	      // updates current stack size (max stack size unchanged)	      --stackSize;	      // ends current block (with many new successors)	      if (currentBlock != null) {	        currentBlock.maxStackSize = maxStackSize;	        addSuccessor(stackSize, dflt);	        for (int i = 0; i < labels.length; ++i) {	          addSuccessor(stackSize, labels[i]);	        }	        currentBlock = null;	      }	    }	    // adds the instruction to the bytecode of the method	    int source = code.length;	    code.put1(Constants.TABLESWITCH);	    while (code.length % 4 != 0) {	      code.put1(0);	    }	    dflt.put(this, code, source, true);	    code.put4(min).put4(max);	    for (int i = 0; i < labels.length; ++i) {	      labels[i].put(this, code, source, true);	    }	  }	
public void visitLookupSwitchInsn (	    final Label dflt,	    final int keys[],	    final Label labels[])	  {	    if (computeMaxs) {	      // updates current stack size (max stack size unchanged)	      --stackSize;	      // ends current block (with many new successors)	      if (currentBlock != null) {	        currentBlock.maxStackSize = maxStackSize;	        addSuccessor(stackSize, dflt);	        for (int i = 0; i < labels.length; ++i) {	          addSuccessor(stackSize, labels[i]);	        }	        currentBlock = null;	      }	    }	    // adds the instruction to the bytecode of the method	    int source = code.length;	    code.put1(Constants.LOOKUPSWITCH);	    while (code.length % 4 != 0) {	      code.put1(0);	    }	    dflt.put(this, code, source, true);	    code.put4(labels.length);	    for (int i = 0; i < labels.length; ++i) {	      code.put4(keys[i]);	      labels[i].put(this, code, source, true);	    }	  }	
public void visitMultiANewArrayInsn (final String desc, final int dims) {	    if (computeMaxs) {	      // updates current stack size (max stack size unchanged because stack	      // size variation always negative or null)	      stackSize += 1 - dims;	    }	    // adds the instruction to the bytecode of the method	    Item classItem = cw.newClass(desc);	    code.put12(Constants.MULTIANEWARRAY, classItem.index).put1(dims);	  }	
public void visitTryCatchBlock (	    final Label start,	    final Label end,	    final Label handler,	    final String type)	  {	    if (CHECK) {	      if (start.owner != this || end.owner != this || handler.owner != this) {	        throw new IllegalArgumentException();	      }	      if (!start.resolved || !end.resolved || !handler.resolved) {	        throw new IllegalArgumentException();	      }	    }	    if (computeMaxs) {	      // pushes handler block onto the stack of blocks to be visited	      if (!handler.pushed) {	        handler.beginStackSize = 1;	        handler.pushed = true;	        handler.next = blockStack;	        blockStack = handler;	      }	    }	    ++catchCount;	    if (catchTable == null) {	      catchTable = new ByteVector();	    }	    catchTable.put2(start.position);	    catchTable.put2(end.position);	    catchTable.put2(handler.position);	    catchTable.put2(type != null ? cw.newClass(type).index : 0);	  }	
public void visitMaxs (final int maxStack, final int maxLocals) {	    if (computeMaxs) {	      // true (non relative) max stack size	      int max = 0;	      // control flow analysis algorithm: while the block stack is not empty,	      // pop a block from this stack, update the max stack size, compute	      // the true (non relative) begin stack size of the successors of this	      // block, and push these successors onto the stack (unless they have	      // already been pushed onto the stack). Note: by hypothesis, the {@link	      // Label#beginStackSize} of the blocks in the block stack are the true	      // (non relative) beginning stack sizes of these blocks.	      Label stack = blockStack;	      while (stack != null) {	        // pops a block from the stack	        Label l = stack;	        stack = stack.next;	        // computes the true (non relative) max stack size of this block	        int start = l.beginStackSize;	        int blockMax = start + l.maxStackSize;	        // updates the global max stack size	        if (blockMax > max) {	          max = blockMax;	        }	        // analyses the successors of the block	        Edge b = l.successors;	        while (b != null) {	          l = b.successor;	          // if this successor has not already been pushed onto the stack...	          if (!l.pushed) {	            // computes the true beginning stack size of this successor block	            l.beginStackSize = start + b.stackSize;	            // pushes this successor onto the stack	            l.pushed = true;	            l.next = stack;	            stack = l;	          }	          b = b.next;	        }	      }	      this.maxStack = max;	      // releases all the Edge objects used by this CodeWriter	      synchronized (SIZE) {	        // appends the [head ... tail] list at the beginning of the pool list	        if (tail != null) {	          tail.poolNext = pool;	          pool = head;	        }	      }	    } else {	      this.maxStack = maxStack;	      this.maxLocals = maxLocals;	    }	  }	
public void visitLocalVariable (	    final String name,	    final String desc,	    final Label start,	    final Label end,	    final int index)	  {	    if (CHECK) {	      if (start.owner != this || !start.resolved) {	        throw new IllegalArgumentException();	      }	      if (end.owner != this || !end.resolved) {	        throw new IllegalArgumentException();	      }	    }	    if (localVar == null) {	      cw.newUTF8("LocalVariableTable");	      localVar = new ByteVector();	    }	    ++localVarCount;	    localVar.put2(start.position);	    localVar.put2(end.position - start.position);	    localVar.put2(cw.newUTF8(name).index);	    localVar.put2(cw.newUTF8(desc).index);	    localVar.put2(index);	  }	
public void visitLineNumber (final int line, final Label start) {	    if (CHECK) {	      if (start.owner != this || !start.resolved) {	        throw new IllegalArgumentException();	      }	    }	    if (lineNumber == null) {	      cw.newUTF8("LineNumberTable");	      lineNumber = new ByteVector();	    }	    ++lineNumberCount;	    lineNumber.put2(start.position);	    lineNumber.put2(line);	  }	
/**	   * Computes the size of the arguments and of the return value of a method.	   *	   * @param desc the descriptor of a method.	   * @return the size of the arguments of the method (plus one for the implicit	   *      this argument), argSize, and the size of its return value, retSize,	   *      packed into a single int i = <tt>(argSize << 2) | retSize</tt>	   *      (argSize is therefore equal to <tt>i >> 2</tt>, and retSize to	   *      <tt>i & 0x03</tt>).	   */		  private static int getArgumentsAndReturnSizes (final String desc) {	    int n = 1;	    int c = 1;	    while (true) {	      char car = desc.charAt(c++);	      if (car == ')') {	        car = desc.charAt(c);	        return n << 2 | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));	      } else if (car == 'L') {	        while (desc.charAt(c++) != ';') {	        }	        n += 1;	      } else if (car == '[') {	        while ((car = desc.charAt(c)) == '[') {	          ++c;	        }	        if (car == 'D' || car == 'J') {	          n -= 1;	        }	      } else if (car == 'D' || car == 'J') {	        n += 2;	      } else {	        n += 1;	      }	    }	  }	
/**	   * Adds a successor to the {@link #currentBlock currentBlock} block.	   *	   * @param stackSize the current (relative) stack size in the current block.	   * @param successor the successor block to be added to the current block.	   */		  private void addSuccessor (final int stackSize, final Label successor) {	    Edge b;	    // creates a new Edge object or reuses one from the shared pool	    synchronized (SIZE) {	      if (pool == null) {	        b = new Edge();	      } else {	        b = pool;	        // removes b from the pool	        pool = pool.poolNext;	      }	    }	    // adds the previous Edge to the list of Edges used by this CodeWriter	    if (tail == null) {	      tail = b;	    }	    b.poolNext = head;	    head = b;	    // initializes the previous Edge object...	    b.stackSize = stackSize;	    b.successor = successor;	    // ...and adds it to the successor list of the currentBlock block	    b.next = currentBlock.successors;	    currentBlock.successors = b;	  }	
/**	   * Returns the size of the bytecode of this method.	   *	   * @return the size of the bytecode of this method.	   */		  final int getSize () {	    if (resize) {	      // replaces the temporary jump opcodes introduced by Label.resolve.	      resizeInstructions(new int[0], new int[0], 0);	    }	    int size = 8;	    if (code.length > 0) {	      cw.newUTF8("Code");	      size += 18 + code.length + 8 * catchCount;	      if (localVar != null) {	        size += 8 + localVar.length;	      }	      if (lineNumber != null) {	        size += 8 + lineNumber.length;	      }	    }	    if (exceptionCount > 0) {	      cw.newUTF8("Exceptions");	      size += 8 + 2 * exceptionCount;	    }	    if ((access & Constants.ACC_SYNTHETIC) != 0) {	      cw.newUTF8("Synthetic");	      size += 6;	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      cw.newUTF8("Deprecated");	      size += 6;	    }	    return size;	  }	
/**	   * Puts the bytecode of this method in the given byte vector.	   *	   * @param out the byte vector into which the bytecode of this method must be	   *      copied.	   */		  final void put (final ByteVector out) {	    out.put2(access).put2(name.index).put2(desc.index);	    int attributeCount = 0;	    if (code.length > 0) {	      ++attributeCount;	    }	    if (exceptionCount > 0) {	      ++attributeCount;	    }	    if ((access & Constants.ACC_SYNTHETIC) != 0) {	      ++attributeCount;	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      ++attributeCount;	    }	    out.put2(attributeCount);	    if (code.length > 0) {	      int size = 12 + code.length + 8 * catchCount;	      if (localVar != null) {	        size += 8 + localVar.length;	      }	      if (lineNumber != null) {	        size += 8 + lineNumber.length;	      }	      out.put2(cw.newUTF8("Code").index).put4(size);	      out.put2(maxStack).put2(maxLocals);	      out.put4(code.length).putByteArray(code.data, 0, code.length);	      out.put2(catchCount);	      if (catchCount > 0) {	        out.putByteArray(catchTable.data, 0, catchTable.length);	      }	      attributeCount = 0;	      if (localVar != null) {	        ++attributeCount;	      }	      if (lineNumber != null) {	        ++attributeCount;	      }	      out.put2(attributeCount);	      if (localVar != null) {	        out.put2(cw.newUTF8("LocalVariableTable").index);	        out.put4(localVar.length + 2).put2(localVarCount);	        out.putByteArray(localVar.data, 0, localVar.length);	      }	      if (lineNumber != null) {	        out.put2(cw.newUTF8("LineNumberTable").index);	        out.put4(lineNumber.length + 2).put2(lineNumberCount);	        out.putByteArray(lineNumber.data, 0, lineNumber.length);	      }	    }	    if (exceptionCount > 0) {	      out.put2(cw.newUTF8("Exceptions").index).put4(2 * exceptionCount + 2);	      out.put2(exceptionCount);	      for (int i = 0; i < exceptionCount; ++i) {	        out.put2(exceptions[i]);	      }	    }	    if ((access & Constants.ACC_SYNTHETIC) != 0) {	      out.put2(cw.newUTF8("Synthetic").index).put4(0);	    }	    if ((access & Constants.ACC_DEPRECATED) != 0) {	      out.put2(cw.newUTF8("Deprecated").index).put4(0);	    }	  }	
/**	   * Resizes the designated instructions, while keeping jump offsets and	   * instruction addresses consistent. This may require to resize other existing	   * instructions, or even to introduce new instructions: for example,	   * increasing the size of an instruction by 2 at the middle of a method can	   * increases the offset of an IFEQ instruction from 32766 to 32768, in which	   * case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W 32765. This, in turn,	   * may require to increase the size of another jump instruction, and so on...	   * All these operations are handled automatically by this method.	   * <p>	   * <i>This method must be called after all the method that is being built has	   * been visited</i>. In particular, the {@link Label Label} objects used to	   * construct the method are no longer valid after this method has been called.	   *	   * @param indexes current positions of the instructions to be resized. Each	   *      instruction must be designated by the index of its <i>last</i> byte,	   *      plus one (or, in other words, by the index of the <i>first</i> byte of	   *      the <i>next</i> instruction).	   * @param sizes the number of bytes to be <i>added</i> to the above	   *      instructions. More precisely, for each i &lt; <tt>len</tt>,	   *      <tt>sizes</tt>[i] bytes will be added at the end of the instruction	   *      designated by <tt>indexes</tt>[i] or, if <tt>sizes</tt>[i] is	   *      negative, the <i>last</i> |<tt>sizes[i]</tt>| bytes of the instruction	   *      will be removed (the instruction size <i>must not</i> become negative	   *      or null). The gaps introduced by this method must be filled in	   *      "manually" in the array returned by the {@link #getCode getCode}	   *      method.	   * @param len the number of instruction to be resized. Must be smaller than or	   *      equal to <tt>indexes</tt>.length and <tt>sizes</tt>.length.	   * @return the <tt>indexes</tt> array, which now contains the new positions of	   *      the resized instructions (designated as above).	   */		  protected int[] resizeInstructions (	    final int[] indexes,	    final int[] sizes,	    final int len)	  {	    byte[] b = code.data; // bytecode of the method	    int u, v, label;      // indexes in b	    int i, j;             // loop indexes		    // 1st step:	    // As explained above, resizing an instruction may require to resize another	    // one, which may require to resize yet another one, and so on. The first	    // step of the algorithm consists in finding all the instructions that	    // need to be resized, without modifying the code. This is done by the	    // following "fix point" algorithm:	    // - parse the code to find the jump instructions whose offset will need	    //   more than 2 bytes to be stored (the future offset is computed from the	    //   current offset and from the number of bytes that will be inserted or	    //   removed between the source and target instructions). For each such	    //   instruction, adds an entry in (a copy of) the indexes and sizes arrays	    //   (if this has not already been done in a previous iteration!)	    // - if at least one entry has been added during the previous step, go back	    //   to the beginning, otherwise stop.	    // In fact the real algorithm is complicated by the fact that the size of	    // TABLESWITCH and LOOKUPSWITCH instructions depends on their position in	    // the bytecode (because of padding). In order to ensure the convergence of	    // the algorithm, the number of bytes to be added or removed from these	    // instructions is over estimated during the previous loop, and computed	    // exactly only after the loop is finished (this requires another pass to	    // parse the bytecode of the method).		    int[] allIndexes = new int[len]; // copy of indexes	    int[] allSizes = new int[len];   // copy of sizes	    boolean[] resize;                // instructions to be resized	    int newOffset;                   // future offset of a jump instruction		    System.arraycopy(indexes, 0, allIndexes, 0, len);	    System.arraycopy(sizes, 0, allSizes, 0, len);	    resize = new boolean[code.length];		    int state = 3; // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done	    do {	      if (state == 3) {	        state = 2;	      }	      u = 0;	      while (u < b.length) {	        int opcode = b[u] & 0xFF;  // opcode of current instruction	        int insert = 0;            // bytes to be added after this instruction		        switch (ClassWriter.TYPE[opcode]) {	          case ClassWriter.NOARG_INSN:	          case ClassWriter.IMPLVAR_INSN:	            u += 1;	            break;	          case ClassWriter.LABEL_INSN:	            if (opcode > 201) {	              // converts temporary opcodes 202 to 217 (inclusive), 218 and 219	              // to IFEQ ... JSR (inclusive), IFNULL and IFNONNULL	              opcode = opcode < 218 ? opcode - 49 : opcode - 20;	              label = u + readUnsignedShort(b, u + 1);	            } else {	              label = u + readShort(b, u + 1);	            }	            newOffset = getNewOffset(allIndexes, allSizes, u, label);	            if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {	              if (!resize[u]) {	                if (opcode == Constants.GOTO || opcode == Constants.JSR) {	                  // two additional bytes will be required to replace this	                  // GOTO or JSR instruction with a GOTO_W or a JSR_W	                  insert = 2;	                } else {	                  // five additional bytes will be required to replace this	                  // IFxxx <l> instruction with IFNOTxxx <l'> GOTO_W <l>, where	                  // IFNOTxxx is the "opposite" opcode of IFxxx (i.e., IFNE for	                  // IFEQ) and where <l'> designates the instruction just after	                  // the GOTO_W.	                  insert = 5;	                }	                resize[u] = true;	              }	            }	            u += 3;	            break;	          case ClassWriter.LABELW_INSN:	            u += 5;	            break;	          case ClassWriter.TABL_INSN:	            if (state == 1) {	              // true number of bytes to be added (or removed) from this	              // instruction = (future number of padding bytes - current number	              // of padding byte) - previously over estimated variation =	              // = ((3 - newOffset%4) - (3 - u%4)) - u%4	              // = (-newOffset%4 + u%4) - u%4	              // = -(newOffset & 3)	              newOffset = getNewOffset(allIndexes, allSizes, 0, u);	              insert = -(newOffset & 3);	            } else if (!resize[u]) {	              // over estimation of the number of bytes to be added to this	              // instruction = 3 - current number of padding bytes = 3 - (3 -	              // u%4) = u%4 = u & 3	              insert = u & 3;	              resize[u] = true;	            }	            // skips instruction	            u = u + 4 - (u & 3);	            u += 4*(readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;	            break;	          case ClassWriter.LOOK_INSN:	            if (state == 1) {	              // like TABL_INSN	              newOffset = getNewOffset(allIndexes, allSizes, 0, u);	              insert = -(newOffset & 3);	            } else if (!resize[u]) {	              // like TABL_INSN	              insert = u & 3;	              resize[u] = true;	            }	            // skips instruction	            u = u + 4 - (u & 3);	            u += 8*readInt(b, u + 4) + 8;	            break;	          case ClassWriter.WIDE_INSN:	            opcode = b[u + 1] & 0xFF;	            if (opcode == Constants.IINC) {	              u += 6;	            } else {	              u += 4;	            }	            break;	          case ClassWriter.VAR_INSN:	          case ClassWriter.SBYTE_INSN:	          case ClassWriter.LDC_INSN:	            u += 2;	            break;	          case ClassWriter.SHORT_INSN:	          case ClassWriter.LDCW_INSN:	          case ClassWriter.FIELDORMETH_INSN:	          case ClassWriter.TYPE_INSN:	          case ClassWriter.IINC_INSN:	            u += 3;	            break;	          case ClassWriter.ITFMETH_INSN:	            u += 5;	            break;	          // case ClassWriter.MANA_INSN:	          default:	            u += 4;	            break;	        }	        if (insert != 0) {	          // adds a new (u, insert) entry in the allIndexes and allSizes arrays	          int[] newIndexes = new int[allIndexes.length + 1];	          int[] newSizes = new int[allSizes.length + 1];	          System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);	          System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);	          newIndexes[allIndexes.length] = u;	          newSizes[allSizes.length] = insert;	          allIndexes = newIndexes;	          allSizes = newSizes;	          if (insert > 0) {	            state = 3;	          }	        }	      }	      if (state < 3) {	        --state;	      }	    } while (state != 0);		    // 2nd step:	    // copies the bytecode of the method into a new bytevector, updates the	    // offsets, and inserts (or removes) bytes as requested.		    ByteVector newCode = new ByteVector(code.length);		    u = 0;	    while (u < code.length) {	      for (i = allIndexes.length - 1; i >= 0; --i) {	        if (allIndexes[i] == u) {	          if (i < len) {	            if (sizes[i] > 0) {	              newCode.putByteArray(null, 0, sizes[i]);	            } else {	              newCode.length += sizes[i];	            }	            indexes[i] = newCode.length;	          }	        }	      }	      int opcode = b[u] & 0xFF;	      switch (ClassWriter.TYPE[opcode]) {	        case ClassWriter.NOARG_INSN:	        case ClassWriter.IMPLVAR_INSN:	          newCode.put1(opcode);	          u += 1;	          break;	        case ClassWriter.LABEL_INSN:	          if (opcode > 201) {	            // changes temporary opcodes 202 to 217 (inclusive), 218 and 219	            // to IFEQ ... JSR (inclusive), IFNULL and IFNONNULL	            opcode = opcode < 218 ? opcode - 49 : opcode - 20;	            label = u + readUnsignedShort(b, u + 1);	          } else {	            label = u + readShort(b, u + 1);	          }	          newOffset = getNewOffset(allIndexes, allSizes, u, label);	          if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {	            // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx <l> with	            // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the "opposite" opcode	            // of IFxxx (i.e., IFNE for IFEQ) and where <l'> designates the	            // instruction just after the GOTO_W.	            if (opcode == Constants.GOTO) {	              newCode.put1(200); // GOTO_W	            } else if (opcode == Constants.JSR) {	              newCode.put1(201); // JSR_W	            } else {	              newCode.put1(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);	              newCode.put2(8);   // jump offset	              newCode.put1(200); // GOTO_W	              newOffset -= 3;    // newOffset now computed from start of GOTO_W	            }	            newCode.put4(newOffset);	          } else {	            newCode.put1(opcode);	            newCode.put2(newOffset);	          }	          u += 3;	          break;	        case ClassWriter.LABELW_INSN:	          label = u + readInt(b, u + 1);	          newOffset = getNewOffset(allIndexes, allSizes, u, label);	          newCode.put1(opcode);	          newCode.put4(newOffset);	          u += 5;	          break;	        case ClassWriter.TABL_INSN:	          // skips 0 to 3 padding bytes	          v = u;	          u = u + 4 - (v & 3);	          // reads and copies instruction	          int source = newCode.length;	          newCode.put1(Constants.TABLESWITCH);	          while (newCode.length % 4 != 0) {	            newCode.put1(0);	          }	          label = v + readInt(b, u); u += 4;	          newOffset = getNewOffset(allIndexes, allSizes, v, label);	          newCode.put4(newOffset);	          j = readInt(b, u); u += 4;	          newCode.put4(j);	          j = readInt(b, u) - j + 1; u += 4;	          newCode.put4(readInt(b, u - 4));	          for ( ; j > 0; --j) {	            label = v + readInt(b, u); u += 4;	            newOffset = getNewOffset(allIndexes, allSizes, v, label);	            newCode.put4(newOffset);	          }	          break;	        case ClassWriter.LOOK_INSN:	          // skips 0 to 3 padding bytes	          v = u;	          u = u + 4 - (v & 3);	          // reads and copies instruction	          source = newCode.length;	          newCode.put1(Constants.LOOKUPSWITCH);	          while (newCode.length % 4 != 0) {	            newCode.put1(0);	          }	          label = v + readInt(b, u); u += 4;	          newOffset = getNewOffset(allIndexes, allSizes, v, label);	          newCode.put4(newOffset);	          j = readInt(b, u); u += 4;	          newCode.put4(j);	          for ( ; j > 0; --j) {	            newCode.put4(readInt(b, u)); u += 4;	            label = v + readInt(b, u); u += 4;	            newOffset = getNewOffset(allIndexes, allSizes, v, label);	            newCode.put4(newOffset);	          }	          break;	        case ClassWriter.WIDE_INSN:	          opcode = b[u + 1] & 0xFF;	          if (opcode == Constants.IINC) {	            newCode.putByteArray(b, u, 6);	            u += 6;	          } else {	            newCode.putByteArray(b, u, 4);	            u += 4;	          }	          break;	        case ClassWriter.VAR_INSN:	        case ClassWriter.SBYTE_INSN:	        case ClassWriter.LDC_INSN:	          newCode.putByteArray(b, u, 2);	          u += 2;	          break;	        case ClassWriter.SHORT_INSN:	        case ClassWriter.LDCW_INSN:	        case ClassWriter.FIELDORMETH_INSN:	        case ClassWriter.TYPE_INSN:	        case ClassWriter.IINC_INSN:	          newCode.putByteArray(b, u, 3);	          u += 3;	          break;	        case ClassWriter.ITFMETH_INSN:	          newCode.putByteArray(b, u, 5);	          u += 5;	          break;	        // case MANA_INSN:	        default:	          newCode.putByteArray(b, u, 4);	          u += 4;	          break;	      }	    }		    // updates the instructions addresses in the	    // catch, local var and line number tables	    if (catchTable != null) {	      b = catchTable.data;	      u = 0;	      while (u < catchTable.length) {	        writeShort(b, u, getNewOffset(	          allIndexes, allSizes, 0, readUnsignedShort(b, u)));	        writeShort(b, u + 2, getNewOffset(	          allIndexes, allSizes, 0, readUnsignedShort(b, u + 2)));	        writeShort(b, u + 4, getNewOffset(	          allIndexes, allSizes, 0, readUnsignedShort(b, u + 4)));	        u += 8;	      }	    }	    if (localVar != null) {	      b = localVar.data;	      u = 0;	      while (u < localVar.length) {	        label = readUnsignedShort(b, u);	        newOffset = getNewOffset(allIndexes, allSizes, 0, label);	        writeShort(b, u, newOffset);	        label += readUnsignedShort(b, u + 2);	        newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;	        writeShort(b, u, newOffset);	        u += 10;	      }	    }	    if (lineNumber != null) {	      b = lineNumber.data;	      u = 0;	      while (u < lineNumber.length) {	        writeShort(b, u, getNewOffset(	          allIndexes, allSizes, 0, readUnsignedShort(b, u)));	        u += 4;	      }	    }		    // replaces old bytecodes with new ones	    code = newCode;		    // returns the positions of the resized instructions	    return indexes;	  }	
/**	   * Reads an unsigned short value in the given byte array.	   *	   * @param b a byte array.	   * @param index the start index of the value to be read.	   * @return the read value.	   */		  static int readUnsignedShort (final byte[] b, final int index) {	    return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);	  }	
/**	   * Reads a signed short value in the given byte array.	   *	   * @param b a byte array.	   * @param index the start index of the value to be read.	   * @return the read value.	   */		  static short readShort (final byte[] b, final int index) {	    return (short)(((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));	  }	
/**	   * Reads a signed int value in the given byte array.	   *	   * @param b a byte array.	   * @param index the start index of the value to be read.	   * @return the read value.	   */		  static int readInt (final byte[] b, final int index) {	    return ((b[index] & 0xFF) << 24) |	           ((b[index + 1] & 0xFF) << 16) |	           ((b[index + 2] & 0xFF) << 8) |	           (b[index + 3] & 0xFF);	  }	
/**	   * Writes a short value in the given byte array.	   *	   * @param b a byte array.	   * @param index where the first byte of the short value must be written.	   * @param s the value to be written in the given byte array.	   */		  static void writeShort (final byte[] b, final int index, final int s) {	    b[index] = (byte)(s >>> 8);	    b[index + 1] = (byte)s;	  }	
/**	   * Computes the future value of a bytecode offset.	   * <p>	   * Note: it is possible to have several entries for the same instruction	   * in the <tt>indexes</tt> and <tt>sizes</tt>: two entries (index=a,size=b)	   * and (index=a,size=b') are equivalent to a single entry (index=a,size=b+b').	   *	   * @param indexes current positions of the instructions to be resized. Each	   *      instruction must be designated by the index of its <i>last</i> byte,	   *      plus one (or, in other words, by the index of the <i>first</i> byte of	   *      the <i>next</i> instruction).	   * @param sizes the number of bytes to be <i>added</i> to the above	   *      instructions. More precisely, for each i < <tt>len</tt>,	   *      <tt>sizes</tt>[i] bytes will be added at the end of the instruction	   *      designated by <tt>indexes</tt>[i] or, if <tt>sizes</tt>[i] is	   *      negative, the <i>last</i> |<tt>sizes[i]</tt>| bytes of the instruction	   *      will be removed (the instruction size <i>must not</i> become negative	   *      or null).	   * @param begin index of the first byte of the source instruction.	   * @param end index of the first byte of the target instruction.	   * @return the future value of the given bytecode offset.	   */		  static int getNewOffset (	    final int[] indexes,	    final int[] sizes,	    final int begin,	    final int end)	  {	    int offset = end - begin;	    for (int i = 0; i < indexes.length; ++i) {	      if (begin < indexes[i] && indexes[i] <= end) { // forward jump	        offset += sizes[i];	      } else if (end < indexes[i] && indexes[i] <= begin) { // backward jump	        offset -= sizes[i];	      }	    }	    return offset;	  }	
/**	   * Returns the current size of the bytecode of this method. This size just	   * includes the size of the bytecode instructions: it does not include the	   * size of the Exceptions, LocalVariableTable, LineNumberTable, Synthetic	   * and Deprecated attributes, if present.	   *	   * @return the current size of the bytecode of this method.	   */		  protected int getCodeSize () {	    return code.length;	  }	
/**	   * Returns the current bytecode of this method. This bytecode only contains	   * the instructions: it does not include the Exceptions, LocalVariableTable,	   * LineNumberTable, Synthetic and Deprecated attributes, if present.	   *	   * @return the current bytecode of this method. The bytecode is contained	   *      between the index 0 (inclusive) and the index {@link #getCodeSize	   *      getCodeSize} (exclusive).	   */		  protected byte[] getCode () {	    return code.data;	  }	
/**	     * Construct a basic CollectionIterator	     *	     * @param iterateOverMe The object over which we are iterating	     *	     * @throws java.lang.IllegalArgumentException If the argument is not a	     * supported (i.e. iterable) type.	     *	     * @throws java.lang.NullPointerException If the argument is null	     */	    public CollectionIterator(Object iterateOverMe) {	        iterator = createIterator(iterateOverMe);	    }	
/**	     * Create an iterator over the given object	     *	     * @param iterateOverMe Object of type Iterator, Collection, or types	     * supported by CollectionManager.BasicBshIterator	     *	     * @return an Iterator	     *	     * @throws java.lang.IllegalArgumentException If the argument is not a	     * supported (i.e. iterable) type.	     *	     * @throws java.lang.NullPointerException If the argument is null	     */	    protected Iterator createIterator(Object iterateOverMe)	    {	        if (iterateOverMe==null)	            throw new NullPointerException("Object arguments passed to " +	                "the CollectionIterator constructor cannot be null.");		        if (iterateOverMe instanceof Iterator)	            return (Iterator)iterateOverMe;		        if (iterateOverMe instanceof Collection)	            return ((Collection)iterateOverMe).iterator();		        /*	        Should we be able to iterate over maps?	        if (iterateOverMe instanceof Map)	            return ((Map)iterateOverMe).entrySet().iterator();	        */		        throw new IllegalArgumentException(	            "Cannot enumerate object of type "+iterateOverMe.getClass());	    }	
/**	     * Fetch the next object in the iteration	     *	     * @return The next object	     */	    public Object next() {	        return iterator.next();	    }	
/**	     * Returns true if and only if there are more objects available	     * via the <code>next()</code> method	     *	     * @return The next object	     */	    public boolean hasNext() {	        return iterator.hasNext();	    }	
public synchronized static CollectionManager getCollectionManager()	    {	        if ( manager == null	            && Capabilities.classExists("java.util.Collection") )	        {	            Class clas;	            try {	                clas = Class.forName( "org.gjt.sp.jedit.bsh.collection.CollectionManagerImpl" );	                manager = (CollectionManager)clas.newInstance();	            } catch ( Exception e ) {	                Interpreter.debug("unable to load CollectionManagerImpl: "+e);	            }	        }		        if ( manager == null )	            manager = new CollectionManager(); // default impl		        return manager;	    }	
/**	    */	    public boolean isBshIterable( Object obj )	    {	        // This could be smarter...	        try {	            getBshIterator( obj );	            return true;	        } catch( IllegalArgumentException e ) {	            return false;	        }	    }	
public BshIterator getBshIterator( Object obj )	        throws IllegalArgumentException	    {	        return new BasicBshIterator( obj );	    }	
public boolean isMap( Object obj ) {	        return obj instanceof Hashtable;	    }	
public Object getFromMap( Object map, Object key ) {	        return ((Hashtable)map).get(key);	    }	
public Object putInMap( Object map, Object key, Object value )	    {	        return ((Hashtable)map).put(key, value);	    }	
/**	         * Construct a basic BasicBshIterator	         *	         * @param iterateOverMe The object over which we are iterating	         *	         * @throws java.lang.IllegalArgumentException If the argument is not a	         * supported (i.e. iterable) type.	         *	         * @throws java.lang.NullPointerException If the argument is null	         */	        public BasicBshIterator(Object iterateOverMe) {	            enumeration = createEnumeration(iterateOverMe);	        }	
/**	         * Create an enumeration over the given object	         *	         * @param iterateOverMe Object of type Enumeration, Vector, String,	         *                      StringBuffer or an array	         *	         * @return an enumeration	         *	         * @throws java.lang.IllegalArgumentException If the argument is not a	         * supported (i.e. iterable) type.	         *	         * @throws java.lang.NullPointerException If the argument is null	         */	        protected Enumeration createEnumeration( Object iterateOverMe )	        {	            if(iterateOverMe==null)	                throw new NullPointerException("Object arguments passed to " +	                    "the BasicBshIterator constructor cannot be null.");		            if (iterateOverMe instanceof Enumeration)	                return (Enumeration)iterateOverMe;		            if (iterateOverMe instanceof Vector)	                return ((Vector)iterateOverMe).elements();		            if (iterateOverMe.getClass().isArray()) {	                final Object array = iterateOverMe;	                return new Enumeration() {	                    int index = 0, length = Array.getLength(array);	                    public Object nextElement() {	                        return Array.get(array, index++);	                    }	                    public boolean hasMoreElements() { return index<length; }	                };	            }		            if (iterateOverMe instanceof String)	                return createEnumeration(((String)iterateOverMe).toCharArray());		            if (iterateOverMe instanceof StringBuffer)	                return createEnumeration(	                    iterateOverMe.toString().toCharArray());		            if (iterateOverMe instanceof StringBuilder)	                return createEnumeration(	                    iterateOverMe.toString().toCharArray());		            throw new IllegalArgumentException(	                "Cannot enumerate object of type "+iterateOverMe.getClass());	        }	
/**	         * Fetch the next object in the iteration	         *	         * @return The next object	         */	        public Object next() {	            return 	enumeration.nextElement();	        }	
/**	         * Returns true if and only if there are more objects available	         * via the <code>next()</code> method	         *	         * @return The next object	         */	        public boolean hasNext() {	            return enumeration.hasMoreElements();	        }	
public BshIterator getBshIterator( Object obj ) 			throws IllegalArgumentException		{			if ( obj instanceof Collection || obj instanceof Iterator )				return new CollectionIterator( obj ); 			else				return new org.gjt.sp.jedit.bsh.CollectionManager.BasicBshIterator( obj );		}	
public boolean isMap( Object obj ) 		{			if ( obj instanceof Map )				return true;			else				return super.isMap( obj );		}	
public Object getFromMap( Object map, Object key ) 		{			// Hashtable implements Map			return ((Map)map).get(key);		}	
public Object putInMap( Object map, Object key, Object value ) 		{			// Hashtable implements Map			return ((Map)map).put(key, value);		}	
public ColorWellButton(Color color)		{			setIcon(new ColorWell(color));			setMargin(new Insets(2,2,2,2));			addActionListener(new ActionHandler());				// according to krisk this looks better on OS X...			if(OperatingSystem.isMacOSLF())				putClientProperty("JButton.buttonType","toolbar");		}	
public Color getSelectedColor()		{			return ((ColorWell)getIcon()).color;		}	
public void setSelectedColor(Color color)		{			((ColorWell)getIcon()).color = color;			repaint();		}	
ColorWell(Color color)			{				this.color = color;			}	
public int getIconWidth()			{				return 35;			}	
public int getIconHeight()			{				return 10;			}	
public void paintIcon(Component c, Graphics g, int x, int y)			{				if(color == null)					return;					g.setColor(color);				g.fillRect(x,y,getIconWidth(),getIconHeight());				g.setColor(color.darker());				g.drawRect(x,y,getIconWidth()-1,getIconHeight()-1);			}	
public void actionPerformed(ActionEvent evt)			{				JDialog parent = GUIUtilities.getParentDialog(ColorWellButton.this);				JDialog dialog;				if (parent != null)				{					dialog = new ColorPickerDialog(parent,						jEdit.getProperty("colorChooser.title"),						true);				}				else				{					dialog = new ColorPickerDialog(						JOptionPane.getFrameForComponent(						ColorWellButton.this),						jEdit.getProperty("colorChooser.title"),						true);				}				dialog.pack();				dialog.setVisible(true);			}	
public ColorPickerDialog(Frame parent, String title, boolean modal)			{				super(parent,title,modal);					init();			}	
public ColorPickerDialog(Dialog parent, String title, boolean modal)			{				super(parent,title,modal);					getContentPane().setLayout(new BorderLayout());					init();			}	
public void ok()			{				Color c = chooser.getColor();				if (c != null)					setSelectedColor(c);				setVisible(false);			}	
public void cancel()			{				setVisible(false);			}	
public void actionPerformed(ActionEvent evt)			{				if (evt.getSource() == ok)					ok();				else					cancel();			}	
private void init()			{				Color c = getSelectedColor();				if(c == null)					chooser = new JColorChooser();				else					chooser = new JColorChooser(c);					getContentPane().add(BorderLayout.CENTER, chooser);					Box buttons = new Box(BoxLayout.X_AXIS);				buttons.add(Box.createGlue());					ok = new JButton(jEdit.getProperty("common.ok"));				ok.addActionListener(this);				buttons.add(ok);				buttons.add(Box.createHorizontalStrut(6));				getRootPane().setDefaultButton(ok);				cancel = new JButton(jEdit.getProperty("common.cancel"));				cancel.addActionListener(this);				buttons.add(cancel);				buttons.add(Box.createGlue());					getContentPane().add(BorderLayout.SOUTH, buttons);				pack();				setLocationRelativeTo(getParent());			}	
public CommandLineReader( Reader in ) {			super(in);	    }	
public int read() throws IOException {			int b;				if ( state == sentSemi ) {				state = lastCharNL;				return '\n';			}				// skip CR	        while ( (b = in.read()) == '\r' );				if ( b == '\n' )				if ( state == lastCharNL ) {					b = ';';					state = sentSemi;				} else					state = lastCharNL;			else				state = normal;				return b;	    }	
/**			This is a degenerate implementation.			I don't know how to keep this from blocking if we try to read more			than one char...  There is no available() for Readers ??		*/	    public int read(char buff[], int off, int len) throws IOException 		{			int b = read();			if ( b == -1 )				return -1;  // EOF, not zero read apparently			else {				buff[off]=(char)b;				return 1;			}	    }	
public static void main( String [] args ) throws Exception {			Reader in = new CommandLineReader( new InputStreamReader(System.in) );			while ( true )				System.out.println( in.read() );					}	
public static void completeWord(View view)		{			JEditTextArea textArea = view.getTextArea();			Buffer buffer = view.getBuffer();			int caretLine = textArea.getCaretLine();			int caret = textArea.getCaretPosition();				if(!buffer.isEditable())			{				textArea.getToolkit().beep();				return;			}				KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);			String noWordSep = getNonAlphaNumericWordChars(				buffer,keywordMap);			String word = getWordToComplete(buffer,caretLine,				caret,noWordSep);			if(word == null)			{				textArea.getToolkit().beep();				return;			}				Completion[] completions = getCompletions(buffer,word,caret);				if(completions.length == 0)			{				textArea.getToolkit().beep();			}			//{{{ if there is only one competion, insert in buffer			else if(completions.length == 1)			{				Completion c = completions[0];					if(c.text.equals(word))				{					textArea.getToolkit().beep();				}				else				{					textArea.replaceSelection(c.text.substring(						word.length()));				}			} //}}}			//{{{ show popup if > 1			else			{				String longestPrefix = MiscUtilities.getLongestPrefix(					completions,					keywordMap != null					? keywordMap.getIgnoreCase()					: false);					if (word.length() < longestPrefix.length())				{					buffer.insert(caret,longestPrefix.substring(						word.length()));				}					textArea.scrollToCaret(false);				Point location = textArea.offsetToXY(					caret - word.length());				location.y += textArea.getPainter().getFontMetrics()					.getHeight();					SwingUtilities.convertPointToScreen(location,					textArea.getPainter());				new CompleteWord(view,longestPrefix,					completions,location,noWordSep);			} //}}}		}	
public CompleteWord(View view, String word, Completion[] completions,			Point location, String noWordSep)		{			super(view, location);				this.noWordSep = noWordSep;			this.view = view;			this.textArea = view.getTextArea();			this.buffer = view.getBuffer();			this.word = word;				reset(new Words(completions), true);		}	
private static String getNonAlphaNumericWordChars(Buffer buffer,			KeywordMap keywordMap)		{			// figure out what constitutes a word character and what			// doesn't			String noWordSep = buffer.getStringProperty("noWordSep");			if(noWordSep == null)				noWordSep = "";			if(keywordMap != null)			{				String keywordNoWordSep = keywordMap.getNonAlphaNumericChars();				if(keywordNoWordSep != null)					noWordSep += keywordNoWordSep;			}				return noWordSep;		}	
private static String getWordToComplete(Buffer buffer, int caretLine,			int caret, String noWordSep)		{			CharSequence line = buffer.getLineSegment(caretLine);			int dot = caret - buffer.getLineStartOffset(caretLine);			if(dot == 0)				return null;				char ch = line.charAt(dot-1);			if(!Character.isLetterOrDigit(ch)				&& noWordSep.indexOf(ch) == -1)			{				// attempting to expand non-word char				return null;			}				int wordStart = TextUtilities.findWordStart(line,dot-1,noWordSep);			CharSequence word = line.subSequence(wordStart,dot);			if(word.length() == 0)				return null;				return word.toString();		}	
private static Collection<Buffer> getVisibleBuffers()		{			final Set<Buffer> buffers = new HashSet<Buffer>();			jEdit.visit(new JEditVisitorAdapter()				{					@Override					public void visit(EditPane editPane)					{						buffers.add(editPane.getBuffer());					}				});			return buffers;		}	
private static Completion[] getCompletions(final Buffer buffer, final String word,			final int caret)		{			// build a list of unique words in all buffers, or visible buffers,			// depending on completeFromAllBuffers			final Set<Completion> completions = new TreeSet<Completion>(new StandardUtilities				.StringCompare<Completion>());				// only complete current buffer's keyword map			final KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);			final String noWordSep = getNonAlphaNumericWordChars(				buffer,keywordMap);						final Collection<Buffer> sourceBuffers = 				jEdit.getBooleanProperty("completeFromAllBuffers") ?					Arrays.asList(jEdit.getBuffers()) :					getVisibleBuffers();				for (Buffer b : sourceBuffers)			{				// only complete current buffer's keyword map				KeywordMap _keywordMap;				if(b == buffer)					_keywordMap = keywordMap;				else					_keywordMap = null;					int offset = (b == buffer ? caret : 0);					getCompletions(b,word,keywordMap,noWordSep,						offset,completions);			}				Completion[] completionArray = completions				.toArray(new Completion[completions.size()]);				return completionArray;		}	
private static void getCompletions(Buffer buffer, String word,			KeywordMap keywordMap, String noWordSep, int caret,			Set<Completion> completions)		{			int wordLen = word.length();				//{{{ try to find matching keywords			if(keywordMap != null)			{				String[] keywords = keywordMap.getKeywords();				for(int i = 0; i < keywords.length; i++)				{					String _keyword = keywords[i];					if(_keyword.regionMatches(keywordMap.getIgnoreCase(),						0,word,0,wordLen))					{						Completion keyword = new Completion(_keyword,true);						if(!completions.contains(keyword))						{							completions.add(keyword);						}					}				}			} //}}}				//{{{ loop through all lines of current buffer			for(int i = 0; i < buffer.getLineCount(); i++)			{				CharSequence line = buffer.getLineSegment(i);				int start = buffer.getLineStartOffset(i);					// check for match at start of line					if (StandardUtilities.startsWith(line, word) &&				    caret != start + word.length())				{					String _word = completeWord(line,0,noWordSep);					Completion comp = new Completion(_word,false);						// remove duplicates					if(!completions.contains(comp))					{						completions.add(comp);					}				}					// check for match inside line				int len = line.length() - word.length();				for(int j = 0; j < len; j++)				{					char c = line.charAt(j);					if(!Character.isLetterOrDigit(c) && noWordSep.indexOf(c) == -1)					{						if (StandardUtilities.regionMatches(line,j + 1,word,0,wordLen)							&& caret != start + j + word.length() + 1)						{							String _word = completeWord(line,j + 1,noWordSep);							Completion comp = new Completion(_word,false);								// remove duplicates							if(!completions.contains(comp))							{								completions.add(comp);							}						}					}				}			} //}}}		}	
private static String completeWord(CharSequence line, int offset, String noWordSep)		{			// '+ 1' so that findWordEnd() doesn't pick up the space at the start			int wordEnd = TextUtilities.findWordEnd(line,offset + 1,noWordSep);			return line.subSequence(offset,wordEnd).toString();		}	
Completion(String text, boolean keyword)			{				this.text = text;				this.keyword = keyword;			}	
public String toString()			{				return text;			}	
public int hashCode()			{				return text.hashCode();			}	
public boolean equals(Object obj)			{				if(obj instanceof Completion)					return ((Completion)obj).text.equals(text);				else					return false;			}	
public Words(Completion[] completions)			{				this.renderer = new DefaultListCellRenderer();				this.completions = completions;			}	
public int getSize()			{				return completions.length;			}	
public boolean isValid()			{				return true;			}	
public void complete(int index)			{				String insertion = completions[index].toString().substring(word.length());				textArea.replaceSelection(insertion);			}	
public Component getCellRenderer(JList list, int index,				boolean isSelected, boolean cellHasFocus)			{				renderer.getListCellRendererComponent(list,					null, index, isSelected, cellHasFocus);					Completion comp = completions[index];					String text = comp.text;				Font font = list.getFont();					if(index < 9)					text = (index + 1) + ": " + text;				else if(index == 9)					text = "0: " + text;					if(comp.keyword)					font = font.deriveFont(Font.BOLD);					renderer.setText(text);				renderer.setFont(font);				return renderer;			}	
public String getDescription(int index)			{				return null;			}	
private void resetWords(String newWord)		{			int caret = textArea.getCaretPosition();			Completion[] completions = getCompletions(				buffer,newWord,caret);			if(completions.length > 0)			{				word = newWord;				reset(new Words(completions), true);			}			else			{				dispose();			}		}	
protected void keyPressed(KeyEvent e)		{			if (e.getKeyCode() == KeyEvent.VK_BACK_SPACE)			{				textArea.backspace();				e.consume();					if(word.length() == 1)				{					dispose();				}				else				{					resetWords(word.substring(0,word.length() - 1));				}			}		}	
protected void keyTyped(KeyEvent e)		{			char ch = e.getKeyChar();			if(Character.isDigit(ch))			{				int index = ch - '0';				if(index == 0)					index = 9;				else					index--;				if(index < getCandidates().getSize())				{					setSelectedIndex(index);					if(doSelectedCompletion())					{						e.consume();						dispose();					}					return;				}				else					/* fall through */;			}				// \t handled above			if(ch != '\b' && ch != '\t')			{				/* eg, foo<C+b>, will insert foobar, */				if(!Character.isLetterOrDigit(ch) && noWordSep.indexOf(ch) == -1)				{					doSelectedCompletion();					textArea.userInput(ch);					e.consume();					dispose();					return;				}					textArea.userInput(ch);				e.consume();				resetWords(word + ch);			}		}	
/**		 * Create a completion popup.		 * It is not shown until reset() method is called with valid		 * candidates. All key events for the view are intercepted by		 * this popup untill end of completion.		 * @since jEdit 4.3pre13		 */ 		public CompletionPopup(View view)		{			super(view);			this.view = view;			this.keyHandler = new KeyHandler();			this.candidates = null;			this.list = new JList();				list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			list.setCellRenderer(new CellRenderer());			list.addKeyListener(keyHandler);			list.addMouseListener(new MouseHandler());				JPanel content = new JPanel(new BorderLayout());			content.setFocusTraversalKeysEnabled(false);			// stupid scrollbar policy is an attempt to work around			// bugs people have been seeing with IBM's JDK -- 7 Sep 2000			JScrollPane scroller = new JScrollPane(list,				ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);			content.add(scroller, BorderLayout.CENTER);			setContentPane(content);			addWindowFocusListener(new WindowFocusHandler());		}	
public CompletionPopup(View view, Point location)		{			this(view);			if (location != null)			{				setLocation(location);			}		}	
/**		 * Quit completion.		 */		public void dispose()		{			if (isDisplayable())			{				if (view.getKeyEventInterceptor() == keyHandler)				{					view.setKeyEventInterceptor(null);				}				super.dispose();					// This is a workaround to ensure setting the				// focus back to the textArea. Without this, the				// focus gets lost after closing the popup in				// some environments. It seems to be a bug in				// J2SE 1.4 or 5.0. Probably it relates to the				// following one.				// "Frame does not receives focus after closing				// of the owned window"				// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4810575				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						view.getTextArea().requestFocus();					}				});			}		}	
/**		 * Start completion.		 * @param candidates The candidates of this completion		 * @param active Set focus to the popup		 */		public void reset(Candidates candidates, boolean active)		{			if(candidates == null || !candidates.isValid()				|| candidates.getSize() <= 0)			{				dispose();				return;			}				this.candidates = candidates;			list.setModel(new CandidateListModel());			list.setVisibleRowCount(Math.min(candidates.getSize(),8));			pack();			setLocation(fitInScreen(getLocation(null),this,				view.getTextArea().getPainter().getFontMetrics().getHeight()));			if (active)			{				setSelectedIndex(0);				GUIUtilities.requestFocus(this,list);			}			setVisible(true);			view.setKeyEventInterceptor(keyHandler);		}	
/**		 * Current candidates of completion.		 */		public Candidates getCandidates()		{			return candidates;		}	
/**		 * Returns index of current selection.		 * Returns -1 if nothing is selected.		 */		public int getSelectedIndex()		{			return list.getSelectedIndex();		}	
/**		 * Set selection.		 */		public void setSelectedIndex(int index)		{			if (candidates != null				&& 0 <= index && index < candidates.getSize())			{				list.setSelectedIndex(index);				list.ensureIndexIsVisible(index);				String description = candidates.getDescription(index);				if (description != null)				{					view.getStatus().setMessageAndClear(description);				}			}		}	
/**		 * Do completion with current selection and quit.		 */		public boolean doSelectedCompletion()		{			int selected = list.getSelectedIndex();			if (candidates != null &&				0 <= selected && selected < candidates.getSize())			{				candidates.complete(selected);				dispose();				return true;			}			return false;		}	
/**		 * Handle key pressed events.		 * Override this method to make additional key handing.		 */		protected void keyPressed(KeyEvent e)		{		}	
/**		 * Handle key typed events.		 * Override this method to make additional key handing.		 */		protected void keyTyped(KeyEvent e)		{		}	
private static Point fitInScreen(Point p, Window w, int lineHeight)		{			Rectangle screenSize = w.getGraphicsConfiguration().getBounds();			if(p.y + w.getHeight() >= screenSize.height)				p.y = p.y - w.getHeight() - lineHeight;			return p;		}	
private void moveRelative(int n)		{			int selected = list.getSelectedIndex();				int newSelect = selected + n;			if (newSelect < 0)			{				newSelect = 0;			}			else			{				int numItems = list.getModel().getSize();				if(numItems < 1)				{					return;				}				if(newSelect >= numItems)				{					newSelect = numItems - 1;				}			}				if(newSelect != selected)			{				setSelectedIndex(newSelect);			}		}	
private void moveRelativePages(int n)		{			int pageSize = list.getVisibleRowCount() - 1;			moveRelative(pageSize * n);		}	
private void passKeyEventToView(KeyEvent e)		{			// Remove intercepter to avoid infinite recursion.			assert (view.getKeyEventInterceptor() == keyHandler);			view.setKeyEventInterceptor(null);				// Here depends on an implementation detail.			// Use ACTION_BAR to force processing KEY_TYPED event in			// the implementation of gui.InputHandler.processKeyEvent().			view.getInputHandler().processKeyEvent(e, View.ACTION_BAR, false);				// Restore keyHandler only if this popup is still alive.			// The key event might trigger dispose() of this popup.			if (this.isDisplayable())			{				view.setKeyEventInterceptor(keyHandler);			}		}	
public int getSize()			{				return candidates.getSize();			}	
public Object getElementAt(int index)			{				// This value is not used.				// The list is only rendered by components				// returned by getCellRenderer().				return candidates;			}	
public Component getListCellRendererComponent(JList list,				Object value, int index,				boolean isSelected, boolean cellHasFocus)			{				return candidates.getCellRenderer(list, index,					isSelected, cellHasFocus);			}	
public void keyPressed(KeyEvent e)			{				CompletionPopup.this.keyPressed(e);					if (candidates == null || !candidates.isValid())				{					dispose();				}				else if (!e.isConsumed())				{					switch(e.getKeyCode())					{					case KeyEvent.VK_TAB:					case KeyEvent.VK_ENTER:						if (doSelectedCompletion())						{							e.consume();						}						else						{							dispose();						}						break;					case KeyEvent.VK_ESCAPE:						dispose();						e.consume();						break;					case KeyEvent.VK_UP:						moveRelative(-1);						e.consume();						break;					case KeyEvent.VK_DOWN:						moveRelative(1);						e.consume();						break;					case KeyEvent.VK_PAGE_UP:						moveRelativePages(-1);						e.consume();						break;					case KeyEvent.VK_PAGE_DOWN:						moveRelativePages(1);						e.consume();						break;					default:						if(e.isActionKey()							|| e.isControlDown()							|| e.isAltDown()							|| e.isMetaDown())						{							dispose();						}						break;					}				}					if (!e.isConsumed())				{					passKeyEventToView(e);				}			}	
public void keyTyped(KeyEvent e)			{				CompletionPopup.this.keyTyped(e);					if (candidates == null || !candidates.isValid())				{					dispose();				}					if (!e.isConsumed())				{					passKeyEventToView(e);				}			}	
public void mouseClicked(MouseEvent e)			{				if (doSelectedCompletion())				{					e.consume();				}				else				{					dispose();				}			}	
public void windowGainedFocus(WindowEvent e)			{			}	
public void windowLostFocus(WindowEvent e)			{				dispose();			}	
public final int getLength()		{			return length;		}	
public String getText(int start, int len)		{			if(start >= gapStart)				return new String(text,start + gapEnd - gapStart,len);			else if(start + len <= gapStart)				return new String(text,start,len);			else			{				return new String(text,start,gapStart - start)					.concat(new String(text,gapEnd,start + len - gapStart));			}		}	
/**		 * Returns the specified text range in a <code>Segment</code>.<p>		 *		 * Using a <classname>Segment</classname> is generally more		 * efficient than using a <classname>String</classname> because it		 * results in less memory allocation and array copying.<p>		 *		 *		 * @param start The start offset		 * @param len The number of characters to get		 * @param seg The segment to copy the text to		 * @see JEditBuffer#getText(int, int, Segment)		 */		public void getText(int start, int len, Segment seg)		{			if(start >= gapStart)			{				seg.array = text;				seg.offset = start + gapEnd - gapStart;				seg.count = len;			}			else if(start + len <= gapStart)			{				seg.array = text;				seg.offset = start;				seg.count = len;			}			else			{				seg.array = new char[len];					// copy text before gap				System.arraycopy(text,start,seg.array,0,gapStart - start);					// copy text after gap				System.arraycopy(text,gapEnd,seg.array,gapStart - start,					len + start - gapStart);					seg.offset = 0;				seg.count = len;			}		}	
/**		 * Returns a read-only segment of the buffer.		 *		 * @since jEdit 4.3pre15		 */		public CharSequence getSegment(int start, int len)		{			if(start >= gapStart)				return new BufferSegment(text,start + gapEnd - gapStart,len);			else if(start + len <= gapStart)				return new BufferSegment(text,start,len);			else			{				return new BufferSegment(text,start,gapStart - start,					new BufferSegment(text,gapEnd,start + len - gapStart));			}		}	
public void insert(int start, String str)		{			int len = str.length();			moveGapStart(start);			if(gapEnd - gapStart < len)			{				ensureCapacity(length + len + 1024);				moveGapEnd(start + len + 1024);			}				str.getChars(0,len,text,start);			gapStart += len;			length += len;		}	
/**		 * Inserts the given data into the buffer.		 *		 * @since jEdit 4.3pre15		 */		public void insert(int start, CharSequence str)		{			int len = str.length();			moveGapStart(start);			if(gapEnd - gapStart < len)			{				ensureCapacity(length + len + 1024);				moveGapEnd(start + len + 1024);			}				for (int i = 0; i < len; i++)			{				text[start+i] = str.charAt(i);			}			gapStart += len;			length += len;		}	
public void insert(int start, Segment seg)		{			moveGapStart(start);			if(gapEnd - gapStart < seg.count)			{				ensureCapacity(length + seg.count + 1024);				moveGapEnd(start + seg.count + 1024);			}				System.arraycopy(seg.array,seg.offset,text,start,seg.count);			gapStart += seg.count;			length += seg.count;		}	
public void _setContent(char[] text, int length)		{			this.text = text;			this.gapStart = this.gapEnd = 0;			this.length = length;		}	
public void remove(int start, int len)		{			moveGapStart(start);			gapEnd += len;			length -= len;		}	
private void moveGapStart(int newStart)		{			int newEnd = gapEnd + (newStart - gapStart);				if(newStart == gapStart)			{				// nothing to do			}			else if(newStart > gapStart)			{				System.arraycopy(text,gapEnd,text,gapStart,					newStart - gapStart);			}			else if(newStart < gapStart)			{				System.arraycopy(text,newStart,text,newEnd,					gapStart - newStart);			}				gapStart = newStart;			gapEnd = newEnd;		}	
private void moveGapEnd(int newEnd)		{			System.arraycopy(text,gapEnd,text,newEnd,length - gapStart);			gapEnd = newEnd;		}	
private void ensureCapacity(int capacity)		{			if(capacity >= text.length)			{				char[] textN = new char[capacity * 2];				System.arraycopy(text,0,textN,0,length + (gapEnd - gapStart));				text = textN;			}		}	
public ContextAddDialog(Component comp)		{			super(GUIUtilities.getParentDialog(comp),			      jEdit.getProperty("options.context.add.title"),			      true);				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				ActionHandler actionHandler = new ActionHandler();			ButtonGroup grp = new ButtonGroup();				JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));			typePanel.setBorder(new EmptyBorder(0,0,6,0));			typePanel.add(new JLabel(						 jEdit.getProperty("options.context.add.caption")));				separator = new JRadioButton(jEdit.getProperty("options.context"								       + ".add.separator"));			separator.addActionListener(actionHandler);			grp.add(separator);			typePanel.add(separator);				action = new JRadioButton(jEdit.getProperty("options.context"								    + ".add.action"));			action.addActionListener(actionHandler);			grp.add(action);			action.setSelected(true);			typePanel.add(action);				content.add(BorderLayout.NORTH,typePanel);				JPanel actionPanel = new JPanel(new BorderLayout(6,6));				ActionSet[] actionsList = jEdit.getActionSets();			TreeSet<ActionSet> actionSets = new TreeSet<ActionSet>();			for(int i = 0; i < actionsList.length; i++)			{				ActionSet actionSet = actionsList[i];				if(actionSet.getActionCount() != 0)					actionSets.add(actionSet);			}			combo = new JComboBox(actionSets.toArray());			combo.setSelectedIndex(jEdit.getIntegerProperty("contextAddDialog.lastSelection",1));			combo.addActionListener(actionHandler);			actionPanel.add(BorderLayout.NORTH,combo);				list = new JList();			list.setVisibleRowCount(8);			list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));				content.add(BorderLayout.CENTER,actionPanel);				JPanel southPanel = new JPanel();			southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));			southPanel.setBorder(new EmptyBorder(12,0,0,0));			southPanel.add(Box.createGlue());			ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(actionHandler);			getRootPane().setDefaultButton(ok);			southPanel.add(ok);			southPanel.add(Box.createHorizontalStrut(6));			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(actionHandler);			southPanel.add(cancel);			southPanel.add(Box.createGlue());				content.add(BorderLayout.SOUTH,southPanel);				updateList();				pack();			setLocationRelativeTo(GUIUtilities.getParentDialog(comp));			setVisible(true);		}	
public void ok()		{			isOK = true;			dispose();		}	
public void cancel()		{			dispose();		}	
public String getSelection()		{			if(!isOK)				return null;				if(separator.isSelected())				return "-";			else if(action.isSelected())			{				return ((AbstractContextOptionPane.MenuItem)list.getSelectedValue())				.actionName;			}			else				throw new InternalError();		}	
private void updateList()		{			ActionSet actionSet = (ActionSet)combo.getSelectedItem();			jEdit.setIntegerProperty("contextAddDialog.lastSelection", combo.getSelectedIndex());				EditAction[] actions = actionSet.getActions();			Vector listModel = new Vector(actions.length);				for(int i = 0; i < actions.length; i++)			{				EditAction action = actions[i];				String label = action.getLabel();				if(label == null)					continue;					listModel.addElement(new AbstractContextOptionPane.MenuItem(											    action.getName(),label));			}				Collections.sort(listModel,new AbstractContextOptionPane.MenuItemCompare());				list.setListData(listModel);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source instanceof JRadioButton)				{					combo.setEnabled(action.isSelected());					list.setEnabled(action.isSelected());				}				if(source == ok)					ok();				else if(source == cancel)					cancel();				else if(source == combo)					updateList();			}	
public ContextOptionPane()		{			super("context", jEdit.getProperty("options.context.caption"));		}	
/**		 * Returns jEdit's context menu configuration.		 *		 * @since jEdit 4.3pre13		 */	    protected String getContextMenu()	    {			return jEdit.getProperty("view.context");		}	
/**		 * Saves jEdit's context menu configuration.		 *		 * @since jEdit 4.3pre13		 */	    protected void saveContextMenu(String menu)	    {			jEdit.setProperty("view.context", menu);	    }	
/**		 * @param comp the component that will be used as parent in case of error		 * @param source the source VFS		 * @param target the target VFS		 */		public CopyFileWorker(Component comp, String source, String target) 		{			if (source == null || target == null)				throw new NullPointerException("The source and target cannot be null");			this.comp = comp;			this.source = source;			this.target = target;		}	
public void run() 		{			try			{				VFS.copy(this, source, target, comp, false);			}			catch (IOException e)			{				Log.log(Log.ERROR,this, e, e);			}		}	
public String getFirstFile(View view)		{			return view.getBuffer().getPath();		}	
public String getNextFile(View view, String file)		{			if(file == null)				return view.getBuffer().getPath();			else				return null;		}	
public String[] getFiles(View view)		{			return new String[] { view.getBuffer().getPath() };		}	
public int getFileCount(View view)		{			return 1;		}	
public String getCode()		{			return "new CurrentBufferSet()";		}	
public DeepIndentRule(char openChar, char closeChar)		{			this.openChar = openChar;			this.closeChar = closeChar;		}	
public void apply(JEditBuffer buffer, int thisLineIndex,				  int prevLineIndex, int prevPrevLineIndex,				  List<IndentAction> indentActions)		{			if (prevLineIndex == -1)				return;				int lineIndex = prevLineIndex;			int oldLineIndex = lineIndex;			CharSequence lineText = buffer.getLineSegment(lineIndex);			int searchPos = -1;			while (true)			{				if (lineIndex != oldLineIndex)				{					lineText = buffer.getLineSegment(lineIndex);					oldLineIndex = lineIndex;				}				Parens parens = new Parens(buffer, lineIndex, searchPos);					// No unmatched parens on prev line.				if (parens.openOffset == -1 && parens.closeOffset == -1)				{					// Try prev-prev line if present.					if (prevPrevLineIndex != -1) {						searchPos = -1;						lineIndex = prevPrevLineIndex;						prevPrevLineIndex = -1;						continue;					}					return;				}					// There's an unmatched open parenthesis - we want to				// align according to its position.				if (parens.closeOffset == -1)				{					// recalculate column (when using tabs instead of spaces)					int indent = parens.openOffset + getIndent(lineText, buffer.getTabSize()) - lineText.length();					indentActions.clear();					indentActions.add(new IndentAction.AlignParameter(indent));					return;				}					// There's an unmatched closed parenthesis - find the				// matching parenthesis and start looking from there again.				int openParenOffset = TextUtilities.findMatchingBracket(buffer, lineIndex, parens.closeOffset);				if (openParenOffset >= 0)				{					// Avoid falling back to the prev-prev line in this case.					prevPrevLineIndex = -1;					lineIndex = buffer.getLineOfOffset(openParenOffset);					searchPos = openParenOffset - buffer.getLineStartOffset(lineIndex) - 1;					if (searchPos < 0)						break;				}				else					break;			}		}	
/**		 * Returns the length of the string as if it were indented with		 * spaces instead of tabs.		 */		private int getIndent(CharSequence line, int tabSize)		{			int cnt = 0;			for (int i = 0;  i < line.length(); i++)			{				if (line.charAt(i) == '\t')				{					cnt += tabSize;				}				else				{					if (!Character.isWhitespace(line.charAt(i)))					{						cnt += (line.length() - i);						break;					}					cnt++;				}			}			return cnt;		}	
Parens(JEditBuffer b, int line, int pos)			{				this.searchPos = pos;				this.open = new Stack<Integer>();				this.close = new Stack<Integer>();				b.markTokens(line, this);				openOffset = (open.isEmpty()) ? -1 : open.pop();				closeOffset = (close.isEmpty()) ? -1 : close.pop();			}	
public void handleToken(Segment seg,						byte id,						int offset,						int length,						TokenMarker.LineContext context)			{				if (length <= 0 ||				    (searchPos != -1 && searchPos < offset))				{					return;				}					if (searchPos != -1 && offset + length > searchPos)				{					length = searchPos - offset + 1;				}					switch (id)				{				case Token.COMMENT1:				case Token.COMMENT2:				case Token.COMMENT3:				case Token.COMMENT4:				case Token.LITERAL1:				case Token.LITERAL2:				case Token.LITERAL3:				case Token.LITERAL4:					/* Ignore comments and literals. */					break;				default:					for (int i = offset; i < offset + length; i++)					{						if (seg.array[seg.offset + i] == openChar)						{							if (open.isEmpty() && !close.isEmpty())								close.pop();							else								open.push(i);						}						else if (seg.array[seg.offset + i] == closeChar)						{							if (close.isEmpty() && !open.isEmpty())								open.pop();							else								close.push(i);						}					}					break;				}			}	
public void setLineContext(TokenMarker.LineContext lineContext)			{				/* Do nothing. */			}	
@Override			public String toString()			{				return "Parens(" + openOffset + ',' + closeOffset + ')';			}	
/**		 * Returns the fold handler with the specified name, or null if		 * there is no registered handler with that name.		 *		 * @param name The name of the desired fold handler		 * @return the FoldHandler or null if it doesn't exist		 * @since jEdit 4.3pre10		 */		public FoldHandler getFoldHandler(String name)		{			return folds.get(name);		}	
/**		 * Returns an array containing the names of all registered fold		 * handlers.		 *		 * @since jEdit 4.0pre6		 */		public String[] getFoldModes()		{			return folds.keySet().toArray(new String[folds.size()]); 		}	
/**		 * Add a new FoldHander.		 *		 * @param foldHandler the new foldHandler		 * @since jEdit 4.3pre13		 */		public void addFoldHandler(FoldHandler foldHandler)		{			folds.put(foldHandler.getName(), foldHandler);		}	
/**		 * Creates a new input handler with no key bindings defined.		 * @param view The view		 * @param bindings An explicitly-specified set of key bindings,		 * must not be null.		 * @since jEdit 4.3pre1		 */		public DefaultInputHandler(View view, Hashtable bindings)		{			super(view);				if(bindings == null)				throw new NullPointerException();			this.bindings = this.currentBindings = bindings;		}	
/**		 * Creates a new input handler with no key bindings defined.		 * @param view The view		 */		public DefaultInputHandler(View view)		{			this(view,new Hashtable());		}	
/**		 * Creates a new input handler with the same set of key bindings		 * as the one specified. Note that both input handlers share		 * a pointer to exactly the same key binding table; so adding		 * a key binding in one will also add it to the other.		 * @param copy The input handler to copy key bindings from		 * @param view The view		 */		public DefaultInputHandler(View view, DefaultInputHandler copy)		{			this(view,copy.bindings);		}	
/**		 * Returns if a prefix key has been pressed.		 */		@Override		public boolean isPrefixActive()		{			return bindings != currentBindings				|| super.isPrefixActive();		}	
@Override		public void setCurrentBindings(Hashtable bindings)		{			view.getStatus().setMessage((String)bindings.get(PREFIX_STR));			currentBindings = bindings;		}	
/**		 * Handles the given keystroke.		 * @param keyStroke The key stroke		 * @param dryRun only calculate the return value, do not have any other effect		 * @since jEdit 4.2pre5		 */		public boolean handleKey(KeyEventTranslator.Key keyStroke,boolean dryRun)		{			char input = '\0';			if(keyStroke.modifiers == null				|| keyStroke.modifiers.equals("S"))			{				switch(keyStroke.key)				{				case '\n':				case '\t':					input = (char)keyStroke.key;					break;				default:					input = keyStroke.input;					break;				}			}				if(readNextChar != null)			{				if(input != '\0')				{					if (!dryRun)					{						setCurrentBindings(bindings);						invokeReadNextChar(input);						repeatCount = 1;					}					return true;				}				else				{					if (!dryRun) 					{						readNextChar = null;						view.getStatus().setMessage(null);					}				}			}				Object o = currentBindings.get(keyStroke);			if(o == null)			{				if (!dryRun) 				{					// Don't beep if the user presses some					// key we don't know about unless a					// prefix is active. Otherwise it will					// beep when caps lock is pressed, etc.					if(currentBindings != bindings)					{						Toolkit.getDefaultToolkit().beep();						// F10 should be passed on, but C+e F10						// shouldn't						repeatCount = 1;						setCurrentBindings(bindings);					}					else if(input != '\0') 					{						if (!keyStroke.isFromGlobalContext()) 						{ // let user input be only local							userInput(input);						}					} 					else					{						// this is retarded. excuse me while I drool						// and make stupid noises						if(KeyEventWorkaround.isNumericKeypad(keyStroke.key))							KeyEventWorkaround.numericKeypadKey();					}					sendShortcutPrefixOff();				}			}			else if(o instanceof Hashtable)			{				if (!dryRun) 				{					setCurrentBindings((Hashtable)o);					ShortcutPrefixActiveEvent.firePrefixStateChange(currentBindings, true);					shortcutOn = true;				}				return true;			}			else if(o instanceof String)			{				if (!dryRun) 				{					setCurrentBindings(bindings);					sendShortcutPrefixOff();					invokeAction((String)o);				}				return true;			}			else if(o instanceof EditAction)			{				if (!dryRun)				{					setCurrentBindings(bindings);					sendShortcutPrefixOff();					invokeAction((EditAction)o);				}				return true;			}			if (!dryRun)			{				sendShortcutPrefixOff();			}			return false;		}	
/**		 * Returns a the symbolic modifier name for the specified Java modifier		 * flag.		 *		 * @param mod A modifier constant from <code>InputEvent</code>		 *		 * @since jEdit 4.1pre3		 */		public static char getSymbolicModifierName(int mod)		{			return KeyEventTranslator.getSymbolicModifierName(mod);		}	
/**		 * Returns a string containing symbolic modifier names set in the		 * specified event.		 *		 * @param evt The event		 *		 * @since jEdit 4.1pre3		 */		public static String getModifierString(InputEvent evt)		{			return KeyEventTranslator.getModifierString(evt);		}	
public DefaultInputHandlerProvider(AbstractInputHandler inputHandler)		{			this.inputHandler = inputHandler;		}	
public AbstractInputHandler getInputHandler()		{			return inputHandler;		}	
/**		 * Clears the list of tokens.		 */		public void init()		{			lastToken = firstToken = null;		}	
/**		 * Returns the first syntax token.		 * @since jEdit 4.1pre1		 */		public Token getTokens()		{			return firstToken;		}	
/**		 * Called by the token marker when a syntax token has been parsed.		 * @param seg The segment containing the text		 * @param id The token type (one of the constants in the		 * {@link Token} class).		 * @param offset The start offset of the token		 * @param length The number of characters in the token		 * @param context The line context		 * @since jEdit 4.2pre3		 */		public void handleToken(Segment seg, byte id, int offset, int length,			TokenMarker.LineContext context)		{			Token token = createToken(id,offset,length,context);			if(token != null)				addToken(token,context);		}	
/**		 * The token handler can compare this object with the object		 * previously given for this line to see if the token type at the end		 * of the line has changed (meaning subsequent lines might need to be		 * retokenized).		 * @since jEdit 4.2pre6		 */		public TokenMarker.LineContext getLineContext()		{			return lineContext;		}	
/**		 * The token handler can compare this object with the object		 * previously given for this line to see if the token type at the end		 * of the line has changed (meaning subsequent lines might need to be		 * retokenized).		 * @since jEdit 4.2pre6		 */		public void setLineContext(TokenMarker.LineContext lineContext)		{			this.lineContext = lineContext;		}	
protected ParserRuleSet getParserRuleSet(TokenMarker.LineContext context)		{			while(context != null)			{				if(!context.rules.isBuiltIn())					return context.rules;					context = context.parent;			}				return null;		}	
protected Token createToken(byte id, int offset, int length,			TokenMarker.LineContext context)		{			return new Token(id,offset,length,getParserRuleSet(context));		}	
protected void addToken(Token token, TokenMarker.LineContext context)		{			if(firstToken == null)			{				firstToken = lastToken = token;			}			else			{				lastToken.next = token;				lastToken = lastToken.next;			}		}	
/**			This constructor is used in class generation.  It supplies String type			descriptors for return and parameter class types and allows delay of 			the evaluation of those types until they are requested.  It does this			by holding BSHType nodes, as well as an evaluation callstack, and			interpreter which are called when the class types are requested. 		*/		/*			Note: technically I think we could get by passing in only the			current namespace or perhaps BshClassManager here instead of 			CallStack and Interpreter.  However let's just play it safe in case			of future changes - anywhere you eval a node you need these.		*/		DelayedEvalBshMethod( 			String name, 			String returnTypeDescriptor, BSHReturnType returnTypeNode,			String [] paramNames,			String [] paramTypeDescriptors, BSHFormalParameters paramTypesNode,			BSHBlock methodBody, 			NameSpace declaringNameSpace, Modifiers modifiers,			CallStack callstack, Interpreter interpreter		) {			super( name, null/*returnType*/, paramNames, null/*paramTypes*/,				methodBody, declaringNameSpace, modifiers );				this.returnTypeDescriptor = returnTypeDescriptor;			this.returnTypeNode = returnTypeNode;			this.paramTypeDescriptors = paramTypeDescriptors;			this.paramTypesNode = paramTypesNode;			this.callstack = callstack;			this.interpreter = interpreter;		}	
public String getReturnTypeDescriptor() { return returnTypeDescriptor; }	
public Class getReturnType() 		{ 			if ( returnTypeNode == null )				return null;				// BSHType will cache the type for us			try {				return returnTypeNode.evalReturnType( callstack, interpreter );			} catch ( EvalError e ) {				throw new InterpreterError("can't eval return type: "+e);			}		}	
public String [] getParamTypeDescriptors() { return paramTypeDescriptors; }	
public Class [] getParameterTypes() 		{ 			// BSHFormalParameters will cache the type for us			try {				return (Class [])paramTypesNode.eval( callstack, interpreter );			} catch ( EvalError e ) {				throw new InterpreterError("can't eval param types: "+e);			}		}	
public static String usage() {			return "usage: dir( String dir )\n       dir()";		}	
/**			Implement dir() command.		*/		public static void invoke( Interpreter env, CallStack callstack ) 		{			String dir = ".";			invoke( env, callstack, dir );		}	
/**			Implement dir( String directory ) command.		*/		public static void invoke( 			Interpreter env, CallStack callstack, String dir ) 		{			File file;			try {				file =  env.pathToFile( dir );			} catch (IOException e ) {				env.println("error reading path: "+e);				return;			}				if ( !file.exists() || !file.canRead() ) {				env.println( "Can't read " + file );				return;			}			if ( !file.isDirectory() )  {				env.println("'"+dir+"' is not a directory");			}				String [] files = file.list();			files = StringUtil.bubbleSort(files);				for( int i=0; i< files.length; i++ ) {				File f = new File( dir + File.separator + files[i] );				StringBuilder sb = new StringBuilder();				sb.append( f.canRead() ? "r": "-" );				sb.append( f.canWrite() ? "w": "-" );				sb.append( "_" );				sb.append( " ");					Date d = new Date(f.lastModified());				GregorianCalendar c = new GregorianCalendar();				c.setTime(d);				int day	= c.get(Calendar.DAY_OF_MONTH);				sb.append( months[ c.get(Calendar.MONTH) ] + " " + day );				if ( day < 10 ) 					sb.append(" ");					sb.append(" ");					// hack to get fixed length 'length' field				int fieldlen = 8;				StringBuilder len = new StringBuilder();				for(int j=0; j<fieldlen; j++)					len.append(" ");				len.insert(0, f.length());				len.setLength(fieldlen);				// hack to move the spaces to the front				int si = len.toString().indexOf(" ");				if ( si != -1 ) {					String pad = len.toString().substring(si);					len.setLength(si);					len.insert(0, pad);				}								sb.append( len.toString() );					sb.append( " " + f.getName() );				if ( f.isDirectory() ) 					sb.append("/");					env.println( sb.toString() );			}		}	
public DirectoryListSet(String directory, String glob, boolean recurse)		{			this.directory = directory;			this.glob = glob;			this.recurse = recurse;			this.skipBinary = jEdit.getBooleanProperty("search.skipBinary.toggle");			this.skipHidden = jEdit.getBooleanProperty("search.skipHidden.toggle");		}	
public String getDirectory()		{			return directory;		}	
/**		 * @since jEdit 4.2pre1		 */		public void setDirectory(String directory)		{			this.directory = directory;			invalidateCachedList();		}	
public String getFileFilter()		{			return glob;		}	
/**		 * @since jEdit 4.2pre1		 */		public void setFileFilter(String glob)		{			this.glob = glob;			invalidateCachedList();		}	
public boolean isRecursive()		{			return recurse;		}	
/**		 * @since jEdit 4.2pre1		 */		public void setRecursive(boolean recurse)		{			this.recurse = recurse;			invalidateCachedList();		}	
@Override		public String getCode()		{			return "new DirectoryListSet(\"" + StandardUtilities.charsToEscapes(directory)				+ "\",\"" + StandardUtilities.charsToEscapes(glob) + "\","				+ recurse + ')';		}	
@Override		protected String[] _getFiles(final Component comp)		{			skipBinary = jEdit.getBooleanProperty("search.skipBinary.toggle");			skipHidden = jEdit.getBooleanProperty("search.skipHidden.toggle");			final VFS vfs = VFSManager.getVFSForPath(directory);			Object session;			if(SwingUtilities.isEventDispatchThread())			{				session = vfs.createVFSSession(directory,comp);			}			else			{				final Object[] returnValue = new Object[1];					try				{					SwingUtilities.invokeAndWait(new Runnable()					{						public void run()						{							returnValue[0] = vfs.createVFSSession(directory,comp);						}					});				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);				}					session = returnValue[0];			}				if(session == null)				return null;				try			{				try				{					return vfs._listDirectory(session,directory,glob,recurse,comp, skipBinary, skipHidden);				}				finally				{					vfs._endVFSSession(session, comp);				}			}			catch(IOException io)			{				VFSManager.error(comp,directory,"ioerror",new String[]					{ io.toString() });				return null;			}		}	
public DirectoryProvider(String dir)		{			this.dir = dir;		}	
public boolean updateEveryTime()		{			return true;		}	
public void update(JMenu menu)		{			final View view = GUIUtilities.getView(menu);				String path;			if(dir == null)			{				path = view.getBuffer().getDirectory();			}			else				path = dir;				JMenuItem mi = new JMenuItem(path + ':');			mi.setActionCommand(path);			mi.setIcon(FileCellRenderer.openDirIcon);				//{{{ ActionListeners			ActionListener fileListener = new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					jEdit.openFile(view,evt.getActionCommand());				}			};				ActionListener dirListener = new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					VFSBrowser.browseDirectory(view,						evt.getActionCommand());				}			}; //}}}				mi.addActionListener(dirListener);				menu.add(mi);			menu.addSeparator();				if(dir == null && !(view.getBuffer().getVFS() instanceof FileVFS))			{				mi = new JMenuItem(jEdit.getProperty(					"directory.not-local"));				mi.setEnabled(false);				menu.add(mi);				return;			}				File directory = new File(path);				JMenu current = menu;				// for filtering out backups			String backupPrefix = jEdit.getProperty("backup.prefix");			String backupSuffix = jEdit.getProperty("backup.suffix");				File[] list = directory.listFiles();			if(list == null || list.length == 0)			{				mi = new JMenuItem(jEdit.getProperty(					"directory.no-files"));				mi.setEnabled(false);				menu.add(mi);			}			else			{				int maxItems = jEdit.getIntegerProperty("menu.spillover",20);					Arrays.sort(list,					new StandardUtilities.StringCompare<File>(true));				for(int i = 0; i < list.length; i++)				{					File file = list[i];						String name = file.getName();						// skip marker files					if(name.endsWith(".marks"))						continue;						// skip autosave files					if(name.startsWith("#") && name.endsWith("#"))						continue;						// skip backup files					if((backupPrefix.length() != 0						&& name.startsWith(backupPrefix))						|| (backupSuffix.length() != 0						&& name.endsWith(backupSuffix)))						continue;						// skip directories					//if(file.isDirectory())					//	continue;						mi = new JMenuItem(name);					mi.setActionCommand(file.getPath());					mi.addActionListener(file.isDirectory()						? dirListener						: fileListener);					mi.setIcon(file.isDirectory()						? FileCellRenderer.dirIcon						: FileCellRenderer.fileIcon);						if(current.getItemCount() >= maxItems && i != list.length - 1)					{						//current.addSeparator();						JMenu newCurrent = new JMenu(							jEdit.getProperty(							"common.more"));						current.add(newCurrent);						current = newCurrent;					}					current.add(mi);				}			}		}	
public void put( String name, ClassSource source ) {				super.put( name, source );			}	
public ClassSource get( String name ) {				return (ClassSource)super.get( name );			}	
public DiscreteFilesClassLoader( 			BshClassManager classManager, ClassSourceMap map ) 		{			super( classManager );			this.map = map;		}	
/**		*/		public Class findClass( String name ) throws ClassNotFoundException 		{			// Load it if it's one of our classes			ClassSource source = map.get( name );				if ( source != null )			{				byte [] code = source.getCode( name );				return defineClass( name, code, 0, code.length );			} else				// Let superclass BshClassLoader (URLClassLoader) findClass try 				// to find the class...				return super.findClass( name );		}	
public String toString() {			return super.toString() + "for files: "+map;		}	
static DisplayManager getDisplayManager(JEditBuffer buffer,			TextArea textArea)		{			List<DisplayManager> l = bufferMap.get(buffer);			if(l == null)			{				l = new LinkedList<DisplayManager>();				bufferMap.put(buffer,l);			}				/* An existing display manager's fold visibility map			that a new display manager will inherit */			DisplayManager copy = null;			Iterator<DisplayManager> liter = l.iterator();			DisplayManager dmgr;			while(liter.hasNext())			{				dmgr = liter.next();				copy = dmgr;				if(!dmgr.inUse && dmgr.textArea == textArea)				{					dmgr.inUse = true;					return dmgr;				}			}				// if we got here, no unused display manager in list			dmgr = new DisplayManager(buffer,textArea,copy);			dmgr.inUse = true;			l.add(dmgr);				return dmgr;		}	
void release()		{			inUse = false;		}	
public static void bufferClosed(JEditBuffer buffer)		{			bufferMap.remove(buffer);		}	
static void textAreaDisposed(TextArea textArea)		{			for (List<DisplayManager> l : bufferMap.values())			{				Iterator<DisplayManager> liter = l.iterator();				while(liter.hasNext())				{					DisplayManager dmgr = liter.next();					if(dmgr.textArea == textArea)					{						dmgr.dispose();						liter.remove();					}				}			}		}	
/**		 * @since jEdit 4.3pre3		 */		public JEditBuffer getBuffer()		{			return buffer;		}	
/**		 * Returns if the specified line is visible.		 * @param line A physical line index		 * @since jEdit 4.2pre1		 */		public final boolean isLineVisible(int line)		{			return folds.search(line) % 2 == 0;		}	
/**		 * Returns the physical line number of the first visible line.		 * @since jEdit 4.2pre1		 */		public int getFirstVisibleLine()		{			return folds.first();		}	
/**		 * Returns the physical line number of the last visible line.		 * @since jEdit 4.2pre1		 */		public int getLastVisibleLine()		{			return folds.last();		}	
/**		 * Returns the next visible line after the specified line index,		 * or (-1) if there is no next visible line.		 * @param line A physical line index		 * @since jEdit 4.0pre1		 */		public int getNextVisibleLine(int line)		{			if(line < 0 || line >= buffer.getLineCount())				throw new ArrayIndexOutOfBoundsException(line);				return folds.next(line);		}	
/**		 * Returns the previous visible line before the specified line index.		 * @param line a physical line index		 * @return the previous visible physical line or -1 if there is no visible line		 * @since jEdit 4.0pre1		 */		public int getPrevVisibleLine(int line)		{			if(line < 0 || line >= buffer.getLineCount())				throw new ArrayIndexOutOfBoundsException(line);				return folds.prev(line);		}	
/**		 * Returns how many screen lines contains the given physical line.		 * It can be greater than 1 when using soft wrap		 *		 * @param line the physical line		 * @return the screen line count		 */		public final int getScreenLineCount(int line)		{			updateScreenLineCount(line);			return screenLineMgr.getScreenLineCount(line);		}	
/**		 * Returns the number of displayable lines		 * It can be greater than the number of lines of the buffer when using		 * soft wrap (a line can count for n lines), or when using folding, if		 * the foldings are collapsed		 * @return the number of displayable lines		 */		public final int getScrollLineCount()		{			return scrollLineCount.scrollLine;		}	
/**		 * Collapses the fold at the specified physical line index.		 * @param line A physical line index		 * @since jEdit 4.2pre1		 */		public void collapseFold(int line)		{			int lineCount = buffer.getLineCount();			int end = lineCount - 1;				// if the caret is on a collapsed fold, collapse the			// parent fold			if(line != 0				&& line != buffer.getLineCount() - 1				&& buffer.isFoldStart(line)				&& !isLineVisible(line + 1))			{				line--;			}				int initialFoldLevel = buffer.getFoldLevel(line);				//{{{ Find fold start and end...			int start = 0;			if(line != lineCount - 1				&& buffer.getFoldLevel(line + 1) > initialFoldLevel)			{				// this line is the start of a fold				start = line + 1;					for(int i = line + 1; i < lineCount; i++)				{					if(buffer.getFoldLevel(i) <= initialFoldLevel)					{						end = i - 1;						break;					}				}			}			else			{				boolean ok = false;					// scan backwards looking for the start				for(int i = line - 1; i >= 0; i--)				{					if(buffer.getFoldLevel(i) < initialFoldLevel)					{						start = i + 1;						ok = true;						break;					}				}					if(!ok)				{					// no folds in buffer					return;				}					for(int i = line + 1; i < lineCount; i++)				{					if(buffer.getFoldLevel(i) < initialFoldLevel)					{						end = i - 1;						break;					}				}			} //}}}				// Collapse the fold...			hideLineRange(start,end);				notifyScreenLineChanges();			textArea.foldStructureChanged();		}	
/**		 * Expands the fold at the specified physical line index.		 * @param line A physical line index		 * @param fully If true, all subfolds will also be expanded		 * @since jEdit 4.2pre1		 */		public int expandFold(int line, boolean fully)		{			// the first sub-fold. used by JEditTextArea.expandFold().			int returnValue = -1;				int lineCount = buffer.getLineCount();			int end = lineCount - 1;				if (line == lineCount - 1)			{				return -1;			}			while (!isLineVisible(line))			{				int prevLine = folds.lookup(folds.search(line)) - 1;				if (!isLineVisible(prevLine))				{					return -1;				}				expandFold(prevLine, fully);				if (!isLineVisible(prevLine + 1))				{					return -1;				}			}			if (isLineVisible(line+1) && !fully)			{				return -1;			}				//{{{ Find fold start and fold end...			int start;			int initialFoldLevel = buffer.getFoldLevel(line);			if (buffer.getFoldLevel(line + 1) > initialFoldLevel)			{				// this line is the start of a fold				start = line;				if (!isLineVisible(line + 1) && folds.search(line + 1) != folds.count() - 1)				{					int index = folds.search(line + 1);					end = folds.lookup(index + 1) - 1;				}				else				{					for (int i = line + 1; i < lineCount; i++)					{						if (buffer.getFoldLevel(i) <= initialFoldLevel)						{							end = i - 1;							break;						}					}				}			}			else			{				if (!fully)				{					return -1;				}				start = line;				while (start > 0 && buffer.getFoldLevel(start) >= initialFoldLevel)				{					start--;				}				initialFoldLevel = buffer.getFoldLevel(start);				for (int i = line + 1; i < lineCount; i++)				{					if (buffer.getFoldLevel(i) <= initialFoldLevel)					{						end = i - 1;						break;					}				}			} // }}}				//{{{ Expand the fold...			if(fully)			{				showLineRange(start,end);			}			else			{				for (int i = start + 1; i <= end;)				{					if (returnValue == -1 && buffer.isFoldStart(i))					{						returnValue = i;					}						showLineRange(i, i);					int fold = buffer.getFoldLevel(i);					i++;					while (i <= end && buffer.getFoldLevel(i) > fold)					{						i++;					}				}			} // }}}				notifyScreenLineChanges();			textArea.foldStructureChanged();				return returnValue;		}	
/**		 * Expands all folds.		 * @since jEdit 4.2pre1		 */		public void expandAllFolds()		{			showLineRange(0,buffer.getLineCount() - 1);			notifyScreenLineChanges();			textArea.foldStructureChanged();		}	
/**		 * This method should only be called from <code>actions.xml</code>.		 * @since jEdit 4.2pre1		 */		public void expandFolds(char digit)		{			if(digit < '1' || digit > '9')			{				Toolkit.getDefaultToolkit().beep();			}			else				expandFolds((digit - '1') + 1);		}	
/**		 * Expands all folds with the specified fold level.		 * @param foldLevel The fold level		 * @since jEdit 4.2pre1		 */		public void expandFolds(int foldLevel)		{			if(buffer.getFoldHandler() instanceof IndentFoldHandler)				foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;				showLineRange(0,buffer.getLineCount() - 1);				/* this ensures that the first line is always visible */			boolean seenVisibleLine = false;				int firstInvisible = 0;				for(int i = 0; i < buffer.getLineCount(); i++)			{				if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)				{					if(firstInvisible != i)					{						hideLineRange(firstInvisible,							i - 1);					}					firstInvisible = i + 1;					seenVisibleLine = true;				}			}				if(firstInvisible != buffer.getLineCount())				hideLineRange(firstInvisible,buffer.getLineCount() - 1);				notifyScreenLineChanges();			if(textArea.getDisplayManager() == this)			{				textArea.foldStructureChanged();			}		}	
/**		 * Narrows the visible portion of the buffer to the specified		 * line range.		 * @param start The first line		 * @param end The last line		 * @since jEdit 4.2pre1		 */		public void narrow(int start, int end)		{			if(start > end || start < 0 || end >= buffer.getLineCount())				throw new ArrayIndexOutOfBoundsException(start + ", " + end);				if(start < getFirstVisibleLine() || end > getLastVisibleLine())				expandAllFolds();				if(start != 0)				hideLineRange(0,start - 1);			if(end != buffer.getLineCount() - 1)				hideLineRange(end + 1,buffer.getLineCount() - 1);				// if we narrowed to a single collapsed fold			if(start != buffer.getLineCount() - 1				&& !isLineVisible(start + 1))				expandFold(start,false);				textArea.fireNarrowActive();				notifyScreenLineChanges();			textArea.foldStructureChanged();		}	
void init()		{			if(initialized)			{				if(!buffer.isLoading())					resetAnchors();			}			else			{				initialized = true;				folds = new RangeMap();				if(buffer.isLoading())					folds.reset(buffer.getLineCount());				else					bufferHandler.foldHandlerChanged(buffer);				notifyScreenLineChanges();			}		}	
void notifyScreenLineChanges()		{			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"notifyScreenLineChanges()");				// when the text area switches to us, it will do			// a reset anyway			if(textArea.getDisplayManager() != this)				return;				try			{				if(firstLine.callReset)					firstLine.reset();				else if(firstLine.callChanged)					firstLine.changed();					if(scrollLineCount.callReset)				{					scrollLineCount.reset();					firstLine.ensurePhysicalLineIsVisible();				}				else if(scrollLineCount.callChanged)					scrollLineCount.changed();								if(firstLine.callChanged || scrollLineCount.callReset					|| scrollLineCount.callChanged)				{					textArea.updateScrollBar();					textArea.recalculateLastPhysicalLine();				}			}			finally			{				firstLine.callReset = firstLine.callChanged = false;				scrollLineCount.callReset = scrollLineCount.callChanged = false;			}		}	
void setFirstLine(int oldFirstLine, int firstLine)		{			int visibleLines = textArea.getVisibleLines();				if(firstLine >= oldFirstLine + visibleLines)			{				this.firstLine.scrollDown(firstLine - oldFirstLine);				textArea.chunkCache.invalidateAll();			}			else if(firstLine <= oldFirstLine - visibleLines)			{				this.firstLine.scrollUp(oldFirstLine - firstLine);				textArea.chunkCache.invalidateAll();			}			else if(firstLine > oldFirstLine)			{				this.firstLine.scrollDown(firstLine - oldFirstLine);				textArea.chunkCache.scrollDown(firstLine - oldFirstLine);			}			else if(firstLine < oldFirstLine)			{				this.firstLine.scrollUp(oldFirstLine - firstLine);				textArea.chunkCache.scrollUp(oldFirstLine - firstLine);			}				notifyScreenLineChanges();		}	
/**		 * Scroll from a given amount of lines.		 *		 * @param amount the amount of lines that must be scrolled		 * @param skew a skew within the given line		 */		void setFirstPhysicalLine(int amount, int skew)		{			int oldFirstLine = textArea.getFirstLine();				if(amount == 0)			{				skew -= this.firstLine.skew;					// JEditTextArea.scrollTo() needs this to simplify				// its code				if(skew < 0)					this.firstLine.scrollUp(-skew);				else if(skew > 0)					this.firstLine.scrollDown(skew);				else				{					// nothing to do					return;				}			}			else if(amount > 0)				this.firstLine.physDown(amount,skew);			else if(amount < 0)				this.firstLine.physUp(-amount,skew);				int firstLine = textArea.getFirstLine();			int visibleLines = textArea.getVisibleLines();				if(firstLine == oldFirstLine)				/* do nothing */;			else if(firstLine >= oldFirstLine + visibleLines				|| firstLine <= oldFirstLine - visibleLines)			{				textArea.chunkCache.invalidateAll();			}			else if(firstLine > oldFirstLine)			{				textArea.chunkCache.scrollDown(firstLine - oldFirstLine);			}			else if(firstLine < oldFirstLine)			{				textArea.chunkCache.scrollUp(oldFirstLine - firstLine);			}				// we have to be careful			notifyScreenLineChanges();		}	
void invalidateScreenLineCounts()		{			screenLineMgr.invalidateScreenLineCounts();			firstLine.callReset = true;			scrollLineCount.callReset = true;		}	
void updateScreenLineCount(int line)		{			if(!screenLineMgr.isScreenLineCountValid(line))			{				int newCount = textArea.chunkCache					.getLineSubregionCount(line);					setScreenLineCount(line,newCount);			}		}	
void bufferLoaded()		{			folds.reset(buffer.getLineCount());			screenLineMgr.reset();				if(textArea.getDisplayManager() == this)			{				textArea.propertiesChanged();				init();			}				int collapseFolds = buffer.getIntegerProperty(				"collapseFolds",0);			if(collapseFolds != 0)				expandFolds(collapseFolds);		}	
void foldHandlerChanged()		{			if(buffer.isLoading())				return;				folds.reset(buffer.getLineCount());			resetAnchors();				int collapseFolds = buffer.getIntegerProperty(				"collapseFolds",0);			if(collapseFolds != 0)				expandFolds(collapseFolds);		}	
private DisplayManager(JEditBuffer buffer, TextArea textArea,			DisplayManager copy)		{			this.buffer = buffer;			this.screenLineMgr = new ScreenLineManager(buffer);			this.textArea = textArea;				scrollLineCount = new ScrollLineCount(this,textArea);			firstLine = new FirstLine(this,textArea);				bufferHandler = new BufferHandler(this,textArea,buffer);			// this listener priority thing is a bad hack...			buffer.addBufferListener(bufferHandler, JEditBuffer.HIGH_PRIORITY);				if(copy != null)			{				folds = new RangeMap(copy.folds);				initialized = true;			}		}	
private void resetAnchors()		{			firstLine.callReset = true;			scrollLineCount.callReset = true;			notifyScreenLineChanges();		}	
private void dispose()		{			buffer.removeBufferListener(bufferHandler);		}	
private void showLineRange(int start, int end)		{			if(Debug.FOLD_VIS_DEBUG)			{				Log.log(Log.DEBUG,this,"showLineRange(" + start					+ ',' + end + ')');			}				for(int i = start; i <= end; i++)			{				//XXX				if(!isLineVisible(i))				{					// important: not screenLineMgr.getScreenLineCount()					int screenLines = getScreenLineCount(i);					if(firstLine.physicalLine >= i)					{						firstLine.scrollLine += screenLines;						firstLine.callChanged = true;					}					scrollLineCount.scrollLine += screenLines;					scrollLineCount.callChanged = true;				}			}				/* update fold visibility map. */			folds.show(start,end);		}	
private void hideLineRange(int start, int end)		{			if(Debug.FOLD_VIS_DEBUG)			{				Log.log(Log.DEBUG,this,"hideLineRange(" + start					+ ',' + end + ')');			}				int i = start;			if(!isLineVisible(i))				i = getNextVisibleLine(i);			while(i != -1 && i <= end)			{				int screenLines = getScreenLineCount(i);				if(i < firstLine.physicalLine)				{					firstLine.scrollLine -= screenLines;					firstLine.skew = 0;					firstLine.callChanged = true;				}					scrollLineCount.scrollLine -= screenLines;				scrollLineCount.callChanged = true;					i = getNextVisibleLine(i);			}				/* update fold visibility map. */			folds.hide(start,end);				if(!isLineVisible(firstLine.physicalLine))			{				int firstVisible = getFirstVisibleLine();				if(firstLine.physicalLine < firstVisible)				{					firstLine.physicalLine = firstVisible;					firstLine.scrollLine = 0;				}				else				{					firstLine.physicalLine = getPrevVisibleLine(						firstLine.physicalLine);					firstLine.scrollLine -= getScreenLineCount(						firstLine.physicalLine);				}				firstLine.callChanged = true;			}		}	
/**		 * Sets the number of screen lines that the specified physical line		 * is split into.		 * @param line the line number		 * @param count the line count (1 if no wrap)		 * @since jEdit 4.2pre1		 */		private void setScreenLineCount(int line, int count)		{			int oldCount = screenLineMgr.getScreenLineCount(line);				// old one so that the screen line manager sets the			// validity flag!				screenLineMgr.setScreenLineCount(line,count);				if(count == oldCount)				return;				if(!isLineVisible(line))				return;				if(firstLine.physicalLine >= line)			{				if(firstLine.physicalLine == line)					firstLine.callChanged = true;				else				{					firstLine.scrollLine += count - oldCount;					firstLine.callChanged = true;				}			}				scrollLineCount.scrollLine += count - oldCount;			scrollLineCount.callChanged = true;		}	
/**		 * Init some variables that will be used when marking tokens.		 * This is called before {@link JEditBuffer#markTokens(int, TokenHandler)}		 * to store some data that will be required and that we don't want		 * to put in the parameters		 *		 * @param styles		 * @param fontRenderContext		 * @param expander		 * @param out		 * @param wrapMargin		 */		public void init(SyntaxStyle[] styles,			FontRenderContext fontRenderContext,			TabExpander expander, List<Chunk> out,			float wrapMargin)		{			super.init();				x = 0.0f;				this.styles = styles;			this.fontRenderContext = fontRenderContext;			this.expander = expander;				// SILLY: allow for anti-aliased characters' "fuzz"			if(wrapMargin != 0.0f)				this.wrapMargin = wrapMargin += 2.0f;			else				this.wrapMargin = 0.0f;				this.out = out;				seenNonWhitespace = false;			endX = endOfWhitespace = 0.0f;			end = null;		}	
/**		 * Returns the list of chunks.		 * @since jEdit 4.1pre7		 */		public List<Chunk> getChunkList()		{			return out;		}	
/**		 * Called by the token marker when a syntax token has been parsed.		 * @param seg The segment containing the text		 * @param id The token type (one of the constants in the		 * {@link Token} class).		 * @param offset The start offset of the token		 * @param length The number of characters in the token		 * @param context The line context		 * @since jEdit 4.2pre3		 */		public void handleToken(Segment seg, byte id, int offset, int length,			TokenMarker.LineContext context)		{			if(id == Token.END)			{				if(firstToken != null)					out.add(merge((Chunk)firstToken,seg));				return;			}				for(int splitOffset = 0; splitOffset < length; splitOffset += MAX_CHUNK_LEN)			{				int splitLength = Math.min(length - splitOffset,MAX_CHUNK_LEN);				Chunk chunk = createChunk(id,offset + splitOffset,splitLength,context);				addToken(chunk,context);					if(wrapMargin != 0.0f)				{					initChunk(chunk,seg);					x += chunk.width;						if(Character.isWhitespace(seg.array[						seg.offset + chunk.offset]))					{						if(seenNonWhitespace)						{							end = lastToken;							endX = x;						}						else							endOfWhitespace = x;					}					else					{						if(x > wrapMargin							&& end != null							&& seenNonWhitespace)						{							Chunk nextLine = new Chunk(endOfWhitespace,								end.offset + end.length,								getParserRuleSet(context));							initChunk(nextLine,seg);								nextLine.next = end.next;							end.next = null;								if(firstToken != null)								out.add(merge((Chunk)firstToken,seg));								firstToken = nextLine;								x = x - endX + endOfWhitespace;								end = null;							endX = x;						}							seenNonWhitespace = true;					}				}			}		}	
private Chunk createChunk(byte id, int offset, int length,			TokenMarker.LineContext context)		{			return new Chunk(id,offset,length,				getParserRuleSet(context),styles,				context.rules.getDefault());		}	
protected void initChunk(Chunk chunk, Segment seg)		{			chunk.init(seg,expander,x,fontRenderContext);		}	
private Chunk merge(Chunk first, Segment seg)		{			if(first == null)				return null;				Chunk chunk = first;			while(chunk.next != null)			{				Chunk next = (Chunk)chunk.next;				if(canMerge(chunk,next,seg))				{					// in case already initialized; un-initialize it					chunk.initialized = false;					chunk.length += next.length;					chunk.width += next.width;					chunk.next = next.next;				}				else				{					if(!chunk.initialized)					{						initChunk(chunk,seg);						if(wrapMargin == 0.0f)							x += chunk.width;					}					chunk = next;				}			}				if(!chunk.initialized)				initChunk(chunk,seg);				return first;		}	
private static boolean canMerge(Chunk c1, Chunk c2, Segment seg)		{			if(!c1.accessable || !c2.accessable)				return false;				char ch1 = seg.array[seg.offset + c1.offset];			char ch2 = seg.array[seg.offset + c2.offset];				return ((c1.style == c2.style)				&& ch1 != '\t' && ch2 != '\t'				&& (c1.length + c2.length <= MAX_CHUNK_LEN));		}	
/** @deprecated use isAlternateLayout */		@Deprecated		public boolean setAlternateLayout()		{			return isAlternateLayout();		}	
/**		 * jEdit View option: wide horizontal docking areas versus tall vertical docking areas 		 * @return true if using the "alternate layout"		 */		public boolean isAlternateLayout()		{			return alternateLayout;		}	
public void setAlternateLayout(boolean alternateLayout)		{			this.alternateLayout = alternateLayout;		}	
public void addLayoutComponent(String name, Component comp)		{			addLayoutComponent(comp, name);		}	
public void addLayoutComponent(Component comp, Object cons)		{			if(cons == null || CENTER.equals(cons))				center = comp;			else if(DockableWindowManager.TOP.equals(cons))				top = (DockablePanel)comp;			else if(DockableWindowManager.LEFT.equals(cons))				left = (DockablePanel)comp;			else if(DockableWindowManager.BOTTOM.equals(cons))				bottom = (DockablePanel)comp;			else if(DockableWindowManager.RIGHT.equals(cons))				right = (DockablePanel)comp;			else if(TOP_BUTTONS.equals(cons))				topButtons = comp;			else if(LEFT_BUTTONS.equals(cons))				leftButtons = comp;			else if(BOTTOM_BUTTONS.equals(cons))				bottomButtons = comp;			else if(RIGHT_BUTTONS.equals(cons))				rightButtons = comp;		}	
public void removeLayoutComponent(Component comp)		{			if(center == comp)				center = null;			else if(comp == top)				top = null;			else if(comp == left)				left = null;			else if(comp == bottom)				bottom = null;			else if(comp == right)				right = null;		}	
public Dimension preferredLayoutSize(Container parent)		{			Dimension prefSize = new Dimension(0,0);			Dimension _top = top.getPreferredSize();			Dimension _left = left.getPreferredSize();			Dimension _bottom = bottom.getPreferredSize();			Dimension _right = right.getPreferredSize();			Dimension _topButtons = topButtons.getPreferredSize();			Dimension _leftButtons = leftButtons.getPreferredSize();			Dimension _bottomButtons = bottomButtons.getPreferredSize();			Dimension _rightButtons = rightButtons.getPreferredSize();			Dimension _center = (center == null				? new Dimension(0,0)				: center.getPreferredSize());			Dimension _topToolbars = new Dimension(0,0);			Dimension _bottomToolbars = new Dimension(0,0);				prefSize.height = _top.height + _bottom.height + _center.height				+ _topButtons.height + _bottomButtons.height				+ _topToolbars.height + _bottomToolbars.height;			prefSize.width = _left.width + _right.width				+ Math.max(_center.width,				Math.max(_topToolbars.width,_bottomToolbars.width))				+ _leftButtons.width + _rightButtons.width;				return prefSize;		}	
public Dimension minimumLayoutSize(Container parent)		{			// I'm lazy			return preferredLayoutSize(parent);		}	
public Dimension maximumLayoutSize(Container parent)		{			return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);		}	
public void layoutContainer(Container parent)		{			Dimension size = parent.getSize();				Dimension _topToolbars = new Dimension(0,0);			Dimension _bottomToolbars = new Dimension(0,0);				int topButtonHeight = -1;			int bottomButtonHeight = -1;			int leftButtonWidth = -1;			int rightButtonWidth = -1;				Dimension _top = top.getPreferredSize();			Dimension _left = left.getPreferredSize();			Dimension _bottom = bottom.getPreferredSize();			Dimension _right = right.getPreferredSize();				int topHeight = _top.height;			int bottomHeight = _bottom.height;			int leftWidth = _left.width;			int rightWidth = _right.width;				boolean topEmpty = ((Container)topButtons)				.getComponentCount() <= 2;			boolean leftEmpty = ((Container)leftButtons)				.getComponentCount() <= 2;			boolean bottomEmpty = ((Container)bottomButtons)				.getComponentCount() <= 2;			boolean rightEmpty = ((Container)rightButtons)				.getComponentCount() <= 2;				Dimension closeBoxSize;			if(((Container)topButtons).getComponentCount() == 0)				closeBoxSize = new Dimension(0,0);			else			{				closeBoxSize = ((Container)topButtons)					.getComponent(0).getPreferredSize();			}				int closeBoxWidth = Math.max(closeBoxSize.width,				closeBoxSize.height) + 1;				if(alternateLayout)			{				//{{{ Lay out independent buttons				int _width = size.width;					int padding = (leftEmpty&&rightEmpty)					? 0 : closeBoxWidth;					topButtonHeight = top.getWindowContainer()					.getWrappedDimension(_width					- closeBoxWidth * 2);				topButtons.setBounds(					padding,					0,					size.width - padding * 2,					topButtonHeight);					bottomButtonHeight = bottom.getWindowContainer()					.getWrappedDimension(_width);				bottomButtons.setBounds(					padding,					size.height - bottomButtonHeight,					size.width - padding * 2,					bottomButtonHeight);					int _height = size.height					- topButtonHeight					- bottomButtonHeight;				//}}}					//{{{ Lay out dependent buttons				leftButtonWidth = left.getWindowContainer()					.getWrappedDimension(_height);				leftButtons.setBounds(					0,					topHeight + topButtonHeight,					leftButtonWidth,					_height - topHeight - bottomHeight);					rightButtonWidth = right.getWindowContainer()					.getWrappedDimension(_height);				rightButtons.setBounds(					size.width - rightButtonWidth,					topHeight + topButtonHeight,					rightButtonWidth,					_height - topHeight - bottomHeight);				//}}}					int[] dimensions = adjustDockingAreasToFit(					size,					topHeight,					leftWidth,					bottomHeight,					rightWidth,					topButtonHeight,					leftButtonWidth,					bottomButtonHeight,					rightButtonWidth,					_topToolbars,					_bottomToolbars);					topHeight = dimensions[0];				leftWidth = dimensions[1];				bottomHeight = dimensions[2];				rightWidth = dimensions[3];					//{{{ Lay out docking areas				top.setBounds(					0,					topButtonHeight,					size.width,					topHeight);					bottom.setBounds(					0,					size.height					- bottomHeight					- bottomButtonHeight,					size.width,					bottomHeight);					left.setBounds(					leftButtonWidth,					topButtonHeight + topHeight,					leftWidth,					_height - topHeight - bottomHeight);					right.setBounds(					_width - rightButtonWidth - rightWidth,					topButtonHeight + topHeight,					rightWidth,					_height - topHeight - bottomHeight); //}}}			}			else			{				//{{{ Lay out independent buttons				int _height = size.height;					int padding = (topEmpty && bottomEmpty					? 0 : closeBoxWidth);					leftButtonWidth = left.getWindowContainer()					.getWrappedDimension(_height					- closeBoxWidth * 2);				leftButtons.setBounds(					0,					padding,					leftButtonWidth,					_height - padding * 2);					rightButtonWidth = right.getWindowContainer()					.getWrappedDimension(_height);				rightButtons.setBounds(					size.width - rightButtonWidth,					padding,					rightButtonWidth,					_height - padding * 2);					int _width = size.width					- leftButtonWidth					- rightButtonWidth;				//}}}					//{{{ Lay out dependent buttons				topButtonHeight = top.getWindowContainer()					.getWrappedDimension(_width);				topButtons.setBounds(					leftButtonWidth + leftWidth,					0,					_width - leftWidth - rightWidth,					topButtonHeight);					bottomButtonHeight = bottom.getWindowContainer()					.getWrappedDimension(_width);				bottomButtons.setBounds(					leftButtonWidth + leftWidth,					_height - bottomButtonHeight,					_width - leftWidth - rightWidth,					bottomButtonHeight); //}}}					int[] dimensions = adjustDockingAreasToFit(					size,					topHeight,					leftWidth,					bottomHeight,					rightWidth,					topButtonHeight,					leftButtonWidth,					bottomButtonHeight,					rightButtonWidth,					_topToolbars,					_bottomToolbars);					topHeight = dimensions[0];				leftWidth = dimensions[1];				bottomHeight = dimensions[2];				rightWidth = dimensions[3];					//{{{ Lay out docking areas				top.setBounds(					leftButtonWidth + leftWidth,					topButtonHeight,					_width - leftWidth - rightWidth,					topHeight);					bottom.setBounds(					leftButtonWidth + leftWidth,					size.height - bottomHeight - bottomButtonHeight,					_width - leftWidth - rightWidth,					bottomHeight);					left.setBounds(					leftButtonWidth,					0,					leftWidth,					_height);					right.setBounds(					size.width - rightWidth - rightButtonWidth,					0,					rightWidth,					_height); //}}}			}				//{{{ Position center (edit pane, or split pane)			if(center != null)			{				center.setBounds(					leftButtonWidth + leftWidth,					topButtonHeight + topHeight					+ _topToolbars.height,					size.width					- leftWidth					- rightWidth					- leftButtonWidth					- rightButtonWidth,					size.height					- topHeight					- topButtonHeight					- bottomHeight					- bottomButtonHeight					- _topToolbars.height					- _bottomToolbars.height);			} //}}}		}	
private int[] adjustDockingAreasToFit(			Dimension size,			int topHeight,			int leftWidth,			int bottomHeight,			int rightWidth,			int topButtonHeight,			int leftButtonWidth,			int bottomButtonHeight,			int rightButtonWidth,			Dimension _topToolbars,			Dimension _bottomToolbars)		{			int maxTopHeight = size.height - bottomHeight				- topButtonHeight - bottomButtonHeight				- _topToolbars.height - _bottomToolbars.height;			topHeight = Math.min(Math.max(0,maxTopHeight),				topHeight);			leftWidth = Math.min(Math.max(0,				size.width - leftButtonWidth				- rightButtonWidth - rightWidth),leftWidth);			int maxBottomHeight = size.height - topHeight				- topButtonHeight - bottomButtonHeight				- _topToolbars.height - _bottomToolbars.height;			bottomHeight = Math.min(Math.max(0,maxBottomHeight),				bottomHeight);			rightWidth = Math.min(Math.max(0,				size.width - leftButtonWidth				- rightButtonWidth - leftWidth),rightWidth);				top.getWindowContainer().setDimension(topHeight);			left.getWindowContainer().setDimension(leftWidth);			bottom.getWindowContainer().setDimension(bottomHeight);			right.getWindowContainer().setDimension(rightWidth);				return new int[] {				topHeight,				leftWidth,				bottomHeight,				rightWidth			};		}	
public float getLayoutAlignmentX(Container target)		{			return 0.5f;		}	
public float getLayoutAlignmentY(Container target)		{			return 0.5f;		}	
public void invalidateLayout(Container target) {}	
DockablePanel(PanelWindowContainer panel)		{			super(new CardLayout());				this.panel = panel;			this.wm = panel.getDockableWindowManager();				ResizeMouseHandler resizeMouseHandler = new ResizeMouseHandler();			addMouseListener(resizeMouseHandler);			addMouseMotionListener(resizeMouseHandler);		}	
PanelWindowContainer getWindowContainer()		{			return panel;		}	
void showDockable(String name)		{			((CardLayout)getLayout()).show(this,name);		}	
public Dimension getMinimumSize()		{			return new Dimension(0,0);		}	
public Dimension getPreferredSize()		{			final String position = panel.getPosition();			final int dimension = panel.getDimension();				if(panel.getCurrent() == null)				return new Dimension(0,0);			else			{				if(position.equals(DockableWindowManager.TOP)					|| position.equals(DockableWindowManager.BOTTOM))				{					if(dimension <= 0)					{						int height = super.getPreferredSize().height;						panel.setDimension(height);					}					return new Dimension(0,						dimension + PanelWindowContainer						.SPLITTER_WIDTH);				}				else				{					if(dimension <= 0)					{						int width = super.getPreferredSize().width;						panel.setDimension(width);					}					return new Dimension(dimension +						PanelWindowContainer.SPLITTER_WIDTH,						0);				}			}		}	
public void setBounds(int x, int y, int width, int height)		{			final String position = panel.getPosition();			final int dimension = panel.getDimension();				if(position.equals(DockableWindowManager.TOP) ||				position.equals(DockableWindowManager.BOTTOM))			{				if(dimension != 0 && height <= PanelWindowContainer.SPLITTER_WIDTH)					panel.show((DockableWindowManagerImpl.Entry) null);				else					panel.setDimension(height);			}			else			{				if(dimension != 0 && width <= PanelWindowContainer.SPLITTER_WIDTH)					panel.show((DockableWindowManagerImpl.Entry) null);				else					panel.setDimension(width);			}				super.setBounds(x,y,width,height);		}	
public void mousePressed(MouseEvent evt)			{				if(canDrag)				{					continuousLayout = jEdit.getBooleanProperty("appearance.continuousLayout");					wm.setResizePos(panel.getDimension(),panel);					dragStart = evt.getPoint();				}			}	
public void mouseReleased(MouseEvent evt)			{				if(canDrag)				{					if (!continuousLayout)					{						panel.setDimension(wm.resizePos								   + PanelWindowContainer							.SPLITTER_WIDTH);					}					wm.finishResizing();					dragStart = null;					wm.revalidate();				}			}	
public void mouseMoved(MouseEvent evt)			{				Border border = getBorder();				if(border == null)				{					// collapsed					return;				}					String position = panel.getPosition();					Insets insets = border.getBorderInsets(DockablePanel.this);				canDrag = false;				//{{{ Top...				if(position.equals(DockableWindowManager.TOP))				{					if(evt.getY() >= getHeight() - insets.bottom)						canDrag = true;				} //}}}				//{{{ Left...				else if(position.equals(DockableWindowManager.LEFT))				{					if(evt.getX() >= getWidth() - insets.right)						canDrag = true;				} //}}}				//{{{ Bottom...				else if(position.equals(DockableWindowManager.BOTTOM))				{					if(evt.getY() <= insets.top)						canDrag = true;				} //}}}				//{{{ Right...				else if(position.equals(DockableWindowManager.RIGHT))				{					if(evt.getX() <= insets.left)						canDrag = true;				} //}}}					if (dragStart == null)				{					if(canDrag)					{						wm.setCursor(Cursor.getPredefinedCursor(							getAppropriateCursor()));					}					else					{						wm.setCursor(Cursor.getPredefinedCursor(							Cursor.DEFAULT_CURSOR));					}				}			}	
public void mouseDragged(MouseEvent evt)			{				if(!canDrag)					return;					if(dragStart == null) // can't happen?					return;					int dimension = panel.getDimension();					String position = panel.getPosition();					int newSize = 0;				//{{{ Top...				if(position.equals(DockableWindowManager.TOP))				{					newSize = evt.getY();					wm.setResizePos(						evt.getY() - dragStart.y						+ dimension,						panel);				} //}}}				//{{{ Left...				else if(position.equals(DockableWindowManager.LEFT))				{					newSize = evt.getX();					wm.setResizePos(evt.getX() - dragStart.x						+ dimension,						panel);				} //}}}				//{{{ Bottom...				else if(position.equals(DockableWindowManager.BOTTOM))				{					newSize = dimension - evt.getY();					wm.setResizePos(dimension - evt.getY()						+ dragStart.y,						panel);				} //}}}				//{{{ Right...				else if(position.equals(DockableWindowManager.RIGHT))				{					newSize = dimension - evt.getX();					wm.setResizePos(dimension - evt.getX()						+ dragStart.x,						panel);				} //}}}					if (continuousLayout)				{					panel.setDimension(newSize							   + PanelWindowContainer.SPLITTER_WIDTH);					wm.revalidate();				}			}	
public void mouseExited(MouseEvent evt)			{				if (dragStart == null)				{					wm.setCursor(Cursor.getPredefinedCursor(						Cursor.DEFAULT_CURSOR));				}			}	
private int getAppropriateCursor()			{				String position = panel.getPosition();					if(position.equals(DockableWindowManager.TOP))					return Cursor.N_RESIZE_CURSOR;				else if(position.equals(DockableWindowManager.LEFT))					return Cursor.W_RESIZE_CURSOR;				else if(position.equals(DockableWindowManager.BOTTOM))					return Cursor.S_RESIZE_CURSOR;				else if(position.equals(DockableWindowManager.RIGHT))					return Cursor.E_RESIZE_CURSOR;				else					throw new InternalError();			}	
public static synchronized DockableWindowFactory getInstance()		{			if(instance == null)				instance = new DockableWindowFactory();			return instance;		}	
public DockableWindowFactory()		{			dockableWindowFactories = new HashMap<String, Window>();		}	
/**		 * Plugins shouldn't need to call this method.		 * @since jEdit 4.2pre1		 */		public void loadDockableWindows(PluginJAR plugin, URL uri,			PluginJAR.PluginCacheEntry cache)		{			try			{				Log.log(Log.DEBUG,DockableWindowManager.class,					"Loading dockables from " + uri);				DockableListHandler dh = new DockableListHandler(plugin,uri);				boolean failure = XMLUtilities.parseXML(uri.openStream(), dh);					if (!failure && cache != null)				{					cache.cachedDockableNames = dh.getCachedDockableNames();					cache.cachedDockableActionFlags = dh.getCachedDockableActionFlags();					cache.cachedDockableMovableFlags = dh.getCachedDockableMovableFlags();				}			}			catch(IOException e)			{				Log.log(Log.ERROR,DockableWindowManager.class,e);			}		}	
/**		 * Plugins shouldn't need to call this method.		 * @since jEdit 4.2pre1		 */		public void unloadDockableWindows(PluginJAR plugin)		{			Iterator entries = dockableWindowFactories.entrySet().iterator();			while(entries.hasNext())			{				Map.Entry entry = (Map.Entry)entries.next();				Window factory = (Window)entry.getValue();				if(factory.plugin == plugin)					entries.remove();			}		}	
/**		 * @since jEdit 4.2pre1		 */		public void cacheDockableWindows(PluginJAR plugin,			String[] name, boolean[] actions, boolean[] movable)		{			for(int i = 0; i < name.length; i++)			{				Window factory = new Window(plugin,					name[i],null,actions[i],movable[i]);				dockableWindowFactories.put(name[i],factory);			}		}	
public void registerDockableWindow(PluginJAR plugin,			String name, String code, boolean actions, boolean movable)		{			Window factory = dockableWindowFactories.get(name);			if(factory != null)			{				factory.code = code;				factory.loaded = true;			}			else			{				factory = new Window(plugin,name,code,actions, movable);				dockableWindowFactories.put(name,factory);			}		}	
public String[] getRegisteredDockableWindows()		{			String[] retVal = new String[dockableWindowFactories.size()];			Iterator<Window> entries = dockableWindowFactories.values().iterator();			int i = 0;			while(entries.hasNext())			{				Window factory = entries.next();				retVal[i++] = factory.name;			}				return retVal;		}	
public Window getDockableWindowFactory(String name)		{			return dockableWindowFactories.get(name);		}	
public String getDockableWindowPluginClass(String name)		{			Window w = getDockableWindowFactory(name);			if (w == null || w.plugin == null || w.plugin.getPlugin() == null)				return null;			return w.plugin.getPlugin().getClassName();		}	
Iterator<Window> getDockableWindowIterator()		{			return dockableWindowFactories.values().iterator();		}	
/**			 * @param plugin - the pluginJAR for which we are loading the dockables.xml			 * @param uri - the uri of the dockables.xml file?			 */			DockableListHandler(PluginJAR plugin, URL uri)			{				this.plugin = plugin;				this.uri = uri;				stateStack = new Stack<String>();				actions = true;				movable = MOVABLE_DEFAULT;					code = new StringBuilder();				cachedDockableNames = new LinkedList<String>();				cachedDockableActionFlags = new LinkedList<Boolean>();				cachedDockableMovableFlags = new LinkedList<Boolean>();			}	
@Override			public InputSource resolveEntity(String publicId, String systemId)			{				return XMLUtilities.findEntity(systemId, "dockables.dtd", MiscUtilities.class);			}	
@Override			public void characters(char[] c, int off, int len)			{				String tag = peekElement();				if (tag.equals("DOCKABLE"))					code.append(c, off, len);			}	
@Override			public void startElement(String uri, String localName,						 String qName, Attributes attrs)			{				String tag = pushElement(qName);				if (tag.equals("DOCKABLE"))				{					dockableName = attrs.getValue("NAME");					actions = "FALSE".equals(attrs.getValue("NO_ACTIONS"));					String movableAttr = attrs.getValue("MOVABLE");					if (movableAttr != null)						movable = movableAttr.equalsIgnoreCase("TRUE");				}			}	
@Override			public void endElement(String uri, String localName, String name)			{				if(name == null)					return;					String tag = peekElement();					if(name.equals(tag))				{					if(tag.equals("DOCKABLE"))					{						registerDockableWindow(plugin,							dockableName,code.toString(),actions, movable);						cachedDockableNames.add(dockableName);						cachedDockableActionFlags.add(							Boolean.valueOf(actions));						cachedDockableMovableFlags.add(								Boolean.valueOf(movable));						// make default be true for the next						// action						actions = true;						movable = MOVABLE_DEFAULT;						code.setLength(0);					}						popElement();				}				else				{					// can't happen					throw new InternalError();				}			}	
@Override			public void startDocument()			{				try				{					pushElement(null);				}				catch (Exception e)				{					Log.log(Log.ERROR, this, e);				}			}	
public String[] getCachedDockableNames()			{				return cachedDockableNames.toArray(new String[cachedDockableNames.size()]);			}	
public boolean[] getCachedDockableActionFlags()			{				return booleanListToArray(cachedDockableActionFlags);			}	
public boolean[] getCachedDockableMovableFlags()			{				return booleanListToArray(cachedDockableMovableFlags);			}	
/**			 * This method transforms a List<Boolean> into the corresponding			 * boolean[] array			 * @param list the List<Boolean> you want to convert			 * @return a boolean[] array			 */			private boolean[] booleanListToArray(java.util.List<Boolean> list)			{				boolean[] returnValue = new boolean[list.size()];				int i = 0;				for (Boolean value : list)				{					returnValue[i++] = value.booleanValue();				}					return returnValue;			}	
private String pushElement(String name)			{				name = (name == null) ? null : name.intern();					stateStack.push(name);					return name;			}	
private String peekElement()			{				return stateStack.peek();			}	
private String popElement()			{				return stateStack.pop();			}	
Window(PluginJAR plugin, String name, String code,				boolean actions, boolean movable)			{				this.plugin = plugin;				this.name = name;				this.code = code;				this.movable = movable;					if(code != null)					loaded = true;					if(actions)				{					ActionSet actionSet = (plugin == null						? jEdit.getBuiltInActionSet()						: plugin.getActionSet());					actionSet.addAction(new OpenAction(name));					actionSet.addAction(new ToggleAction(name));					actionSet.addAction(new FloatAction(name));						String label = jEdit.getProperty(name						+ ".label");					if(label == null)						label = "NO LABEL PROPERTY: " + name;						String[] args = { label };					jEdit.setTemporaryProperty(name + ".label",						label);					jEdit.setTemporaryProperty(name						+ "-toggle.label",						jEdit.getProperty(						"view.docking.toggle.label",args));					jEdit.setTemporaryProperty(name						+ "-toggle.toggle","true");					jEdit.setTemporaryProperty(name						+ "-float.label",						jEdit.getProperty(						"view.docking.float.label",args));				}			}	
void load()			{				if(loaded)					return;					loadDockableWindows(plugin,plugin.getDockablesURI(),null);			}	
JComponent createDockableWindow(View view, String position)			{				// Avoid infinite recursion				synchronized(this)				{					if (isBeingCreated)						return null;					isBeingCreated = true;				}					load();					if(!loaded)				{					Log.log(Log.WARNING,this,"Outdated cache");					return null;				}					NameSpace nameSpace = new NameSpace(					BeanShell.getNameSpace(),					"DockableWindowManager.Factory"					+ ".createDockableWindow()");				try				{					nameSpace.setVariable(						"position",position);				}				catch(UtilEvalError e)				{					Log.log(Log.ERROR,this,e);				}				JComponent win = (JComponent)BeanShell.eval(view,					nameSpace,code);				synchronized(this)				{					isBeingCreated = false;				}				return win;			}	
OpenAction(String name)				{					super(name);					this.dockable = name;				}	
public void invoke(View view)				{					view.getDockableWindowManager()						.showDockableWindow(dockable);				}	
@Override				public String getCode()				{					return "view.getDockableWindowManager()"						+ ".showDockableWindow(\"" + dockable + "\");";				}	
ToggleAction(String name)				{					super(name + "-toggle");					this.dockable = name;				}	
public void invoke(View view)				{					view.getDockableWindowManager()						.toggleDockableWindow(dockable);				}	
public boolean isSelected(View view)				{					return view.getDockableWindowManager()						.isDockableWindowVisible(dockable);				}	
@Override				public String getCode()				{					return "view.getDockableWindowManager()"						+ ".toggleDockableWindow(\"" + dockable + "\");";				}	
FloatAction(String name)				{					super(name + "-float");					this.dockable = name;				}	
public void invoke(View view)				{					view.getDockableWindowManager()						.floatDockableWindow(dockable);				}	
@Override				public String getCode()				{					return "view.getDockableWindowManager()"						+ ".floatDockableWindow(\"" + dockable + "\");";				}	
public DockableWindowManager(View view, DockableWindowFactory instance,				ViewConfig config)		{			this.view = view;			this.factory = instance;			alternateLayout = jEdit.getBooleanProperty(ALTERNATE_LAYOUT_PROP);		}	
public void init()		{			EditBus.addToBus(this);				Iterator<DockableWindowFactory.Window> entries = factory.getDockableWindowIterator();			while(entries.hasNext())			{				DockableWindowFactory.Window window = entries.next();				String dockable = window.name;				positions.put(dockable, getDockablePosition(dockable));				addPluginDockable(window.plugin, dockable);			}		}	
public void close()		{			EditBus.removeFromBus(this);		}	
public void applyDockingLayout(DockingLayout docking)		{			// By default, use the docking positions specified by the jEdit properties			Iterator<Entry<String, String>> iterator = positions.entrySet().iterator();			while (iterator.hasNext())			{				Entry<String, String> entry = iterator.next();				String dockable = entry.getKey();				String position = entry.getValue();				if (! position.equals(FLOATING))					showDockableWindow(dockable);			}		}	
/**		 * Opens the specified dockable window. As of jEdit 4.0pre1, has the		 * same effect as calling showDockableWindow().		 * @param name The dockable window name		 * @since jEdit 2.6pre3		 */		public void addDockableWindow(String name)		{			showDockableWindow(name);		}	
/**		 * Hides the specified dockable window. As of jEdit 4.2pre1, has the		 * same effect as calling hideDockableWindow().		 * @param name The dockable window name		 * @since jEdit 4.2pre1		 */		public void removeDockableWindow(String name)		{			hideDockableWindow(name);		}	
/**		 * Toggles the visibility of the specified dockable window.		 * @param name The dockable window name		 */		public void toggleDockableWindow(String name)		{			if(isDockableWindowVisible(name))				removeDockableWindow(name);			else				addDockableWindow(name);		}	
/**		 * Returns the specified dockable window.		 *		 * Note that this method		 * will return null if the dockable has not been added yet.		 * Make sure you call {@link #addDockableWindow(String)} first.		 *		 * @param name The name of the dockable window		 * @since jEdit 4.1pre2		 */		public JComponent getDockableWindow(String name)		{			return getDockable(name);		}	
/**		 * Hides all visible dock areas, or shows them again,		 * if the last time it was a hide.		 * @since jEdit 4.3pre16		 *		 */		public void toggleDockAreas()		{			if (closeToggle)			{				tTop = getTopDockingArea().getCurrent() != null;				tLeft = getLeftDockingArea().getCurrent() != null;				tRight = getRightDockingArea().getCurrent() != null;				tBottom = getBottomDockingArea().getCurrent() != null;				getBottomDockingArea().show(null);				getTopDockingArea().show(null);				getRightDockingArea().show(null);				getLeftDockingArea().show(null);			}			else			{				if (tBottom) getBottomDockingArea().showMostRecent();				if (tLeft) getLeftDockingArea().showMostRecent();				if (tRight) getRightDockingArea().showMostRecent();				if (tTop) getTopDockingArea().showMostRecent();			}			closeToggle = !closeToggle;			view.getTextArea().requestFocus();		}	
public void dockableTitleChanged(String dockable, String newTitle)		{		}	
/**		 *		 * The actionEvent "close-docking-area" by default only works on		 * windows that are docked. If you want your floatable plugins to also		 * respond to this event, you need to add key listeners to each component		 * in your plugin that usually has keyboard focus.		 * This function returns a key listener which does exactly that.		 * You should not need to call this method - it is used by FloatingWindowContainer.		 *		 * @param dockableName the name of your dockable		 * @return a KeyListener you can add to that plugin's component.		 * @since jEdit 4.3pre6		 *		 */		public KeyListener closeListener(String dockableName)		{			return new KeyHandler(dockableName);		}	
/**		 * Returns this dockable window manager's view.		 * @since jEdit 4.0pre2		 */		public View getView()		{			return view;		}	
/**		 * @since jEdit 4.3pre2		 */		public JComponent getDockable(String name)		{			return windows.get(name);		}	
/**		 * Returns the title of the specified dockable window.		 * @param name The name of the dockable window.		 * @since jEdit 4.1pre5		 */		public String getDockableTitle(String name)		{			return longTitle(name);		}	
/**		 * Changes the .longtitle property of a dockable window, which corresponds to the		 * title shown when it is floating (not docked). Fires a change event that makes sure		 * all floating dockables change their title.		 *		 * @param dockable the name of the dockable, as specified in the dockables.xml		 * @param title the new .longtitle you want to see above it.		 * @since 4.3pre5		 *		 */		public void setDockableTitle(String dockable, String title)		{			String propName = getLongTitlePropertyName(dockable);			String oldTitle = jEdit.getProperty(propName);			jEdit.setProperty(propName, title);			firePropertyChange(propName, oldTitle, title);			dockableTitleChanged(dockable, title);		}	
public static String[] getRegisteredDockableWindows()		{			return DockableWindowFactory.getInstance()				.getRegisteredDockableWindows();		}	
public static String getDockableWindowPluginName(String name)		{			String pluginClass =				DockableWindowFactory.getInstance().getDockableWindowPluginClass(name);			if (pluginClass == null)				return null;			return jEdit.getProperty("plugin." + pluginClass + ".name");		}	
public void setDockingLayout(DockingLayout docking)		{			applyDockingLayout(docking);			applyAlternateLayout(alternateLayout);		}	
private void addPluginDockable(PluginJAR plugin, String name)		{			Set<String> dockables = plugins.get(plugin);			if (dockables == null)			{				dockables = new HashSet<String>();				plugins.put(plugin, dockables);			}			dockables.add(name);		}	
public void handleMessage(EBMessage msg)		{			if (msg instanceof DockableWindowUpdate)			{				if(((DockableWindowUpdate)msg).getWhat() == DockableWindowUpdate.PROPERTIES_CHANGED)					propertiesChanged();			}			else if (msg instanceof PropertiesChanged)				propertiesChanged();			else if(msg instanceof PluginUpdate)			{				PluginUpdate pmsg = (PluginUpdate)msg;				if (pmsg.getWhat() == PluginUpdate.LOADED)				{					Iterator<DockableWindowFactory.Window> iter = factory.getDockableWindowIterator();					while (iter.hasNext())					{						DockableWindowFactory.Window w = iter.next();						if (w.plugin == pmsg.getPluginJAR())						{							String position = getDockablePosition(w.name);							positions.put(w.name, position);							addPluginDockable(w.plugin, w.name);							dockableLoaded(w.name, position);						}					}					propertiesChanged();				}				else if(pmsg.isExiting())				{					// we don't care				}				else if(pmsg.getWhat() == PluginUpdate.DEACTIVATED ||						pmsg.getWhat() == PluginUpdate.UNLOADED)				{					Set<String> dockables = plugins.remove(pmsg.getPluginJAR());					if (dockables != null)					{						for (String dockable: dockables)						{							disposeDockableWindow(dockable);							windows.remove(dockable);						}					}				}			}		}	
public String longTitle(String name)		{			String title = jEdit.getProperty(getLongTitlePropertyName(name));			if (title == null)				return shortTitle(name);			return title;		}	
public String shortTitle(String name)		{			String title = jEdit.getProperty(name + ".title");			if(title == null)				return "NO TITLE PROPERTY: " + name;			return title;		}	
protected void applyAlternateLayout(boolean alternateLayout)		{		}	
protected void dockableLoaded(String dockableName, String position)		{		}	
protected void dockingPositionChanged(String dockableName,			String oldPosition, String newPosition)		{		}	
protected boolean getAlternateLayoutProp()		{			return alternateLayout;		}	
protected void propertiesChanged()		{			if(view.isPlainView())				return;				boolean newAlternateLayout = jEdit.getBooleanProperty(ALTERNATE_LAYOUT_PROP);			if (newAlternateLayout != alternateLayout)			{				alternateLayout = newAlternateLayout;				applyAlternateLayout(newAlternateLayout);			}				String[] dockables = factory.getRegisteredDockableWindows();			for(int i = 0; i < dockables.length; i++)			{				String dockable = dockables[i];				String oldPosition = positions.get(dockable);				String newPosition = getDockablePosition(dockable);				if (oldPosition == null || !newPosition.equals(oldPosition))				{					positions.put(dockable, newPosition);					dockingPositionChanged(dockable, oldPosition, newPosition);				}			}			}	
protected JComponent createDockable(String name)		{			DockableWindowFactory.Window wf = factory.getDockableWindowFactory(name);			if (wf == null)			{				Log.log(Log.ERROR,this,"Unknown dockable window: " + name);				return null;			}			String position = getDockablePosition(name);			JComponent window = wf.createDockableWindow(view, position);			if (window != null)				windows.put(name, window);			return window;		}	
protected String getDockablePosition(String name)		{			return jEdit.getProperty(name + ".dock-position", FLOATING);		}	
protected void focusDockable(String name)		{			JComponent c = getDockable(name);			if (c == null)				return;			if (c instanceof DefaultFocusComponent)				((DefaultFocusComponent)c).focusOnDefaultComponent();			else				c.requestFocus();		}	
protected String getLongTitlePropertyName(String dockableName)		{			return dockableName + ".longtitle";		}	
public KeyHandler(String dockableName)			{				String shortcut1=jEdit.getProperty(action + ".shortcut");				String shortcut2=jEdit.getProperty(action + ".shortcut2");				if (shortcut1 != null)					b1 = parseShortcut(shortcut1);				if (shortcut2 != null)					b2 = parseShortcut(shortcut2);				name = dockableName;				match1 = match2 = 0;			}	
@Override			public void keyTyped(KeyEvent e)			{				if (b1 != null)					match1 = match(e, b1, match1);				if (b2 != null)					match2 = match(e, b2, match2);				if ((match1 > 0 && match1 == b1.size()) ||					(match2 > 0 && match2 == b2.size()))				{					hideDockableWindow(name);					match1 = match2 = 0;				}			}	
private int match(KeyEvent e, Vector<Key> shortcut, int index)			{				char c = e.getKeyChar();				if (shortcut != null && c == shortcut.get(index).key)					return index + 1;				return 0;			}	
private Vector<Key> parseShortcut(String shortcut)			{				Vector<Key> keys = new Vector<Key>();				String [] parts = shortcut.split("\\s+");				for (String part: parts)				{					if (part.length() > 0)						keys.add(KeyEventTranslator.parseKey(part));				}				return keys;			}	
public void setPlainView(boolean plain)			{			}	
public String [] getSavedLayouts()			{				String layoutDir = getLayoutDirectory();				if (layoutDir == null)					return null;				File dir = new File(layoutDir);				File[] files = dir.listFiles(new FilenameFilter()				{					public boolean accept(File dir, String name)					{						return name.endsWith(".xml");					}				});				String[] layouts = new String[files.length];				for (int i = 0; i < files.length; i++)					layouts[i] = fileToLayout(files[i].getName());				return layouts;			}	
private static String fileToLayout(String filename)			{				return filename.replaceFirst(".xml", "");			}	
private static String layoutToFile(String baseName, int viewIndex)			{				StringBuilder name = new StringBuilder(baseName);				if (viewIndex != NO_VIEW_INDEX)					name.append("-view").append(viewIndex);				name.append(".xml");				return name.toString();			}	
public String getLayoutFilename(String baseName, int viewIndex)			{				String dir = getLayoutDirectory();				if (dir == null)					return null;				return dir + File.separator + layoutToFile(baseName, viewIndex);			}	
private String getLayoutDirectory()			{				String name = getName();				if (name == null)					return null;				String dir = jEdit.getSettingsDirectory();				if (dir == null)					return null;				dir = dir + File.separator + name;				File d = new File(dir);				if (!d.exists())					d.mkdir();				return dir;			}	
public void startElement(String uri, String localName,						 String qName, Attributes attrs)				{					for (int i = 0; i < attrs.getLength(); i++)						attribute(attrs.getQName(i), attrs.getValue(i));				}	
private void attribute(String aname, String value)				{					if(aname.equals("TOP"))						top = value;					else if(aname.equals("LEFT"))						left = value;					else if(aname.equals("BOTTOM"))						bottom = value;					else if(aname.equals("RIGHT"))						right = value;					else if(aname.equals("TOP_POS"))						topPos = Integer.parseInt(value);					else if(aname.equals("LEFT_POS"))						leftPos = Integer.parseInt(value);					else if(aname.equals("BOTTOM_POS"))						bottomPos = Integer.parseInt(value);					else if(aname.equals("RIGHT_POS"))						rightPos = Integer.parseInt(value);				}	
public DefaultHandler getPerspectiveHandler()			{				return new PerspectiveHandler();			}	
public boolean saveLayout(String baseName, int viewIndex)			{				String lineSep = System.getProperty("line.separator");				String filename = getLayoutFilename(baseName, viewIndex);				BufferedWriter out = null;				try				{					out = new BufferedWriter(new FileWriter(filename));					out.write("<DOCKING LEFT=\"");					out.write(left == null ? "" : left);					out.write("\" TOP=\"");					out.write(top == null ? "" : top);					out.write("\" RIGHT=\"");					out.write(right == null ? "" : right);					out.write("\" BOTTOM=\"");					out.write(bottom == null ? "" : bottom);					out.write("\" LEFT_POS=\"");					out.write(String.valueOf(leftPos));					out.write("\" TOP_POS=\"");					out.write(String.valueOf(topPos));					out.write("\" RIGHT_POS=\"");					out.write(String.valueOf(rightPos));					out.write("\" BOTTOM_POS=\"");					out.write(String.valueOf(bottomPos));					out.write("\" />");					out.write(lineSep);				}				catch (IOException e)				{					Log.log(Log.ERROR, this, e, e);					return false;				}				finally				{					IOUtilities.closeQuietly(out);				}				return true;			}	
@Override			public boolean loadLayout(String baseName, int viewIndex)			{				String filename = getLayoutFilename(baseName, viewIndex);				DefaultHandler handler = getPerspectiveHandler();				try				{					// no need to close the stream it is closed by XMLUtilities.parseXML() method					XMLUtilities.parseXML(new FileInputStream(filename), handler);				}				catch (FileNotFoundException e)				{					return false;				}				catch (IOException e)				{					return false;				}				return true;			}	
@Override			public String getName()			{				return "DockableWindowManager";			}	
public void setDockingLayout(DockingLayout docking)		{			DockableWindowConfig config = (DockableWindowConfig) docking;			if (config == null)				return;			if(config.top != null && config.top.length() != 0)					showDockableWindow(config.top);				if(config.left != null && config.left.length() != 0)					showDockableWindow(config.left);				if(config.bottom != null && config.bottom.length() != 0)					showDockableWindow(config.bottom);				if(config.right != null && config.right.length() != 0)					showDockableWindow(config.right);					}	
@Override		public DockingLayout getDockingLayout(ViewConfig config)		{			DockableWindowConfig docking = new DockableWindowConfig();						docking.top = getTopDockingArea().getCurrent();			docking.left = getLeftDockingArea().getCurrent();			docking.bottom = getBottomDockingArea().getCurrent();			docking.right = getRightDockingArea().getCurrent();				docking.topPos = getTopDockingArea().getDimension();			docking.leftPos = getLeftDockingArea().getDimension();			docking.bottomPos = getBottomDockingArea().getDimension();			docking.rightPos = getRightDockingArea().getDimension();			return docking;		}	
/**		 * Creates a new dockable window manager.		 * @param view The view		 * @param factory A {@link DockableWindowFactory}, usually		 * <code>DockableWindowFactory.getInstance()</code>.		 * @param config A docking configuration		 * @since jEdit 2.6pre3		 */		public DockableWindowManagerImpl(View view, DockableWindowFactory factory,			View.ViewConfig config)		{			super(view, factory, config);			setLayout(new DockableLayout());				windows = new HashMap<String, Entry>();			clones = new ArrayList<Entry>();				DockableWindowConfig docking = (DockableWindowConfig) config.docking;			if (docking == null)				docking = new DockableWindowConfig();			top = new PanelWindowContainer(this,TOP,docking.topPos);			left = new PanelWindowContainer(this,LEFT,docking.leftPos);			bottom = new PanelWindowContainer(this,BOTTOM,docking.bottomPos);			right = new PanelWindowContainer(this,RIGHT,docking.rightPos);				add(DockableLayout.TOP_BUTTONS,top.buttonPanel);			add(DockableLayout.LEFT_BUTTONS,left.buttonPanel);			add(DockableLayout.BOTTOM_BUTTONS,bottom.buttonPanel);			add(DockableLayout.RIGHT_BUTTONS,right.buttonPanel);				add(TOP,top.dockablePanel);			add(LEFT,left.dockablePanel);			add(BOTTOM,bottom.dockablePanel);			add(RIGHT,right.dockablePanel);		}	
public void setMainPanel(JPanel panel) 		{			add(panel, 0);		}	
/**		 * Initialises dockable window manager. Do not call this method directly.		 */		public void init()		{			super.init();			Iterator<DockableWindowFactory.Window> entries = factory.getDockableWindowIterator();				while(entries.hasNext())				addEntry(entries.next());				propertiesChanged();		}	
/**		 * Opens a new instance of the specified dockable window in a floating		 * container.		 * @param name The dockable window name		 * @return The new dockable window instance		 * @since jEdit 4.1pre2		 */		public JComponent floatDockableWindow(String name)		{			Entry entry = windows.get(name);			if(entry == null)			{				Log.log(Log.ERROR,this,"Unknown dockable window: " + name);				return null;			}						// create a copy of this dockable window and float it			Entry newEntry = new Entry(entry.factory,FLOATING);			newEntry.win = newEntry.factory.createDockableWindow(view,FLOATING);						if(newEntry.win != null)			{				FloatingWindowContainer fwc = new FloatingWindowContainer(this,true); 				newEntry.container = fwc;				newEntry.container.register(newEntry);				newEntry.container.show(newEntry);											}			clones.add(newEntry);			return newEntry.win;		}	
/**		 * Opens the specified dockable window.		 * @param name The dockable window name		 * @since jEdit 2.6pre3		 */		public void showDockableWindow(String name)		{			lastEntry = windows.get(name);			if(lastEntry == null)			{				Log.log(Log.ERROR,this,"Unknown dockable window: " + name);				return;			}				if(lastEntry.win == null)			{				lastEntry.win = lastEntry.factory.createDockableWindow(					view,lastEntry.position);			}				if(lastEntry.win != null)			{				if(lastEntry.position.equals(FLOATING)					&& lastEntry.container == null)				{					FloatingWindowContainer fwc = new FloatingWindowContainer(						this,view.isPlainView()); 					lastEntry.container = fwc;					lastEntry.container.register(lastEntry);				}				showStack.push(name);				lastEntry.container.show(lastEntry);				Object reason = DockableWindowUpdate.ACTIVATED;				EditBus.send(new DockableWindowUpdate(this, reason, name));			}			else				/* an error occurred */;		}	
/**		 * Hides the specified dockable window.		 * @param name The dockable window name		 * @since jEdit 2.6pre3		 */		public void hideDockableWindow(String name)		{			Entry entry = windows.get(name);			if(entry == null)			{				Log.log(Log.ERROR,this,"Unknown dockable window: " + name);				return;			}			if(entry.win == null)				return;			entry.container.show(null);		}	
/**		 * Returns the specified dockable window.		 *		 * Note that this method		 * will return null if the dockable has not been added yet.		 * Make sure you call {@link #addDockableWindow(String)} first.		 *		 * For historical reasons, this		 * does the same thing as {@link #getDockableWindow(String)}.		 *		 * @param name The name of the dockable window		 * @since jEdit 4.0pre1		 */		public JComponent getDockable(String name)		{			Entry entry = windows.get(name);			if(entry == null || entry.win == null)				return null;			else				return entry.win;		}	
/**		 * Returns if the specified dockable window is visible.		 * @param name The dockable window name		 */		public boolean isDockableWindowVisible(String name)		{			Entry entry = windows.get(name);			if(entry == null || entry.win == null)				return false;			else				return entry.container.isVisible(entry);		}	
/**		 * Returns if the specified dockable window is docked into the		 * view.		 * @param name The dockable's name		 * @since jEdit 4.0pre2		 */		public boolean isDockableWindowDocked(String name)		{			Entry entry = windows.get(name);			if(entry == null)				return false;			else				return !entry.position.equals(FLOATING);		}	
/**		 * Closes the most recently focused dockable. 		 * @since jEdit 4.1pre3		 */		public void closeCurrentArea()		{			// I don't know of any other way to fix this, since invoking this			// command from a menu results in the focus owner being the menu			// until the menu goes away.			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					/* Try to hide the last entry that was shown */					try					{						String dockableName = showStack.pop();						hideDockableWindow(dockableName);						return;					}					catch (Exception e) {}										Component comp = view.getFocusOwner();					while(comp != null)					{						//System.err.println(comp.getClass());						if(comp instanceof DockablePanel)						{							DockablePanel panel = (DockablePanel) comp;														PanelWindowContainer container = panel.getWindowContainer();														container.show((DockableWindowManagerImpl.Entry) null);							return;						}							comp = comp.getParent();					}						getToolkit().beep();				}			});		}	
/**		 * Called when the view is being closed.		 * @since jEdit 2.6pre3		 */		public void close()		{			super.close();				for (Entry entry : windows.values())			{				if (entry.win != null)					entry.container.unregister(entry);			}				for (Entry clone : clones)			{				if (clone.win != null)					clone.container.unregister(clone);			}		}	
public PanelWindowContainer getTopDockingArea()		{			return top;		}	
public PanelWindowContainer getLeftDockingArea()		{			return left;		}	
public PanelWindowContainer getBottomDockingArea()		{			return bottom;		}	
public PanelWindowContainer getRightDockingArea()		{			return right;		}	
public JPopupMenu createPopupMenu(			final DockableWindowContainer container,			final String dockable,			final boolean clone)		{			JPopupMenu popup = new JPopupMenu();			if(dockable == null && container instanceof PanelWindowContainer)			{				ActionListener listener = new ActionListener()				{					public void actionPerformed(ActionEvent evt)					{						showDockableWindow(evt.getActionCommand());					}				};					String[] dockables = ((PanelWindowContainer)					container).getDockables();				Map<String,String> dockableMap = new TreeMap<String, String>();				for (int i = 0; i < dockables.length; i++)				{					String action = dockables[i];					dockableMap.put(getDockableTitle(action), action);				}				for (Map.Entry<String, String> entry : dockableMap.entrySet())				{					JMenuItem item = new JMenuItem(entry.getKey());					item.setActionCommand(entry.getValue());					item.addActionListener(listener);					popup.add(item);				}			}			else			{				JMenuItem caption = new JMenuItem(getDockableTitle(dockable));				caption.setEnabled(false);				popup.add(caption);				popup.addSeparator();				String currentPos = jEdit.getProperty(dockable + ".dock-position",FLOATING);				if(!clone)				{					String[] positions = { FLOATING, TOP, LEFT, BOTTOM, RIGHT };					for(int i = 0; i < positions.length; i++)					{						final String pos = positions[i];						if(pos.equals(currentPos))							continue;							JMenuItem moveMenuItem = new JMenuItem(jEdit.getProperty("view.docking.menu-"							+ pos));							moveMenuItem.addActionListener(new ActionListener()						{							public void actionPerformed(ActionEvent evt)							{								jEdit.setProperty(dockable + ".dock-position",pos);								EditBus.send(new DockableWindowUpdate(									DockableWindowManagerImpl.this,									DockableWindowUpdate.PROPERTIES_CHANGED,									dockable								));								showDockableWindow(dockable);							}						});						popup.add(moveMenuItem);					}						popup.addSeparator();				}					JMenuItem cloneMenuItem = new JMenuItem(jEdit.getProperty("view.docking.menu-clone"));					cloneMenuItem.addActionListener(new ActionListener()				{					public void actionPerformed(ActionEvent evt)					{						floatDockableWindow(dockable);					}				});				popup.add(cloneMenuItem);					popup.addSeparator();					JMenuItem closeMenuItem = new JMenuItem(jEdit.getProperty("view.docking.menu-close"));					closeMenuItem.addActionListener(new ActionListener()				{					public void actionPerformed(ActionEvent evt)					{						if(clone)							((FloatingWindowContainer)container).dispose();						else							removeDockableWindow(dockable);					}				});				popup.add(closeMenuItem);					if(!(clone || currentPos.equals(FLOATING)))				{					JMenuItem undockMenuItem = new JMenuItem(jEdit.getProperty("view.docking.menu-undock"));						undockMenuItem.addActionListener(new ActionListener()					{						public void actionPerformed(ActionEvent evt)						{							jEdit.setProperty(dockable + ".dock-position",FLOATING);							EditBus.send(new DockableWindowUpdate(								DockableWindowManagerImpl.this,								DockableWindowUpdate.PROPERTIES_CHANGED,								dockable							));							// Reset the window, propertiesChanged() doesn't							// reset it for MOVABLE windows.							Entry entry = windows.get(dockable);							if (entry == null)								Log.log(Log.ERROR,this,"Unknown dockable window: " + dockable);							else								entry.win = null;						}					});					popup.add(undockMenuItem);				}			}				return popup;		}	
public void paintChildren(Graphics g)		{			super.paintChildren(g);				if(resizeRect != null)			{				g.setColor(Color.darkGray);				g.fillRect(resizeRect.x,resizeRect.y,					resizeRect.width,resizeRect.height);			}		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof DockableWindowUpdate)			{				if(((DockableWindowUpdate)msg).getWhat()					== DockableWindowUpdate.PROPERTIES_CHANGED)					propertiesChanged();			}			else if(msg instanceof PropertiesChanged)				propertiesChanged();			else if(msg instanceof PluginUpdate)			{				PluginUpdate pmsg = (PluginUpdate)msg;				if(pmsg.getWhat() == PluginUpdate.LOADED)				{					Iterator<DockableWindowFactory.Window> iter = factory.getDockableWindowIterator();						while(iter.hasNext())					{						DockableWindowFactory.Window w = iter.next();						if(w.plugin == pmsg.getPluginJAR())							addEntry(w);					}						propertiesChanged();				}				else if(pmsg.isExiting())				{					// we don't care				}				else if(pmsg.getWhat() == PluginUpdate.DEACTIVATED)				{					Iterator<Entry> iter = getAllPluginEntries(						pmsg.getPluginJAR(),false);					while(iter.hasNext())					{						Entry entry = iter.next();						if(entry.container != null)							entry.container.remove(entry);					}				}				else if(pmsg.getWhat() == PluginUpdate.UNLOADED)				{					Iterator<Entry> iter = getAllPluginEntries(						pmsg.getPluginJAR(),true);					while(iter.hasNext())					{						Entry entry = iter.next();						if(entry.container != null)						{							entry.container.unregister(entry);							entry.win = null;							entry.container = null;						}					}				}			}		}	
void setResizePos(int resizePos, PanelWindowContainer resizing)		{			this.resizePos = resizePos;				if(resizePos < 0)				resizePos = 0;				if (continuousLayout)				return;				Rectangle newResizeRect = new Rectangle(0,0,				PanelWindowContainer.SPLITTER_WIDTH - 2,				PanelWindowContainer.SPLITTER_WIDTH - 2);			if(resizing == top)			{				resizePos = Math.min(resizePos,getHeight()					- top.buttonPanel.getHeight()					- bottom.dockablePanel.getHeight()					- bottom.buttonPanel.getHeight()					- PanelWindowContainer.SPLITTER_WIDTH);				newResizeRect.x = top.dockablePanel.getX() + 1;				newResizeRect.y = resizePos + top.buttonPanel.getHeight() + 1;				newResizeRect.width = top.dockablePanel.getWidth() - 2;			}			else if(resizing == left)			{				resizePos = Math.min(resizePos,getWidth()					- left.buttonPanel.getWidth()					- right.dockablePanel.getWidth()					- right.buttonPanel.getWidth()					- PanelWindowContainer.SPLITTER_WIDTH);				newResizeRect.x = resizePos + left.buttonPanel.getWidth() + 1;				newResizeRect.y = left.dockablePanel.getY() + 1;				newResizeRect.height = left.dockablePanel.getHeight() - 2;			}			else if(resizing == bottom)			{				resizePos = Math.min(resizePos,getHeight()					- bottom.buttonPanel.getHeight()					- top.dockablePanel.getHeight()					- top.buttonPanel.getHeight()					- PanelWindowContainer.SPLITTER_WIDTH);				newResizeRect.x = bottom.dockablePanel.getX() + 1;				newResizeRect.y = getHeight() - bottom.buttonPanel.getHeight() - resizePos					- PanelWindowContainer.SPLITTER_WIDTH + 2;				newResizeRect.width = bottom.dockablePanel.getWidth() - 2;			}			else if(resizing == right)			{				resizePos = Math.min(resizePos,getWidth()					- right.buttonPanel.getWidth()					- left.dockablePanel.getWidth()					- left.buttonPanel.getWidth()					- PanelWindowContainer.SPLITTER_WIDTH);				newResizeRect.x = getWidth() - right.buttonPanel.getWidth() - resizePos					- PanelWindowContainer.SPLITTER_WIDTH + 1;				newResizeRect.y = right.dockablePanel.getY() + 1;				newResizeRect.height = right.dockablePanel.getHeight() - 2;			}				Rectangle toRepaint;			if(resizeRect == null)				toRepaint = newResizeRect;			else				toRepaint = resizeRect.union(newResizeRect);			resizeRect = newResizeRect;			repaint(toRepaint);		}	
void finishResizing()		{			resizeRect = null;			repaint();		}	
protected void propertiesChanged()		{			if(view.isPlainView())				return;				((DockableLayout)getLayout()).setAlternateLayout(				jEdit.getBooleanProperty("view.docking.alternateLayout"));				String[] windowList = factory.getRegisteredDockableWindows();				for(int i = 0; i < windowList.length; i++)			{				String dockable = windowList[i];				Entry entry = windows.get(dockable);					String newPosition = jEdit.getProperty(dockable					+ ".dock-position",FLOATING);				if(newPosition.equals(entry.position))				{					continue;				}					entry.position = newPosition;				if(entry.container != null)				{					entry.container.unregister(entry);					entry.container = null;					if (entry.factory.movable && (! newPosition.equals(FLOATING)))					{						if (entry.win instanceof DockableWindow)							((DockableWindow)entry.win).move(newPosition);					}					else						entry.win = null;				}					if(newPosition.equals(FLOATING)) 				{				}									else				{					if(newPosition.equals(TOP))						entry.container = top;					else if(newPosition.equals(LEFT))						entry.container = left;					else if(newPosition.equals(BOTTOM))						entry.container = bottom;					else if(newPosition.equals(RIGHT))						entry.container = right;					else					{						Log.log(Log.WARNING,this,							"Unknown position: "							+ newPosition);						continue;					}						entry.container.register(entry);				}			}				top.sortDockables();			left.sortDockables();			bottom.sortDockables();			right.sortDockables();				continuousLayout = jEdit.getBooleanProperty("appearance.continuousLayout");			revalidate();			repaint();		}	
private void addEntry(DockableWindowFactory.Window factory)		{			Entry e;			if(view.isPlainView())			{				// don't show menu items to dock into a plain view				e = new Entry(factory,FLOATING);			}			else			{				e = new Entry(factory);				if(e.position.equals(FLOATING))					/* nothing to do */;				else if(e.position.equals(TOP))					e.container = top;				else if(e.position.equals(LEFT))					e.container = left;				else if(e.position.equals(BOTTOM))					e.container = bottom;				else if(e.position.equals(RIGHT))					e.container = right;				else				{					Log.log(Log.WARNING,this,						"Unknown position: "						+ e.position);				}					if(e.container != null)					e.container.register(e);			}			windows.put(factory.name,e);		}	
/**		 * If remove is false, only remove from clones list, otherwise remove		 * from both entries and clones.		 */		private Iterator<Entry> getAllPluginEntries(PluginJAR plugin, boolean remove)		{			List<Entry> returnValue = new LinkedList<Entry>();			Iterator<Entry> iter = windows.values().iterator();			while(iter.hasNext())			{				Entry entry = iter.next();				if(entry.factory.plugin == plugin)				{					returnValue.add(entry);					if(remove)						iter.remove();				}			}				iter = clones.iterator();			while(iter.hasNext())			{				Entry entry = iter.next();				if(entry.factory.plugin == plugin)				{					returnValue.add(entry);					iter.remove();				}			}				return returnValue.iterator();		}	
Entry(DockableWindowFactory.Window factory)			{				this(factory,jEdit.getProperty(factory.name					+ ".dock-position",FLOATING));			}	
/**			 * @return the long title for the dockable floating window.			 */			public String longTitle() 			{				String title = jEdit.getProperty(factory.name + ".longtitle");				if (title == null) return shortTitle();				else return title;							}	
/**			 * @return The short title, for the dockable button text			 */			public String shortTitle() 			{								String title = jEdit.getProperty(factory.name + ".title");				if(title == null)					return "NO TITLE PROPERTY: " + factory.name;				else					return title;			}	
/**			 * @return A label appropriate for the title on the dock buttons.			 */			public String label()			{				String retval = jEdit.getProperty(factory.name + ".label");				retval = retval.replaceAll("\\$", "");				return retval; 			}	
Entry(DockableWindowFactory.Window factory, String position)			{				this.factory = factory;				this.position = position;					// get the title here, not in the factory constructor,				// since the factory might be created before a plugin's				// props are loaded							}	
@Override		public void disposeDockableWindow(String name)		{			// Nothing to do here; called as a response to plugin unloading,			// handled differently by this implementation.		}	
public DockableWindowManager create(View view,				DockableWindowFactory instance, ViewConfig config)		{			return new DockableWindowManagerImpl(view, instance, config);		}	
public DockingLayout createDockingLayout()		{			return new DockableWindowManagerImpl.DockableWindowConfig();		}	
/**		 * Creates a new dockable window update message.		 * @param wm The dockable window manager		 * @param what What happened		 * @param dockable The dockable window in question		 */		public DockableWindowUpdate(DockableWindowManager wm, Object what,			String dockable)		{			super(wm);				if(what == null)				throw new NullPointerException("What must be non-null");				this.what = what;			this.dockable = dockable;		}	
/**		 * Returns what caused this dockable update.		 */		public Object getWhat()		{			return what;		}	
/**		 * Returns the dockable in question, or null if the message type is		 * <code>PROPERTIES_CHANGED</code>.		 */		public String getDockable()		{			return dockable;		}	
public String paramString()		{			return "what=" + what				+ ",dockable=" + dockable				+ "," + super.paramString();		}	
private DockingLayoutManager()		{			currentMode = new HashMap<View, String>();		}	
private static boolean save(View view, String layoutName)		{			DockingLayout docking = view.getViewConfig().docking; 			if (docking != null)			{				boolean ret = docking.saveLayout(layoutName, DockingLayout.NO_VIEW_INDEX);				if (! ret)					return false;				addAction(layoutName);			}			return true;		}	
public static void saveAs(View view)		{			if (jEdit.getSettingsDirectory() == null)			{				JOptionPane.showMessageDialog(view, jEdit.getProperty(NO_SETTINGS_MESSAGE));				return;			}			String layoutName = JOptionPane.showInputDialog(view,				jEdit.getProperty(SAVE_LAYOUT_MESSAGE),				jEdit.getProperty(SAVE_LAYOUT_TITLE),				JOptionPane.QUESTION_MESSAGE);			if (layoutName == null)				return;			if (! save(view, layoutName))				JOptionPane.showMessageDialog(view, jEdit.getProperty(SAVE_LAYOUT_FAILED));		}	
private static void load(View view, String layoutName)		{			DockingLayout docking = View.getDockingFrameworkProvider().createDockingLayout();			if (docking.loadLayout(layoutName, DockingLayout.NO_VIEW_INDEX))				view.getDockableWindowManager().setDockingLayout(docking);		}	
public static void load(View view)		{			if (jEdit.getSettingsDirectory() == null)			{				JOptionPane.showMessageDialog(view, jEdit.getProperty(NO_SETTINGS_MESSAGE));				return;			}			String layoutName = (String) JOptionPane.showInputDialog(view,				jEdit.getProperty(LOAD_LAYOUT_MESSAGE),				jEdit.getProperty(LOAD_LAYOUT_TITLE),				JOptionPane.QUESTION_MESSAGE,				null,				getSavedLayouts(),				null);			if (layoutName == null)				return;			load(view, layoutName);		}	
private static String[] getSavedLayouts()		{			DockingLayout docking = View.getDockingFrameworkProvider().createDockingLayout();			String[] layouts = null;			if (docking != null)				layouts = docking.getSavedLayouts();			if (layouts == null)				return new String[0];			return layouts;		}	
private static void addAction(String layoutName)		{			if ((actions != null) && (! actions.contains(layoutName)))				actions.addAction(new LoadPerspectiveAction(layoutName));		}	
public static void init()		{			createActions();			instance = new DockingLayoutManager();			EditBus.addToBus(instance);		}	
private static void createActions()		{			actions = new ActionSet("Docking Layouts");			String[] layouts = getSavedLayouts();			for (String layout: layouts)				addAction(layout);			jEdit.addActionSet(actions);			actions.initKeyBindings();		}	
public static void removeActions()		{			jEdit.removeActionSet(actions);		}	
public LoadPerspectiveAction(String layoutName)			{				super(LOAD_PREFIX + layoutName, new String[] { layoutName });				jEdit.setTemporaryProperty(LOAD_PREFIX + layoutName + ".label", LOAD_PREFIX + layoutName);			}	
@Override			public void invoke(View view)			{				DockingLayoutManager.load(view, (String) args[0]);			}	
private boolean canChangeEditMode(EBMessage message)		{			if (message instanceof BufferUpdate)			{				BufferUpdate bu = (BufferUpdate) message;				Object what = bu.getWhat();				if ((what == BufferUpdate.CLOSED) ||					(what == BufferUpdate.CREATED) ||					(what == BufferUpdate.PROPERTIES_CHANGED))				{					return true;				}			}			else if (message instanceof EditPaneUpdate)			{				EditPaneUpdate ep = (EditPaneUpdate) message;				Object what = ep.getWhat();				if ((what == EditPaneUpdate.BUFFER_CHANGED) ||					(what == EditPaneUpdate.CREATED))				{					return true;				}			}			return false;		}	
public void handleMessage(EBMessage message)		{			boolean autoLoadModeLayout = jEdit.getBooleanProperty(				DockingOptionPane.AUTO_LOAD_MODE_LAYOUT_PROP, false);			if (! autoLoadModeLayout)				return;			if (message instanceof ViewUpdate)			{				ViewUpdate vu = (ViewUpdate) message;				if (vu.getWhat() == ViewUpdate.CLOSED)				{					View view = jEdit.getActiveView();					String mode = currentMode.get(view);					saveModeLayout(view, mode);					return;				}			}			// Check for a change in the edit mode			View view = jEdit.getActiveView();			if (view == null)				return;			if (! canChangeEditMode(message))				return;			String newMode = getCurrentEditMode(view);			String mode = currentMode.get(view);			boolean sameMode =				(mode == null && newMode == null) ||				(mode != null && mode.equals(newMode));			if (! sameMode)			{				boolean autoSaveModeLayout = jEdit.getBooleanProperty(					DockingOptionPane.AUTO_SAVE_MODE_LAYOUT_PROP, false);				if (autoSaveModeLayout)					saveModeLayout(view, mode);				currentMode.put(view, newMode);				loadModeLayout(view, newMode);			}		}	
private String getCurrentEditMode(View view)		{			Buffer buffer = view.getBuffer();			if (buffer == null)				return null;			Mode bufferMode = buffer.getMode();			if (bufferMode == null)				return null;			return bufferMode.getName();		}	
private void saveModeLayout(View view, String mode)		{			String modeLayout = getModePerspective(mode);			if (modeLayout == null)				return;			save(view, modeLayout);		}	
private void loadModeLayout(View view, String mode)		{			String modeLayout = getModePerspective(mode);			if (modeLayout == null)				return;			load(view, modeLayout);		}	
public static void loadCurrentModeLayout(View view)		{			if (view == null)				return;			String mode = instance.getCurrentEditMode(view);			instance.loadModeLayout(view, mode);		}	
public static void saveCurrentModeLayout(View view)		{			if (view == null)				return;			String mode = instance.getCurrentEditMode(view);			instance.saveModeLayout(view, mode);		}	
private String getModePerspective(String mode)		{			if (mode == null)				mode = GLOBAL_MODE;			return "mode-" + mode;		}	
public DockingOptionPane()		{			super("docking");		}	
public void _init()		{			setLayout(new BorderLayout());			add(BorderLayout.NORTH,createDockingOptionsPanel());			add(BorderLayout.CENTER,createWindowTableScroller());			dockableSetSelection.setModel(				new DefaultComboBoxModel(windowModel.getDockableSets()));		}	
public void _save()		{			jEdit.setBooleanProperty(AUTO_LOAD_MODE_LAYOUT_PROP, autoLoadModeLayout.isSelected());			jEdit.setBooleanProperty(AUTO_SAVE_MODE_LAYOUT_PROP, autoSaveModeLayout.isSelected());			windowModel.save();		}	
private JPanel createDockingOptionsPanel()		{			JPanel p = new JPanel();			p.setLayout(new GridLayout(0, 1));			boolean autoLoadModeLayoutProp = jEdit.getBooleanProperty(				AUTO_LOAD_MODE_LAYOUT_PROP, false);			autoLoadModeLayout = new JCheckBox(				jEdit.getProperty(AUTO_LOAD_MODE_LAYOUT_LABEL),				autoLoadModeLayoutProp);			p.add(autoLoadModeLayout);			autoSaveModeLayout = new JCheckBox(				jEdit.getProperty(AUTO_SAVE_MODE_LAYOUT_LABEL),				jEdit.getBooleanProperty(AUTO_SAVE_MODE_LAYOUT_PROP, false));			p.add(autoSaveModeLayout);			autoSaveModeLayout.setEnabled(autoLoadModeLayoutProp);			autoLoadModeLayout.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent e)				{					autoSaveModeLayout.setEnabled(autoLoadModeLayout.isSelected());				}			});			Box vSetSelection = Box.createVerticalBox();			p.add(vSetSelection);			Box setSelection = Box.createHorizontalBox();			vSetSelection.add(setSelection);			setSelection.add(Box.createHorizontalStrut(6));			setSelection.add(new JLabel(jEdit.getProperty(				"options.docking.selectSet.label")));			setSelection.add(Box.createHorizontalStrut(6));			dockableSetSelection = new JComboBox();			setSelection.add(dockableSetSelection);			dockableSetSelection.addItemListener(new ItemListener()			{				public void itemStateChanged(ItemEvent e)				{					windowModel.showSet((String) dockableSetSelection.getSelectedItem());				}			});			setSelection.add(Box.createHorizontalStrut(6));			vSetSelection.add(Box.createVerticalStrut(6));			return p;		}	
private JScrollPane createWindowTableScroller()		{			windowModel = createWindowModel();			windowTable = new JTable(windowModel);			windowTable.getTableHeader().setReorderingAllowed(false);			windowTable.setColumnSelectionAllowed(false);			windowTable.setRowSelectionAllowed(false);			windowTable.setCellSelectionEnabled(false);				DockPositionCellRenderer comboBox = new DockPositionCellRenderer();			windowTable.setRowHeight(comboBox.getPreferredSize().height);			TableColumn column = windowTable.getColumnModel().getColumn(1);			column.setCellRenderer(comboBox);			column.setCellEditor(new DefaultCellEditor(new DockPositionCellRenderer()));				Dimension d = windowTable.getPreferredSize();			d.height = Math.min(d.height,50);			JScrollPane scroller = new JScrollPane(windowTable);			scroller.setPreferredSize(d);			return scroller;		}	
private static WindowTableModel createWindowModel()		{			return new WindowTableModel();		}	
DockPositionCellRenderer()			{				super(new String[] {					DockableWindowManager.FLOATING,					DockableWindowManager.TOP,					DockableWindowManager.LEFT,					DockableWindowManager.BOTTOM,					DockableWindowManager.RIGHT				});				DockPositionCellRenderer.this.setRequestFocusEnabled(false);			}	
public Component getTableCellRendererComponent(JTable table,				Object value, boolean isSelected, boolean hasFocus,				int row, int column)			{				setSelectedItem(value);				return this;			}	
WindowTableModel()		{			dockableSets = new HashMap<String, Vector<Entry>>();			Vector<Entry> all = new Vector<Entry>();			dockableSets.put(ALL_DOCKABLE_SET, all);			windows = new Vector<Entry>();			String[] dockables = DockableWindowManager.getRegisteredDockableWindows();			for (String dockable: dockables)			{				String plugin = DockableWindowManager.					getDockableWindowPluginName(dockable);				String set;				if (plugin != null)					set = PLUGIN_SET_PREFIX + plugin;				else					set = CORE_DOCKABLE_SET; 				Vector<Entry> currentSetDockables = dockableSets.get(set);				if (currentSetDockables == null)				{					currentSetDockables = new Vector<Entry>();					dockableSets.put(set, currentSetDockables);				}				Entry entry = new Entry(dockable);				currentSetDockables.add(entry);				all.add(entry);			}			showSet(ALL_DOCKABLE_SET);		}	
public Vector<String> getDockableSets()		{			Vector<String> sets = new Vector<String>();			for (String set: dockableSets.keySet())				sets.add(set);			sets.remove(ALL_DOCKABLE_SET);			sets.remove(CORE_DOCKABLE_SET);			Collections.sort(sets);			sets.insertElementAt(CORE_DOCKABLE_SET, 0);			sets.insertElementAt(ALL_DOCKABLE_SET, 0);			return sets;		}	
public void showSet(String set)		{			windows = dockableSets.get(set);			Collections.sort(windows,new WindowCompare());			fireTableDataChanged();		}	
public int getColumnCount()		{			return 2;		}	
public int getRowCount()		{			return windows.size();		}	
public Class getColumnClass(int col)		{			switch(col)			{			case 0:			case 1:				return String.class;			default:				throw new InternalError();			}		}	
public Object getValueAt(int row, int col)		{			Entry window = (Entry)windows.elementAt(row);			switch(col)			{			case 0:				return window.title;			case 1:				return window.dockPosition;			default:				throw new InternalError();			}		}	
public boolean isCellEditable(int row, int col)		{			return col != 0;		}	
public void setValueAt(Object value, int row, int col)		{			if(col == 0)				return;				Entry window = (Entry)windows.elementAt(row);			switch(col)			{			case 1:				window.dockPosition = (String)value;				break;			default:				throw new InternalError();			}				fireTableRowsUpdated(row,row);		}	
public String getColumnName(int index)		{			switch(index)			{			case 0:				return jEdit.getProperty("options.docking.title");			case 1:				return jEdit.getProperty("options.docking.dockPosition");			default:				throw new InternalError();			}		}	
public void save()		{			for(int i = 0; i < windows.size(); i++)			{				((Entry)windows.elementAt(i)).save();			}		}	
Entry(String name)			{				this.name = name;				title = jEdit.getProperty(name + ".title");				if(title == null)					title = name;					dockPosition = jEdit.getProperty(name + ".dock-position");				if(dockPosition == null)					dockPosition = DockableWindowManager.FLOATING;			}	
void save()			{				jEdit.setProperty(name + ".dock-position",dockPosition);			}	
public int compare(Object obj1, Object obj2)			{				Entry e1 = (Entry)obj1;				Entry e2 = (Entry)obj2;					return StandardUtilities.compareStrings(					e1.title,e2.title,true);			}	
public DummyFoldHandler()		{			super("none");		}	
/**		 * Returns the fold level of the specified line.		 * @param buffer The buffer in question		 * @param lineIndex The line index		 * @param seg A segment the fold handler can use to obtain any		 * text from the buffer, if necessary		 * @return The fold level of the specified line		 * @since jEdit 4.0pre1		 */		public int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg)		{			return 0;		}	
/**		 * Called by the token marker when a syntax token has been parsed.		 * @param seg The segment containing the text		 * @param id The token type (one of the constants in the		 * {@link Token} class).		 * @param offset The start offset of the token		 * @param length The number of characters in the token		 * @param context The line context		 * @since jEdit 4.2pre3		 */		public void handleToken(Segment seg, byte id, int offset, int length,			TokenMarker.LineContext context) {}	
/**		 * The token handler can compare this object with the object		 * previously given for this line to see if the token type at the end		 * of the line has changed (meaning subsequent lines might need to be		 * retokenized).		 * @since jEdit 4.2pre6		 */		public void setLineContext(TokenMarker.LineContext lineContext)		{		}	
/**		 * Creates a new dynamic menu changed message.		 * @param name The menu name. All dynamic menus with this name will be		 * recreated next time they are displayed.		 */		public DynamicMenuChanged(String name)		{			super(null);				this.name = name;		}	
/**		 * Returns the name of the menu in question.		 */		public String getMenuName()		{			return name;		}	
public String paramString()		{			return "menu=" + name + "," + super.paramString();		}	
/**		 * Creates a new message.		 * @param source The message source		 * @since jEdit 4.2pre1		 */		protected EBMessage(Object source)		{			this.source = source;		}	
/**		 * Creates a new message.		 * @param source The message source		 */		protected EBMessage(EBComponent source)		{			this.source = source;		}	
/**		 * Returns the sender of this message.		 * @since jEdit 4.2pre1		 */		public Object getSource()		{			return source;		}	
/**		 * Returns a string representation of this message.		 */		@Override		public String toString()		{			String className = getClass().getName();			int index = className.lastIndexOf('.');			return className.substring(index + 1)				+ '[' + paramString() + ']';		}	
/**		 * Returns a string representation of this message's parameters.		 */		public String paramString()		{			return "source=" + source;		}	
/**		 * Handles a message sent on the EditBus.		 */		// next version: remove this		public void handleMessage(EBMessage message)		{			EditBus.removeFromBus(this);			if(seenWarning)				return;			seenWarning = true;			Log.log(Log.WARNING,this,getClassName() + " should extend"				+ " EditPlugin not EBPlugin since it has an empty"				+ " handleMessage()");		}	
protected EBPlugin() {}	
/**		 * @since jEdit 4.2pre3		 */		public EditAbbrevDialog(Frame frame, String abbrev, String expansion,			Map abbrevs)		{			super(frame,jEdit.getProperty("edit-abbrev.title"),true);			init(abbrev, expansion, abbrevs);		}	
public EditAbbrevDialog(Dialog dialog, String abbrev, String expansion,			Map abbrevs)		{			super(dialog,jEdit.getProperty("edit-abbrev.title"),true);			init(abbrev, expansion, abbrevs);		}	
public String getAbbrev()		{			if(!isOK)				return null;				return editor.getAbbrev();		}	
public String getExpansion()		{			if(!isOK)				return null;				return editor.getExpansion();		}	
private void init(String abbrev, String expansion, Map abbrevs)		{			this.abbrevs = abbrevs;				this.originalAbbrev = abbrev;				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				editor = new AbbrevEditor();			editor.setAbbrev(abbrev);			editor.setExpansion(expansion);			editor.setBorder(new EmptyBorder(0,0,12,0));			content.add(BorderLayout.CENTER,editor);				Box box = new Box(BoxLayout.X_AXIS);			box.add(Box.createGlue());			ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(new ActionHandler());			getRootPane().setDefaultButton(ok);			box.add(ok);			box.add(Box.createHorizontalStrut(6));			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(new ActionHandler());			box.add(cancel);			box.add(Box.createGlue());			content.add(BorderLayout.SOUTH,box);				KeyListener listener = new KeyHandler();			addKeyListener(listener);			editor.getBeforeCaretTextArea().addKeyListener(listener);			editor.getAfterCaretTextArea().addKeyListener(listener);				setDefaultCloseOperation(DISPOSE_ON_CLOSE);			pack();			setLocationRelativeTo(getParent());			setVisible(true);		}	
private boolean checkForExistingAbbrev()		{			String abbrev = editor.getAbbrev();			if(abbrevs.get(abbrev) != null)			{				if(abbrev.equals(originalAbbrev))					return true;					int result = GUIUtilities.confirm(this,					"edit-abbrev.duplicate",null,					JOptionPane.YES_NO_OPTION,					JOptionPane.WARNING_MESSAGE);				return (result == JOptionPane.YES_OPTION);			}				return true;		}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == ok)				{					if(editor.getAbbrev() == null						|| editor.getAbbrev().length() == 0)					{						getToolkit().beep();						return;					}						if(!checkForExistingAbbrev())						return;						isOK = true;				}					dispose();			}	
public void keyPressed(KeyEvent evt)			{				if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)					dispose();			}	
/**		 * Creates a new edit action with the specified name.		 * @param name The action name		 */		public EditAction(String name)		{			super(name);		}	
public EditAction(String name, Object[] newArgs) 		{			super(name, newArgs);		}	
/**		 * Returns the action's label. This returns the		 * value of the property named by {@link #getName()} suffixed		 * with <code>.label</code>.		 * 		 */		public String getLabel()		{			if (args != null)			{				return jEdit.getProperty(name + ".label", args);			}			return jEdit.getProperty(name + ".label");		}	
/**		 * Returns the action's mouse over message. This returns the		 * value of the property named by {@link #getName()} suffixed		 * with <code>.mouse-over</code>.		 */		public final String getMouseOverText()		{			return jEdit.getProperty(name + ".mouse-over");		}	
/**		 * @deprecated Call <code>GUIUtilities.getView()</code> instead.		 */		public static View getView(Component comp)		{			// moved to GUIUtilities as it makes no sense being here.			return GUIUtilities.getView(comp);		}	
/**		 * Returns if this edit action should be displayed as a check box		 * in menus. This returns the		 * value of the property named by {@link #getName()} suffixed		 * with <code>.toggle</code>.		 *		 * @since jEdit 2.2pre4		 */		public final boolean isToggle()		{			return jEdit.getBooleanProperty(name + ".toggle");		}	
/**		 * If this edit action is a toggle, returns if it is selected or not.		 * @param comp The component		 * @since jEdit 4.2pre1		 */		public boolean isSelected(Component comp)		{			return false;		}	
/**		 * Returns if this edit action should not be repeated. Returns false		 * by default.		 * @since jEdit 2.7pre2		 */		public boolean noRepeat()		{			return false;		}	
/**		 * Returns if this edit action should not be recorded. Returns false		 * by default.		 * @since jEdit 2.7pre2		 */		public boolean noRecord()		{			return false;		}	
/**		 * Returns if this edit action should not be remembered as the most		 * recently invoked action.		 * @since jEdit 4.2pre1		 */		public boolean noRememberLast()		{			return false;		}	
/**		 * Returns the BeanShell code that will replay this action.		 * BeanShellAction.getCode() returns something more interesting for Actions that were loaded		 * from the actions.xml file. 		 * You do not need to override this method if your action name is unique,		 * this EditAction was added to an ActionSet and that to an ActionContext of jEdit.		 * 		 * concrete since jEdit 4.3pre7		 * @since jEdit 2.7pre2		 * 		 */		public String getCode() 		{			return "jEdit.getAction(" + name + ").invoke(view); ";		}	
/**			 * Creates a new action listener wrapper.			 * @since jEdit 4.2pre1			 */			public Wrapper(ActionContext context, String actionName)			{				this.context = context;				this.actionName = actionName;			}	
/**			 * Called when the user selects this action from a menu.			 * It passes the action through the			 * {@link org.gjt.sp.jedit.gui.InputHandler#invokeAction(EditAction)}			 * method, which performs any recording or repeating.			 *			 * @param evt The action event			 */			public void actionPerformed(ActionEvent evt)			{				EditAction action = context.getAction(actionName);				if(action == null)				{					Log.log(Log.WARNING,this,"Unknown action: "						+ actionName);				}				else					context.invokeAction(evt,action);			}	
/**		 * Adds a component to the bus. It will receive all messages sent		 * on the bus.		 *		 * @param comp The component to add		 */		public static void addToBus(EBComponent comp)		{			addToBus((Object)comp);		}	
/**		 * Adds a component to the bus. Methods annotated with the		 * {@link EBHandler} annotation found in the component will		 * be used as EditBus message handlers if a message of a		 * matching type is sent on the bus.<p>		 *		 * If the component implements {@link EBComponent}, then the		 * {@link EBComponent#handleMessage(EBMessage)} method will be		 * called for every message sent on the bus.		 *		 * @param comp The component to add		 *		 * @since jEdit 4.3pre19		 */		public static void addToBus(Object comp)		{			components.addComponent(comp);		}	
/**		 * Removes a component from the bus.		 * @param comp The component to remove		 */		public static void removeFromBus(EBComponent comp)		{			removeFromBus((Object) comp);		}	
/**		 * Removes a component from the bus.		 * @param comp The component to remove		 * @since 4.3pre19		 */		public static void removeFromBus(Object comp)		{			components.removeComponent(comp);		}	
/**		 * Returns an array of all components connected to the bus.		 *		 * @deprecated Don't use this method. It now returns an empty array.		 */		@Deprecated		public static EBComponent[] getComponents()		{			return new EBComponent[0];		}	
/**		 * Sends a message to all components on the bus in turn.		 * @param message The message		 */		public static void send(EBMessage message)		{			Log.log(Log.DEBUG,EditBus.class,message.toString());				components.lock();			try			{				sendImpl(message);			}			finally			{				components.unlock();			}		}	
private EditBus() {}	
private static void dispatch(EBMessageHandler emh,					     EBMessage msg)			throws Exception		{			if (emh.handler != null)				emh.handler.invoke(emh.comp, msg);			else			{				assert (emh.comp instanceof EBComponent);				((EBComponent)emh.comp).handleMessage(msg);			}		}	
private static void sendImpl(EBMessage message)		{			boolean isExact = true;			Class<?> type = message.getClass();			while (!type.equals(Object.class))			{				List<EBMessageHandler> handlers = components.get(type);				if (handlers != null)				{					try					{						for (EBMessageHandler emh : handlers)						{							if (!isExact &&							    emh.source != null &&							    emh.source.exact())							{								continue;							}							if(Debug.EB_TIMER)							{								long start = System.nanoTime();								dispatch(emh, message);								long time = System.nanoTime() - start;								if(time >= 1000000)								{									Log.log(Log.DEBUG,EditBus.class,emh.comp + ": " + time + " ns");								}							}							else								dispatch(emh, message);						}					}					catch(Throwable t)					{						Log.log(Log.ERROR,EditBus.class,"Exception"							+ " while sending message on EditBus:");						Log.log(Log.ERROR,EditBus.class,t);					}				}				type = type.getSuperclass();				isExact = false;			}		}	
EBMessageHandler(Object comp,					 Method handler,					 EBHandler source)			{				this.comp = comp;				this.handler = handler;				this.source = source;			}	
public List<EBMessageHandler> safeGet(Class<?> type)			{				List<EBMessageHandler> lst = super.get(type);				if (lst == null) {					lst = new LinkedList<EBMessageHandler>();					super.put(type, lst);				}				return lst;			}	
public synchronized void lock()			{				lock++;			}	
public synchronized void unlock()			{				lock--;				if (lock == 0)				{					for (Object comp : add)						addComponent(comp);					for (Object comp : remove)						removeComponent(comp);					add.clear();					remove.clear();				}			}	
public synchronized void removeComponent(Object comp)			{				if (lock != 0)				{					remove.add(comp);					return;				}					for (Class<?> msg : keySet())				{					List<EBMessageHandler> handlers = get(msg);					if (handlers == null)						continue;					for (Iterator<EBMessageHandler> it = handlers.iterator();					     it.hasNext(); )					{						EBMessageHandler emh = it.next();						if (emh.comp == comp)							it.remove();					}				}			}	
public synchronized void addComponent(Object comp)			{				if (lock != 0)				{					add.add(comp);					return;				}					for (Method m : comp.getClass().getMethods())				{					EBHandler source = m.getAnnotation(EBHandler.class);					if (source == null)						continue;						Class[] params = m.getParameterTypes();						if (params.length != 1)					{						Log.log(Log.ERROR, EditBus.class,							"Invalid EBHandler method " + m.getName() +							" in class " + comp.getClass().getName() +							": too many parameters.");						continue;					}						if (!EBMessage.class.isAssignableFrom(params[0]))					{						Log.log(Log.ERROR, EditBus.class,							"Invalid parameter " + params[0].getName() +							" in method " + m.getName() +							" of class " + comp.getClass().getName());						continue;					}						synchronized (components)					{						safeGet(params[0]).add(new EBMessageHandler(comp, m, source));					}				}					/*				 * If the component implements EBComponent, then add the				 * default handler for backwards compatibility.				 */				if (comp instanceof EBComponent)					safeGet(EBMessage.class).add(new EBMessageHandler(comp, null, null));			}	
public EditingOptionPane()		{			super("editing");		}	
@Override		protected void _init()		{			Mode[] modes = jEdit.getModes();			Arrays.sort(modes,new StandardUtilities.StringCompare<Mode>(true));				global = new ModeProperties();			modeProps = new ModeProperties[modes.length];				String[] modeNames = new String[modes.length + 1];			modeNames[0] = jEdit.getProperty("options.editing.global");				for(int i = 0; i < modes.length; i++)			{				modeProps[i] = new ModeProperties(modes[i]);				modeNames[i + 1] = modes[i].getName();			}				mode = new JComboBox(modeNames);			mode.addActionListener(new ActionHandler());				captionBox = new Box(BoxLayout.X_AXIS);			addComponent(captionBox);				addComponent(jEdit.getProperty("options.editing.mode"),mode);				useDefaults = new JCheckBox(jEdit.getProperty("options.editing.useDefaults"));			useDefaults.addActionListener(new ActionHandler());			addComponent(useDefaults);				addComponent(jEdit.getProperty("options.editing.noWordSep"),				noWordSep = new JTextField());				addComponent(camelCasedWords = new JCheckBox(jEdit.getProperty(				"options.editing.camelCasedWords")));				String[] foldModes = FoldHandler.getFoldModes();			addComponent(jEdit.getProperty("options.editing.folding"),				folding = new JComboBox(foldModes));				addComponent(jEdit.getProperty("options.editing.collapseFolds"),				collapseFolds = new JTextField());				String[] wrapModes = {				"none",				"soft",				"hard"			};			addComponent(jEdit.getProperty("options.editing.wrap"),				wrap = new JComboBox(wrapModes));				String[] lineLens = { "0", "72", "76", "80" };			maxLineLen = new JComboBox(lineLens);			maxLineLen.setToolTipText(jEdit.getProperty("options.editing.maxLineLen.tooltip"));			addComponent(jEdit.getProperty("options.editing.maxLineLen"), maxLineLen);			maxLineLen.setEditable(true);				String[] tabSizes = { "2", "4", "8" };			addComponent(jEdit.getProperty("options.editing.tabSize"),				tabSize = new JComboBox(tabSizes));			tabSize.setEditable(true);				addComponent(jEdit.getProperty("options.editing.indentSize"),				indentSize = new JComboBox(tabSizes));			indentSize.setEditable(true);				addComponent(noTabs = new JCheckBox(jEdit.getProperty(				"options.editing.noTabs")));				addComponent(deepIndent = new JCheckBox(jEdit.getProperty(				"options.editing.deepIndent")));				filenameGlob = new JTextField();			filenameGlob.setToolTipText(jEdit.getProperty("glob.tooltip"));			addComponent(jEdit.getProperty("options.editing.filenameGlob"),				filenameGlob);				addComponent(jEdit.getProperty("options.editing.firstlineGlob"),				firstlineGlob = new JTextField());				selectMode();				addSeparator();				defaultMode = new JComboBox(modes);			defaultMode.setSelectedItem(jEdit.getMode(				jEdit.getProperty("buffer.defaultMode")));			addComponent(jEdit.getProperty("options.editing.defaultMode"),				defaultMode);				undoCount = new JTextField(jEdit.getProperty("buffer.undoCount"));			addComponent(jEdit.getProperty("options.editing.undoCount"),undoCount);				//{{{ Reset Undo Manager On Save			resetUndoOnSave = new JCheckBox(jEdit.getProperty("options.general.resetUndo"));			resetUndoOnSave.setSelected(jEdit.getBooleanProperty("resetUndoOnSave"));			addComponent(resetUndoOnSave);			//}}}			}	
@Override		protected void _save()		{			jEdit.setProperty("buffer.defaultMode",				((Mode)defaultMode.getSelectedItem()).getName());			jEdit.setProperty("buffer.undoCount",undoCount.getText());			jEdit.setBooleanProperty("resetUndoOnSave", resetUndoOnSave.isSelected());				saveMode();				global.save();				for(int i = 0; i < modeProps.length; i++)			{				modeProps[i].save();			}		}	
private void saveMode()		{			current.useDefaults = useDefaults.isSelected();			current.filenameGlob = filenameGlob.getText();			current.firstlineGlob = firstlineGlob.getText();			current.noWordSep = noWordSep.getText();			current.camelCasedWords = camelCasedWords.isSelected();			current.folding = (String)folding.getSelectedItem();			current.collapseFolds = collapseFolds.getText();			current.wrap = (String)wrap.getSelectedItem();			current.maxLineLen = (String)maxLineLen.getSelectedItem();			current.tabSize = (String)tabSize.getSelectedItem();			current.indentSize = (String)indentSize.getSelectedItem();			current.noTabs = noTabs.isSelected();			current.deepIndent = deepIndent.isSelected();		}	
private void selectMode()		{			int index = mode.getSelectedIndex();			current = index == 0 ? global : modeProps[index - 1];			current.edited = true;			current.load();				captionBox.removeAll();			captionBox.add(GUIUtilities.createMultilineLabel(				jEdit.getProperty("options.editing.caption-"				+ (index == 0 ? "0" : "1"))));				useDefaults.setSelected(current.useDefaults);			filenameGlob.setText(current.filenameGlob);			firstlineGlob.setText(current.firstlineGlob);			noWordSep.setText(current.noWordSep);			camelCasedWords.setSelected(current.camelCasedWords);			folding.setSelectedItem(current.folding);			collapseFolds.setText(current.collapseFolds);			wrap.setSelectedItem(current.wrap);			maxLineLen.setSelectedItem(current.maxLineLen);			tabSize.setSelectedItem(current.tabSize);			indentSize.setSelectedItem(current.indentSize);			noTabs.setSelected(current.noTabs);			deepIndent.setSelected(current.deepIndent);				updateEnabled();			revalidate();		}	
private void updateEnabled()		{			boolean enabled;			if(current == global)			{				enabled = true;				useDefaults.setEnabled(false);				filenameGlob.setEnabled(false);				firstlineGlob.setEnabled(false);			}			else			{				enabled = !modeProps[mode.getSelectedIndex() - 1]					.useDefaults;				useDefaults.setEnabled(true);				filenameGlob.setEnabled(enabled);				firstlineGlob.setEnabled(enabled);			}				noWordSep.setEnabled(enabled);			camelCasedWords.setEnabled(enabled);			folding.setEnabled(enabled);			collapseFolds.setEnabled(enabled);			wrap.setEnabled(enabled);			maxLineLen.setEnabled(enabled);			tabSize.setEnabled(enabled);			indentSize.setEnabled(enabled);			noTabs.setEnabled(enabled);			deepIndent.setEnabled(enabled);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == mode)				{					saveMode();					selectMode();				}				else if(source == useDefaults)				{					modeProps[mode.getSelectedIndex() - 1].useDefaults =						useDefaults.isSelected();					updateEnabled();				}			}	
ModeProperties()			{			}	
ModeProperties(Mode mode)			{				this.mode = mode;			}	
void load()			{				if(loaded)					return;					loaded = true;					if(mode != null)				{					mode.loadIfNecessary();						useDefaults = !jEdit.getBooleanProperty("mode."						+ mode.getName() + ".customSettings");					filenameGlob = (String)mode.getProperty("filenameGlob");					firstlineGlob = (String)mode.getProperty("firstlineGlob");					noWordSep = (String)mode.getProperty("noWordSep");					camelCasedWords = mode.getBooleanProperty("camelCasedWords");					folding = mode.getProperty("folding").toString();					collapseFolds = mode.getProperty("collapseFolds").toString();					wrap = mode.getProperty("wrap").toString();					maxLineLen = mode.getProperty("maxLineLen").toString();					tabSize = mode.getProperty("tabSize").toString();					indentSize = mode.getProperty("indentSize").toString();					noTabs = mode.getBooleanProperty("noTabs");					deepIndent = mode.getBooleanProperty("deepIndent");				}				else				{					noWordSep = jEdit.getProperty("buffer.noWordSep");					camelCasedWords = jEdit.getBooleanProperty("buffer.camelCasedWords");					folding = jEdit.getProperty("buffer.folding");					collapseFolds = jEdit.getProperty("buffer.collapseFolds");					wrap = jEdit.getProperty("buffer.wrap");					maxLineLen = jEdit.getProperty("buffer.maxLineLen");					tabSize = jEdit.getProperty("buffer.tabSize");					indentSize = jEdit.getProperty("buffer.indentSize");					noTabs = jEdit.getBooleanProperty("buffer.noTabs");					deepIndent = jEdit.getBooleanProperty("buffer.deepIndent");				}			}	
void save()			{				// don't do anything if the user didn't change				// any settings				if(!edited)					return;					String prefix;				if(mode != null)				{					prefix = "mode." + mode.getName() + '.';					jEdit.setBooleanProperty(prefix + "customSettings",!useDefaults);						// need to call Mode.init() if the file name or first line					// globs change					String oldFilenameGlob = (String)mode.getProperty("filenameGlob");					String oldFirstlineGlob = (String)mode.getProperty("firstlineGlob");					if(useDefaults)					{						jEdit.resetProperty(prefix + "filenameGlob");						jEdit.resetProperty(prefix + "firstlineGlob");						jEdit.resetProperty(prefix + "noWordSep");						jEdit.resetProperty(prefix + "camelCasedWords");						jEdit.resetProperty(prefix + "folding");						jEdit.resetProperty(prefix + "collapseFolds");						jEdit.resetProperty(prefix + "wrap");						jEdit.resetProperty(prefix + "maxLineLen");						jEdit.resetProperty(prefix + "tabSize");						jEdit.resetProperty(prefix + "indentSize");						jEdit.resetProperty(prefix + "noTabs");						jEdit.resetProperty(prefix + "deepIndent");							if(!(StandardUtilities.objectsEqual(oldFilenameGlob,							mode.getProperty("filenameGlob"))							&& StandardUtilities.objectsEqual(oldFirstlineGlob,							mode.getProperty("firstlineGlob"))))						{							mode.init();						}							return;					}					else					{						jEdit.setProperty(prefix + "filenameGlob",filenameGlob);						jEdit.setProperty(prefix + "firstlineGlob",firstlineGlob);							if(!(StandardUtilities.objectsEqual(oldFilenameGlob,							filenameGlob)							&& StandardUtilities.objectsEqual(oldFirstlineGlob,							firstlineGlob)))						{							mode.init();						}					}				}				else				{					prefix = "buffer.";				}					jEdit.setProperty(prefix + "noWordSep",noWordSep);				jEdit.setBooleanProperty(prefix + "camelCasedWords",camelCasedWords);				jEdit.setProperty(prefix + "folding",folding);				jEdit.setProperty(prefix + "collapseFolds",collapseFolds);				jEdit.setProperty(prefix + "wrap",wrap);				jEdit.setProperty(prefix + "maxLineLen",maxLineLen);				jEdit.setProperty(prefix + "tabSize",tabSize);				jEdit.setProperty(prefix + "indentSize",indentSize);				jEdit.setBooleanProperty(prefix + "noTabs",noTabs);				jEdit.setBooleanProperty(prefix + "deepIndent",deepIndent);			}	
/**		 * Creates a new editor exiting message.		 * @param source The message source		 */		public EditorExiting(EBComponent source)		{			super(source);		}	
/**		 * Creates a new editor exiting started message.		 * @param view The view from which this exit was called		 */		public EditorExitRequested(View view)		{			super(view);		}	
/**		 * Returns the view involved.		 */		public View getView()		{			return (View)getSource();		}	
/**		 * Cancels the exit process. If a plugin calls this method, jEdit will not		 * exit anymore		 */		public void cancelExit()		{			hasBeenExitCancelled = true;		}	
/**		 * Check if the exit process has been cancelled.		 */ 		 public boolean hasBeenExitCancelled()		 {			 return hasBeenExitCancelled;		 }	
/**		 * Creates a new editor started message.		 * @param source The message source		 */		public EditorStarted(EBComponent source)		{			super(source);		}	
/**		 * Returns the view containing this edit pane.		 * @return the view that contains this EditPane		 * @since jEdit 2.5pre2		 */		public View getView()		{			return view;		}	
/**		 * Returns the EditPane of a TextArea.		 *		 * @param ta the textArea		 * @return the EditPane containing the TextArea.		 */		public static EditPane get(TextArea ta)		{			if (ta == null) return null;			return (EditPane)SwingUtilities.getAncestorOfClass(EditPane.class, ta);		}	
/**		 * Returns the current buffer.		 * @return the current buffer		 * @since jEdit 2.5pre2		 */		public Buffer getBuffer()		{			return buffer;		}	
/**		 * Sets the current buffer.		 * @param buffer The buffer to edit.		 * @since jEdit 2.5pre2		 */		public void setBuffer(Buffer buffer)		{			setBuffer(buffer, true);		}	
/**		 * Sets the current buffer.		 * @param buffer The buffer to edit.		 * @param requestFocus true if the textarea should request focus, false otherwise		 * @since jEdit 4.3pre6		 */		public void setBuffer(final Buffer buffer, boolean requestFocus)		{				if(buffer == null)				throw new NullPointerException();				if(this.buffer == buffer)				return;				if (bufferSet.indexOf(buffer) == -1)			{				jEdit.getBufferSetManager().addBuffer(this, buffer);			}			//if(buffer.insideCompoundEdit())			//	buffer.endCompoundEdit();			EditBus.send(new BufferChanging(this, buffer));			if (bufferSet.indexOf(this.buffer) != -1)			{				// when closing the last buffer of a bufferSet, the current buffer will still be the closed				// buffer until a new empty buffer is created.				// So if the current buffer is not anymore in the bufferSet, do not set the recentBuffer				recentBuffer = this.buffer;			}			if(recentBuffer != null)				saveCaretInfo();			this.buffer = buffer;				textArea.setBuffer(buffer);				if(!init)			{				view.updateTitle();					if(bufferSwitcher != null)				{					if(bufferSwitcher.getSelectedItem() != buffer)						bufferSwitcher.setSelectedItem(buffer);					bufferSwitcher.setToolTipText(buffer.getPath());				}					EditBus.send(new EditPaneUpdate(this,EditPaneUpdate					.BUFFER_CHANGED));			}				if (requestFocus)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						// only do this if we are the current edit pane						if(view.getEditPane() == EditPane.this							&& (bufferSwitcher == null							|| !bufferSwitcher.isPopupVisible()))						{							textArea.requestFocus();						}					}				});			}				// Only do this after all I/O requests are complete			Runnable runnable = new Runnable()			{				public void run()				{					// avoid a race condition					// see bug #834338					if(buffer == getBuffer())						loadCaretInfo();				}			};				if(buffer.isPerformingIO())				VFSManager.runInAWTThread(runnable);			else				runnable.run();		}	
/**		 * Selects the previous buffer.		 * @since jEdit 2.7pre2		 */		public void prevBuffer()		{			Buffer buffer = bufferSet.getPreviousBuffer(bufferSet.indexOf(this.buffer));			setBuffer(buffer);		}	
/**		 * Selects the next buffer.		 * @since jEdit 2.7pre2		 */		public void nextBuffer()		{			Buffer buffer = bufferSet.getNextBuffer(bufferSet.indexOf(this.buffer));			setBuffer(buffer);		}	
/**		 * Selects the most recently edited buffer.		 * @since jEdit 2.7pre2		 */		public void recentBuffer()		{			if(recentBuffer != null)				setBuffer(recentBuffer);			else				getToolkit().beep();		}	
/**		 * Sets the focus onto the text area.		 * @since jEdit 2.5pre2		 */		public void focusOnTextArea()		{			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					textArea.requestFocus();				}			});		}	
/**		 * Returns the view's text area.		 * @return the text area of the edit pane		 * @since jEdit 2.5pre2		 */		public JEditTextArea getTextArea()		{			return textArea;		}	
/**		 * Returns the buffer switcher combo box instance.		 * @return the buffer switcher (it can be null)		 * @since jEdit 4.1pre8		 */		public BufferSwitcher getBufferSwitcher()		{			return bufferSwitcher;		}	
/**		 * Pops up and focuses on the buffer switcher combo box.		 * @since jEdit 4.3pre18		 * (previously known as showBufferSwitcher)		 */		public void focusBufferSwitcher()		{			if(bufferSwitcher == null)				getToolkit().beep();			else			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						bufferSwitcher.requestFocus();						bufferSwitcher.showPopup();					}					});			}		}	
/**		 * Saves the caret information to the current buffer.		 * @since jEdit 2.5pre2		 */		public void saveCaretInfo()		{			if(!buffer.isLoaded())				return;				buffer.setIntegerProperty(Buffer.CARET,				textArea.getCaretPosition());				CaretInfo caretInfo = caretsForPath.get(buffer.getPath());			if (caretInfo == null)			{				caretInfo = new CaretInfo();				caretsForPath.put(buffer.getPath(), caretInfo);			}			caretInfo.caret = textArea.getCaretPosition();					Selection[] selection = textArea.getSelection();			for(int i = 0; i < selection.length; i++)				selection[i] = (Selection)selection[i].clone();			buffer.setProperty(Buffer.SELECTION,selection);			caretInfo.selection = selection;				caretInfo.rectangularSelection = textArea.isRectangularSelectionEnabled();			caretInfo.multipleSelection = textArea.isMultipleSelectionEnabled();				buffer.setIntegerProperty(Buffer.SCROLL_VERT,				textArea.getFirstPhysicalLine());			caretInfo.scrollVert = textArea.getFirstPhysicalLine();			buffer.setIntegerProperty(Buffer.SCROLL_HORIZ,				textArea.getHorizontalOffset());			caretInfo.scrollHoriz = textArea.getHorizontalOffset();			if (!buffer.isUntitled())			{				BufferHistory.setEntry(buffer.getPath(), textArea.getCaretPosition(),					(Selection[])buffer.getProperty(Buffer.SELECTION),					buffer.getStringProperty(JEditBuffer.ENCODING),					buffer.getMode().getName());			}		}	
/**		 * Loads the caret and selection information from this EditPane, fall		 * back to the information from the current buffer if none is already		 * in this EditPane.		 * @since jEdit 2.5pre2		 */		public void loadCaretInfo()		{			// get our internal map of buffer -> CaretInfo since there might			// be current info already			CaretInfo caretInfo = caretsForPath.get(buffer.getPath());			if (caretInfo == null)			{				caretInfo = new CaretInfo();			}				// set the position of the caret itself.			// Caret position could be stored in the internal map already,			// if so, use that one first.  Otherwise, fall back to any			// previously saved caret position that was stored in the			// buffer properties.			int caret = caretInfo.caret;			if (caret == -1 || buffer.getBooleanProperty(Buffer.CARET_POSITIONED))			{				Integer i = (Integer) buffer.getProperty(Buffer.CARET);				caret = i == null ? -1 : i;			}			buffer.unsetProperty(Buffer.CARET_POSITIONED);					if(caret != -1)				textArea.setCaretPosition(Math.min(caret,					buffer.getLength()));				// set any selections			Selection[] selection = caretInfo.selection;			if ( selection == null )			{				selection = (Selection[]) buffer.getProperty(Buffer.SELECTION);			}			if(selection != null)			{				for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					int max = buffer.getLength();					if(s.getStart() > max || s.getEnd() > max)						selection[i] = null;				}			}			textArea.setSelection(selection);			textArea.setRectangularSelectionEnabled(caretInfo.rectangularSelection);			textArea.setMultipleSelectionEnabled(caretInfo.multipleSelection);			// set firstLine value			int firstLine = caretInfo.scrollVert;			if ( firstLine == -1 )			{				Integer i = (Integer) buffer.getProperty(Buffer.SCROLL_VERT);				firstLine = i == null ? -1 : i;			}				if(firstLine != -1)				textArea.setFirstPhysicalLine(firstLine);				// set horizontal offset			int horizontalOffset = caretInfo.scrollHoriz;			if (horizontalOffset == -1)			{				Integer i = (Integer) buffer.getProperty(Buffer.SCROLL_HORIZ);				horizontalOffset = i == null ? -1 : i;			}				if(horizontalOffset != -1)				textArea.setHorizontalOffset(horizontalOffset);				/* Silly bug workaround #8694. If you look at the above code,			 * note that we restore the saved caret position first, then			 * scroll to the saved location. However, the caret changing			 * can itself result in scrolling to a different location than			 * what was saved; and since moveCaretPosition() calls			 * updateBracketHighlight(), the bracket highlight's out of			 * bounds calculation will rely on a different set of physical			 * first/last lines than what we will end up with eventually.			 * Instead of confusing the user with status messages that			 * appear at random when switching buffers, we simply hide the			 * message altogether. */			view.getStatus().setMessage(null);		}	
/**		 * This method should be called by the Buffer when the path is changing.		 * @param oldPath the old path of the buffer		 * @param newPath the new path of the buffer		 */		void bufferRenamed(String oldPath, String newPath)		{			CaretInfo caretInfo = caretsForPath.remove(oldPath);			if (caretInfo != null)				caretsForPath.put(newPath, caretInfo);			}	
/**		 * Moves the caret to the next marker.		 * @since jEdit 4.3pre3		 */		public void goToNextMarker(boolean select)		{			java.util.List<Marker> markers = buffer.getMarkers();			if(markers.isEmpty())			{				getToolkit().beep();				return;			}				Marker marker = null;				int caret = textArea.getCaretPosition();				for(int i = 0; i < markers.size(); i++)			{				Marker _marker = markers.get(i);				if(_marker.getPosition() > caret)				{					marker = _marker;					break;				}			}			// the markers list is not empty at this point			if(marker == null)				marker = markers.get(0);				if(select)				textArea.extendSelection(caret,marker.getPosition());			else if(!textArea.isMultipleSelectionEnabled())				textArea.selectNone();			textArea.moveCaretPosition(marker.getPosition());		}	
/**		 * Moves the caret to the previous marker.		 * @since jEdit 2.7pre2		 */		public void goToPrevMarker(boolean select)		{			java.util.List<Marker> markers = buffer.getMarkers();			if(markers.isEmpty())			{				getToolkit().beep();				return;			}				int caret = textArea.getCaretPosition();				Marker marker = null;			for(int i = markers.size() - 1; i >= 0; i--)			{				Marker _marker = markers.get(i);				if(_marker.getPosition() < caret)				{					marker = _marker;					break;				}			}				if(marker == null)				marker = markers.get(markers.size() - 1);				if(select)				textArea.extendSelection(caret,marker.getPosition());			else if(!textArea.isMultipleSelectionEnabled())				textArea.selectNone();			textArea.moveCaretPosition(marker.getPosition());		}	
/**		 * Moves the caret to the marker with the specified shortcut.		 * @param shortcut The shortcut		 * @param select True if the selection should be extended,		 * false otherwise		 * @since jEdit 3.2pre2		 */		public void goToMarker(char shortcut, boolean select)		{			Marker marker = buffer.getMarker(shortcut);			if(marker == null)			{				getToolkit().beep();				return;			}				int pos = marker.getPosition();				if(select)				textArea.extendSelection(textArea.getCaretPosition(),pos);			else if(!textArea.isMultipleSelectionEnabled())				textArea.selectNone();			textArea.moveCaretPosition(pos);		}	
/**		 * Adds a marker at the caret position.		 * @since jEdit 3.2pre1		 */		public void addMarker()		{			int caretLine = textArea.getCaretLine();				// always add markers on selected lines			Selection[] selection = textArea.getSelection();			for(int i = 0; i < selection.length; i++)			{				Selection s = selection[i];				int startLine = s.getStartLine();				if(startLine != s.getEndLine() && startLine != caretLine)				{					buffer.addMarker('\0',s.getStart());				}					if(s.getEndLine() != caretLine)					buffer.addMarker('\0',s.getEnd());			}				// toggle marker on caret line			buffer.addOrRemoveMarker('\0',textArea.getCaretPosition());		}	
/**		 * Moves the caret to the marker with the specified shortcut,		 * then sets the marker position to the former caret position.		 * @param shortcut The shortcut		 * @since jEdit 3.2pre2		 */		public void swapMarkerAndCaret(char shortcut)		{			Marker marker = buffer.getMarker(shortcut);			if(marker == null)			{				getToolkit().beep();				return;			}				int caret = textArea.getCaretPosition();				textArea.setCaretPosition(marker.getPosition());			buffer.addMarker(shortcut,caret);		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof PropertiesChanged)			{				propertiesChanged();				loadBufferSwitcher();			}			else if(msg instanceof BufferUpdate)				handleBufferUpdate((BufferUpdate)msg);		}	
/**		 * Returns 0,0 for split pane compatibility.		 */		@Override		public final Dimension getMinimumSize()		{			return new Dimension(0,0);		}	
/**		 * Returns the current buffer set.		 * This can be changed by setBufferSetScope().		 * @return the buffer set which is currently used by this EditPane		 * @since jEdit 4.3pre17		 */		public BufferSet getBufferSet()		{			return bufferSet;		}	
/**		 * Get the current scope of bufferSet.		 * @since jEdit 4.3pre17		 */		public BufferSet.Scope getBufferSetScope()		{			return bufferSetScope;		}	
/**		 * Set the scope of bufferSet for the EditPane.		 * @param scope the new scope		 * @since jEdit 4.3pre17		 */		public void setBufferSetScope(BufferSet.Scope scope)		{			if (this.bufferSetScope != scope)			{				BufferSet oldBufferSet = this.bufferSet;				BufferSet newBufferSet;				switch (scope)				{					case editpane:						newBufferSet = new BufferSet();						break;					case view:						newBufferSet = view.getLocalBufferSet();						break;					default:						scope = BufferSet.Scope.global;					case global:						newBufferSet = jEdit.getGlobalBufferSet();						break;				}					BufferSetManager bufferSetManager = jEdit.getBufferSetManager();					if (jEdit.isStartupDone())	// Ignore "new buffersets contain:" option when loading perspective				{					String action = jEdit.getProperty("editpane.bufferset.new");					BufferSetManager.NewBufferSetAction bufferSetAction = BufferSetManager.NewBufferSetAction.fromString(action);					View activeView = jEdit.getActiveView();					switch (bufferSetAction)					{						case copy:							if (oldBufferSet == null)							{								EditPane editPane = view.getEditPane();								if (editPane == null)								{									if (activeView != null)										editPane = activeView.getEditPane();									}								if (editPane == null)								{									bufferSetManager.addAllBuffers(newBufferSet);								}								else								{									bufferSetManager.mergeBufferSet(newBufferSet, editPane.bufferSet);								}							}							else								bufferSetManager.mergeBufferSet(newBufferSet, oldBufferSet);							break;						case empty:							break;						case currentbuffer:							if (activeView == null)								break;							EditPane editPane = activeView.getEditPane();							Buffer buffer = editPane.getBuffer();							bufferSetManager.addBuffer(newBufferSet,buffer);							break;					}				}				if (buffer != null)					bufferSetManager.addBuffer(newBufferSet, buffer);						this.bufferSet = newBufferSet;				this.bufferSetScope = scope;				if (newBufferSet.size() == 0)				{					jEdit.newFile(this);				}					// This must be after updating this.bufferSet since				// removeBufferSetListener() uses				// EditPane#getBufferSet() on this EditPane.				if (oldBufferSet != null)				{					oldBufferSet.removeBufferSetListener(this);				}					newBufferSet.addBufferSetListener(this);				if (bufferSwitcher != null)				{					bufferSwitcher.updateBufferList();				}				EditBus.send(new EditPaneUpdate(this, EditPaneUpdate.BUFFERSET_CHANGED));				if (newBufferSet.indexOf(recentBuffer) == -1)				{					// the recent buffer is not in the bufferSet					recentBuffer =  null;				}				if (newBufferSet.indexOf(buffer) == -1)				{					// the current buffer is not contained in the bufferSet, we must change the current buffer					if (recentBuffer != null)						setBuffer(recentBuffer);					else					{						setBuffer(newBufferSet.getBuffer(0));					}				}				if (jEdit.isStartupDone())	// Do not mark perspective dirty on startup					PerspectiveManager.setPerspectiveDirty(true);			}		}	
/**		 * A buffer was added in the bufferSet.		 * @param buffer the added buffer		 * @param index the position where it was added		 * @since jEdit 4.3pre15		 */		public void bufferAdded(Buffer buffer, int index)		{			if (buffer == null)				return;			if (bufferSwitcher != null)				bufferSwitcher.updateBufferList();			if (bufferSet.indexOf(this.buffer) == -1)			{				// it happens when having 1 untitled buffer if I open a file. The untitled buffer				// is closed but the new buffer is not yet opened				setBuffer(buffer);			}		}	
/**		 * A buffer was removed from the bufferSet.		 * @param buffer the removed buffer		 * @param index the position where it was before being removed		 * @since jEdit 4.3pre15		 */		public void bufferRemoved(Buffer buffer, int index)		{			if (buffer.isUntitled())			{				// the buffer was a new file so I do not need to keep it's informations				caretsForPath.remove(buffer.getPath());			}			if (buffer == this.buffer)			{				// The closed buffer is the current buffer				Buffer newBuffer = recentBuffer != null ?					recentBuffer : bufferSet.getPreviousBuffer(index);					if(newBuffer != null && !newBuffer.isClosed())				{					setBuffer(newBuffer);					if (bufferSet.size() > 1)					{						recentBuffer = bufferSet.getPreviousBuffer(index -1);					}				}				else if(bufferSet.size() != 0)				{					setBuffer(bufferSet.getBuffer(0));					recentBuffer = null;				}			}			if(buffer == recentBuffer)				recentBuffer = null;			if (bufferSwitcher != null)				bufferSwitcher.updateBufferList();		}	
/**		 * A buffer was moved in the BufferSet.		 * @param buffer the moved buffer		 * @param oldIndex the position it was before		 * @param newIndex the new position		 * @since jEdit 4.3pre15		 */		public void bufferMoved(Buffer buffer, int oldIndex, int newIndex)		{			if (bufferSwitcher != null)				bufferSwitcher.updateBufferList();		}	
/**		 * The bufferSet was sorted		 * @since jEdit 4.3pre16		 */		public void bufferSetSorted()		{			if (bufferSwitcher != null)				bufferSwitcher.updateBufferList();		}	
@Override		public String toString()		{			return getClass().getName() + '['				+ (view.getEditPane() == this				? "active" : "inactive")				+ ',' + bufferSetScope + ']';		}	
EditPane(View view, Buffer buffer, BufferSet.Scope scope)		{			super(new BorderLayout());				init = true;				this.view = view;					textArea = new JEditTextArea(view);			textArea.getPainter().setAntiAlias(new AntiAlias(jEdit.getProperty("view.antiAlias")));			textArea.setMouseHandler(new MouseHandler(textArea));			textArea.setTransferHandler(new TextAreaTransferHandler());			markerHighlight = new MarkerHighlight();			Gutter gutter = textArea.getGutter();			gutter.setGutterEnabled(GutterOptionPane.isGutterEnabled());			gutter.setMinLineNumberDigitCount(GutterOptionPane.getMinLineNumberDigits());			gutter.setSelectionAreaEnabled(GutterOptionPane.isSelectionAreaEnabled());			gutter.addExtension(markerHighlight);			gutter.setSelectionPopupHandler(				new GutterPopupHandler()				{					public void handlePopup(int x, int y, int line)					{						Buffer buffer = getBuffer();						buffer.addOrRemoveMarker('\0',							buffer.getLineStartOffset(line));					}				});				textArea.addStatusListener(new StatusHandler());			add(BorderLayout.CENTER,textArea);				propertiesChanged();			this.buffer = buffer;			setBufferSetScope(scope);			this.buffer = null;			if(buffer == null)			{				setBuffer(jEdit.getFirstBuffer());			}			else				setBuffer(buffer);				loadBufferSwitcher();				init = false;			EditBus.addToBus(this);		}	
void close()		{			saveCaretInfo();			EditBus.send(new EditPaneUpdate(this,EditPaneUpdate.DESTROYED));			EditBus.removeFromBus(this);			textArea.dispose();		}	
private void propertiesChanged()		{			TextAreaPainter painter = textArea.getPainter();				initPainter(painter);			Gutter gutter = textArea.getGutter();			gutter.setExpanded(jEdit.getBooleanProperty(				"view.gutter.lineNumbers"));			int interval = jEdit.getIntegerProperty(				"view.gutter.highlightInterval",5);			gutter.setHighlightInterval(interval);			gutter.setCurrentLineHighlightEnabled(jEdit.getBooleanProperty(				"view.gutter.highlightCurrentLine"));			gutter.setStructureHighlightEnabled(jEdit.getBooleanProperty(				"view.gutter.structureHighlight"));			gutter.setStructureHighlightColor(				jEdit.getColorProperty("view.gutter.structureHighlightColor"));			gutter.setBackground(				jEdit.getColorProperty("view.gutter.bgColor"));			gutter.setForeground(				jEdit.getColorProperty("view.gutter.fgColor"));			gutter.setHighlightedForeground(				jEdit.getColorProperty("view.gutter.highlightColor"));			gutter.setFoldColor(				jEdit.getColorProperty("view.gutter.foldColor"));			markerHighlight.setMarkerHighlightColor(				jEdit.getColorProperty("view.gutter.markerColor"));			markerHighlight.setMarkerHighlightEnabled(jEdit.getBooleanProperty(				"view.gutter.markerHighlight"));			gutter.setCurrentLineForeground(				jEdit.getColorProperty("view.gutter.currentLineColor"));			String alignment = jEdit.getProperty(				"view.gutter.numberAlignment");			if ("right".equals(alignment))			{				gutter.setLineNumberAlignment(Gutter.RIGHT);			}			else if ("center".equals(alignment))			{				gutter.setLineNumberAlignment(Gutter.CENTER);			}			else // left == default case			{				gutter.setLineNumberAlignment(Gutter.LEFT);			}				gutter.setFont(jEdit.getFontProperty("view.gutter.font"));			gutter.setGutterEnabled(GutterOptionPane.isGutterEnabled());			gutter.setMinLineNumberDigitCount(				GutterOptionPane.getMinLineNumberDigits());			gutter.setSelectionAreaEnabled(				GutterOptionPane.isSelectionAreaEnabled());			gutter.setSelectionAreaBackground(				GutterOptionPane.getSelectionAreaBackground());			gutter.setSelectionAreaWidth(					GutterOptionPane.getSelectionAreaWidth());				int width = jEdit.getIntegerProperty(				"view.gutter.borderWidth",3);			gutter.setBorder(width,				jEdit.getColorProperty("view.gutter.focusBorderColor"),				jEdit.getColorProperty("view.gutter.noFocusBorderColor"),				textArea.getPainter().getBackground());			gutter.setFoldPainter(textArea.getFoldPainter());				textArea.setCaretBlinkEnabled(jEdit.getBooleanProperty(				"view.caretBlink"));				textArea.setElectricScroll(jEdit.getIntegerProperty(				"view.electricBorders",0));				// Set up the right-click popup menu			textArea.createPopupMenu(null);				// use old property name for backwards compatibility			textArea.setQuickCopyEnabled(jEdit.getBooleanProperty(				"view.middleMousePaste"));				textArea.setDragEnabled(jEdit.getBooleanProperty(				"view.dragAndDrop"));				textArea.setJoinNonWordChars(jEdit.getBooleanProperty(				"view.joinNonWordChars"));				textArea.setCtrlForRectangularSelection(jEdit.getBooleanProperty(				"view.ctrlForRectangularSelection"));				textArea.propertiesChanged();				if (bufferSwitcher != null)			{				bufferSwitcher.setMaximumRowCount(jEdit.getIntegerProperty(					"bufferSwitcher.maxRowCount",10));			}		}	
/**		 * Init the painter of a textarea.		 *		 * @param painter the painter of a textarea		 * @since jEdit 4.3pre12		 */		public static void initPainter(TextAreaPainter painter)		{			painter.setFont(jEdit.getFontProperty("view.font"));			painter.setStructureHighlightEnabled(jEdit.getBooleanProperty(				"view.structureHighlight"));			painter.setStructureHighlightColor(				jEdit.getColorProperty("view.structureHighlightColor"));			painter.setEOLMarkersPainted(jEdit.getBooleanProperty(				"view.eolMarkers"));			painter.setEOLMarkerColor(				jEdit.getColorProperty("view.eolMarkerColor"));			painter.setWrapGuidePainted(jEdit.getBooleanProperty(				"view.wrapGuide"));			painter.setWrapGuideColor(				jEdit.getColorProperty("view.wrapGuideColor"));			painter.setCaretColor(				jEdit.getColorProperty("view.caretColor"));			painter.setSelectionColor(				jEdit.getColorProperty("view.selectionColor"));			painter.setMultipleSelectionColor(				jEdit.getColorProperty("view.multipleSelectionColor"));			painter.setBackground(				jEdit.getColorProperty("view.bgColor"));			painter.setForeground(				jEdit.getColorProperty("view.fgColor"));			painter.setBlockCaretEnabled(jEdit.getBooleanProperty(				"view.blockCaret"));			painter.setThickCaretEnabled(jEdit.getBooleanProperty(				"view.thickCaret"));			painter.setLineHighlightEnabled(jEdit.getBooleanProperty(				"view.lineHighlight"));			painter.setLineHighlightColor(				jEdit.getColorProperty("view.lineHighlightColor"));			painter.setAntiAlias(new AntiAlias(jEdit.getProperty("view.antiAlias")));			painter.setFractionalFontMetricsEnabled(jEdit.getBooleanProperty(				"view.fracFontMetrics"));				String defaultFont = jEdit.getProperty("view.font");			int defaultFontSize = jEdit.getIntegerProperty("view.fontsize",12);			painter.setStyles(SyntaxUtilities.loadStyles(defaultFont,defaultFontSize));				SyntaxStyle[] foldLineStyle = new SyntaxStyle[4];			for(int i = 0; i <= 3; i++)			{				foldLineStyle[i] = GUIUtilities.parseStyle(					jEdit.getProperty("view.style.foldLine." + i),					defaultFont,defaultFontSize);			}			painter.setFoldLineStyle(foldLineStyle);		}	
void loadBufferSwitcher()		{			if(jEdit.getBooleanProperty("view.showBufferSwitcher"))			{				if(bufferSwitcher == null)				{					bufferSwitcher = new BufferSwitcher(this);					add(BorderLayout.NORTH,bufferSwitcher);					bufferSwitcher.updateBufferList();					revalidate();				}			}			else if(bufferSwitcher != null)			{				remove(bufferSwitcher);				revalidate();				bufferSwitcher = null;			}		}	
private void handleBufferUpdate(BufferUpdate msg)		{			Buffer _buffer = msg.getBuffer();			if(msg.getWhat() == BufferUpdate.CREATED)			{				if(bufferSwitcher != null)					bufferSwitcher.updateBufferList();					/* When closing the last buffer, the BufferUpdate.CLOSED				 * handler doesn't call setBuffer(), because null buffers				 * are not supported. Instead, it waits for the subsequent				 * 'Untitled' file creation. */				if(buffer.isClosed())				{					// since recentBuffer will be set to the one that					// was closed					recentBuffer = null;				}			}			else if(msg.getWhat() == BufferUpdate.CLOSED)			{				if(bufferSwitcher != null)					bufferSwitcher.updateBufferList();					if(_buffer == buffer)				{					// The closed buffer is the current buffer					Buffer newBuffer = recentBuffer != null ?						recentBuffer : _buffer.getPrev();						if(newBuffer != null && !newBuffer.isClosed())					{						setBuffer(newBuffer);						recentBuffer = newBuffer.getPrev();					}				}				else if(_buffer == recentBuffer)					recentBuffer = null;					Buffer closedBuffer = msg.getBuffer();				if (closedBuffer.isUntitled())				{					// the buffer was a new file so I do not need to keep it's informations					caretsForPath.remove(closedBuffer.getPath());				}			}			else if(msg.getWhat() == BufferUpdate.LOAD_STARTED)			{				if(_buffer == buffer)				{					textArea.setCaretPosition(0);					textArea.getPainter().repaint();				}			}			else if(msg.getWhat() == BufferUpdate.LOADED)			{				if(_buffer == buffer)				{					textArea.repaint();					if(bufferSwitcher != null)						bufferSwitcher.updateBufferList();						if(view.getEditPane() == this)					{						StatusBar status = view.getStatus();						status.updateCaretStatus();						status.updateBufferStatus();						status.updateMiscStatus();					}						loadCaretInfo();				}				}			else if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)			{				if(_buffer == buffer && bufferSwitcher != null)				{					if(buffer.isDirty())						bufferSwitcher.repaint();					else						bufferSwitcher.updateBufferList();				}			}			else if(msg.getWhat() == BufferUpdate.MARKERS_CHANGED)			{				if(_buffer == buffer)					textArea.getGutter().repaint();			}			else if(msg.getWhat() == BufferUpdate.PROPERTIES_CHANGED)			{				if(_buffer == buffer && buffer.isLoaded())				{					textArea.propertiesChanged();					if(view.getEditPane() == this)						view.getStatus().updateBufferStatus();				}			}			else if(msg.getWhat() == BufferUpdate.SAVED && _buffer == buffer)			{				textArea.propertiesChanged();			}		}	
public void statusChanged(org.gjt.sp.jedit.textarea.TextArea textArea, int flag, boolean value)			{				StatusBar status = view.getStatus();				if(status == null)					return;					switch(flag)				{				case OVERWRITE_CHANGED:					status.setMessageAndClear(						jEdit.getProperty("view.status.overwrite-changed",						new Integer[] { value ? 1 : 0 }));					break;				case MULTI_SELECT_CHANGED:					status.setMessageAndClear(						jEdit.getProperty("view.status.multi-changed",						new Integer[] { value ? 1 : 0 }));					break;				case RECT_SELECT_CHANGED:					status.setMessageAndClear(						jEdit.getProperty("view.status.rect-select-changed",						new Integer[] { value ? 1 : 0 }));					break;				}					status.updateMiscStatus();			}	
public void bracketSelected(org.gjt.sp.jedit.textarea.TextArea textArea, int line, String text)			{				StatusBar status = view.getStatus();				if(status == null)					return;					status.setMessageAndClear(jEdit.getProperty(					"view.status.bracket",new Object[] {					line, text }));			}	
public void narrowActive(org.gjt.sp.jedit.textarea.TextArea textArea)			{				StatusBar status = view.getStatus();				if(status == null)					return;					status.setMessageAndClear(					jEdit.getProperty("view.status.narrow"));			}	
public Color getMarkerHighlightColor()			{				return markerHighlightColor;			}	
public void setMarkerHighlightColor(Color markerHighlightColor)			{				this.markerHighlightColor = markerHighlightColor;			}	
public boolean isMarkerHighlightEnabled()			{				return markerHighlight;			}	
public void setMarkerHighlightEnabled(boolean markerHighlight)			{				this.markerHighlight = markerHighlight;			}	
@Override			public void paintValidLine(Graphics2D gfx, int screenLine,				int physicalLine, int start, int end, int y)			{				if(isMarkerHighlightEnabled())				{					Buffer buffer = (Buffer)textArea.getBuffer();					if(buffer.getMarkerInRange(start,end) != null)					{						gfx.setColor(getMarkerHighlightColor());						FontMetrics fm = textArea.getPainter().getFontMetrics();						gfx.fillRect(0,y,textArea.getGutter()							.getWidth(),fm.getHeight());					}				}			}	
@Override			public String getToolTipText(int x, int y)			{				if(isMarkerHighlightEnabled())				{					int lineHeight = textArea.getPainter().getFontMetrics().getHeight();					if(lineHeight == 0)						return null;						int line = y / lineHeight;					int start = textArea.getScreenLineStartOffset(line);					int end = textArea.getScreenLineEndOffset(line);					if(start == -1 || end == -1)						return null;						Buffer buffer = (Buffer)textArea.getBuffer();					Marker marker = buffer.getMarkerInRange(start,end);					if(marker != null)					{						char shortcut = marker.getShortcut();						if(shortcut == '\0')							return jEdit.getProperty("view.gutter.marker.no-name");						else						{							String[] args = { String.valueOf(shortcut) };							return jEdit.getProperty("view.gutter.marker",args);						}					}				}					return null;			}	
/**		 * Creates a new edit pane update message.		 * @param editPane The edit pane		 * @param what What happened		 */		public EditPaneUpdate(EditPane editPane, Object what)		{			super(editPane);			if(what == null)				throw new NullPointerException("What must be non-null");				this.what = what;		}	
/**		 * Returns what caused this edit pane update.		 */		public Object getWhat()		{			return what;		}	
/**		 * Returns the edit pane involved.		 */		public EditPane getEditPane()		{			return (EditPane)getSource();		}	
public String paramString()		{			return "what=" + what + "," + super.paramString();		}	
/**		 * jEdit calls this method when the plugin is being activated, either		 * during startup or at any other time. A plugin can get activated for		 * a number of reasons:		 *		 * <ul>		 * <li>The plugin is written for jEdit 4.1 or older, in which case it		 * will always be loaded at startup.</li>		 * <li>The plugin has its <code>activate</code> property set to		 * <code>startup</code>, in which case it will always be loaded at		 * startup.</li>		 * <li>One of the properties listed in the plugin's		 * <code>activate</code> property is set to <code>true</code>,		 * in which case it will always be loaded at startup.</li>		 * <li>One of the plugin's classes is being accessed by another plugin,		 * a macro, or a BeanShell snippet in a plugin API XML file.</li>		 * </ul>		 *		 * Note that this method is always called from the event dispatch		 * thread, even if the activation resulted from a class being loaded		 * from another thread. A side effect of this is that some of your		 * plugin's code might get executed before this method finishes		 * running.<p>		 *		 * When this method is being called for plugins written for jEdit 4.1		 * and below, no views or buffers are open. However, this is not the		 * case for plugins using the new API. For example, if your plugin adds		 * tool bars to views, make sure you correctly handle the case where		 * views are already open when the plugin is loaded.<p>		 *		 * If your plugin must be loaded on startup, take care to have this		 * method return as quickly as possible.<p>		 *		 * The default implementation of this method does nothing.		 *		 * @since jEdit 2.1pre1		 */		public void start() {}	
/**		 * jEdit calls this method when the plugin is being unloaded. This can		 * be when the program is exiting, or at any other time.<p>		 *		 * If a plugin uses state information or other persistent data		 * that should be stored in a special format, this would be a good place		 * to write the data to storage.  If the plugin uses jEdit's properties		 * API to hold settings, no special processing is needed for them on		 * exit, since they will be saved automatically.<p>		 *		 * With plugins written for jEdit 4.1 and below, this method is only		 * called when the program is exiting. However, this is not the case		 * for plugins using the new API. For example, if your plugin adds		 * tool bars to views, make sure you correctly handle the case where		 * views are still open when the plugin is unloaded.<p>		 *		 * To avoid memory leaks, this method should ensure that no references		 * to any objects created by this plugin remain in the heap. In the		 * case of actions, dockable windows and services, jEdit ensures this		 * automatically. For other objects, your plugin must clean up maually.		 * <p>		 *		 * The default implementation of this method does nothing.		 *		 * @since jEdit 2.1pre1		 */		public void stop() {}	
/**		 * Returns the home of your plugin.		 *		 * @return the plugin home. It can be null if there is no 		 *	   settings directory		 * @since 4.3pre10		 * @see #getResourceAsStream		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		public File getPluginHome()		{			return getPluginHome(getClassName());		}	
/**		 * <p>Returns the home of the specified plugin.</p>		 *		 * <p>Since the first parameter is a reference to the		 * {@code Class} instance for the plugin,		 * this method requires the plugin to be activated.</p>		 *		 * <p>See {@link #getPluginHome(EditPlugin)} method, as		 * an alternate, for when the plugin doesn't need		 * to be activated, or when you do not have the		 * {@code Class} instance available.</p>		 *		 * @param clazz the class of the plugin		 * @return the plugin home. It can be null if there is no		 * 	   settings directory		 * @since 4.3pre10		 * @see #getPluginHome(EditPlugin)		 * @see #getResourceAsStream		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		public static File getPluginHome(Class<? extends EditPlugin> clazz)		{			return getPluginHome(clazz.getName());		}	
/**		 * <p>Returns the home of the specified plugin.</p>		 * 		 * <p>This method doesn't need the plugin to be activated. You can pass		 * an {@code EditPlugin.Deferred} instance that you get from		 * {@code jEdit.getPlugin(String)} or {@code jEdit.getPlugins()} if		 * the plugin in question is not activated yet and this method doesn't		 * cause the plugin to get activated. If you have a reference to the		 * plugins {@code Class} instance available, consider using the		 * {@code Class} method.</p>		 *		 * @param plugin the plugin		 * @return the plugin home. It can be null if there is no settings directory		 * @since 4.3pre10		 * @see #getPluginHome(Class)		 * @see #getResourceAsStream		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		public static File getPluginHome(EditPlugin plugin)		{			return getPluginHome(plugin.getClassName());		}	
/**		 * Returns the home of the specified plugin.		 *		 * @param pluginClassName the plugin class name (fully qualified)		 * @return the plugin home. It can be null if there is no settings directory		 * @since 4.3pre10		 * @see #getResourceAsStream		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		private static File getPluginHome(String pluginClassName)		{			String settingsDirectory = jEdit.getSettingsDirectory();			if (settingsDirectory == null)				return null;				File file = new File(settingsDirectory, "plugins");			if (!file.isDirectory()) 			{				if (!file.mkdir()) 				{					Log.log(Log.ERROR, EditPlugin.class, "Can't create directory:" + file.getAbsolutePath());				}			}			return new File(file, pluginClassName);		}	
/**		 * <p>Returns an input stream to the specified resource, or {@code null}		 * if none is found.</p>		 *		 * <p>Since the first parameter is a reference to the		 * {@code Class} instance for the plugin,		 * this method requires the plugin to be activated.</p>		 *		 * <p>See {@link #getResourceAsStream(EditPlugin,String)} method, as		 * an alternate, for when the plugin doesn't need		 * to be activated, or when you do not have the		 * {@code Class} instance available.</p>		 *		 * @param clazz the plugin class		 * @param path The path to the resource to be returned, relative to		 * the plugin's resource path.		 * @return An input stream for the resource, or <code>null</code>.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsStream(EditPlugin,String)		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		public static InputStream getResourceAsStream(Class<? extends EditPlugin> clazz, String path)		{			return getResourceAsStream(clazz.getName(), path);		}	
/**		 * <p>Returns an input stream to the specified resource, or <code>null</code>		 * if none is found.</p>		 * 		 * <p>This method doesn't need the plugin to be activated. You can pass		 * an {@code EditPlugin.Deferred} instance that you get from		 * {@code jEdit.getPlugin(String)} or {@code jEdit.getPlugins()} if		 * the plugin in question is not activated yet and this method doesn't		 * cause the plugin to get activated. If you have a reference to the		 * plugins {@code Class} instance available, consider using the		 * {@code Class} method.</p>		 *		 * @param plugin the plugin		 * @param path The path to the resource to be returned, relative to		 * the plugin's resource path.		 * @return An input stream for the resource, or <code>null</code>.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsStream(Class,String)		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		public static InputStream getResourceAsStream(EditPlugin plugin, String path)		{			return getResourceAsStream(plugin.getClassName(), path);		}	
/**		 * Returns an input stream to the specified resource, or <code>null</code>		 * if none is found.		 * 		 * @param pluginClassName the plugin class name (fully qualified)		 * @param path The path to the resource to be returned, relative to		 * the plugin's resource path.		 * @return An input stream for the resource, or <code>null</code>.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsOutputStream		 * @see #getResourcePath		 */		private static InputStream getResourceAsStream(String pluginClassName, String path)		{			try 			{				File file = getResourcePath(pluginClassName, path);				if (file == null || !file.exists())					return null;				return new FileInputStream(file);			} 			catch (IOException e)			{				return null;			}		}	
/**		 * <p>Returns an output stream to the specified resource, or {@code null}		 * if access to that resource is denied.</p>		 *		 * <p>Since the first parameter is a reference to the		 * {@code Class} instance for the plugin,		 * this method requires the plugin to be activated.</p>		 *		 * <p>See {@link #getResourceAsOutputStream(EditPlugin,String)} method, as		 * an alternate, for when the plugin doesn't need		 * to be activated, or when you do not have the		 * {@code Class} instance available.</p>		 *		 * @param clazz the plugin class		 * @param path The path to the resource to be returned, relative to		 * the plugin's resource path.		 * @return An output stream for the resource, or <code>null</code>.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsOutputStream(EditPlugin,String)		 * @see #getResourceAsStream		 * @see #getResourcePath		 */		public static OutputStream getResourceAsOutputStream(Class<? extends EditPlugin> clazz, String path)		{			return getResourceAsOutputStream(clazz.getName(), path);		}	
/**		 * <p>Returns an output stream to the specified resource, or <code>null</node> if access		 * to that resource is denied.</p>		 *		 * <p>This method doesn't need the plugin to be activated. You can pass		 * an {@code EditPlugin.Deferred} instance that you get from		 * {@code jEdit.getPlugin(String)} or {@code jEdit.getPlugins()} if		 * the plugin in question is not activated yet and this method doesn't		 * cause the plugin to get activated. If you have a reference to the		 * plugins {@code Class} instance available, consider using the		 * {@code Class} method.</p>		 *		 * @param plugin the plugin		 * @param path The path to the resource to be returned, relative to		 * the plugin's resource path.		 * @return An output stream for the resource, or <code>null</code>.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsOutputStream(Class,String)		 * @see #getResourceAsStream		 * @see #getResourcePath		 */		public static OutputStream getResourceAsOutputStream(EditPlugin plugin, String path)		{			return getResourceAsOutputStream(plugin.getClassName(), path);		}	
/**		 * Returns an output stream to the specified resource, or <code>null</node> if access		 * to that resource is denied.		 * 		 * @param pluginClassName the plugin class name (fully qualified)		 * @param path The path to the resource to be returned, relative to		 * the plugin's resource path.		 * @return An output stream for the resource, or <code>null</code>.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsStream		 * @see #getResourcePath		 */		private static OutputStream getResourceAsOutputStream(String pluginClassName, String path)		{			try 			{				File file = getResourcePath(pluginClassName, path);				if (file == null)					return null;				File parentFile = file.getParentFile();				if (!parentFile.exists())				{					if (!parentFile.mkdirs())					{						Log.log(Log.ERROR, EditPlugin.class, "Unable to create folder " + parentFile.getPath());						return null;					}				}				return new FileOutputStream(file);			}			catch (IOException e)			{				return null;			}		}	
/**		 * <p>Returns the full path of the specified plugin resource.</p>		 *		 * <p>Since the first parameter is a reference to the		 * {@code Class} instance for the plugin,		 * this method requires the plugin to be activated.</p>		 *		 * <p>See {@link #getResourcePath(EditPlugin,String)} method, as		 * an alternate, for when the plugin doesn't need		 * to be activated, or when you do not have the		 * {@code Class} instance available.</p>		 *		 * @param clazz the plugin class		 * @param path The relative path to the resource from the plugin's		 * resource path.		 * @return The absolute path to the resource or null if there is no plugin home.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsOutputStream		 * @see #getResourceAsStream		 * @see #getResourcePath(EditPlugin,String)		 */		public static File getResourcePath(Class<? extends EditPlugin> clazz, String path)		{			return getResourcePath(clazz.getName(), path);		}	
/**		 * <p>Returns the full path of the specified plugin resource.</p>		 *		 * <p>This method doesn't need the plugin to be activated. You can pass		 * an {@code EditPlugin.Deferred} instance that you get from		 * {@code jEdit.getPlugin(String)} or {@code jEdit.getPlugins()} if		 * the plugin in question is not activated yet and this method doesn't		 * cause the plugin to get activated. If you have a reference to the		 * plugins {@code Class} instance available, consider using the		 * {@code Class} method.</p>		 *		 * @param plugin the plugin		 * @param path The relative path to the resource from the plugin's		 * resource path.		 * @return The absolute path to the resource or null if there is no plugin home.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsOutputStream		 * @see #getResourceAsStream		 * @see #getResourcePath(Class,String)		 */		public static File getResourcePath(EditPlugin plugin, String path)		{			return getResourcePath(plugin.getClassName(), path);		}	
/**		 * Returns the full path of the specified plugin resource.		 *		 * @param pluginClassName the plugin class name (fully qualified)		 * @param path The relative path to the resource from the plugin's		 * resource path.		 * @return The absolute path to the resource or null if there is no plugin home.		 * @since 4.3pre10		 * @see #getPluginHome		 * @see #getResourceAsOutputStream		 * @see #getResourceAsStream		 */		private static File getResourcePath(String pluginClassName, String path)		{			File home = getPluginHome(pluginClassName);			if (home == null)				return null;			return new File(home, path);		}	
/**		 * Returns the plugin's class name. This might not be the same as		 * the class of the actual <code>EditPlugin</code> instance, for		 * example if the plugin is not loaded yet.		 *		 * @since jEdit 2.5pre3		 */		public String getClassName()		{			return getClass().getName();		}	
/**		 * Returns the JAR file containing this plugin.		 * @since jEdit 4.2pre1		 */		public PluginJAR getPluginJAR()		{			return jar;		}	
/**		 * Called by the view when constructing its <b>Plugins</b> menu.		 * See the description of this class for details about how the		 * menu items are constructed from plugin properties.		 *		 * @since jEdit 4.2pre1		 */		public final JMenuItem createMenuItems()		{			if(this instanceof Broken)				return null;				String menuItemName = jEdit.getProperty("plugin." +				getClassName() + ".menu-item");			if(menuItemName != null)				return GUIUtilities.loadMenuItem(menuItemName);				String menuProperty = "plugin." + getClassName() + ".menu";			String codeProperty = "plugin." + getClassName() + ".menu.code";			if(jEdit.getProperty(menuProperty) != null				|| jEdit.getProperty(codeProperty) != null)			{				String pluginName = jEdit.getProperty("plugin." +					getClassName() + ".name");				return new EnhancedMenu(menuProperty,pluginName);			}				return null;		}	
/**		 * Called by the filesystem browser when constructing its		 * <b>Plugins</b> menu.		 * See the description of this class for details about how the		 * menu items are constructed from plugin properties.		 *		 * @since jEdit 4.2pre1		 */		public final JMenuItem createBrowserMenuItems()		{			if(this instanceof Broken)				return null;				String menuItemName = jEdit.getProperty("plugin." +				getClassName() + ".browser-menu-item");			if(menuItemName != null)			{				return GUIUtilities.loadMenuItem(					VFSBrowser.getActionContext(),					menuItemName,					false);			}				String menuProperty = "plugin." + getClassName() + ".browser-menu";			if(jEdit.getProperty(menuProperty) != null)			{				String pluginName = jEdit.getProperty("plugin." +					getClassName() + ".name");				return new EnhancedMenu(menuProperty,pluginName,					VFSBrowser.getActionContext());			}				return null;		}	
/**		 * @deprecated Instead of overriding this method, define properties		 * as specified in the description of this class.		 */		public void createMenuItems(Vector menuItems) {}	
/**		 * @deprecated Instead of overriding this method, define properties		 * as specified in the description of this class.		 */		public void createOptionPanes(OptionsDialog optionsDialog) {}	
public String getClassName()			{				return clazz;			}	
Broken(PluginJAR jar, String clazz)			{				this.jar = jar;				this.clazz = clazz;			}	
public String getClassName()			{				return clazz;			}	
Deferred(PluginJAR jar, String clazz)			{				this.jar = jar;				this.clazz = clazz;			}	
EditPlugin loadPluginClass()			{				return null;			}	
public String toString()			{				return "Deferred[" + clazz + ']';			}	
EditServer(String portFile)		{			super("jEdit server daemon [" + portFile + "]");			setDaemon(true);			this.portFile = portFile;				try			{				// On Unix, set permissions of port file to rw-------,				// so that on broken Unices which give everyone read				// access to user home dirs, people can't see your				// port file (and hence send arbitriary BeanShell code				// your way. Nasty.)				if(OperatingSystem.isUnix())				{					new File(portFile).createNewFile();					FileVFS.setPermissions(portFile,0600);				}					// Bind to any port on localhost; accept 2 simultaneous				// connection attempts before rejecting connections				socket = new ServerSocket(0, 2,					InetAddress.getByName("127.0.0.1"));				authKey = new Random().nextInt(Integer.MAX_VALUE);				int port = socket.getLocalPort();					FileWriter out = new FileWriter(portFile);					try				{					out.write("b\n");					out.write(String.valueOf(port));					out.write("\n");					out.write(String.valueOf(authKey));					out.write("\n");				}				finally				{					out.close();				}					ok = true;					Log.log(Log.DEBUG,this,"jEdit server started on port "					+ socket.getLocalPort());				Log.log(Log.DEBUG,this,"Authorization key is "					+ authKey);			}			catch(IOException io)			{				/* on some Windows versions, connections to localhost				 * fail if the network is not running. To avoid				 * confusing newbies with weird error messages, log				 * errors that occur while starting the server				 * as NOTICE, not ERROR */				Log.log(Log.NOTICE,this,io);			}		}	
public void run()		{			for(;;)			{				if(abort)					return;					Socket client = null;				try				{					client = socket.accept();						// Stop script kiddies from opening the edit					// server port and just leaving it open, as a					// DoS					client.setSoTimeout(1000);						Log.log(Log.MESSAGE,this,client + ": connected");						DataInputStream in = new DataInputStream(						client.getInputStream());						if(!handleClient(client,in))						abort = true;				}				catch(Exception e)				{					if(!abort)						Log.log(Log.ERROR,this,e);					abort = true;				}				finally				{					/* if(client != null)					{						try						{							client.close();						}						catch(Exception e)						{							Log.log(Log.ERROR,this,e);						}							client = null;					} */				}			}		}	
/**		 * @param restore Ignored unless no views are open		 * @param parent The client's parent directory		 * @param args A list of files. Null entries are ignored, for convinience		 * @since jEdit 3.2pre7		 */		public static void handleClient(boolean restore, String parent,			String[] args)		{			handleClient(restore,false,false,parent,args);		}	
/**		 * @param restore Ignored unless no views are open		 * @param newView Open a new view?		 * @param newPlainView Open a new plain view?		 * @param parent The client's parent directory		 * @param args A list of files. Null entries are ignored, for convinience		 * @since jEdit 4.2pre1		 */		public static Buffer handleClient(boolean restore,			boolean newView, boolean newPlainView, String parent,			String[] args)		{			// we have to deal with a huge range of possible border cases here.			if(jEdit.getFirstView() == null)			{				// coming out of background mode.				// no views open.				// no buffers open if args empty.					Buffer buffer = jEdit.openFiles(null,parent,args);					if(jEdit.getBufferCount() == 0)					jEdit.newFile((EditPane) null);					boolean restoreFiles = restore					&& jEdit.getBooleanProperty("restore")					&& (buffer == null					|| jEdit.getBooleanProperty("restore.cli"));					View view = PerspectiveManager.loadPerspective(					restoreFiles);					if(view == null)				{					if(buffer == null)						buffer = jEdit.getFirstBuffer();					view = jEdit.newView(null,buffer);				}				else if(buffer != null)					view.setBuffer(buffer,false);					return buffer;			}			else if(newPlainView)			{				// no background mode, and opening a new view				Buffer buffer = jEdit.openFiles(null,parent,args);				if(buffer == null)					buffer = jEdit.getFirstBuffer();				jEdit.newView(null,buffer,true);				return buffer;			}			else if(newView)			{				// no background mode, and opening a new view				Buffer buffer = jEdit.openFiles(null,parent,args);				if(buffer == null)					buffer = jEdit.getFirstBuffer();				jEdit.newView(jEdit.getActiveView(),buffer,false);				return buffer;			}			else			{				// no background mode, and reusing existing view				View view = jEdit.getActiveView();					Buffer buffer = jEdit.openFiles(view,parent,args);					// Hack done to fix bringing the window to the front.				// At least on windows, Frame.toFront() doesn't cut it.				// Remove the isWindows check if it's broken under other				// OSes too.				if (jEdit.getBooleanProperty("server.brokenToFront"))					view.setState(java.awt.Frame.ICONIFIED);					// un-iconify using JDK 1.3 API				view.setState(java.awt.Frame.NORMAL);				view.requestFocus();				view.toFront();					return buffer;			}		}	
boolean isOK()		{			return ok;		}	
public int getPort()		{			return socket.getLocalPort();		}	
void stopServer()		{			abort = true;			try			{				socket.close();			}			catch(IOException io)			{			}				new File(portFile).delete();		}	
private boolean handleClient(final Socket client, DataInputStream in)			throws Exception		{			int key = in.readInt();			if(key != authKey)			{				Log.log(Log.ERROR,this,client + ": wrong"					+ " authorization key (got " + key					+ ", expected " + authKey + ")");				in.close();				client.close();					return false;			}			else			{				// Reset the timeout				client.setSoTimeout(0);					Log.log(Log.DEBUG,this,client + ": authenticated"					+ " successfully");					final String script = in.readUTF();				Log.log(Log.DEBUG,this,script);					SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						try						{							NameSpace ns = new NameSpace(								BeanShell.getNameSpace(),								"EditServer namespace");							ns.setVariable("socket",client);							BeanShell.eval(null,ns,script);						}						catch(org.gjt.sp.jedit.bsh.UtilEvalError e)						{							Log.log(Log.ERROR,this,e);						}						finally						{							try							{								BeanShell.getNameSpace().setVariable("socket",null);							}							catch(org.gjt.sp.jedit.bsh.UtilEvalError e)							{								Log.log(Log.ERROR,this,e);							}						}					}				});					return true;			}		}	
/**		 * Returns an instance of Encoding for specified name.		 * The name is used for search the following domains in the		 * listed order.		 *   - java.nio.charset.Charset		 *   - jEdit ServiceManager		 */		public static Encoding getEncoding(String name)		{			try			{				return new CharsetEncoding(name);			}			catch (IllegalCharsetNameException e)			{				// just failed			}			catch (UnsupportedCharsetException e)			{				// just failed			}				Object namedService = ServiceManager.getService(serviceClass, name);			if (namedService != null && namedService instanceof Encoding)			{				return (Encoding)namedService;			}				// UnsupportedCharsetException is for java.nio.charset,			// but throw this here too so that this can be caught as			// an encoding error by catch clause for general I/O code.			throw new UnsupportedCharsetException("No such encoding: \"" + name + "\"");		}	
/**		 * Returns the set of all available encoding names.		 */		public static Set<String> getAvailableNames()		{			Set<String> set = new HashSet<String>();			set.addAll(Charset.availableCharsets().keySet());			set.addAll(Arrays.asList(ServiceManager.getServiceNames(serviceClass)));			return set;		}	
/**		 * Returns the set of user selected encoding names.		 */		public static Set<String> getSelectedNames()		{			Set<String> set = getAvailableNames();			Iterator<String> i = set.iterator();			while (i.hasNext())			{				String name = i.next();				if (jEdit.getBooleanProperty("encoding.opt-out." + name, false))				{					i.remove();				}			}			return set;		}	
/**		 * Returns a Reader object that reads the InputStream with		 * the encoding. This method is same with		 * "getEncoding(encoding).getTextReader(in)".		 */		public static Reader getTextReader(InputStream in, String encoding)			throws IOException		{			return getEncoding(encoding).getTextReader(in);		}	
/**		 * Returns a Writer object that writes to the OutputStream with		 * the encoding. This method is same with		 * "getEncoding(encoding).getTextWriter(out)".		 */		public static Writer getTextWriter(OutputStream out, String encoding)			throws IOException		{			return getEncoding(encoding).getTextWriter(out);		}	
/**		 * Returns if the specified name is supported as a name for an Encoding.		 */		public static boolean hasEncoding(String name)		{			try			{				if (Charset.isSupported(name))				{					return true;				}			}			catch (IllegalCharsetNameException e)			{				// The name is illegal for java.nio.charset.Charset.				// But it may be legal for service name.			}				return Arrays.asList(ServiceManager.getServiceNames(serviceClass)).contains(name);		}	
public EncodingsOptionPane()		{			super("encodings");		}	
@Override		protected void _init()		{			// Default file encoding			String[] encodings = getEncodings(true);			sort(encodings,new StandardUtilities.StringCompare<String>(true));			defaultEncoding = new JComboBox(encodings);			defaultEncoding.setEditable(true);			defaultEncoding.setSelectedItem(jEdit.getProperty("buffer."+JEditBuffer.ENCODING,				System.getProperty("file.encoding")));			addComponent(jEdit.getProperty("options.general.encoding"),defaultEncoding);				// Auto detect encoding			encodingAutodetect = new JCheckBox(jEdit.getProperty(				"options.general.encodingAutodetect"));			encodingAutodetect.setSelected(jEdit.getBooleanProperty(				"buffer.encodingAutodetect"));			addComponent(encodingAutodetect,BOTH);						// Encoding detectors			encodingDetectors = new JTextField(jEdit.getProperty(				"encodingDetectors","BOM XML-PI"));			addComponent(jEdit.getProperty("options.general.encodingDetectors"),encodingDetectors);				// Fallback Encodings			fallbackEncodings = new JTextField(jEdit.getProperty(				"fallbackEncodings",""));			fallbackEncodings.setToolTipText(jEdit.getProperty(				"options.general.fallbackEncodings.tooltip"));			addComponent(jEdit.getProperty("options.general.fallbackEncodings"),fallbackEncodings);				// Encodings to display			encodings = getEncodings(false);			sort(encodings,new StandardUtilities.StringCompare<String>(true));			Vector<Entry> encodingEntriesVector = new Vector<Entry>();			boolean enableSelectAll = false;			boolean enableSelectNone = false;			for (String encoding : encodings)			{				boolean selected = !getBooleanProperty("encoding.opt-out."+encoding,false);				enableSelectAll = enableSelectAll || !selected;				enableSelectNone = enableSelectNone || selected;				encodingEntriesVector.add(new Entry(selected,encoding));			}			encodingsList = new JCheckBoxList(encodingEntriesVector);			encodingsList.getModel().addTableModelListener(new TableModelHandler());			JScrollPane encodingsScrollPane = new JScrollPane(encodingsList);			encodingsScrollPane.setBorder(				new TitledBorder(getProperty("options.encodings.selectEncodings")));			Dimension d = encodingsList.getPreferredSize();			d.height = Math.min(d.height,200);			encodingsScrollPane.setPreferredSize(d);			addComponent(encodingsScrollPane,BOTH);				// Select All/None Buttons			Box buttonsBox = createHorizontalBox();			buttonsBox.add(createHorizontalStrut(12));						ActionHandler actionHandler = new ActionHandler();			selectAllButton = new JButton(getProperty("options.encodings.selectAll"));			selectAllButton.addActionListener(actionHandler);			selectAllButton.setEnabled(enableSelectAll);			buttonsBox.add(selectAllButton);			buttonsBox.add(createHorizontalStrut(12));				selectNoneButton = new JButton(getProperty("options.encodings.selectNone"));			selectNoneButton.addActionListener(actionHandler);			selectNoneButton.setEnabled(enableSelectNone);			buttonsBox.add(selectNoneButton);			buttonsBox.add(createHorizontalStrut(12));						addComponent(buttonsBox);		}	
@Override		protected void _save()		{						jEdit.setProperty("buffer."+ JEditBuffer.ENCODING,(String)				defaultEncoding.getSelectedItem());			jEdit.setBooleanProperty("buffer.encodingAutodetect",				encodingAutodetect.isSelected());			jEdit.setProperty("encodingDetectors",encodingDetectors.getText());			jEdit.setProperty("fallbackEncodings",fallbackEncodings.getText());						for (Entry entry : encodingsList.getValues())			{				if (entry.isChecked())				{					unsetProperty("encoding.opt-out."+entry.getValue());				}				else				{					setBooleanProperty("encoding.opt-out."+entry.getValue(),true);				}			}		}	
public void actionPerformed(ActionEvent ae)			{				Object source = ae.getSource();				if (source == selectAllButton)				{					encodingsList.selectAll();				}				else if (source == selectNoneButton)				{					for (int i=0, c=encodingsList.getRowCount() ; i<c ; i++)					{						encodingsList.setValueAt(false,i,0);					}				}			}	
public void tableChanged(TableModelEvent tme)			{				int checkedAmount = encodingsList.getCheckedValues().length;				if (checkedAmount == 0)				{					selectNoneButton.setEnabled(false);				}				else				{					selectNoneButton.setEnabled(true);				}				if (encodingsList.getValues().length == checkedAmount)				{					selectAllButton.setEnabled(false);				}				else				{					selectAllButton.setEnabled(true);				}			}	
public Widget getWidget(View view) 		{			EncodingWidget mode = new EncodingWidget(view);			return mode;		}	
public EncodingWidget(final View view) 			{				encoding = new ToolTipLabel();				this.view = view;				encoding.setToolTipText(jEdit.getProperty("view.status.mode-tooltip"));				encoding.addMouseListener(new MouseAdapter() 							  {								  @Override								  public void mouseClicked(MouseEvent evt)								  {									  if(evt.getClickCount() == 2)										  new BufferOptions(view,view.getBuffer());								  }							  });			}	
public JComponent getComponent() 			{				return encoding;			}	
public void update() 			{				Buffer buffer = view.getBuffer();				if (buffer.isLoaded())					encoding.setText(buffer.getStringProperty("encoding"));			}	
public void propertiesChanged()			{			}	
public EncodingWithBOM(String plain)		{			byte[] bom = bomMap.get(plain);			if (bom == null)			{				throw new UnsupportedCharsetException(plain + " with BOM");			}			this.plain = new CharsetEncoding(plain);			this.bom = bom;		}	
public Reader getTextReader(InputStream in) throws IOException		{			byte[] actualMark = new byte[bom.length];			int count = in.read(actualMark);			if (count < bom.length || !Arrays.equals(actualMark, bom))			{				throw new MalformedInputException(0);			}			return plain.getTextReader(in);		}	
public Writer getTextWriter(OutputStream out) throws IOException		{			out.write(bom);			return plain.getTextWriter(out);		}	
public Reader getPermissiveTextReader(InputStream in) throws IOException		{			byte[] actualMark = new byte[bom.length];			int count = in.read(actualMark);			if (count < bom.length || !Arrays.equals(actualMark, bom))			{				// Concatenate the non-BOM bytes and the rest of				// input so that the non-BOM bytes are reinterepreted				// as some characters.				in = new SequenceInputStream(					new ByteArrayInputStream(actualMark, 0, count),					in);			}			return plain.getPermissiveTextReader(in);		}	
public String detectEncoding(InputStream sample) throws IOException			{				byte[] mark = new byte[4];				int count = sample.read(mark);						byte low = (byte)(BOM16 & 0xff);				byte high = (byte)((BOM16 >> 8) & 0xff);				if (count >= 4)				{					if (mark[0] == low && mark[1] == high						&& mark[2] == 0x00 && mark[3] == 0x00)					{						return "X-UTF-32LE-BOM";					}					else if (mark[0] == 0x00 && mark[1] == 0x00						&& mark[2] == high && mark[3] == low)					{						return "X-UTF-32BE-BOM";					}				}				if (count >= 2)				{					if (mark[0] == low && mark[1] == high)					{						return "x-UTF-16LE-BOM";					}					else if (mark[0] == high && mark[1] == low)					{						// "x-UTF-16BE-BOM" does not available.						// But an encoder for "UTF-16" actually uses						// big endian with corresponding BOM. It just						// works as "UTF-16BE with BOM".						return "UTF-16";					}				}						if (count >= UTF8BOM.length)				{					int i = 0;					while (i < UTF8BOM.length)					{						if (mark[i] != UTF8BOM[i])						{							break;						}						++i;					}					if (i == UTF8BOM.length)					{						return "UTF-8Y";					}				}						return null;			}	
public EnhancedButton(Icon icon, String toolTip, String action,			ActionContext context)		{			super(icon);				this.action = action;				if(action != null)			{				// set the name of this button :				// for instance, if the action is 'vfs.browser.previous'				// the name will be 'previous'				// this helps greatly in testing the UI with Fest-Swing				int iSuffix = action.lastIndexOf('.');				if(iSuffix<0 || iSuffix == action.length()-1)				{					setName(action);				}				else				{					setName(action.substring(iSuffix+1));				}								setEnabled(true);				addActionListener(new EditAction.Wrapper(context,action));				addMouseListener(new MouseHandler());			}			else				setEnabled(false);				setToolTipText(toolTip);		}	
public boolean isFocusTraversable()		{			return false;		}	
public void mouseReleased(MouseEvent evt)			{				if(msgSet)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(null);					msgSet = false;				}			}	
public void mouseEntered(MouseEvent evt)			{				String msg = jEdit.getProperty(action + ".mouse-over");				if(msg != null)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(msg);					msgSet = true;				}			}	
public void mouseExited(MouseEvent evt)			{				if(msgSet)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(null);					msgSet = false;				}			}	
/**		 * Creates a new menu item. Most plugins should call		 * GUIUtilities.loadMenuItem() instead.		 * @param label The menu item label		 * @param action The edit action		 * @param context An action context		 * @since jEdit 4.2pre1		 */		public EnhancedCheckBoxMenuItem(String label, String action,			ActionContext context)		{			this.context = context;			this.action = action;			this.shortcut = GUIUtilities.getShortcutLabel(action);			if(OperatingSystem.hasScreenMenuBar() && shortcut != null)			{				setText(label + " (" + shortcut + ")");				shortcut = null;			}			else				setText(label);				if(action != null)			{				setEnabled(true);				addActionListener(new EditAction.Wrapper(context,action));					addMouseListener(new MouseHandler());			}			else				setEnabled(false);				setModel(new Model());		}	
public Dimension getPreferredSize()		{			Dimension d = super.getPreferredSize();				if(shortcut != null)			{				d.width += (getFontMetrics(EnhancedMenuItem.acceleratorFont)					.stringWidth(shortcut) + 15);			}			return d;		}	
public void paint(Graphics g)		{			super.paint(g);				if(shortcut != null)			{				g.setFont(EnhancedMenuItem.acceleratorFont);				g.setColor(getModel().isArmed() ?					EnhancedMenuItem.acceleratorSelectionForeground :					EnhancedMenuItem.acceleratorForeground);				FontMetrics fm = g.getFontMetrics();				Insets insets = getInsets();				g.drawString(shortcut,getWidth() - (fm.stringWidth(					shortcut) + insets.right + insets.left + 5),					getFont().getSize() + (insets.top - 					(OperatingSystem.isMacOSLF() ? 0 : 1))					/* XXX magic number */);			}		}	
public boolean isSelected()			{				if(!isShowing())					return false;					EditAction a = context.getAction(action);				if(a == null)				{					Log.log(Log.WARNING,this,"Unknown action: "						+ action);					return false;				}					try				{					return a.isSelected(EnhancedCheckBoxMenuItem.this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,t);					return false;				}			}	
public void setSelected(boolean b) {}	
public void mouseReleased(MouseEvent evt)			{				if(msgSet)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(null);					msgSet = false;				}			}	
public void mouseEntered(MouseEvent evt)			{				String msg = jEdit.getProperty(action + ".mouse-over");				if(msg != null)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(msg);					msgSet = true;				}			}	
public void mouseExited(MouseEvent evt)			{				if(msgSet)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(null);					msgSet = false;				}			}	
public EnhancedDialog(Frame parent, String title, boolean modal)		{			super(parent,title,modal);			_init();		}	
public EnhancedDialog(Dialog parent, String title, boolean modal)		{			super(parent,title,modal);			_init();		}	
public boolean getEnterEnabled()		{			return enterEnabled;		}	
public void setEnterEnabled(boolean enterEnabled)		{			this.enterEnabled = enterEnabled;		}	
private void _init()		{			((Container)getLayeredPane()).addContainerListener(				new ContainerHandler());			getContentPane().addContainerListener(new ContainerHandler());				keyHandler = new KeyHandler();			addKeyListener(keyHandler);			addWindowListener(new WindowHandler());				setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);						enterEnabled = true;		}	
public void componentAdded(ContainerEvent evt)			{				componentAdded(evt.getChild());			}	
public void componentRemoved(ContainerEvent evt)			{				componentRemoved(evt.getChild());			}	
private void componentAdded(Component comp)			{				comp.addKeyListener(keyHandler);				if(comp instanceof Container)				{					Container cont = (Container)comp;					cont.addContainerListener(this);					Component[] comps = cont.getComponents();					for(int i = 0; i < comps.length; i++)					{						componentAdded(comps[i]);					}				}			}	
private void componentRemoved(Component comp)			{				comp.removeKeyListener(keyHandler);				if(comp instanceof Container)				{					Container cont = (Container)comp;					cont.removeContainerListener(this);					Component[] comps = cont.getComponents();					for(int i = 0; i < comps.length; i++)					{						componentRemoved(comps[i]);					}				}			}	
public void keyPressed(KeyEvent evt)			{				if(evt.isConsumed())					return;					if(evt.getKeyCode() == KeyEvent.VK_ENTER					&& enterEnabled)				{					Component comp = getFocusOwner();					while(comp != null)					{						if(comp instanceof JComboBox)						{							JComboBox combo = (JComboBox)comp;							if(combo.isEditable())							{								Object selected = combo.getEditor().getItem();								if(selected != null)									combo.setSelectedItem(selected);							}							break;						}							comp = comp.getParent();					}						ok();					evt.consume();				}				else if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)				{					cancel();					evt.consume();				}			}	
public void windowClosing(WindowEvent evt)			{				cancel();			}	
public EnhancedMenu(String name)		{			this(name,jEdit.getProperty(name.concat(".label")),				jEdit.getActionContext());		}	
public EnhancedMenu(String name, String label)		{			this(name,label,jEdit.getActionContext());		}	
public EnhancedMenu(String name, String label, ActionContext context)		{			this.context = context;			if(label == null)				label = name;				char mnemonic;			int index = label.indexOf('$');			if(index != -1 && label.length() - index > 1)			{				mnemonic = Character.toLowerCase(label.charAt(index + 1));				label = label.substring(0,index).concat(label.substring(++index));			}			else				mnemonic = '\0';				setText(label);			if(!OperatingSystem.isMacOS())				setMnemonic(mnemonic);				String menuItems = jEdit.getProperty(name);			if(menuItems != null)			{				StringTokenizer st = new StringTokenizer(menuItems);				while(st.hasMoreTokens())				{					String menuItemName = st.nextToken();					if(menuItemName.equals("-"))						addSeparator();					else						add(GUIUtilities.loadMenuItem(context,menuItemName,true));				}			}				initialComponentCount = getMenuComponentCount();				providerCode = jEdit.getProperty(name + ".code");				ebStub = new EditBusStub(name);			ebStub.menuOutOfDate = true;				addMenuListener(this);				if(providerCode != null)				EditBus.addToBus(ebStub);		}	
public void menuSelected(MenuEvent evt)		{			init();		}	
public void menuDeselected(MenuEvent e) {}	
public void menuCanceled(MenuEvent e) {}	
public void init()		{			if(providerCode == null)				return;				if(provider == null)			{				Object obj = BeanShell.eval(null,					BeanShell.getNameSpace(),					providerCode);				provider = (DynamicMenuProvider)obj;			}				if(provider == null)			{				// error				providerCode = null;				return;			}				if(ebStub.menuOutOfDate || provider.updateEveryTime())			{				ebStub.menuOutOfDate = false;					while(getMenuComponentCount() != initialComponentCount)					remove(getMenuComponentCount() - 1);					if(provider != null)					provider.update(this);			}		}	
protected void finalize() throws Exception		{			if(ebStub != null)				EditBus.removeFromBus(ebStub);		}	
EditBusStub(String name)			{				this.name = name;				menuOutOfDate = true;			}	
public void handleMessage(EBMessage msg)			{				if(msg instanceof DynamicMenuChanged					&& name.equals(((DynamicMenuChanged)msg)					.getMenuName()))				{					menuOutOfDate = true;				}				else if(msg instanceof PropertiesChanged)				{					// while this might be questionable, some					// menus depend on properties					menuOutOfDate = true;				}			}	
/**		 * Creates a new menu item. Most plugins should call		 * GUIUtilities.loadMenuItem() instead.		 * @param label The menu item label		 * @param action The edit action		 * @param context An action context		 * @since jEdit 4.2pre1		 */		public EnhancedMenuItem(String label, String action, ActionContext context)		{			this.action = action;			this.shortcut = GUIUtilities.getShortcutLabel(action);			if(OperatingSystem.hasScreenMenuBar() && shortcut != null)			{				setText(label + " (" + shortcut + ")");				shortcut = null;			}			else				setText(label);				if(action != null)			{				setEnabled(true);				addActionListener(new EditAction.Wrapper(context,action));				addMouseListener(new MouseHandler());			}			else				setEnabled(false);		}	
public Dimension getPreferredSize()		{			Dimension d = super.getPreferredSize();				if(shortcut != null)			{				d.width += (getFontMetrics(acceleratorFont)					.stringWidth(shortcut) + 15);			}			return d;		}	
public void paint(Graphics g)		{			super.paint(g);				if(shortcut != null)			{				g.setFont(acceleratorFont);				g.setColor(getModel().isArmed() ?					acceleratorSelectionForeground :					acceleratorForeground);				FontMetrics fm = g.getFontMetrics();				Insets insets = getInsets();				g.drawString(shortcut,getWidth() - (fm.stringWidth(					shortcut) + insets.right + insets.left + 5),					getFont().getSize() + (insets.top - 					(OperatingSystem.isMacOSLF() ? 0 : 1))					/* XXX magic number */);			}		}	
public void mouseReleased(MouseEvent evt)			{				if(msgSet)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(null);					msgSet = false;				}			}	
public void mouseEntered(MouseEvent evt)			{				String msg = jEdit.getProperty(action + ".mouse-over");				if(msg != null)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(msg);					msgSet = true;				}			}	
public void mouseExited(MouseEvent evt)			{				if(msgSet)				{					GUIUtilities.getView((Component)evt.getSource())						.getStatus().setMessage(null);					msgSet = false;				}			}	
public ErrorEntry(String path, String messageProp, Object[] args)			{				this.path = path;					String message = jEdit.getProperty(messageProp,args);				if(message == null)					message = "Undefined property: " + messageProp;					Log.log(Log.ERROR,this,path + ":");				Log.log(Log.ERROR,this,message);					Vector<String> tokenizedMessage = new Vector<String>();				int lastIndex = -1;				for(int i = 0; i < message.length(); i++)				{					if(message.charAt(i) == '\n')					{						tokenizedMessage.addElement(message.substring(							lastIndex + 1,i));						lastIndex = i;					}				}					if(lastIndex != message.length())				{					tokenizedMessage.addElement(message.substring(						lastIndex + 1));				}					messages = new String[tokenizedMessage.size()];				tokenizedMessage.copyInto(messages);			}	
public boolean equals(Object o)			{				if(o instanceof ErrorEntry)				{					ErrorEntry e = (ErrorEntry)o;					return e.path.equals(path);				}				else					return false;			}	
public String toString()			{				return path + ":\n" +					TextUtilities.join(java.util.Arrays.asList(messages), "\n");			}	
public ErrorListDialog(Frame frame, String title, String caption,			Vector<ErrorEntry> messages, boolean pluginError)		{			super(frame,title,!pluginError);				JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				Box iconBox = new Box(BoxLayout.Y_AXIS);			iconBox.add(new JLabel(UIManager.getIcon("OptionPane.errorIcon")));			iconBox.add(Box.createGlue());			content.add(BorderLayout.WEST,iconBox);				JPanel centerPanel = new JPanel(new BorderLayout());				JLabel label = new JLabel(caption);			label.setBorder(new EmptyBorder(0,0,6,0));			centerPanel.add(BorderLayout.NORTH,label);				JTextPane errors = new JTextPane();			errors.setEditable(false);			errors.setForeground( jEdit.getColorProperty("view.fgColor") );			errors.setBackground( jEdit.getColorProperty("view.bgColor") );			errors.setCaretColor( jEdit.getActiveView().getEditPane().getTextArea().getPainter().getCaretColor() );			errors.setSelectionColor( jEdit.getActiveView().getEditPane().getTextArea().getPainter().getSelectionColor() );			StyledDocument doc = errors.getStyledDocument();			Font plainFont = new JLabel().getFont();			SimpleAttributeSet plainFontAttrSet = new SimpleAttributeSet();			StyleConstants.setFontFamily(plainFontAttrSet, plainFont.getFamily());			SimpleAttributeSet boldFontAttrSet = (SimpleAttributeSet) plainFontAttrSet.clone();			StyleConstants.setBold(boldFontAttrSet, true);			for (ErrorEntry entry : messages)			{				try				{					doc.insertString(doc.getLength(), entry.path + ":\n", boldFontAttrSet);					for (String s: entry.messages)						doc.insertString(doc.getLength(), s + "\n", plainFontAttrSet);				}				catch (BadLocationException e)				{				}			}				// need this bullshit scroll bar policy for the preferred size			// hack to work			JScrollPane scrollPane = new JScrollPane(errors,				JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,				JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);			Dimension size = scrollPane.getPreferredSize();			size.width = Math.min(size.width,400);			scrollPane.setPreferredSize(size);				centerPanel.add(BorderLayout.CENTER,scrollPane);				content.add(BorderLayout.CENTER,centerPanel);				Box buttons = new Box(BoxLayout.X_AXIS);			buttons.add(Box.createGlue());				ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(new ActionHandler());				if(pluginError)			{				pluginMgr = new JButton(jEdit.getProperty("error-list.plugin-manager"));				pluginMgr.addActionListener(new ActionHandler());				buttons.add(pluginMgr);				buttons.add(Box.createHorizontalStrut(6));			}				buttons.add(ok);				buttons.add(Box.createGlue());			content.add(BorderLayout.SOUTH,buttons);				getRootPane().setDefaultButton(ok);				pack();			setLocationRelativeTo(frame);			setVisible(true);		}	
public void ok()		{			dispose();		}	
public void cancel()		{			dispose();		}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == ok)					dispose();				else if(evt.getSource() == pluginMgr)				{					PluginManager.showPluginManager(JOptionPane.getFrameForComponent(						ErrorListDialog.this));				}			}	
public Widget getWidget(View view)		{			Widget errorWidget = new ErrorWidget(view);			return errorWidget;		}	
ErrorWidget(View view)			{				errorHighlight = new ErrorHighlight(view);			}	
public JComponent getComponent()			{				return errorHighlight;			}	
public void update()			{				errorHighlight.update();			}	
public void propertiesChanged()			{			}	
ErrorHighlight(View view)			{				setForeground(jEdit.getColorProperty("view.status.foreground"));				setBackground(jEdit.getColorProperty("view.status.background"));				addMouseListener(new MyMouseAdapter(view));			}	
@Override			public void addNotify()			{				super.addNotify();				update();				int millisecondsPerMinute = 1000;					timer = new Timer(millisecondsPerMinute, this);				timer.start();				ToolTipManager.sharedInstance().registerComponent(this);			}	
@Override			public void removeNotify()			{				timer.stop();				ToolTipManager.sharedInstance().unregisterComponent(this);				super.removeNotify();			}	
@Override			public Point getToolTipLocation(MouseEvent event)			{				return new Point(event.getX(), -20);			}	
public void actionPerformed(ActionEvent e)			{				update();			}	
private void update()			{				int size = Log.throwables.size();				if (size != currentSize)				{					currentSize = size;					if (size == 0)					{						setForeground(jEdit.getColorProperty("view.status.foreground"));						setText(null);						setToolTipText(size + " error");					}					else					{						setForeground(Color.red);						setText(Integer.toString(size) + " error(s)");						setToolTipText(size + " error(s)");					}				}			}	
MyMouseAdapter(View view)				{					this.view = view;				}	
@Override					public void mouseClicked(MouseEvent e)				{					if (Log.throwables.isEmpty())						return;					if (GUIUtilities.isRightButton(e.getModifiers()))					{						JPopupMenu menu = GUIUtilities.loadPopupMenu("errorwidget.popupmenu");						GUIUtilities.showPopupMenu(menu, ErrorHighlight.this, e.getX(), e.getY());						}					else if (e.getClickCount() == 2)						new ErrorDialog(view);					}	
private ErrorDialog(Frame view)			{				super(view, "Errors", false);				byteArrayOutputStream = new ByteArrayOutputStream();				printStream = new PrintStream(byteArrayOutputStream);				throwables = Log.throwables.toArray();				textArea = new JTextArea();				textArea.setEditable(false);				if (throwables.length != 0)				{					Throwable throwable = (Throwable) throwables[0];					setThrowable(throwable);				}				combo = new JComboBox(throwables);				combo.addItemListener(new ItemListener()				{					public void itemStateChanged(ItemEvent e)					{						setThrowable((Throwable) combo.getSelectedItem());					}				});				getContentPane().add(combo, BorderLayout.NORTH);				getContentPane().add(new JScrollPane(textArea));							Box buttons = new Box(BoxLayout.X_AXIS);				buttons.add(Box.createGlue());					buttons.add(removeThisError = new JButton(jEdit.getProperty("grab-key.remove")));				buttons.add(Box.createHorizontalStrut(6));				buttons.add(removeAllErrors = new JButton(jEdit.getProperty("common.clearAll")));					ErrorDialog.MyActionListener actionListener = new MyActionListener();				removeThisError.addActionListener(actionListener);				removeAllErrors.addActionListener(actionListener);				buttons.add(Box.createGlue());						getContentPane().add(buttons, BorderLayout.SOUTH);				pack();				GUIUtilities.loadGeometry(this,"status.errorWidget");				setVisible(true);			}	
private void setThrowable(Throwable throwable)			{				if (throwable == null)				{					textArea.setText(null);				}				else				{					throwable.printStackTrace(printStream);					textArea.setText(byteArrayOutputStream.toString());					textArea.setCaretPosition(0);					byteArrayOutputStream.reset();				}			}	
@Override			public void dispose()			{				GUIUtilities.saveGeometry(this, "status.errorWidget");				super.dispose();			}	
@Override			public void ok()			{				dispose();			}	
@Override			public void cancel()			{				dispose();			}	
public void actionPerformed(ActionEvent e)				{					Object source = e.getSource();					if (source == removeThisError)					{						Throwable throwable = (Throwable) combo.getSelectedItem();						if (throwable != null)						{							Log.throwables.remove(throwable);							combo.removeItem(throwable);							if (combo.getItemCount() == 0)							{								dispose();							}						}					}					else if (source == removeAllErrors)					{						for (Object throwable : throwables)						{							Log.throwables.remove(throwable);						}						dispose();					}				}	
public EvalError( String s, SimpleNode node, CallStack callstack ) {			setMessage(s);			this.node = node;			// freeze the callstack for the stack trace.			if ( callstack != null )				this.callstack = callstack.copy();		}	
/**			Print the error with line number and stack trace.		*/		public String toString() 		{			String trace;			if ( node != null )				trace = " : at Line: "+ node.getLineNumber() 					+ " : in file: "+ node.getSourceFile()					+ " : "+node.getText();			else				// Users should not normally see this.				trace = ": <at unknown location>";				if ( callstack != null )				trace = trace +"\n" + getScriptStackTrace();				return getMessage() + trace;		}	
/**			Re-throw the error, prepending the specified message.		*/		public void reThrow( String msg ) 			throws EvalError 		{			prependMessage( msg );			throw this;		}	
/**			The error has trace info associated with it. 			i.e. It has an AST node that can print its location and source text.		*/		SimpleNode getNode() {			return node;		}	
void setNode( SimpleNode node ) {			this.node = node;		}	
public String getErrorText() { 			if ( node != null )				return node.getText() ;			else				return "<unknown error>";		}	
public int getErrorLineNumber() { 			if ( node != null )				return node.getLineNumber() ;			else				return -1;		}	
public String getErrorSourceFile() {			if ( node != null )				return node.getSourceFile() ;			else				return "<unknown file>";		}	
public String getScriptStackTrace() 		{			if ( callstack == null )				return "<Unknown>";				String trace = "";			CallStack stack = callstack.copy();			while ( stack.depth() > 0 ) 			{				NameSpace ns = stack.pop();				SimpleNode node = ns.getNode();				if ( ns.isMethod )				{					trace = trace + "\nCalled from method: " + ns.getName();					if ( node != null )						trace += " : at Line: "+ node.getLineNumber() 							+ " : in file: "+ node.getSourceFile()							+ " : "+node.getText();				}			}				return trace;		}	
/**			@see #toString() for a full display of the information		*/		public String getMessage() { return message; }	
public void setMessage( String s ) { message = s; }	
/**			Prepend the message if it is non-null.		*/		protected void prependMessage( String s ) 		{ 			if ( s == null )				return;				if ( message == null )				message = s;			else				message = s + " : "+ message;		}	
public ExplicitFoldHandler()		{			super("explicit");		}	
/**		 * Returns the fold level of the specified line.		 * @param buffer The buffer in question		 * @param lineIndex The line index		 * @param seg A segment the fold handler can use to obtain any		 * text from the buffer, if necessary		 * @return The fold level of the specified line		 * @since jEdit 4.0pre1		 */		public int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg)		{			if(lineIndex == 0)				return 0;			else			{				int foldLevel = buffer.getFoldLevel(lineIndex - 1);					buffer.getLineText(lineIndex - 1,seg);					int offset = seg.offset;				int count = seg.count;					int openingBrackets = 0, closingBrackets = 0;				for(int i = 0; i < count; i++)				{					switch(seg.array[offset + i])					{					case '{':						closingBrackets = 0;						openingBrackets++;						if(openingBrackets == 3)						{							foldLevel++;							openingBrackets = 0;						}						break;					case '}':						openingBrackets = 0;						closingBrackets++;						if(closingBrackets == 3)						{							if(foldLevel > 0)								foldLevel--;							closingBrackets = 0;						}						break;					default:						closingBrackets = openingBrackets = 0;						break;					}				}					return foldLevel;			}		}	
/**		  * Creates an extended grid layout manager with the specified horizontal		  * and vertical gap, and the specified distance to the borders		  * of the parent container.		  * 		  * @param hgap The horizontal space between two columns ({@literal >=0})		  * @param vgap The vertical space between two rows ({@literal >=0})		  * @param distanceToBorders The distances to the borders of the parent container		  * @throws IllegalArgumentException if hgap {@literal < 0}		  * @throws IllegalArgumentException if vgap {@literal < 0}		  */		public ExtendedGridLayout(int hgap, int vgap, Insets distanceToBorders)		{			if (hgap < 0)			{				throw new IllegalArgumentException("hgap must be non-negative (" + hgap + ')');			}			if (vgap < 0)			{				throw new IllegalArgumentException("vgap must be non-negative (" + vgap + ')');			}			this.hgap = hgap;			this.vgap = vgap;			this.distanceToBorders = (Insets)distanceToBorders.clone();			comptable = new Hashtable<Component,ExtendedGridLayoutConstraints>();		}	
/**		  * Creates an extended grid layout manager with zero horizontal		  * and vertical gap, and zero distance to the borders		  * of the parent container.		  */		public ExtendedGridLayout()		{			this(0,0,new Insets(0,0,0,0));		}	
/**		  * If the layout manager uses a per-component string,		  * adds the component <code>component</code> to the layout,		  * associating it with the string specified by <code>name</code>.		  * 		  * @param name      The string to be associated with the component.		  *                  Has to be {@code null}, so that default constraints are used.		  * @param component The component to be added		  * @throws IllegalArgumentException if {@code name} is not {@code null}		  * @see #addLayoutComponent(java.awt.Component, java.lang.Object)		  */		public void addLayoutComponent(String name, Component component)		{			addLayoutComponent(component,name);		}	
/**		  * Adds the specified component to the layout, using the specified		  * constraints object.		  * 		  * @param component    The component to be added		  * @param constraints  Where/how the component is added to the layout.		  * @throws IllegalArgumentException if {@code constraints} is not an ExtendedGridLayoutConstraints object		  * @throws IllegalArgumentException if {@code constraints} is a placeholder		  * @throws IllegalArgumentException if {@code constraints} is not the right one for the component		  * @see ExtendedGridLayoutConstraints		  */		public void addLayoutComponent(Component component, Object constraints)		{			if (null == constraints)			{				constraints = new ExtendedGridLayoutConstraints(component);			}			if (constraints instanceof ExtendedGridLayoutConstraints)			{				ExtendedGridLayoutConstraints eglConstraints = (ExtendedGridLayoutConstraints)constraints;				if (eglConstraints.isPlaceholder())				{					throw new IllegalArgumentException("constraints must not be a placeholder");				}				else if (component != eglConstraints.getComponent())				{					throw new IllegalArgumentException("constraints is not the right one for this component");				}				comptable.put(component,eglConstraints);			}			else 			{				throw new IllegalArgumentException("constraints must not be an ExtendedGridLayoutConstraints object");			}		}	
/**		  * Retrieves the constraints for the specified {@code component}.		  * If {@code component} is not in the {@code ExtendedGridLayout},		  * a set of default {@code ExtendedGridLayoutConstraints} are returned.		  * 		  * @param component the {@code component} to be queried		  * @return the contraints for the specified {@code component}		  * @throws NullPointerException if {@code component} is {@code null}		  * @see ExtendedGridLayoutConstraints		  */		private ExtendedGridLayoutConstraints lookupConstraints(Component component)		{			if (null == component)			{				throw new NullPointerException("component must not be null");			}			ExtendedGridLayoutConstraints constraints = comptable.get(component);			if (null == constraints)			{				constraints = new ExtendedGridLayoutConstraints(component);				comptable.put(component,constraints);			}			return constraints;		}	
/**		  * Removes the specified component from the layout.		  * 		  * @param component The component to be removed		  */		public void removeLayoutComponent(Component component)		{			comptable.remove(component);		}	
/**		  * Returns the alignment along the X axis.  This specifies how		  * the component would like to be aligned relative to other		  * components.  The value should be a number between 0 and 1		  * where 0 represents alignment along the origin, 1 is aligned		  * the furthest away from the origin, 0.5 is centered, etc.		  * 		  * @param container The container for which the alignment should be returned		  * @return {@code java.awt.Component.CENTER_ALIGNMENT}		  */		public float getLayoutAlignmentX(Container container)		{			return CENTER_ALIGNMENT;		}	
/**		  * Returns the alignment along the Y axis. This specifies how		  * the component would like to be aligned relative to other		  * components. The value should be a number between 0 and 1		  * where 0 represents alignment along the origin, 1 is aligned		  * the furthest away from the origin, 0.5 is centered, etc.		  * 		  * @param container The container for which the alignment should be returned		  * @return {@code java.awt.Component.CENTER_ALIGNMENT}		  */		public float getLayoutAlignmentY(Container container)		{			return CENTER_ALIGNMENT;		}	
/**		  * Calculates the minimum size dimensions for the specified		  * container, given the components it contains.		  * 		  * @param parent The component to be laid out		  * @return The minimum size for the container		  * @see #maximumLayoutSize		  * @see #preferredLayoutSize		  */		public Dimension minimumLayoutSize(Container parent)		{			synchronized (parent.getTreeLock())			{				List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();				Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();				Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();				Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);				return getSize(parent,LayoutSize.MINIMUM,false,gridSize,gridRows,colspans,rowspans,new int[0][0]);			}		}	
/**		  * Calculates the preferred size dimensions for the specified		  * container, given the components it contains.		  * 		  * @param parent The container to be laid out		  * @return The preferred size for the container		  * @see #maximumLayoutSize		  * @see #minimumLayoutSize		  */		public Dimension preferredLayoutSize(Container parent)		{			synchronized (parent.getTreeLock())			{				List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();				Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();				Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();				Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);				return getSize(parent,LayoutSize.PREFERRED,false,gridSize,gridRows,colspans,rowspans,new int[0][0]);			}		}	
/**		  * Calculates the maximum size dimensions for the specified		  * container, given the components it contains.		  * 		  * @param parent The container to be laid out		  * @return The maximum size for the container		  * @see #minimumLayoutSize		  * @see #preferredLayoutSize		  */		public Dimension maximumLayoutSize(Container parent)		{			synchronized (parent.getTreeLock())			{				List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();				Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();				Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();				Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);				return getSize(parent,LayoutSize.MAXIMUM,false,gridSize,gridRows,colspans,rowspans,new int[0][0]);			}		}	
/**		  * Invalidates the layout, indicating that if the layout manager		  * has cached information it should be discarded.		  * 		  * @param container The container for which the cached information should be discarded		  */		public void invalidateLayout(Container container)		{		}	
/**		  * Lays out the specified container.		  * 		  * @param parent The container to be laid out 		  */		public void layoutContainer(Container parent)		{			synchronized (parent.getTreeLock())			{				// Pass 1: build the grid				List<List<ExtendedGridLayoutConstraints>> gridRows = new ArrayList<List<ExtendedGridLayoutConstraints>>();				Set<ExtendedGridLayoutConstraints> colspans = new HashSet<ExtendedGridLayoutConstraints>();				Set<ExtendedGridLayoutConstraints> rowspans = new HashSet<ExtendedGridLayoutConstraints>();				Dimension gridSize = buildGrid(parent,gridRows,colspans,rowspans);								// Pass 2: compute minimum, preferred and maximum column widths / row heights				int[][] layoutSizes = new int[6][];				Dimension preferredSize = getSize(parent,LayoutSize.PREFERRED,true,gridSize,gridRows,colspans,rowspans,layoutSizes);				int[] minimumColWidths = layoutSizes[0];				int[] minimumRowHeights = layoutSizes[1];				int[] preferredColWidths = layoutSizes[2];				int[] preferredRowHeights = layoutSizes[3];				int[] maximumColWidths = layoutSizes[4];				int[] maximumRowHeights = layoutSizes[5];								// Pass 3: redistribute free space				Dimension parentSize = parent.getSize();				Insets insets = parent.getInsets();				int freeWidth = parentSize.width						- insets.left - insets.right						- (gridSize.width - 1) * hgap						- distanceToBorders.left - distanceToBorders.right;				int freeHeight = parentSize.height						 - insets.top - insets.bottom						 - (gridSize.height - 1) * vgap						 - distanceToBorders.top - distanceToBorders.bottom;				redistributeSpace(preferredSize.width,						  freeWidth,						  0,gridSize.width,						  preferredColWidths,						  minimumColWidths,						  maximumColWidths);				redistributeSpace(preferredSize.height,						  freeHeight,						  0,gridSize.height,						  preferredRowHeights,						  minimumRowHeights,						  maximumRowHeights);								// Pass 4: layout components				for (int row=0, y=insets.top+distanceToBorders.top ; row<gridSize.height ; y+=preferredRowHeights[row]+vgap, row++)				{					List<ExtendedGridLayoutConstraints> gridRow = gridRows.get(row);					for (int col=0, x=insets.left+distanceToBorders.left ; col<gridSize.width; x+=preferredColWidths[col]+hgap, col++)					{						ExtendedGridLayoutConstraints cell = gridRow.get(col);						if ((null != cell) && (null != cell.getComponent()) && !cell.isPlaceholder())						{							Component component = cell.getComponent();							Dimension maxSize = component.getMaximumSize();							int fromCol = cell.getCol();							int colspan = cell.getEffectiveColspan();							int toCol = fromCol + colspan;							int width = 0;							for (int col2=fromCol ; col2<toCol ; col2++)							{								width += preferredColWidths[col2];							}							width += (colspan - 1) * hgap;							int fromRow = cell.getRow();							int rowspan = cell.getEffectiveRowspan();							int toRow = fromRow + rowspan;							int height = 0;							for (int row2=fromRow ; row2<toRow ; row2++)							{								height += preferredRowHeights[row2];							}							height += (rowspan - 1) * vgap;							int xCorrection = 0;							int yCorrection = 0;							if (width > maxSize.width)							{								xCorrection = (int)((width - maxSize.width) * component.getAlignmentX());								width = maxSize.width;							}							if (height > maxSize.height)							{								yCorrection = (int)((height-maxSize.height) * component.getAlignmentY());								height = maxSize.height;							}														component.setBounds(x + xCorrection, y + yCorrection, width, height);						}					}				}			}		}	
/**		  * Redistributs free space (positive or negative) to all available		  * columns or rows while taking elements maximum and minimum sizes into		  * account if possible.		  * 		  * @param totalSize             The cumulated preferred sizes of the components		  * @param freeSize              The available space for displaying components		  *                              without any gaps between components or between		  *                              the grid and the borders of the parent container		  * @param start                 The start in the arrays of rows or columns inclusive		  * @param stop                  The stop in the arrays of rows or columns exclusive		  * @param preferredElementSizes The preferredSizes of the rows or columns.		  *                              After invocation of this method, this array		  *                              holds the sizes that should be used		  * @param minimumElementSizes   The minimumSizes of the rows or columns		  * @param maximumElementSizes   The maximumSizes of the rows or columns		  */		private void redistributeSpace(int totalSize, int freeSize,					       int start, int stop,					       int[] preferredElementSizes,					       int[] minimumElementSizes,					       int[] maximumElementSizes)		{			if (totalSize != freeSize)			{				boolean grow = totalSize < freeSize;				// calculate the size that is available for redistribution				freeSize = (freeSize - totalSize) * (grow ? 1 : -1);				while (freeSize > 0)				{					// calculate the amount of elements that can be resized without violating					// the minimum and maximum sizes and their current cumulated size					int modifyableAmount = 0;					long modifySize = 0;					for (int i=start ; i<stop ; i++)					{						if ((grow && (preferredElementSizes[i] < maximumElementSizes[i])) ||						    (!grow && (preferredElementSizes[i] > minimumElementSizes[i])))						{							modifyableAmount++;							modifySize += preferredElementSizes[i];						}					}					boolean checkBounds = true;					// if all elements are at their minimum or maximum size, resize all elements					if (0 == modifyableAmount)					{						for (int i=start ; i<stop ; i++)						{							modifySize += preferredElementSizes[i];						}						checkBounds = false;						modifyableAmount = stop - start;					}					// to prevent an endless loop if the container gets resized to a very small amount					if (modifySize == 0)					{						break;					}					// resize the elements					if (freeSize < modifyableAmount)					{						for (int i=start ; i<stop ; i++)						{							if ((freeSize != 0) &&							    (!checkBounds ||							     (checkBounds &&							      (grow && (preferredElementSizes[i] < maximumElementSizes[i])) ||							      (!grow && (preferredElementSizes[i] > minimumElementSizes[i])))))							{								preferredElementSizes[i] += (grow ? 1 : -1);								if (0 > preferredElementSizes[i])								{									preferredElementSizes[i] = 0;								}								freeSize--;							}						}					}					else					{						long modifySizeAddition = 0;						double factor = (double)(freeSize + modifySize) / (double)modifySize;						for (int i=start ; i<stop ; i++)						{							long modifyableSize = (checkBounds ? (grow ? maximumElementSizes[i] - preferredElementSizes[i] : preferredElementSizes[i] - minimumElementSizes[i]) : Integer.MAX_VALUE - preferredElementSizes[i]);							long elementModifySize = Math.abs(Math.round((factor * preferredElementSizes[i]) - preferredElementSizes[i]));							if (elementModifySize <= modifyableSize)							{								preferredElementSizes[i] += (grow ? elementModifySize : -elementModifySize);								modifySizeAddition += (grow ? elementModifySize : -elementModifySize);								freeSize -= elementModifySize;							}							else							{								preferredElementSizes[i] += (grow ? modifyableSize : -modifyableSize);								modifySizeAddition += (grow ? modifyableSize : -modifyableSize);								freeSize -= modifyableSize;							}							if (0 > preferredElementSizes[i])							{								preferredElementSizes[i] = 0;							}						}						modifySize += modifySizeAddition;					}				}			}		}	
/**		  * Calculates the minimum, preferred or maximum size dimensions		  * for the specified container, given the components it contains.		  * 		  * @param parent       The container to be laid out		  * @param layoutSize   if {@code LayoutSize.MINIMUM} compute minimum layout size,		  *                     if {@code LayoutSize.PREFERRED} compute preferred layout size,		  *                     if {@code LayoutSize.MAXIMUM} compute maximum layout size,		  *                     if {@code fillRawSizes} is {@code true}, the layout size is computed		  *                     without applying gaps between components or between		  *                     the grid and the borders of the parent container		  * @param fillRawSizes Whether to fill the resultArrays with the raw		  *                     row heights and column widths and whether to apply		  *                     gaps between components or between		  *                     the grid and the borders of the parent container		  *                     when computing the layout size		  * @param gridSize     The amount of rows and columns in the grid		  * @param gridRows     The grid holding the constraints for the components		  * @param colspans     In this {@code Set} the constraints which are part		  *                     of a colspan are stored		  * @param rowspans     In this {@code Set} the constraints which are part		  *                     of a rowspan are stored		  * @param resultArrays If {@code fillRawSizes} is {@code true}, the first six arrays		  *                     get filled with the raw row heights and column widths.		  *                     resultArrays[0] = resultMinimumColWidths;		  *                     resultArrays[1] = resultMinimumRowHeights;		  *                     resultArrays[2] = resultPreferredColWidths;		  *                     resultArrays[3] = resultPreferredRowHeights;		  *                     resultArrays[4] = resultMaximumColWidths;		  *                     resultArrays[5] = resultMaximumRowHeights;		  * @return The minimum, preferred or maximum size dimensions for the specified container		  * @throws IllegalArgumentException If {@code fillRawSizes == true} and {@code resultArrays.length < 6}		  */		private Dimension getSize(Container parent, LayoutSize layoutSize, boolean fillRawSizes,					  Dimension gridSize, List<List<ExtendedGridLayoutConstraints>> gridRows,					  Set<ExtendedGridLayoutConstraints> colspans,					  Set<ExtendedGridLayoutConstraints> rowspans,					  int[][] resultArrays)		{			if (fillRawSizes && (resultArrays.length < 6))			{				throw new IllegalArgumentException("If fillRawSizes is true, resultArrays.length must be >= 6 (" + resultArrays.length + ')');			}			int[] minimumColWidths = new int[gridSize.width];			int[] minimumRowHeights = new int[gridSize.height];			int[] preferredColWidths = new int[gridSize.width];			int[] preferredRowHeights = new int[gridSize.height];			int[] maximumColWidths = new int[gridSize.width];			int[] maximumRowHeights = new int[gridSize.height];			Arrays.fill(minimumColWidths,0);			Arrays.fill(minimumRowHeights,0);			Arrays.fill(preferredColWidths,0);			Arrays.fill(preferredRowHeights,0);			Arrays.fill(maximumColWidths,0);			Arrays.fill(maximumRowHeights,0);						// get the maximum of the minimum sizes,			//     the maximum of the preferred sizes and			//     the minimum of the maximum sizes			// of all rows and columns, not taking			// rowspans and colspans into account			for (int row=0 ; row<gridSize.height ; row++)			{				List<ExtendedGridLayoutConstraints> gridRow = gridRows.get(row);				for (int col=0 ; col<gridSize.width ; col++)				{					ExtendedGridLayoutConstraints cell = gridRow.get(col);					if ((null != cell) && (null != cell.getComponent()))					{						Component component = cell.getComponent();						Dimension minimumSize = component.getMinimumSize();						Dimension preferredSize = component.getPreferredSize();						Dimension maximumSize = component.getMaximumSize();						if (!colspans.contains(cell))						{							minimumColWidths[col] = Math.max(minimumColWidths[col],minimumSize.width);							preferredColWidths[col] = Math.max(preferredColWidths[col],preferredSize.width);							maximumColWidths[col] = Math.max(maximumColWidths[col],maximumSize.width);						}						if (!rowspans.contains(cell))						{							minimumRowHeights[row] = Math.max(minimumRowHeights[row],minimumSize.height);							preferredRowHeights[row] = Math.max(preferredRowHeights[row],preferredSize.height);							maximumRowHeights[row] = Math.max(maximumRowHeights[row],maximumSize.height);						}					}				}			}						// correct cases where			// minimumColWidths[col] <= preferredColWidths[col] <= maximumColWidths[col]			// is not true by clipping to the minimumColWidths and maximumColWidths			for (int col=0 ; col<gridSize.width ; col++)			{				if (minimumColWidths[col] >= maximumColWidths[col])				{					maximumColWidths[col] = minimumColWidths[col];					preferredColWidths[col] = minimumColWidths[col];				}				else if (preferredColWidths[col] < minimumColWidths[col])				{					preferredColWidths[col] = minimumColWidths[col];				}				else if (preferredColWidths[col] > maximumColWidths[col])				{					preferredColWidths[col] = maximumColWidths[col];				}			}						// plug in the colspans and correct the minimum, preferred and			// maximum column widths the colspans are part of			for (ExtendedGridLayoutConstraints cell : colspans)			{				int fromCol = cell.getCol();				int colspan = cell.getEffectiveColspan();				int toCol = fromCol + colspan;				int currentMinimumColWidth = 0;				int currentPreferredColWidth = 0;				int currentMaximumColWidth = 0;				for (int col=fromCol ; col<toCol ; col++)				{					int minimumColWidth = minimumColWidths[col];					if ((Integer.MAX_VALUE-minimumColWidth) < currentMinimumColWidth)					{						currentMinimumColWidth = Integer.MAX_VALUE;					}					else					{						currentMinimumColWidth += minimumColWidth;					}					int preferredColWidth = preferredColWidths[col];					if ((Integer.MAX_VALUE-preferredColWidth) < currentPreferredColWidth)					{						currentPreferredColWidth = Integer.MAX_VALUE;					}					else					{						currentPreferredColWidth += preferredColWidth;					}					int maximumColWidth = maximumColWidths[col];					if ((Integer.MAX_VALUE-maximumColWidth) < currentMaximumColWidth)					{						currentMaximumColWidth = Integer.MAX_VALUE;					}					else					{						currentMaximumColWidth += maximumColWidth;					}				}				Component component = cell.getComponent();				int wantedMaximumColWidth = component.getMaximumSize().width - ((colspan - 1) * hgap);				if (currentMaximumColWidth < wantedMaximumColWidth)				{					redistributeSpace(currentMaximumColWidth,							  wantedMaximumColWidth,							  fromCol,toCol,							  maximumColWidths,							  maximumColWidths,							  maximumColWidths);				}				int wantedMinimumColWidth = component.getMinimumSize().width - ((colspan - 1) * hgap);				if (currentMinimumColWidth < wantedMinimumColWidth)				{					redistributeSpace(currentMinimumColWidth,							  wantedMinimumColWidth,							  fromCol,toCol,							  minimumColWidths,							  minimumColWidths,							  maximumColWidths);				}				int wantedPreferredColWidth = component.getPreferredSize().width - ((colspan - 1) * hgap);				if (currentPreferredColWidth < wantedPreferredColWidth)				{					redistributeSpace(currentPreferredColWidth,							  wantedPreferredColWidth,							  fromCol,toCol,							  preferredColWidths,							  minimumColWidths,							  maximumColWidths);				}			}						// correct cases where			// minimumColWidths[col] <= preferredColWidths[col] <= maximumColWidths[col]			// is not true by clipping to the minimumColWidths and maximumColWidths			for (int col=0 ; col<gridSize.width ; col++)			{				if (minimumColWidths[col] >= maximumColWidths[col])				{					maximumColWidths[col] = minimumColWidths[col];					preferredColWidths[col] = minimumColWidths[col];				}				else if (preferredColWidths[col] < minimumColWidths[col])				{					preferredColWidths[col] = minimumColWidths[col];				}				else if (preferredColWidths[col] > maximumColWidths[col])				{					preferredColWidths[col] = maximumColWidths[col];				}			}						// correct cases where			// minimumRowHeights[row] <= preferredRowHeights[row] <= maximumRowHeights[row]			// is not true by clipping to the minimumRowHeights and maximumRowHeights			for (int row=0 ; row<gridSize.height ; row++)			{				if (minimumRowHeights[row] >= maximumRowHeights[row])				{					maximumRowHeights[row] = minimumRowHeights[row];					preferredRowHeights[row] = minimumRowHeights[row];				}				else if (preferredRowHeights[row] < minimumRowHeights[row])				{					preferredRowHeights[row] = minimumRowHeights[row];				}				else if (preferredRowHeights[row] > maximumRowHeights[row])				{					preferredRowHeights[row] = maximumRowHeights[row];				}			}						// plug in the rowspans and correct the minimum, preferred and			// maximum row heights the rowspans are part of			for (ExtendedGridLayoutConstraints cell : rowspans)			{				int fromRow = cell.getRow();				int rowspan = cell.getEffectiveRowspan();				int toRow = fromRow + rowspan;				int currentMinimumRowHeight = 0;				int currentPreferredRowHeight = 0;				int currentMaximumRowHeight = 0;				for (int row=fromRow ; row<toRow ; row++)				{					int minimumRowHeight = minimumRowHeights[row];					if ((Integer.MAX_VALUE-minimumRowHeight) < currentMinimumRowHeight)					{						currentMinimumRowHeight = Integer.MAX_VALUE;					}					else					{						currentMinimumRowHeight += minimumRowHeight;					}					int preferredRowHeight = preferredRowHeights[row];					if ((Integer.MAX_VALUE-preferredRowHeight) < currentPreferredRowHeight)					{						currentPreferredRowHeight = Integer.MAX_VALUE;					}					else					{						currentPreferredRowHeight += preferredRowHeight;					}					int maximumRowHeight = maximumRowHeights[row];					if ((Integer.MAX_VALUE-maximumRowHeight) < currentMaximumRowHeight)					{						currentMaximumRowHeight = Integer.MAX_VALUE;					}					else					{						currentMaximumRowHeight += maximumRowHeight;					}				}				Component component = cell.getComponent();				int wantedMaximumRowHeight = component.getMaximumSize().height - ((rowspan - 1) * vgap);				if (currentMaximumRowHeight < wantedMaximumRowHeight)				{					redistributeSpace(currentMaximumRowHeight,							  wantedMaximumRowHeight,							  fromRow,toRow,							  maximumRowHeights,							  maximumRowHeights,							  maximumRowHeights);				}				int wantedMinimumRowHeight = component.getMinimumSize().height - ((rowspan - 1) * vgap);				if (currentMinimumRowHeight < wantedMinimumRowHeight)				{					redistributeSpace(currentMinimumRowHeight,							  wantedMinimumRowHeight,							  fromRow,toRow,							  minimumRowHeights,							  minimumRowHeights,							  maximumRowHeights);				}				int wantedPreferredRowHeight = component.getPreferredSize().height - ((rowspan - 1) * vgap);				if (currentPreferredRowHeight < wantedPreferredRowHeight)				{					redistributeSpace(currentPreferredRowHeight,							  wantedPreferredRowHeight,							  fromRow,toRow,							  preferredRowHeights,							  minimumRowHeights,							  maximumRowHeights);				}			}						// correct cases where			// minimumRowHeights[row] <= preferredRowHeights[row] <= maximumRowHeights[row]			// is not true by clipping to the minimumRowHeights and maximumRowHeights			for (int row=0 ; row<gridSize.height ; row++)			{				if (minimumRowHeights[row] >= maximumRowHeights[row])				{					maximumRowHeights[row] = minimumRowHeights[row];					preferredRowHeights[row] = minimumRowHeights[row];				}				else if (preferredRowHeights[row] < minimumRowHeights[row])				{					preferredRowHeights[row] = minimumRowHeights[row];				}				else if (preferredRowHeights[row] > maximumRowHeights[row])				{					preferredRowHeights[row] = maximumRowHeights[row];				}			}						// copies the computed sizes to the result arrays			if (fillRawSizes)			{				resultArrays[0] = minimumColWidths;				resultArrays[1] = minimumRowHeights;				resultArrays[2] = preferredColWidths;				resultArrays[3] = preferredRowHeights;				resultArrays[4] = maximumColWidths;				resultArrays[5] = maximumRowHeights;			}						// sums up the sizes for return value			int[] colWidths;			int[] rowHeights;			switch (layoutSize)			{				case MINIMUM:					colWidths = minimumColWidths;					rowHeights = minimumRowHeights;					break;								case PREFERRED:					colWidths = preferredColWidths;					rowHeights = preferredRowHeights;					break;								case MAXIMUM:					colWidths = maximumColWidths;					rowHeights = maximumRowHeights;					break;								default:					throw new InternalError("Missing case branch for LayoutSize: " + layoutSize);			}			long totalWidth = 0;			long totalHeight = 0;			for (int width : colWidths)			{				totalWidth += width;			}			for (int height : rowHeights)			{				totalHeight += height;			}						// add space between components or between			// componetns and the borders of the parent container			if (!fillRawSizes)			{				Insets insets = parent.getInsets();				totalWidth += insets.left + insets.right + ((gridSize.width - 1) * hgap) + distanceToBorders.left + distanceToBorders.right;				totalHeight += insets.top + insets.bottom + ((gridSize.height - 1) * vgap) + distanceToBorders.top + distanceToBorders.bottom;			}						// clip the size to Integer.MAX_VALUE if too big			if (totalWidth > Integer.MAX_VALUE)			{				totalWidth = Integer.MAX_VALUE;			}			if (totalHeight > Integer.MAX_VALUE)			{				totalHeight = Integer.MAX_VALUE;			}						return new Dimension((int)totalWidth,(int)totalHeight);		}	
/**		  * Builds up the grid for the specified container,		  * given the components it contains.		  * 		  * @param parent   The container to be laid out		  * @param gridRows In this {@code List<List>} the grid gets stored		  * @param colspans In this {@code Set} the constraints which are part		  *                 of a colspan get stored		  * @param rowspans In this {@code Set} the constraints which are part		  *                 of a rowspan get stored		  * @return The amount of rows and columns in the grid		  */		private Dimension buildGrid(Container parent, List<List<ExtendedGridLayoutConstraints>> gridRows,					    Set<ExtendedGridLayoutConstraints> colspans, Set<ExtendedGridLayoutConstraints> rowspans)		{			// put the parent's components in source rows			List<List<ExtendedGridLayoutConstraints>> rows = new ArrayList<List<ExtendedGridLayoutConstraints>>();			Component[] components = parent.getComponents();			for (Component component : components)			{				if (component.isVisible())				{					ExtendedGridLayoutConstraints constraints = lookupConstraints(component).getWorkCopy();					int rowNumber = constraints.getRow();					for (int i=rowNumber, c=rows.size() ; i>=c ; i--)					{						rows.add(new ArrayList<ExtendedGridLayoutConstraints>());					}					List<ExtendedGridLayoutConstraints> row = rows.get(rowNumber);					row.add(constraints);				}			}						// initialize the rowIterators, gridRowIterators and gridRows			List<Iterator<ExtendedGridLayoutConstraints>> rowIterators = new ArrayList<Iterator<ExtendedGridLayoutConstraints>>();			List<ListIterator<ExtendedGridLayoutConstraints>> gridRowIterators = new ArrayList<ListIterator<ExtendedGridLayoutConstraints>>();			boolean haveNext = false;			for (List<ExtendedGridLayoutConstraints> row : rows)			{				Iterator<ExtendedGridLayoutConstraints> rowIterator = row.iterator();				rowIterators.add(rowIterator);				if (rowIterator.hasNext())				{					haveNext = true;				}				List<ExtendedGridLayoutConstraints> gridRow = new ArrayList<ExtendedGridLayoutConstraints>();				gridRows.add(gridRow);				gridRowIterators.add(gridRow.listIterator());			}						// build the grid			int col = -1;			while (haveNext)			{				col++;				haveNext = false;				for (int row=0, c=gridRows.size() ; row<c ; row++)				{					Iterator<ExtendedGridLayoutConstraints> rowIterator = rowIterators.get(row);					ListIterator<ExtendedGridLayoutConstraints> gridRowIterator = gridRowIterators.get(row);										// look for a rowspan in the previous row					if (row > 0)					{						ExtendedGridLayoutConstraints rowspanSource = gridRows.get(row-1).get(col);						if (null != rowspanSource)						{							ExtendedGridLayoutConstraints rowspanPlaceholder = rowspanSource.getRowspanPlaceholder(true);							if (null != rowspanPlaceholder)							{								rowspans.add(rowspanSource);								gridRowIterator.add(rowspanPlaceholder);								if (null != rowspanPlaceholder.getColspanPlaceholder(false))								{									switch (rowspanPlaceholder.getColspan())									{										case REMAINDER:											break;																				default:											haveNext = true;									}								}								else if (rowIterator.hasNext())								{									haveNext = true;								}								continue;							}						}					}										// look for a colspan in the previous column					if (gridRowIterator.hasPrevious())					{						ExtendedGridLayoutConstraints colspanSource = gridRowIterator.previous();						gridRowIterator.next();						if (null != colspanSource)						{							ExtendedGridLayoutConstraints colspanPlaceholder = colspanSource.getColspanPlaceholder(true);							if (null != colspanPlaceholder)							{								colspans.add(colspanSource);								gridRowIterator.add(colspanPlaceholder);								if (null != colspanPlaceholder.getColspanPlaceholder(false))								{									switch (colspanPlaceholder.getColspan())									{										case REMAINDER:											break;																				default:											haveNext = true;									}								}								else if (rowIterator.hasNext())								{									haveNext = true;								}								continue;							}						}					}										// add a new element or null					if (rowIterator.hasNext())					{						ExtendedGridLayoutConstraints newConstraints = rowIterator.next();						newConstraints.setCol(col);						gridRowIterator.add(newConstraints);						if (null != newConstraints.getColspanPlaceholder(false))						{							switch (newConstraints.getColspan())							{								case REMAINDER:									break;																default:									haveNext = true;							}						}						else if (rowIterator.hasNext())						{							haveNext = true;						}					}					else					{						gridRowIterator.add(null);					}				}			}						// check the last gridRow for rowspans and probably add rows for these			haveNext = false;			int gridRowsSize = gridRows.size();			if (gridRowsSize > 0)			{				ListIterator<ExtendedGridLayoutConstraints> gridRowIterator = gridRows.get(gridRows.size()-1).listIterator();				while (gridRowIterator.hasNext())				{					ExtendedGridLayoutConstraints cell = gridRowIterator.next();					if ((null != cell) &&					    ((REMAINDER != cell.getRowspan()) &&					     (null != cell.getRowspanPlaceholder(false))))					{						haveNext = true;						break;					}				}				while (haveNext)				{					haveNext = false;					gridRowIterator = gridRows.get(gridRows.size()-1).listIterator();					List<ExtendedGridLayoutConstraints> gridRow = new ArrayList<ExtendedGridLayoutConstraints>();					gridRows.add(gridRow);					ListIterator<ExtendedGridLayoutConstraints> newGridRowIterator = gridRow.listIterator();					while (gridRowIterator.hasNext())					{						ExtendedGridLayoutConstraints cell = gridRowIterator.next();						if ((null != cell) &&						    (null != cell.getRowspanPlaceholder(false)))						{							rowspans.add(cell);							ExtendedGridLayoutConstraints rowspanPlaceholder = cell.getRowspanPlaceholder(true);							newGridRowIterator.add(rowspanPlaceholder);						}						else						{							newGridRowIterator.add(null);						}					}					gridRowIterator = gridRow.listIterator();					while (gridRowIterator.hasNext())					{						ExtendedGridLayoutConstraints cell = gridRowIterator.next();						if ((null != cell) &&						    ((REMAINDER != cell.getRowspan()) &&						     (null != cell.getRowspanPlaceholder(false))))						{							haveNext = true;							break;						}					}				}			}						return new Dimension(col+1,gridRows.size());		}	
/**		  * Returns a string representation of the object. In general, the		  * {@code toString} method returns a string that		  * "textually represents" this object. The result should		  * be a concise but informative representation that is easy for a		  * person to read.		  * 		  * @return  a string representation of the object.		  */		public String toString()		{			return getClass().getName() + "[hgap=" + hgap + ",vgap=" + vgap				+ ",distanceToBorders=" + distanceToBorders				+ ",comptable=" + comptable + "]";		}	
/**		  * Creates an {@code ExtendedGridLayoutConstraints} object with		  * all of its fields set to their default value. For further information		  * about the default values see		  * {@link #ExtendedGridLayoutConstraints(int, int, int, java.awt.Component)}.		  * 		  * @param component The {@code Component} this constraints object describes		  */		public ExtendedGridLayoutConstraints(Component component)		{			this(0,0,1,1,component,false,null);		}	
/**		  * Creates an {@code ExtendedGridLayoutConstraints} object with		  * all of its fields set to their default value		  * except of the row which is specified. For further information		  * about the default values see		  * {@link #ExtendedGridLayoutConstraints(int, int, int, java.awt.Component)}.		  * 		  * @param row       The row in which a component starts its display area. First row is 0		  * @param component The {@code Component} this constraints object d describes		  * @throws IllegalArgumentException If row {@literal < 0}		  */		public ExtendedGridLayoutConstraints(int row, Component component)		{			this(row,0,1,1,component,false,null);		}	
/**		  * Creates an {@code ExtendedGridLayoutConstraints} object with		  * all of its fields set to the passed-in arguments.		  * 		  * @param row       The row in which a component starts its display area.		  *                  First row is 0. Default value is 0.		  * @param colspan   The number of cells in a row for the component's display area.		  *                  Use {@code REMAINDER} to specify that the component's		  *                  display area will be from its grid position to the last		  *                  cell in the row. Default value is 1.		  * @param rowspan   The number of cells in a column for the component's display area.		  *                  Use {@code REMAINDER} to specify that the component's		  *                  display area will be from its grid position to the last		  *                  cell in the column. Default value is 1.		  * @param component The {@code Component} this constraints object describes		  * @throws IllegalArgumentException If row {@literal < 0}		  * @throws IllegalArgumentException If colspan {@literal < 1}		  * @throws IllegalArgumentException If rowspan {@literal < 1}		  */		public ExtendedGridLayoutConstraints(int row, int colspan, int rowspan, Component component)		{			this(row,0,colspan,rowspan,component,false,null);		}	
/**		  * Creates an {@code ExtendedGridLayoutConstraints} object with		  * all of its fields set to the passed-in arguments.		  * 		  * @param row             The row in which a component starts its display area.		  *                        First row is 0.		  * @param col             The col in which a component starts its display area.		  *                        First col is 0.		  * @param colspan         The number of cells in a row for the component's display area.		  *                        Use {@code REMAINDER} to specify that the component's		  *                        display area will be from its grid position to the last		  *                        cell in the row.		  * @param rowspan         The number of cells in a column for the component's display area.		  *                        Use {@code REMAINDER} to specify that the component's		  *                        display area will be from its grid position to the last		  *                        cell in the column.		  * @param component       The {@code Component} this constraints object describes		  * @param placeholder     If this constraints are used as placeholder to build the grid		  * @param mainConstraints The mainConstraints object for which this constraints		  *                        object is a placeholder		  * @throws IllegalArgumentException If row {@literal < 0}		  * @throws IllegalArgumentException If col {@literal < 0}		  * @throws IllegalArgumentException If colspan {@literal < 1}		  * @throws IllegalArgumentException If rowspan {@literal < 1}		  */		private ExtendedGridLayoutConstraints(int row, int col, int colspan, int rowspan, Component component, boolean placeholder, ExtendedGridLayoutConstraints mainConstraints)		{			if (row < 0)			{				throw new IllegalArgumentException("row must be non-negative (" + row + ')');			}			if (col < 0)			{				throw new IllegalArgumentException("col must be non-negative (" + col + ')');			}			if (colspan < 1)			{				throw new IllegalArgumentException("colspan must be at least 1 (" + colspan + ')');			}			if (rowspan < 1)			{				throw new IllegalArgumentException("rowspan must be at least 1 (" + rowspan + ')');			}			this.row = row;			this.col = col;			this.colspan = colspan;			effectiveColspan = 1;			this.rowspan = rowspan;			effectiveRowspan = 1;			this.component = component;			this.placeholder = placeholder;			this.mainConstraints = mainConstraints;		}	
/**		  * Creates an {@code ExtendedGridLayoutConstraints} object which can be		  * used as placeholder for building a grid with colspans.		  * 		  * @param forUsage If the returned object will be used in the grid		  *                 and therefor the effectiveColspan should be raised by one		  * @return The newly created {@code ExtendedGridLayoutConstraints}		  *         object or {@code null} if no colspan is applicable		  * @see #getRowspanPlaceholder(boolean)		  */		ExtendedGridLayoutConstraints getColspanPlaceholder(boolean forUsage)		{			if (1 == colspan)			{				return null;			}			ExtendedGridLayoutConstraints result = new ExtendedGridLayoutConstraints(row,col+1,colspan==REMAINDER ? REMAINDER : colspan-1,rowspan,component,true,null == mainConstraints ? this : mainConstraints);			if (forUsage && (result.mainConstraints.row == row))			{				result.mainConstraints.effectiveColspan++;			}			return result;		}	
/**		  * Creates an {@code ExtendedGridLayoutConstraints} object which can be		  * used as placeholder for building a grid with rowspans.		  * 		  * @param forUsage If the returned object will be used in the grid		  *                 and therefor the effectiveRowspan should be raised by one		  * @return The newly created {@code ExtendedGridLayoutConstraints}		  *         object or {@code null} if no rowspan is applicable		  * @see #getColspanPlaceholder(boolean)		  */		ExtendedGridLayoutConstraints getRowspanPlaceholder(boolean forUsage)		{			if (1 == rowspan)			{				return null;			}			ExtendedGridLayoutConstraints result = new ExtendedGridLayoutConstraints(row+1,col,colspan,rowspan==REMAINDER ? REMAINDER : rowspan-1,component,true,null == mainConstraints ? this : mainConstraints);			if (forUsage && (result.mainConstraints.col == col))			{				result.mainConstraints.effectiveRowspan++;			}			return result;		}	
/**		  * @return The row in which the component starts its display area.		  */		public int getRow()		{			return row;		}	
/**		  * @return The column in which the component starts its display area.		  */		public int getCol()		{			return col;		}	
/**		  * @param col The column in which the component starts its display area.		  */		void setCol(int col)		{			if (col < 0)			{				throw new IllegalArgumentException("col must be non-negative (" + col + ')');			}			this.col = col;		}	
/**		  * @return The number of cells in a row for the component's display area		  *         or {@code REMAINDER} if the component's display area will be		  *         from its grid position to the last cell in the row.		  */		public int getColspan()		{			return colspan;		}	
/**		  * @return The effective number of cells in a row for the component's display area.		  */		int getEffectiveColspan()		{			return null == mainConstraints ? effectiveColspan : mainConstraints.effectiveColspan;		}	
/**		  * @return The number of cells in a column for the component's display area		  *         or {@code REMAINDER} if the component's display area will be		  *         from its grid position to the last cell in the column.		  */		public int getRowspan()		{			return rowspan;		}	
/**		  * @return The effective number of cells in a column for the component's display area.		  */		int getEffectiveRowspan()		{			return null == mainConstraints ? effectiveRowspan : mainConstraints.effectiveRowspan;		}	
/**		  * @return The {@code Component} this constraints object describes		  */		Component getComponent()		{			return component;		}	
/**		  * @return Whether this constraints object is a placeholder or not		  */		public boolean isPlaceholder()		{			return placeholder;		}	
/**		  * @return A work copy if this constraints object. This is a flat copy		  *         which means that the reference to the component stays the same.		  *         The returned object could be used without modifying this		  *         constraints object.		  */		ExtendedGridLayoutConstraints getWorkCopy()		{			return new ExtendedGridLayoutConstraints(row,col,colspan,rowspan,component,placeholder,(null == mainConstraints ? null : mainConstraints.getWorkCopy()));		}	
/**		  * Indicates whether some other object is "equal to" this one.		  * <p>		  * The {@code equals} method implements an equivalence relation		  * on non-null object references:		  * <ul>		  * <li>It is <i>reflexive</i>: for any non-null reference value		  *     {@code x}, {@code x.equals(x)} returns		  *     {@code true}.		  * <li>It is <i>symmetric</i>: for any non-null reference values		  *     {@code x} and {@code y}, {@code x.equals(y)}		  *     returns {@code true} if and only if		  *     {@code y.equals(x)} returns {@code true}.		  * <li>It is <i>transitive</i>: for any non-null reference values		  *     {@code x}, {@code y}, and {@code z}, if		  *     {@code x.equals(y)} returns {@code true} and		  *     {@code y.equals(z)} returns {@code true}, then		  *     {@code x.equals(z)} returns {@code true}.		  * <li>It is <i>consistent</i>: for any non-null reference values		  *     {@code x} and {@code y}, multiple invocations of		  *     <tt>x.equals(y)</tt> consistently return {@code true}		  *     or consistently return {@code false}, provided no		  *     information used in {@code equals} comparisons on the		  *     objects is modified.		  * <li>For any non-null reference value {@code x},		  *     {@code x.equals(null)} returns {@code false}.		  * </ul>		  * <p>		  * The <tt>equals</tt> method for class		  * {@code ExtendedGridLayoutConstraints} returns {@code true}		  * if and only if the constraints objects describe the same {@code Component}		  * 		  * @param o the reference object with which to compare.		  * @return {@code true} if this object is the same as the o		  *         argument; {@code false} otherwise.		  * @see #hashCode()		  * @see <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Hashtable.html"><code>java.util.Hashtable</code></a>		  */		public boolean equals(Object o)		{			if ((o == null) ||			    (!(o instanceof ExtendedGridLayoutConstraints)))			{				return false;			}			if (component == null)			{				return ((ExtendedGridLayoutConstraints)o).component == null;			}			return component.equals(((ExtendedGridLayoutConstraints)o).component);		}	
/**		  * Returns a hash code value for the object. This method is		  * supported for the benefit of hashtables such as those provided by		  * {@code java.util.Hashtable}.		  * <p>		  * The general contract of {@code hashCode} is:		  * <ul>		  * <li>Whenever it is invoked on the same object more than once during		  *     an execution of a Java application, the <tt>hashCode</tt> method		  *     must consistently return the same integer, provided no information		  *     used in <tt>equals</tt> comparisons on the object is modified.		  *     This integer need not remain consistent from one execution of an		  *     application to another execution of the same application.		  * <li>If two objects are equal according to the <tt>equals(Object)</tt>		  *     method, then calling the {@code hashCode} method on each of		  *     the two objects must produce the same integer result.		  * <li>It is <em>not</em> required that if two objects are unequal		  *     according to the		  *     <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#equals(java.lang.Object)">{@code java.lang.Object#equals(java.lang.Object)}</a>		  *     method, then calling the <tt>hashCode</tt> method on each of the		  *     two objects must produce distinct integer results.  However, the		  *     programmer should be aware that producing distinct integer results		  *     for unequal objects may improve the performance of hashtables.		  * </ul>		  * 		  * @return a hash code value for this object.		  * @see #equals(java.lang.Object)		  * @see <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Hashtable.html"><code>java.util.Hashtable</code></a>		  */		public int hashCode()		{			if (null == component)			{				return 0;			}			return component.hashCode();		}	
/**		  * Returns a string representation of the object. In general, the		  * {@code toString} method returns a string that		  * "textually represents" this object. The result should		  * be a concise but informative representation that is easy for a		  * person to read.		  * 		  * @return  a string representation of the object.		  */		public String toString()		{			return getClass().getName() + "[row=" + row + ",col=" + col				+ ",colspan=" + colspan + ",effectiveColspan=" + effectiveColspan				+ ",rowspan=" + rowspan + ",effectiveRowspan=" + effectiveRowspan				+ ",placeholder=" + placeholder + ",component=" + component				+ ",mainConstraints=" + mainConstraints + "]";		}	
/**		 * Add an extension.		 * See {@link Gutter} and {@link TextAreaPainter} to know the layers		 *		 * @param layer the layer. It could be defined in Gutter or TextAreaPainter		 * @param ext the extension to add		 */		void addExtension(int layer, TextAreaExtension ext)		{			Entry entry = new Entry(layer,ext);				int i = 0;			for (Entry extension : extensions)			{				int _layer = extension.layer;				if (layer < _layer)				{					extensions.add(i, entry);					return;				}				i++;			}				extensions.add(entry);		}	
void removeExtension(TextAreaExtension ext)		{			Iterator<Entry> iter = extensions.iterator();			while(iter.hasNext())			{				if(iter.next().ext == ext)				{					iter.remove();					return;				}			}		}	
TextAreaExtension[] getExtensions()		{			TextAreaExtension[] retVal = new TextAreaExtension[				extensions.size()];			Iterator<Entry> iter = extensions.iterator();			int i = 0;			while(iter.hasNext())				retVal[i++] = iter.next().ext;				return retVal;		}	
void paintScreenLineRange(TextArea textArea, Graphics2D gfx,			int firstLine, int lastLine, int y, int lineHeight)		{			try			{				int[] physicalLines = new int[lastLine - firstLine + 1];				int[] start = new int[physicalLines.length];				int[] end = new int[physicalLines.length];					for(int i = 0; i < physicalLines.length; i++)				{					int screenLine = i + firstLine;					ChunkCache.LineInfo lineInfo = textArea						.chunkCache.getLineInfo(screenLine);						if(lineInfo.physicalLine == -1)						physicalLines[i] = -1;					else					{						physicalLines[i] = lineInfo.physicalLine;						start[i] = textArea.getScreenLineStartOffset(screenLine);						end[i] = textArea.getScreenLineEndOffset(screenLine);					}				}					paintScreenLineRange(gfx,firstLine,lastLine,physicalLines,					start,end,y,lineHeight);			}			catch(Exception e)			{				Log.log(Log.ERROR,this,"Error repainting line"					+ " range {" + firstLine + ','						+ lastLine + "}:");				Log.log(Log.ERROR,this,e);			}		}	
String getToolTipText(int x, int y)		{			for(int i = 0; i < extensions.size(); i++)			{				TextAreaExtension ext = extensions.get(i).ext;				String toolTip = ext.getToolTipText(x,y);				if(toolTip != null)					return toolTip;			}				return null;		}	
private void paintScreenLineRange(Graphics2D gfx, int firstLine,			int lastLine, int[] physicalLines, int[] start, int[] end,			int y, int lineHeight)		{			Iterator<Entry> iter = extensions.iterator();			while(iter.hasNext())			{				TextAreaExtension ext = iter.next().ext;				try				{					ext.paintScreenLineRange(gfx,firstLine,lastLine,						physicalLines,start,end,y,lineHeight);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,t);						// remove it so editor can continue					// functioning					iter.remove();				}			}		}	
Entry(int layer, TextAreaExtension ext)			{				this.layer = layer;				this.ext = ext;			}	
public ExternalNameSpace() 		{			this( null, "External Map Namespace", null );		}	
/**		*/	    public ExternalNameSpace( NameSpace parent, String name, Map externalMap ) 		{			super( parent, name );				if ( externalMap == null )				externalMap = new HashMap();							this.externalMap = externalMap;			}	
/**			Get the map view of this namespace.		*/		public Map getMap() { return externalMap; }	
/**			Set the external Map which to which this namespace synchronizes.			The previous external map is detached from this namespace.  Previous			map values are retained in the external map, but are removed from the			BeanShell namespace.		*/		public void setMap( Map map ) 		{ 			// Detach any existing namespace to preserve it, then clear this			// namespace and set the new one			this.externalMap = null; 			clear();			this.externalMap = map ; 		}	
/**		*/	    void setVariable( 			String name, Object value, boolean strictJava, boolean recurse ) 			throws UtilEvalError 		{			super.setVariable( name, value, strictJava, recurse );			putExternalMap( name, value );		}	
/**		*/		public void unsetVariable( String name )		{			super.unsetVariable( name );			externalMap.remove( name );		}	
/**		*/		public String [] getVariableNames() 		{			// union of the names in the internal namespace and external map			Set nameSet = new HashSet();			String [] nsNames = super.getVariableNames();			nameSet.addAll( Arrays.asList( nsNames ) );			nameSet.addAll( externalMap.keySet() );			return (String [])nameSet.toArray( new String[0] );		}	
/**		*/		/*			Notes: This implmenetation of getVariableImpl handles the following			cases:			1) var in map not in local scope - var was added through map			2) var in map and in local scope - var was added through namespace			3) var not in map but in local scope - var was removed via map			4) var not in map and not in local scope - non-existent var		*/	    protected Variable getVariableImpl( String name, boolean recurse ) 			throws UtilEvalError		{			// check the external map for the variable name			Object value = externalMap.get( name );				Variable var;			if ( value == null ) 			{				// The var is not in external map and it should therefore not be				// found in local scope (it may have been removed via the map).  				// Clear it prophalactically.				super.unsetVariable( name ); 					// Search parent for var if applicable.				var = super.getVariableImpl( name, recurse );			} else			{				// Var in external map may be found in local scope with type and				// modifier info.				Variable localVar = super.getVariableImpl( name, false );					// If not in local scope then it was added via the external map,				// we'll wrap it and pass it along.  Else we'll use the local				// version.				if ( localVar == null ) 					var = new Variable( name, (Class)null, value, (Modifiers)null );				else					var = localVar;			}				return var;	    }	
/**		*/		/*			Note: the meaning of getDeclaredVariables() is not entirely clear, but			the name (and current usage in class generation support) suggests that			untyped variables should not be inclueded.  Therefore we do not			currently have to add the external names here.		*/		public Variable [] getDeclaredVariables() 		{			return super.getDeclaredVariables();		}	
/**	    */	    public void	setTypedVariable(			String	name, Class type, Object value,	Modifiers modifiers )			throws UtilEvalError 		{			super.setTypedVariable( name, type, value, modifiers );			putExternalMap( name, value );	    }	
public void	setMethod( String name, BshMethod method )			throws UtilEvalError		{			super.setMethod( name, method );	    }	
public BshMethod getMethod( 			String name, Class [] sig, boolean declaredOnly ) 			throws UtilEvalError		{			return super.getMethod( name, sig, declaredOnly );	    }	
protected void getAllNamesAux( Vector vec ) 		{			super.getAllNamesAux( vec );		}	
/**			Clear all variables, methods, and imports from this namespace and clear			all values from the external map (via Map clear()).		*/		public void clear() 		{			super.clear();			externalMap.clear();		}	
/**			Place an unwrapped value in the external map.			BeanShell primitive types are represented by their object wrappers, so			it is not possible to differentiate between wrapper types and primitive			types via the external Map.		*/		protected void putExternalMap( String name, Object value ) 		{			if ( value instanceof Variable )				try {					value = unwrapVariable( (Variable)value );				} catch ( UtilEvalError ute ) {					// There should be no case for this.  unwrapVariable throws					// UtilEvalError in some cases where it holds an LHS or array					// index.					throw new InterpreterError("unexpected UtilEvalError");				}				if ( value instanceof Primitive )				value = Primitive.unwrap( (Primitive)value );				externalMap.put( name, value );		}	
public boolean updateEveryTime()		{			return false;		}	
public void update(JMenu menu)		{			final View view = GUIUtilities.getView(menu);				//{{{ ActionListeners			ActionListener fileListener = new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					jEdit.openFile(view,evt.getActionCommand());				}			};				ActionListener dirListener = new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					VFSBrowser.browseDirectory(view,						evt.getActionCommand());				}			}; //}}}				VFSFile[] favorites = FavoritesVFS.getFavorites();			if(favorites.length == 0)			{				JMenuItem mi = new JMenuItem(					jEdit.getProperty(					"vfs.browser.favorites"					+ ".no-favorites.label"));				mi.setEnabled(false);				menu.add(mi);			}			else			{				Arrays.sort(favorites,					new VFS.DirectoryEntryCompare(					jEdit.getBooleanProperty("vfs.browser.sortMixFilesAndDirs"),					jEdit.getBooleanProperty("vfs.browser.sortIgnoreCase")));				for(int i = 0; i < favorites.length; i++)				{					VFSFile favorite = favorites[i];					JMenuItem mi = new JMenuItem(						favorite.getPath());					mi.setIcon(FileCellRenderer						.getIconForFile(						favorite,false));					if(favorite.getType() == VFSFile.FILE)					{						mi.addActionListener(fileListener);					}					else					{						mi.addActionListener(dirListener);					}					menu.add(mi);				}			}		}	
public FavoritesVFS()		{			super("favorites",DELETE_CAP | LOW_LATENCY_CAP,				new String[] { EA_TYPE });				/* addToFavorites(), which is a static method			 * (for convinience) needs an instance of the			 * VFS to pass to VFSManager.sendVFSUpdate(),			 * hence this hack. */			instance = this;		}	
public String getParentOfPath(String path)		{			return PROTOCOL + ":";		}	
public VFSFile[] _listFiles(Object session, String url,			Component comp)		{			return getFavorites();		}	
public VFSFile _getFile(Object session, String path,			Component comp)		{			// does it matter that this doesn't set the type correctly?			return new Favorite(path,VFSFile.DIRECTORY);		}	
public boolean _delete(Object session, String path, Component comp)		{			synchronized(lock)			{				path = path.substring(PROTOCOL.length() + 1);					Iterator<Favorite> iter = favorites.iterator();				while(iter.hasNext())				{					if(iter.next().getPath().equals(path))					{						iter.remove();						VFSManager.sendVFSUpdate(this,PROTOCOL							+ ':',false);						EditBus.send(new DynamicMenuChanged(							"favorites"));						return true;					}				}			}				return false;		}	
public static void loadFavorites()		{			synchronized(lock)			{				favorites = new LinkedList<Favorite>();					String favorite;				int i = 0;				while((favorite = jEdit.getProperty("vfs.favorite." + i)) != null)				{					favorites.add(new Favorite(favorite,						jEdit.getIntegerProperty("vfs.favorite."						+ i + ".type",						VFSFile.DIRECTORY)));					i++;				}			}		}	
public static void addToFavorites(String path, int type)		{			synchronized(lock)			{				if(favorites == null)					loadFavorites();					for (Favorite favorite : favorites)				{					if (favorite.getPath().equals(path))						return;				}					favorites.add(new Favorite(path,type));					VFSManager.sendVFSUpdate(instance,PROTOCOL + ':',false);				EditBus.send(new DynamicMenuChanged("favorites"));			}		}	
public static void saveFavorites()		{			synchronized(lock)			{				if(favorites == null)					return;					int i = 0;				for (Favorite favorite : favorites)				{					jEdit.setProperty("vfs.favorite." + i,						favorite.getPath());					jEdit.setIntegerProperty("vfs.favorite." + i						+ ".type", favorite.getType());						i++;				}				jEdit.unsetProperty("vfs.favorite." + favorites.size());				jEdit.unsetProperty("vfs.favorite." + favorites.size()					+ ".type");			}		}	
public static VFSFile[] getFavorites()		{			synchronized(lock)			{				if(favorites == null)					loadFavorites();					return favorites.toArray(					new VFSFile[favorites.size()]);			}		}	
Favorite(String path, int type)			{				super(path,path,PROTOCOL + ':' + path,type,0,false);			}	
public String getExtendedAttribute(String name)			{				if(name.equals(EA_TYPE))					return super.getExtendedAttribute(name);				else				{					// don't want it to show "0 bytes" for size,					// etc.					return null;				}			}	
public FileCellRenderer()		{			plainFont = UIManager.getFont("Tree.font");			if(plainFont == null)				plainFont = jEdit.getFontProperty("metal.secondary.font");			boldFont = plainFont.deriveFont(Font.BOLD);		}	
public Component getTableCellRendererComponent(JTable table,			Object value, boolean isSelected, boolean hasFocus, 			int row, int column)		{			super.getTableCellRendererComponent(table,value,isSelected,				hasFocus,row,column);				if(value instanceof VFSDirectoryEntryTableModel.Entry)			{				VFSDirectoryEntryTableModel.Entry entry =					(VFSDirectoryEntryTableModel.Entry)value;				VFSFile file = entry.dirEntry;					setFont(file.getType() == VFSFile.FILE					? plainFont : boldFont);					this.isSelected = isSelected;				this.file = file;					if(column == 0)				{					// while its broken to have a null					// symlinkPath, some older plugins					// might...					String path;					if(file.getSymlinkPath() == null)						path = file.getPath();					else						path = file.getSymlinkPath();					openBuffer = jEdit._getBuffer(path) != null;						setIcon(showIcons						? getIconForFile(file,entry.expanded,						openBuffer) : null);					setText(file.getName());						int state;					if(file.getType() == VFSFile.FILE)						state = ExpansionToggleBorder.STATE_NONE;					else if(entry.expanded)						state = ExpansionToggleBorder.STATE_EXPANDED;					else						state = ExpansionToggleBorder.STATE_COLLAPSED;						setBorder(new ExpansionToggleBorder(						state,entry.level));				}				else				{					VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)table.getModel();					String extAttr = model.getExtendedAttribute(column);						openBuffer = false;					setIcon(null);					setText(file.getExtendedAttribute(extAttr));					setBorder(new EmptyBorder(1,1,1,1));				}			}				return this;		}	
public void paintComponent(Graphics g)		{			if(!isSelected)			{				Color color = file.getColor();					setForeground(color == null					? UIManager.getColor("Tree.foreground")					: color);			}				super.paintComponent(g);				if(openBuffer)			{				Font font = getFont();					FontMetrics fm = getFontMetrics(font);				int x, y;				if(getIcon() == null)				{					x = 0;					y = fm.getAscent() + 2;				}				else				{					x = getIcon().getIconWidth() + getIconTextGap();					y = Math.max(fm.getAscent() + 2,16);				}					Insets border = getBorder().getBorderInsets(this);				x += border.left;					g.setColor(getForeground());				g.drawLine(x,y,x + fm.stringWidth(getText()),y);			}		}	
/**		 * @since jEdit 4.3pre2		 */		public static Icon getIconForFile(VFSFile file,			boolean expanded)		{			return getIconForFile(file,expanded,				jEdit._getBuffer(file.getSymlinkPath()) != null);		}	
public static Icon getIconForFile(VFSFile file,			boolean expanded, boolean openBuffer)		{			if (defaultIcons)				return file.getDefaultIcon(expanded, openBuffer);			return file.getIcon(expanded, openBuffer);		}	
void propertiesChanged()		{			showIcons = jEdit.getBooleanProperty("vfs.browser.showIcons");			defaultIcons = jEdit.getBooleanProperty("vfs.browser.useDefaultIcons");		}	
int getEntryWidth(VFSDirectoryEntryTableModel.Entry entry,			Font font, FontRenderContext fontRenderContext)		{			String name = entry.dirEntry.getName();			int width = (int)font.getStringBounds(name,fontRenderContext)				.getWidth();			width += ExpansionToggleBorder.ICON_WIDTH				+ entry.level * ExpansionToggleBorder.LEVEL_WIDTH				+ 3;			if(showIcons)			{				width += fileIcon.getIconWidth();				width += getIconTextGap();			}			return width;		}	
ExpansionToggleBorder(int state, int level)			{				this.state = state;				this.level = level;			}	
public void paintBorder(Component c, Graphics g,				int x, int y, int width, int height)			{				// paint the opposite icon of what the state is				switch(state)				{				case STATE_COLLAPSED:					EXPAND_ICON.paintIcon(c,g,						x + level * LEVEL_WIDTH + 2,						y + (height - EXPAND_ICON.getIconHeight()) / 2);					break;				case STATE_EXPANDED:					COLLAPSE_ICON.paintIcon(c,g,						x + level * LEVEL_WIDTH + 2,						y + (height - COLLAPSE_ICON.getIconHeight()) / 2);					break;				}			}	
public Insets getBorderInsets(Component c)			{				return new Insets(1,level * LEVEL_WIDTH					+ ICON_WIDTH + 4,1,1);			}	
public boolean isBorderOpaque()			{				return false;			}	
public static boolean isExpansionToggle(int level, int x)			{				return (x >= level * LEVEL_WIDTH)					&& (x <= level * LEVEL_WIDTH + ICON_WIDTH);			}	
/**		 * The FilePropertiesDialog's constructor		 * @param view The view		 * @param browser The VFSBrowser		 */		public FilePropertiesDialog(View view, VFSBrowser browser, VFSFile[] files)		{			super(view,jEdit.getProperty("vfs.browser.properties.title"),true);			GUIUtilities.loadGeometry(this,"propdialog");				this.browser = browser;				if (files.length > 0)				selectedFiles = files;			else				selectedFiles = browser.getSelectedFiles();			local = (LocalFile) selectedFiles[0];			createAndShowGUI();		}	
public void addComponentsToPane()		{			JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,5,0,5));			setContentPane(content);				if (selectedFiles.length == 1)			{				content.add(BorderLayout.NORTH, createNorthPanel());				content.add(BorderLayout.CENTER, createCenterPanel());				content.add(BorderLayout.SOUTH, createSouthPanel());			}			else if(selectedFiles.length > 1)			{				content.add(BorderLayout.NORTH, createNorthPanelAll());				content.add(BorderLayout.CENTER, createCenterPanelAll());				content.add(BorderLayout.SOUTH, createSouthPanelAll());			}		}	
public JPanel createNorthPanelAll()		{			JPanel northPanel = new JPanel(new BorderLayout());				infoIcon = new JLabel();			infoIcon.setIcon(UIManager.getIcon("OptionPane.informationIcon"));			northPanel.add(BorderLayout.WEST, infoIcon);				int filesCounter = 0;			int directoriesCounter = 0;			for(int i=0;i<selectedFiles.length;i++)			{				if(selectedFiles[i].getType() == VFSFile.DIRECTORY)				{					directoriesCounter++;				}				else if(selectedFiles[i].getType() == VFSFile.FILE)				{					filesCounter++;				}			}			JPanel nameField = new JPanel();			nameField.add(new JLabel(jEdit.getProperty("fileprop.selectedFiles")+": "+filesCounter+", "+								jEdit.getProperty("fileprop.selectedDirectories")+": "+directoriesCounter));				northPanel.add(BorderLayout.CENTER, nameField);			northPanel.add(BorderLayout.SOUTH, new JPanel());				return northPanel;		}	
public JPanel createCenterPanelAll()		{			long filesSize = 0L;			JPanel centerPanel = new JPanel(new BorderLayout());				for (int i=0;i<selectedFiles.length;i++)			{				if(selectedFiles[i].getType() == VFSFile.DIRECTORY)				{					File ioFile = new File(selectedFiles[i].getPath());					filesSize += IOUtilities.fileLength(ioFile);				}				else if(selectedFiles[i].getType() == VFSFile.FILE)				{					filesSize += selectedFiles[i].getLength();				}			}				JPanel propField = new JPanel();			propField.setLayout(new GridLayout(2, 1));			String path = local.getPath();			if(OperatingSystem.isWindows() || OperatingSystem.isWindows9x() || OperatingSystem.isWindowsNT())			{				path = path.substring(0, path.lastIndexOf(92)); // 92 = '\'			}			else			{				path = path.substring(0, path.lastIndexOf('/'));			}			propField.add(new JLabel(jEdit.getProperty("fileprop.path")+": "+path));			propField.add(new JLabel(jEdit.getProperty("fileprop.size")+": "+MiscUtilities.formatFileSize(filesSize)));			Border etch = BorderFactory.createEtchedBorder();			propField.setBorder(BorderFactory.createTitledBorder(etch, jEdit.getProperty("fileprop.properties")));			centerPanel.add(BorderLayout.CENTER, propField);				return centerPanel;		}	
public JPanel createSouthPanelAll()		{			ButtonActionHandler actionHandler = new ButtonActionHandler();			JPanel southPanel = new JPanel(new BorderLayout());				JPanel buttonsField = new JPanel();			okButton = new JButton(jEdit.getProperty("fileprop.okBtn"));			buttonsField.add(okButton);			okButton.addActionListener(actionHandler);			cancelButton = new JButton(jEdit.getProperty("fileprop.cancelBtn"));			buttonsField.add(cancelButton);			cancelButton.addActionListener(actionHandler);				southPanel.add(BorderLayout.EAST, buttonsField);				return southPanel;		}	
public JPanel createNorthPanel()		{			JPanel northPanel = new JPanel(new BorderLayout());				infoIcon = new JLabel();			infoIcon.setIcon(UIManager.getIcon("OptionPane.informationIcon"));			northPanel.add(BorderLayout.WEST, infoIcon);				JPanel nameField = new JPanel();			nameField.add(new JLabel(jEdit.getProperty("fileprop.name")+": "));			nameTextField = new JTextField(local.getName(), 20);			nameField.add(nameTextField);			northPanel.add(BorderLayout.CENTER, nameField);			northPanel.add(BorderLayout.SOUTH, new JPanel());				return northPanel;		}	
public JPanel createCenterPanel()		{			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm");				JPanel centerPanel = new JPanel(new BorderLayout());				JPanel propField = new JPanel();			propField.setLayout(new GridLayout(4, 1));			propField.add(new JLabel(jEdit.getProperty("fileprop.name")+": "+local.getName()));			propField.add(new JLabel(jEdit.getProperty("fileprop.path")+": "+local.getPath()));			propField.add(new JLabel(jEdit.getProperty("fileprop.lastmod")+": "+sdf.format(new Date(local.getModified()))));			if(local.getType() == VFSFile.DIRECTORY)			{				File ioFile = new File(local.getPath());				propField.add(new JLabel(jEdit.getProperty("fileprop.size")+": "+MiscUtilities.formatFileSize(IOUtilities.fileLength(ioFile))));			}			else			{				propField.add(new JLabel(jEdit.getProperty("fileprop.size")+": "+MiscUtilities.formatFileSize(local.getLength())));			}			Border etch = BorderFactory.createEtchedBorder();			propField.setBorder(BorderFactory.createTitledBorder(etch, jEdit.getProperty("fileprop.properties")));			centerPanel.add(BorderLayout.CENTER, propField);				JPanel attributeField = new JPanel();			attributeField.setLayout(new GridLayout(1, 2));			readable = new JCheckBox(jEdit.getProperty("fileprop.readable"));			readable.setSelected(local.isReadable());			readable.setEnabled(false);			attributeField.add(readable);				write = new JCheckBox(jEdit.getProperty("fileprop.writeable"));			write.setSelected(local.isWriteable());			write.setEnabled(false);			attributeField.add(write);			attributeField.setBorder(BorderFactory.createTitledBorder(etch, jEdit.getProperty("fileprop.attribute")));			centerPanel.add(BorderLayout.SOUTH, attributeField);				return centerPanel;		}	
public JPanel createSouthPanel()		{			ButtonActionHandler actionHandler = new ButtonActionHandler();			JPanel southPanel = new JPanel(new BorderLayout());				JPanel buttonsField = new JPanel();			okButton = new JButton(jEdit.getProperty("fileprop.okBtn"));			buttonsField.add(okButton);			okButton.addActionListener(actionHandler);			cancelButton = new JButton(jEdit.getProperty("fileprop.cancelBtn"));			buttonsField.add(cancelButton);			cancelButton.addActionListener(actionHandler);				southPanel.add(BorderLayout.EAST, buttonsField);				return southPanel;		}	
@Override		public void ok()		{			if(nameTextField != null)			{				browser.rename(browser.getSelectedFiles()[0].getPath(), nameTextField.getText());			}				GUIUtilities.saveGeometry(this,"propdialog");			setVisible(false);		}	
@Override		public void cancel()		{			GUIUtilities.saveGeometry(this,"propdialog");			setVisible(false);		}	
private void createAndShowGUI()		{			addComponentsToPane();			pack();				setDefaultCloseOperation(DISPOSE_ON_CLOSE);			setFocusable(true);			toFront();			requestFocus();			setResizable(false);			setVisible(true);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();						if(source == okButton)				{					ok();				}				else if(source == cancelButton)				{					cancel();				}			}	
public FileRootsVFS()		{			super("roots",LOW_LATENCY_CAP | BROWSE_CAP, new String[] {				EA_TYPE });		}	
public String getParentOfPath(String path)		{			return PROTOCOL + ':';		}	
public VFSFile[] _listFiles(Object session, String url,			Component comp)		{			File[] roots = listRoots();				if(roots == null)				return null;				VFSFile[] rootDE = new VFSFile[roots.length];			for(int i = 0; i < roots.length; i++)				rootDE[i] = new Root(roots[i]);				return rootDE;		}	
public VFSFile _getFile(Object session, String path,			Component comp)		{			return new Root(new File(path));		}	
private static File[] listRoots()		{			if (OperatingSystem.isMacOS())			{				// Nasty hardcoded values				File[] volumes = new File("/Volumes").listFiles();				LinkedList<File> roots = new LinkedList<File>();					roots.add(new File("/"));					for (int i=0; i<volumes.length; i++)				{					// Make sure people don't do stupid things like putting files in /Volumes					if (volumes[i].isDirectory())						roots.add(volumes[i]);				}					return roots.toArray(new File[roots.size()]);			}			else			{				File[] roots = File.listRoots();				File[] desktop = fsView.getRoots();					if(desktop == null)					return roots;					File[] rootsPlus = new File[roots.length + desktop.length];				System.arraycopy(desktop, 0, rootsPlus, 0, desktop.length);				System.arraycopy(roots, 0, rootsPlus, 1, roots.length);				return rootsPlus;			}		}	
Root(File file)			{				// REMIND: calling isDirectory() on a floppy drive				// displays stupid I/O error dialog box on Windows					String path = file.getPath();				setPath(path);				setDeletePath(path);				setSymlinkPath(path);					if(fsView.isFloppyDrive(file))				{					setType(VFSFile.FILESYSTEM);					setName(path);				}				else if(fsView.isDrive(file))				{					setType(VFSFile.FILESYSTEM);					setName(path + ' '						+ fsView.getSystemDisplayName(file));				}				else if(file.isDirectory())				{					if(fsView.isFileSystemRoot(file))						setType(VFSFile.DIRECTORY);					else						setType(VFSFile.FILESYSTEM);						if(OperatingSystem.isMacOS())						setName(MiscUtilities.getFileName(path));					else						setName(path);				}				else					setType(VFSFile.FILE);			}	
public String getExtendedAttribute(String name)			{				if(name.equals(EA_TYPE))					return super.getExtendedAttribute(name);				else				{					// don't want it to show "0 bytes" for size,					// etc.					return null;				}			}	
public FilesChangedDialog(View view, int[] states,			boolean alreadyReloaded)		{			super(view,jEdit.getProperty("files-changed.title"),false);				this.view = view;				JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				Box iconBox = new Box(BoxLayout.Y_AXIS);			iconBox.add(new JLabel(UIManager.getIcon("OptionPane.warningIcon")));			iconBox.add(Box.createGlue());			content.add(BorderLayout.WEST,iconBox);				JPanel centerPanel = new JPanel(new BorderLayout());				JLabel label = new JLabel(jEdit.getProperty("files-changed.caption"));			label.setBorder(new EmptyBorder(0,0,6,0));			centerPanel.add(BorderLayout.NORTH,label);				DefaultMutableTreeNode deleted = new DefaultMutableTreeNode(				jEdit.getProperty("files-changed.deleted"),true);			DefaultMutableTreeNode changed = new DefaultMutableTreeNode(				jEdit.getProperty("files-changed.changed"				+ (alreadyReloaded ? "-auto" : "")),true);			DefaultMutableTreeNode changedDirty = new DefaultMutableTreeNode(				jEdit.getProperty("files-changed.changed-dirty"				+ (alreadyReloaded ? "-auto" : "")),true);			Buffer[] buffers = jEdit.getBuffers();			for(int i = 0; i < states.length; i++)			{				Buffer buffer = buffers[i];				DefaultMutableTreeNode addTo;				switch(states[i])				{				case Buffer.FILE_DELETED:					addTo = deleted;					break;				case Buffer.FILE_CHANGED:					addTo = buffer.isDirty() ? changedDirty : changed;					break;				default:					addTo = null;					break;				}					if(addTo != null)				{					addTo.add(new DefaultMutableTreeNode(						buffer.getPath()));				}			}				root = new DefaultMutableTreeNode("",true);			if(deleted.getChildCount() != 0)			{				root.add(deleted);			}			if(changed.getChildCount() != 0)			{				root.add(changed);			}			if(changedDirty.getChildCount() != 0)			{				root.add(changedDirty);			}				bufferTreeModel = new DefaultTreeModel(root);			bufferTree = new JTree(bufferTreeModel);			bufferTree.setRootVisible(false);			bufferTree.setVisibleRowCount(10);			bufferTree.setCellRenderer(new Renderer());			bufferTree.getSelectionModel().addTreeSelectionListener(new TreeHandler());			bufferTree.getSelectionModel().setSelectionMode(				TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);				centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferTree));				content.add(BorderLayout.CENTER,centerPanel);				Box buttons = new Box(BoxLayout.X_AXIS);			buttons.add(Box.createGlue());				if(!alreadyReloaded)			{				selectAll = new JButton(jEdit.getProperty(					"files-changed.select-all"));				selectAll.setMnemonic(jEdit.getProperty(					"files-changed.select-all.mnemonic").charAt(0));				buttons.add(selectAll);				selectAll.addActionListener(new ActionHandler());					buttons.add(Box.createHorizontalStrut(12));					reload = new JButton(jEdit.getProperty(					"files-changed.reload"));				reload.setMnemonic(jEdit.getProperty(					"files-changed.reload.mnemonic").charAt(0));				buttons.add(reload);				reload.addActionListener(new ActionHandler());					buttons.add(Box.createHorizontalStrut(12));					ignore = new JButton(jEdit.getProperty("files-changed.ignore"));				ignore.setMnemonic(jEdit.getProperty(					"files-changed.ignore.mnemonic").charAt(0));				buttons.add(ignore);				ignore.addActionListener(new ActionHandler());					buttons.add(Box.createHorizontalStrut(12));			}				close = new JButton(jEdit.getProperty("common.close"));			getRootPane().setDefaultButton(close);			buttons.add(close);			close.addActionListener(new ActionHandler());				buttons.add(Box.createGlue());				content.add(BorderLayout.SOUTH,buttons);				bufferTree.expandPath(new TreePath(				new Object[] {					root,					deleted				}));			bufferTree.expandPath(new TreePath(				new Object[] {					root,					changed				}));			bufferTree.expandPath(new TreePath(				new Object[] {					root,					changedDirty				}));				GUIUtilities.requestFocus(this,bufferTree);				updateEnabled();				pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public void ok()		{			dispose();		}	
public void cancel()		{			dispose();		}	
private void updateEnabled()		{			TreePath[] paths = bufferTree				.getSelectionPaths();			boolean enabled = false;			if(paths != null)			{				for(int i = 0; i < paths.length; i++)				{					Object[] path = paths[i].getPath();					if(path.length == 3)						enabled = true;				}			}				if(reload != null)				reload.setEnabled(enabled);				if (ignore != null)				ignore.setEnabled(enabled);		}	
private void selectAll()		{			selectAllInProgress = true;				TreeNode[] path = new TreeNode[3];			path[0] = root;			for(int i = 0; i < root.getChildCount(); i++)			{				DefaultMutableTreeNode node =					(DefaultMutableTreeNode)					root.getChildAt(i);				path[1] = node;				for(int j = 0; j < node.getChildCount(); j++)				{					DefaultMutableTreeNode node2 =						(DefaultMutableTreeNode)						node.getChildAt(j);					path[2] = node2;					bufferTree.getSelectionModel()						.addSelectionPath(						new TreePath(path));				}			}				selectAllInProgress = false;				updateEnabled();		}	
private void action(String action)		{			TreePath[] paths = bufferTree				.getSelectionPaths();			if(paths == null || paths.length == 0)				return;				int row = bufferTree.getRowForPath(paths[0]);				for(int i = 0; i < paths.length; i++)			{				TreePath path = paths[i];					// is it a header?				if(path.getPathCount() == 2)					continue;					DefaultMutableTreeNode node = (DefaultMutableTreeNode)					path.getLastPathComponent();				if(!(node.getUserObject() instanceof String))				{					return;				}					Buffer buffer = jEdit.getBuffer(					(String)node.getUserObject());				if(buffer == null)					return;					if ("RELOAD".equals(action))					buffer.reload(view);				else				{					buffer.setAutoReload(false);					buffer.setAutoReloadDialog(false);				}					DefaultMutableTreeNode parent =					(DefaultMutableTreeNode)					node.getParent();				parent.remove(node);			}				bufferTreeModel.reload(root);				// we expand those that are non-empty, and			// remove those that are empty			TreeNode[] nodes = { root, null };				// remove empty category branches			for(int j = 0; j < root.getChildCount(); j++)			{				DefaultMutableTreeNode node					= (DefaultMutableTreeNode)					root.getChildAt(j);				if(root.getChildAt(j)					.getChildCount() == 0)				{					root.remove(j);					j--;				}				else				{					nodes[1] = node;					bufferTree.expandPath(						new TreePath(nodes));				}			}				if(root.getChildCount() == 0)				dispose();			else			{				if(row >= bufferTree.getRowCount())					row = bufferTree.getRowCount() - 1;				TreePath path = bufferTree.getPathForRow(row);				if(path.getPathCount() == 2)				{					// selected a header; skip to the next row					bufferTree.setSelectionRow(row + 1);				}				else					bufferTree.setSelectionPath(path);			}		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == selectAll)					selectAll();				else if(source == reload)					action("RELOAD");				else if(source == close)					dispose();				else if (source == ignore)					action("IGNORE");			}	
public void valueChanged(TreeSelectionEvent evt)			{				if(selectAllInProgress)					return;					updateEnabled();					TreePath[] paths = bufferTree					.getSelectionPaths();				if(paths == null || paths.length == 0)					return;				TreePath path = paths[paths.length - 1];				DefaultMutableTreeNode node = (DefaultMutableTreeNode)					path.getLastPathComponent();				if(node.getUserObject() instanceof String)				{					Buffer buffer = jEdit.getBuffer(						(String)node.getUserObject());					if(buffer != null)						view.showBuffer(buffer);				}			}	
Renderer()			{				entryFont = UIManager.getFont("Tree.font");				if(entryFont == null)					entryFont = jEdit.getFontProperty("metal.secondary.font");				groupFont = entryFont.deriveFont(Font.BOLD);			}	
public Component getTreeCellRendererComponent(JTree tree,				Object value, boolean selected, boolean expanded,				boolean leaf, int row, boolean hasFocus)			{				super.getTreeCellRendererComponent(tree,value,					selected,expanded,leaf,row,hasFocus);					DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;					if(node.getParent() == tree.getModel().getRoot())					setFont(groupFont);				else					setFont(entryFont);					setIcon(null);					return this;			}	
public FileVFS()		{			super("file",READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP				| RENAME_CAP | MKDIR_CAP | LOW_LATENCY_CAP				| (OperatingSystem.isCaseInsensitiveFS()				? CASE_INSENSITIVE_CAP : 0),				new String[] { EA_TYPE, EA_SIZE, EA_STATUS,				EA_MODIFIED });		}	
@Override		public String getParentOfPath(String path)		{			if(OperatingSystem.isDOSDerived())			{				if(path.length() == 2 && path.charAt(1) == ':')					return FileRootsVFS.PROTOCOL + ':';				else if(path.length() == 3 && path.endsWith(":\\"))					return FileRootsVFS.PROTOCOL + ':';				else if(path.startsWith("\\\\") && path.indexOf('\\',2) == -1)					return path;			}				return super.getParentOfPath(path);		}	
@Override		public String constructPath(String parent, String path)		{			if(parent.endsWith(File.separator)				|| parent.endsWith("/"))				return parent + path;			else				return parent + File.separator + path;		}	
@Override		public char getFileSeparator()		{			return File.separatorChar;		}	
/**		 * Returns a temporary file name based on the given path.		 *		 * <p>If the directory where the file would be created cannot be		 * written (i.e., no new files can be created in that directory),		 * this method returns <code>null</code>.</p>		 *		 * @param path The path name		 */		@Override		public String getTwoStageSaveName(String path)		{			File parent = new File(getParentOfPath(path));			// the ignorance of the canWrite() method for windows			// is, because the read-only flag on windows has			// not the effect of preventing the creation of new files.			// The only way to make a directory read-only in this means			// the ACL of the directory has to be set to read-only,			// which is not checkable by java.			// The " || OperatingSystem.isWindows()" can be removed			// if the canWrite() method gives back the right value.			return (parent.canWrite() || OperatingSystem.isWindows())				? super.getTwoStageSaveName(path)				: null;		}	
@Override		public boolean save(View view, Buffer buffer, String path)		{			if(OperatingSystem.isUnix())			{				int permissions = getPermissions(buffer.getPath());				Log.log(Log.DEBUG,this,buffer.getPath() + " has permissions 0"					+ Integer.toString(permissions,8));				buffer.setIntegerProperty(PERMISSIONS_PROPERTY,permissions);			}				return super.save(view,buffer,path);		}	
@Override		public boolean insert(View view, Buffer buffer, String path)		{			File file = new File(path);				//{{{ Check if file is valid			if(!file.exists())				return false;				if(file.isDirectory())			{				VFSManager.error(view,file.getPath(),					"ioerror.open-directory",null);				return false;			}				if(!file.canRead())			{				VFSManager.error(view,file.getPath(),					"ioerror.no-read",null);				return false;			} //}}}				return super.insert(view,buffer,path);		}	
/**		 * #		 * @param path the directory path to recursive delete		 * @return true if successful, else false		 */		public static boolean recursiveDelete(File path)		{			if (path.exists())			{				File[] files = path.listFiles();				for (int i = 0; i < files.length; i++)				{					if (files[i].isDirectory())					{						recursiveDelete(files[i]);					}					else					{						files[i].delete();					}				}			}			return path.delete();		}	
/**		 * Returns the canonical form if the specified path name. For example,		 * <code>~</code> might be expanded to the user's home directory.		 * @param session The session		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @since jEdit 4.0pre2		 */		@Override		public String _canonPath(Object session, String path, Component comp)			throws IOException		{			return MiscUtilities.canonPath(path);		}	
public LocalFile(File file)			{				this.file = file;					/* These attributes are fetched relatively				quickly. The rest are lazily filled in. */				setName(file.getName());				String path = file.getPath();				setPath(path);				setDeletePath(path);				setHidden(file.isHidden());				setType(file.isDirectory()					? VFSFile.DIRECTORY					: VFSFile.FILE);			}	
@Override			public String getExtendedAttribute(String name)			{				fetchAttrs();				if (name.equals(EA_MODIFIED))				{					return DATE_FORMAT.format(new Date(modified));				}				else				{					return super.getExtendedAttribute(name);				}			}	
/** Fetch the attributes of the local file. */			@Override			protected void fetchAttrs()			{				if(fetchedAttrs())					return;					super.fetchAttrs();					setSymlinkPath(MiscUtilities.resolveSymlinks(					file.getPath()));				setReadable(file.canRead());				setWriteable(file.canWrite());				setLength(file.length());				setModified(file.lastModified());			}	
/**			 * Returns the file system icon for the file.			 *			 * @param expanded not used here			 * @param openBuffer not used here			 * @return the file system icon			 * @since 4.3pre9			 */			@Override			public Icon getIcon(boolean expanded, boolean openBuffer)			{				if (icon == null)				{					if (fsView == null)						fsView = FileSystemView.getFileSystemView();						icon = fsView.getSystemIcon(file);				}				return icon;  			}	
@Override			public String getSymlinkPath()			{				fetchAttrs();				return super.getSymlinkPath();			}	
@Override			public long getLength()			{				fetchAttrs();				return super.getLength();			}	
@Override			public boolean isReadable()			{				fetchAttrs();				return super.isReadable();			}	
@Override			public boolean isWriteable()			{				fetchAttrs();				return super.isWriteable();			}	
public long getModified()			{				fetchAttrs();				return modified;			}	
public void setModified(long modified)			{				this.modified = modified;			}	
@Override		public VFSFile[] _listFiles(Object session, String path,			Component comp)		{			//{{{ Windows work around			/* On Windows, paths of the form X: list the last *working			 * directory* on that drive. To list the root of the drive,			 * you must use X:\.			 *			 * However, the VFS browser and friends strip off trailing			 * path separators, for various reasons. So to work around			 * that, we add a '\' to drive letter paths on Windows.			 */			if(OperatingSystem.isWindows())			{				if(path.length() == 2 && path.charAt(1) == ':')					path = path.concat(File.separator);			} //}}}				File directory = new File(path);			File[] list = null;			if(directory.exists())				list = fsView.getFiles(directory,false);				if(list == null)			{				VFSManager.error(comp,path,"ioerror.directory-error-nomsg",null);				return null;			}				VFSFile[] list2 = new VFSFile[list.length];			for(int i = 0; i < list.length; i++)				list2[i] = new LocalFile(list[i]);				return list2;		}	
@Override		public VFSFile _getFile(Object session, String path,			Component comp)		{			if(path.equals("/") && OperatingSystem.isUnix())			{				return new VFS.DirectoryEntry(path,path,path,					VFSFile.DIRECTORY,0L,false);			}				File file = new File(path);			if(!file.exists())				return null;				return new LocalFile(file);		}	
@Override		public boolean _delete(Object session, String path, Component comp)		{			File file = new File(path);			// do some platforms throw exceptions if the file does not exist			// when we ask for the canonical path?			String canonPath;			try			{				canonPath = file.getCanonicalPath();			}			catch(IOException io)			{				canonPath = path;			}			// if directory, do recursive delete			boolean retVal;			if (!file.isDirectory())			{				retVal = file.delete();			} 			else 			{				retVal = recursiveDelete(file);			}			if(retVal)				VFSManager.sendVFSUpdate(this,canonPath,true);			return retVal;		}	
@Override		public boolean _rename(Object session, String from, String to,			Component comp)		{			File _to = new File(to);				String toCanonPath;			try			{				toCanonPath = _to.getCanonicalPath();			}			catch(IOException io)			{				toCanonPath = to;			}				// this is needed because on OS X renaming to a non-existent			// directory causes problems			File parent = new File(_to.getParent());			if(parent.exists())			{				if(!parent.isDirectory())					return false;			}			else			{				parent.mkdirs();				if(!parent.exists())					return false;			}				File _from = new File(from);				String fromCanonPath;			try			{				fromCanonPath = _from.getCanonicalPath();			}			catch(IOException io)			{				fromCanonPath = from;			}				// Case-insensitive fs workaround			if(!fromCanonPath.equalsIgnoreCase(toCanonPath))				_to.delete();				boolean retVal = _from.renameTo(_to);			VFSManager.sendVFSUpdate(this,fromCanonPath,true);			VFSManager.sendVFSUpdate(this,toCanonPath,true);			return retVal;		}	
@Override		public boolean _mkdir(Object session, String directory, Component comp)		{			String parent = getParentOfPath(directory);			if(!new File(parent).exists())			{				if(!_mkdir(session,parent,comp))					return false;			}				File file = new File(directory);				boolean retVal = file.mkdir();			String canonPath;			try			{				canonPath = file.getCanonicalPath();			}			catch(IOException io)			{				canonPath = directory;			}			VFSManager.sendVFSUpdate(this,canonPath,true);			return retVal;		}	
@Override		public void _backup(Object session, String path, Component comp)			throws IOException		{			// Fetch properties			int backups = jEdit.getIntegerProperty("backups",1);				if(backups == 0)				return;				String backupPrefix = jEdit.getProperty("backup.prefix");			String backupSuffix = jEdit.getProperty("backup.suffix");				String backupDirectory = jEdit.getProperty("backup.directory");				int backupTimeDistance = jEdit.getIntegerProperty("backup.minTime",0);			File file = new File(path);				if (!file.exists())				return;				// Check for backup.directory, and create that			// directory if it doesn't exist			if(backupDirectory == null || backupDirectory.length() == 0)				backupDirectory = file.getParent();			else			{				backupDirectory = MiscUtilities.constructPath(					System.getProperty("user.home"),backupDirectory);					// Perhaps here we would want to guard with				// a property for parallel backups or not.				backupDirectory = MiscUtilities.concatPath(					backupDirectory,file.getParent());					File dir = new File(backupDirectory);					if (!dir.exists())					dir.mkdirs();			}				MiscUtilities.saveBackup(file,backups,backupPrefix,				backupSuffix,backupDirectory,backupTimeDistance);		}	
@Override		public InputStream _createInputStream(Object session, String path,			boolean ignoreErrors, Component comp) throws IOException		{			try			{				return new FileInputStream(path);			}			catch(IOException io)			{				if(ignoreErrors)					return null;				else					throw io;			}		}	
@Override		public OutputStream _createOutputStream(Object session, String path,			Component comp) throws IOException		{			return new FileOutputStream(path);		}	
@Override		public void _saveComplete(Object session, Buffer buffer, String path,			Component comp)		{			int permissions = buffer.getIntegerProperty(PERMISSIONS_PROPERTY,0);			setPermissions(path,permissions);		}	
/**		 * Returns numeric permissions of a file. On non-Unix systems, always		 * returns zero.		 * @since jEdit 3.2pre9		 */		public static int getPermissions(String path)		{			int permissions = 0;				if(jEdit.getBooleanProperty("chmodDisabled"))				return permissions;				if(OperatingSystem.isUnix())			{				String[] cmdarray = { "ls", "-ld", path };					try				{					Process process = Runtime.getRuntime().exec(cmdarray);						BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));						String output = reader.readLine();						if(output != null)					{						String s = output.substring(1, 10);							permissions = MiscUtilities							.parsePermissions(s);					}				}					// Feb 4 2000 5:30 PM				// Catch Throwable here rather than Exception.				// Kaffe's implementation of Runtime.exec throws java.lang.InternalError.				catch (Throwable t)				{				}			}				return permissions;		}	
/**		 * Sets numeric permissions of a file. On non-Unix platforms,		 * does nothing.		 * @since jEdit 3.2pre9		 */		public static void setPermissions(String path, int permissions)		{			if(jEdit.getBooleanProperty("chmodDisabled"))				return;				if(permissions != 0)			{				if(OperatingSystem.isUnix())				{					String[] cmdarray = { "chmod", Integer.toString(permissions, 8), path };						try					{						Process process = Runtime.getRuntime().exec(cmdarray);						process.getInputStream().close();						process.getOutputStream().close();						process.getErrorStream().close();						// Jun 9 2004 12:40 PM						// waitFor() hangs on some Java						// implementations.						/* int exitCode = process.waitFor();						if(exitCode != 0)							Log.log(Log.NOTICE,FileVFS.class,"chmod exited with code " + exitCode); */					}						// Feb 4 2000 5:30 PM					// Catch Throwable here rather than Exception.					// Kaffe's implementation of Runtime.exec throws java.lang.InternalError.					catch (Throwable t)					{					}				}			}		}	
protected FilteredListModel(E delegated)		{			this.delegated = delegated;			delegated.addListDataListener(this);			resetFilter();		}	
/**		 * Set the JList that uses this model.		 * It is used to restore the selection after the filter has been applied		 * If it is null,		 *		 * @param list the list that uses the model		 */		public void setList(JList list)		{			if (list.getModel() != this)				throw new IllegalArgumentException("The given list " + list + " doesn't use this model " + this);			this.list = list;		}	
public E getDelegated()		{			return delegated;		}	
public void setDelegated(E delegated)		{			this.delegated.removeListDataListener(this);			delegated.addListDataListener(this);			this.delegated = delegated;		}	
private void resetFilter()		{			filteredIndices = null;		}	
public void setFilter(final String filter)		{			Runnable runner = new Runnable()			{				public void run()				{					Set<Integer> selectedIndices = saveSelection();					list.clearSelection();					FilteredListModel.this.filter = filter;					if (filter != null && filter.length() > 0)					{						int size = delegated.getSize();						String prepped_filter = prepareFilter(filter);						Vector<Integer> indices = new Vector<Integer>(size);						Map<Integer, Integer> invertedIndices = new HashMap<Integer, Integer>();						for (int i = 0; i < size; i++)						{							if (passFilter(i, prepped_filter))							{								Integer delegatedIndice = Integer.valueOf(i);								indices.add(delegatedIndice);									invertedIndices.put(delegatedIndice, indices.size() - 1);							}						}						FilteredListModel.this.invertedIndices = invertedIndices;						filteredIndices = indices;					}					else						resetFilter();						fireContentsChanged(this, 0, getSize() - 1);					restoreSelection(selectedIndices);				}			};			SwingUtilities.invokeLater(runner);		}	
public String prepareFilter(String filter)		{			return filter;		}	
protected Set<Integer> saveSelection()		{			if (list == null)				return null;			int[] rows = list.getSelectedIndices();			if (rows.length == 0)				return null;				Set<Integer> selectedRows = new HashSet<Integer>(rows.length);			for (int row : rows)			{				selectedRows.add(getTrueRow(row));			}			return selectedRows;		}	
protected void restoreSelection(Set<Integer> selectedIndices)		{			if (selectedIndices == null || getSize() == 0)				return;				// To correctly handle "single interval" selection mode,			// each interval has to be selected using a single call to			// setSelectionInterval; calling setSelectionInterval on			// each item cancels the previous selection.			// Sort the list of selected indices to simplify interval			// identification.			Vector<Integer> sel = new Vector<Integer>(selectedIndices);			Collections.sort(sel);			int from = -1;			int to = -1;			for (Integer selectedIndex : sel)			{				int i = getInternal2ExternalRow(selectedIndex.intValue());				if (i != -1)				{					if (from == -1)						from = to = i;					else if (i == to + 1)						to = i;					else					{						list.setSelectionInterval(from, to);						from = to = i;					}				}			}			if (from != -1)				list.setSelectionInterval(from, to);		}	
/**		 * Converts a row index from the JTable to an internal row index from the delegated model.		 *		 * @param rowIndex the row index		 * @return the row index in the delegated model		 */		public int getTrueRow(int rowIndex)		{			if (filteredIndices == null)				return rowIndex;			return filteredIndices.get(rowIndex).intValue();		}	
/**		 * Converts a row index from the delegated table model into a row index of the JTable.		 *		 * @param internalRowIndex the internal row index		 * @return the table row index or -1 if this row is not visible		 */		public int getInternal2ExternalRow(int internalRowIndex)		{			if (invertedIndices == null)				return internalRowIndex;				Integer externalRowIndex = invertedIndices.get(internalRowIndex);			if (externalRowIndex == null)				return -1;				return externalRowIndex.intValue();		}	
public Object getElementAt(int index)		{			int trueRowIndex = getTrueRow(index);			return delegated.getElementAt(trueRowIndex);		}	
public int getSize()		{			if (filteredIndices == null)				return delegated.getSize();			return filteredIndices.size();		}	
public void contentsChanged(ListDataEvent e)		{			setFilter(filter);		}	
public void intervalAdded(ListDataEvent e)		{			setFilter(filter);		}	
public void intervalRemoved(ListDataEvent e)		{			setFilter(filter);		}	
protected FilteredTableModel(E delegated)		{			this.delegated = delegated;			delegated.addTableModelListener(this);			resetFilter();		}	
/**		 * Set the JTable that uses this model.		 * It is used to restore the selection after the filter has been applied		 * If it is null,		 *		 * @param table the table that uses the model		 */		public void setTable(JTable table)		{			if (table.getModel() != this)				throw new IllegalArgumentException("The given table " + table + " doesn't use this model " + this);			this.table = table;		}	
public E getDelegated()		{			return delegated;		}	
public void setDelegated(E delegated)		{			this.delegated.removeTableModelListener(this);			delegated.addTableModelListener(this);			this.delegated = delegated;		}	
private void resetFilter()		{			filteredIndices = null;		}	
public void setFilter(String filter)		{			Set<Integer> selectedIndices = saveSelection();			this.filter = filter;			if (filter != null && filter.length() > 0)			{				int size = delegated.getRowCount();				filter = prepareFilter(filter);				Vector<Integer> indices = new Vector<Integer>(size);				Map<Integer, Integer> invertedIndices = new HashMap<Integer, Integer>();				for (int i = 0; i < size; i++)				{					if (passFilter(i, filter))					{						Integer delegatedIndice = Integer.valueOf(i);						indices.add(delegatedIndice);							invertedIndices.put(delegatedIndice, indices.size() - 1);					}				}				this.invertedIndices = invertedIndices;				filteredIndices = indices;			}			else				resetFilter();				fireTableDataChanged();			restoreSelection(selectedIndices);		}	
public String prepareFilter(String filter)		{			return filter;		}	
private Set<Integer> saveSelection()		{			if (table == null)				return null;			int[] rows = table.getSelectedRows();			if (rows.length == 0)				return null;				Set<Integer> selectedRows = new HashSet<Integer>(rows.length);			for (int row : rows)			{				selectedRows.add(getTrueRow(row));			}			return selectedRows;		}	
private void restoreSelection(Set<Integer> selectedIndices)		{			if (selectedIndices == null || getRowCount() == 0)				return; 						for (Integer selectedIndex : selectedIndices)			{				int i = getInternal2ExternalRow(selectedIndex.intValue());				if (i != -1)					table.getSelectionModel().setSelectionInterval(i, i);			}		}	
public int getRowCount()		{			if (filteredIndices == null)				return delegated.getRowCount();			return filteredIndices.size();		}	
public int getColumnCount()		{			return delegated.getColumnCount();		}	
public String getColumnName(int columnIndex)		{			return delegated.getColumnName(columnIndex);		}	
public Class<?> getColumnClass(int columnIndex)		{			return delegated.getColumnClass(columnIndex);		}	
public boolean isCellEditable(int rowIndex, int columnIndex)		{			int trueRowIndex = getTrueRow(rowIndex);			return delegated.isCellEditable(trueRowIndex, columnIndex);		}	
public Object getValueAt(int rowIndex, int columnIndex)		{			int trueRowIndex = getTrueRow(rowIndex);			return delegated.getValueAt(trueRowIndex, columnIndex);		}	
public void setValueAt(Object aValue, int rowIndex, int columnIndex)		{			int trueRowIndex = getTrueRow(rowIndex);			delegated.setValueAt(aValue, trueRowIndex, columnIndex);		}	
/**		 * Converts a row index from the JTable to an internal row index from the delegated model.		 *		 * @param rowIndex the row index		 * @return the row index in the delegated model		 */		public int getTrueRow(int rowIndex)		{			if (filteredIndices == null)				return rowIndex;			return filteredIndices.get(rowIndex).intValue();		}	
/**		 * Converts a row index from the delegated table model into a row index of the JTable.		 *		 * @param internalRowIndex the internal row index		 * @return the table row index or -1 if this row is not visible		 */		public int getInternal2ExternalRow(int internalRowIndex)		{			if (invertedIndices == null)				return internalRowIndex;				Integer externalRowIndex = invertedIndices.get(internalRowIndex);			if (externalRowIndex == null)				return -1;				return externalRowIndex.intValue();		}	
/**		 * This fine grain notification tells listeners the exact range		 * of cells, rows, or columns that changed.		 */		public void tableChanged(TableModelEvent e)		{			setFilter(filter);		}	
public FirewallOptionPane()		{			super("firewall");		}	
public void _init()		{			// checkbox			addComponent(httpEnabled = new JCheckBox(jEdit.getProperty(				"options.firewall.http.enabled")));			// proxy host			addComponent(jEdit.getProperty("options.firewall.http.host"), 				httpHost = new JTextField(jEdit.getProperty("firewall.host"), 15));			// proxy port			addComponent(jEdit.getProperty("options.firewall.http.port"), 				httpPort = new JTextField(jEdit.getProperty("firewall.port"), 15));			// proxy username			addComponent(jEdit.getProperty("options.firewall.http.user"),				httpUser = new JTextField(jEdit.getProperty("firewall.user"), 15));			// proxy password			addComponent(jEdit.getProperty("options.firewall.http.password"),				httpPass = new JPasswordField(jEdit.getProperty("firewall.password"), 15));			// no proxy for			addComponent(jEdit.getProperty("options.firewall.http.nonProxy"),				httpNonProxy = new JTextField(jEdit.getProperty("firewall.nonProxyHosts"), 15));				boolean enabled = jEdit.getBooleanProperty("firewall.enabled");			httpEnabled.setSelected(enabled);			httpHost.setEnabled(enabled);			httpPort.setEnabled(enabled);			httpUser.setEnabled(enabled);			httpPass.setEnabled(enabled);			httpNonProxy.setEnabled(enabled);				httpEnabled.addActionListener(new ActionHandler());				// checkbox			addComponent(socksEnabled = new JCheckBox(jEdit.getProperty(				"options.firewall.socks.enabled")));			// proxy host			addComponent(jEdit.getProperty("options.firewall.socks.host"), 				socksHost = new JTextField(jEdit.getProperty("firewall.socks.host"), 15));			// proxy port			addComponent(jEdit.getProperty("options.firewall.socks.port"), 				socksPort = new JTextField(jEdit.getProperty("firewall.socks.port"), 15));				enabled = jEdit.getBooleanProperty("firewall.socks.enabled");			socksEnabled.setSelected(enabled);			socksHost.setEnabled(enabled);			socksPort.setEnabled(enabled);				socksEnabled.addActionListener(new ActionHandler());		}	
public void _save()		{			jEdit.setBooleanProperty("firewall.enabled", httpEnabled.isSelected());			jEdit.setProperty("firewall.host", httpHost.getText());			jEdit.setProperty("firewall.port", httpPort.getText());			jEdit.setProperty("firewall.user", httpUser.getText());			jEdit.setProperty("firewall.password", new String(httpPass.getPassword()));			jEdit.setProperty("firewall.nonProxyHosts", httpNonProxy.getText());				jEdit.setBooleanProperty("firewall.socks.enabled", socksEnabled.isSelected());			jEdit.setProperty("firewall.socks.host", socksHost.getText());			jEdit.setProperty("firewall.socks.port", socksPort.getText());		}	
public void actionPerformed(ActionEvent evt)			{				httpHost.setEnabled(httpEnabled.isSelected());				httpPort.setEnabled(httpEnabled.isSelected());				httpUser.setEnabled(httpEnabled.isSelected());				httpPass.setEnabled(httpEnabled.isSelected());				httpNonProxy.setEnabled(httpEnabled.isSelected());				socksHost.setEnabled(socksEnabled.isSelected());				socksPort.setEnabled(socksEnabled.isSelected());			}	
FirstLine(DisplayManager displayManager,			TextArea textArea)		{			super(displayManager,textArea);		}	
@Override		public void changed()		{			//{{{ Debug code			if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"changed() before: "					+ physicalLine + ':' + scrollLine					+ ':' + skew);			} //}}}				ensurePhysicalLineIsVisible();				int screenLines = displayManager				.getScreenLineCount(physicalLine);			if(skew >= screenLines)				skew = screenLines - 1;				//{{{ Debug code			if(Debug.SCROLL_VERIFY)			{				System.err.println("SCROLL_VERIFY");				int verifyScrollLine = 0;					for(int i = 0; i < displayManager.getBuffer()					.getLineCount(); i++)				{					if(!displayManager.isLineVisible(i))						continue;						if(i >= physicalLine)						break;						verifyScrollLine += displayManager						.getScreenLineCount(i);				}					if(verifyScrollLine != scrollLine)				{					Exception ex = new Exception(scrollLine + ":" + verifyScrollLine);					Log.log(Log.ERROR,this,ex);				}			}				if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"changed() after: "					+ physicalLine + ':' + scrollLine					+ ':' + skew);			} //}}}		}	
@Override		public void reset()		{			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"reset()");				int oldPhysicalLine = physicalLine;			physicalLine = 0;			scrollLine = 0;				int i = displayManager.getFirstVisibleLine();				for(;;)			{				if(i >= oldPhysicalLine)					break;					scrollLine += displayManager.getScreenLineCount(i);					int nextLine = displayManager.getNextVisibleLine(i);				if(nextLine == -1)					break;				else					i = nextLine;			}				physicalLine = i;				int screenLines = displayManager.getScreenLineCount(physicalLine);			if(skew >= screenLines)				skew = screenLines - 1;				textArea.updateScrollBar();		}	
void physDown(int amount, int screenAmount)		{			if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"physDown() start: "					+ physicalLine + ':' + scrollLine);			}				skew = 0;				if(!displayManager.isLineVisible(physicalLine))			{				int lastVisibleLine = displayManager.getLastVisibleLine();				if(physicalLine > lastVisibleLine)					physicalLine = lastVisibleLine;				else				{					int nextPhysicalLine = displayManager.getNextVisibleLine(physicalLine);					amount -= nextPhysicalLine - physicalLine;					scrollLine += displayManager.getScreenLineCount(physicalLine);					physicalLine = nextPhysicalLine;				}			}				for(;;)			{				int nextPhysicalLine = displayManager.getNextVisibleLine(					physicalLine);				if(nextPhysicalLine == -1)					break;				else if(nextPhysicalLine > physicalLine + amount)					break;				else				{					scrollLine += displayManager.getScreenLineCount(physicalLine);					amount -= nextPhysicalLine - physicalLine;					physicalLine = nextPhysicalLine;				}			}				if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"physDown() end: "					+ physicalLine + ':' + scrollLine);			}				callChanged = true;				// JEditTextArea.scrollTo() needs this to simplify			// its code			if(screenAmount < 0)				scrollUp(-screenAmount);			else if(screenAmount > 0)				scrollDown(screenAmount);		}	
void physUp(int amount, int screenAmount)		{			if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"physUp() start: "					+ physicalLine + ':' + scrollLine);			}				skew = 0;				if(!displayManager.isLineVisible(physicalLine))			{				int firstVisibleLine = displayManager.getFirstVisibleLine();				if(physicalLine < firstVisibleLine)					physicalLine = firstVisibleLine;				else				{					int prevPhysicalLine = displayManager.getPrevVisibleLine(physicalLine);					amount -= physicalLine - prevPhysicalLine;				}			}				for(;;)			{				int prevPhysicalLine = displayManager.getPrevVisibleLine(					physicalLine);				if(prevPhysicalLine == -1)					break;				else if(prevPhysicalLine < physicalLine - amount)					break;				else				{					amount -= physicalLine - prevPhysicalLine;					physicalLine = prevPhysicalLine;					scrollLine -= displayManager.getScreenLineCount(						prevPhysicalLine);				}			}				if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"physUp() end: "					+ physicalLine + ':' + scrollLine);			}				callChanged = true;				// JEditTextArea.scrollTo() needs this to simplify			// its code			if(screenAmount < 0)				scrollUp(-screenAmount);			else if(screenAmount > 0)				scrollDown(screenAmount);		}	
void scrollDown(int amount)		{			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"scrollDown()");				ensurePhysicalLineIsVisible();				amount += skew;				skew = 0;				while(amount > 0)			{				int screenLines = displayManager.getScreenLineCount(physicalLine);				if(amount < screenLines)				{					skew = amount;					break;				}				else				{					int nextLine = displayManager.getNextVisibleLine(physicalLine);					if(nextLine == -1)						break;					boolean visible = displayManager.isLineVisible(physicalLine);					physicalLine = nextLine;					if(visible)					{						amount -= screenLines;						scrollLine += screenLines;					}				}			}				callChanged = true;		}	
void scrollUp(int amount)		{			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"scrollUp() before:" + this);				ensurePhysicalLineIsVisible();				if(amount <= skew)			{				// the amount is less than the skew, so we stay in the same like, just going				// upper				skew -= amount;			}			else			{				// moving to the first screen line of the current physical line				amount -= skew;				skew = 0;					while(amount > 0)				{					int prevLine = displayManager.getPrevVisibleLine(physicalLine);					if(prevLine == -1)						break;					// moving to the previous visible physical line					physicalLine = prevLine;						int screenLines = displayManager.getScreenLineCount(physicalLine);					scrollLine -= screenLines;					if(amount < screenLines)					{						skew = screenLines - amount;						break;					}					else						amount -= screenLines;				}			}				if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"scrollUp() after:" + this);			callChanged = true;		}	
void ensurePhysicalLineIsVisible()		{			if(!displayManager.isLineVisible(physicalLine))			{				if(physicalLine > displayManager.getLastVisibleLine())				{					physicalLine = displayManager.getLastVisibleLine();					scrollLine = displayManager.getScrollLineCount() - 1;				}				else if(physicalLine < displayManager.getFirstVisibleLine())				{					physicalLine = displayManager.getFirstVisibleLine();					scrollLine = 0;				}				else				{					physicalLine = displayManager.getNextVisibleLine(physicalLine);					scrollLine += displayManager.getScreenLineCount(physicalLine);				}			}		}	
@Override		public String toString()		{			return "FirstLine["+physicalLine+','+scrollLine+','+skew+']';		}	
public FloatingWindowContainer(DockableWindowManagerImpl dockableWindowManager,			boolean clone)		{			this.dockableWindowManager = dockableWindowManager;				dockableWindowManager.addPropertyChangeListener(this);			this.clone = clone;			setIconImage(GUIUtilities.getPluginIcon());			setDefaultCloseOperation(DISPOSE_ON_CLOSE);				Box caption = new Box(BoxLayout.X_AXIS);			caption.add(menu = new RolloverButton(GUIUtilities				.loadIcon(jEdit.getProperty("dropdown-arrow.icon"))));			menu.addMouseListener(new MouseHandler());			menu.setToolTipText(jEdit.getProperty("docking.menu.label"));			Box separatorBox = new Box(BoxLayout.Y_AXIS);			separatorBox.add(Box.createVerticalStrut(3));			separatorBox.add(new JSeparator(JSeparator.HORIZONTAL));			separatorBox.add(Box.createVerticalStrut(3));			caption.add(separatorBox);			getContentPane().add(BorderLayout.NORTH,caption);							}	
public void register(DockableWindowManagerImpl.Entry entry)		{			this.entry = entry;			dockableName = entry.factory.name;						setTitle(entry.shortTitle());				getContentPane().add(BorderLayout.CENTER,entry.win);				pack();			Container parent = dockableWindowManager.getView();			GUIUtilities.loadGeometry(this, parent, dockableName);			GUIUtilities.addSizeSaver(this, parent, dockableName);			KeyListener listener = dockableWindowManager.closeListener(dockableName);			addKeyListener(listener);			getContentPane().addKeyListener(listener);			menu.addKeyListener(listener);			entry.win.addKeyListener(listener);			setVisible(true);			if (! entry.win.isVisible())				entry.win.setVisible(true);		}	
public void remove(DockableWindowManagerImpl.Entry entry)		{			dispose();		}	
public void unregister(DockableWindowManagerImpl.Entry entry)		{			this.entry = null;			entry.btn = null;			entry.container = null;			// Note: entry.win must not be reset, to enable the dockable			// instance to be moved instead of recreated if it uses the			// MOVABLE attribute.			super.dispose();		}	
public void show(final DockableWindowManagerImpl.Entry entry)		{			if(entry == null)				dispose();			else			{				setTitle(entry.longTitle());				toFront();				requestFocus();				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						if(entry.win instanceof DefaultFocusComponent)						{							((DefaultFocusComponent)entry.win)								.focusOnDefaultComponent();						}						else						{							entry.win.requestFocus();						}					}				});			}		}	
public boolean isVisible(DockableWindowManagerImpl.Entry entry)		{			return true;		}	
@Override		public void dispose()		{			entry.container = null;			entry.win = null;			super.dispose();		}	
public DockableWindowManagerImpl getDockableWindowManager()		{			return dockableWindowManager;		}	
@Override		public Dimension getMinimumSize()		{			return new Dimension(0,0);		}	
@Override			public void mousePressed(MouseEvent evt)			{				if(popup != null && popup.isVisible())					popup.setVisible(false);				else				{					popup = dockableWindowManager.createPopupMenu(						FloatingWindowContainer.this,						entry.factory.name,clone);					GUIUtilities.showPopupMenu(popup,						menu,menu.getX(),menu.getY() + menu.getHeight(),						false);				}			}	
public void propertyChange(PropertyChangeEvent evt)		{			if (dockableName == null) return;			String pn = evt.getPropertyName();			if (pn.startsWith(dockableName) && pn.endsWith("title"))				setTitle(evt.getNewValue().toString());		}	
/**		 * Returns the internal name of this FoldHandler		 * @return The internal name of this FoldHandler		 * @since jEdit 4.0pre6		 */		public String getName()		{			return name;		}	
/**		 * Returns the fold levels of the lines preceding the specified line,		 * which depend on the specified line.		 * @param buffer The buffer in question		 * @param lineIndex The line index		 * @param seg A segment the fold handler can use to obtain any		 * @param lineFoldLevel The fold level of the specified line		 * @return The fold levels of the preceding lines, in decreasing line		 * number order (i.e. bottomost line first).		 * @since jEdit 4.3pre18		 */		public List<Integer> getPrecedingFoldLevels(JEditBuffer buffer,			int lineIndex, Segment seg, int lineFoldLevel)		{			return null;		}	
/**		 * Returns if the specified fold handler is equal to this one.		 * @param o The object		 */		public boolean equals(Object o)		{			// Default implementation... subclasses can extend this.			if(o == null)				return false;			else				return getClass() == o.getClass();		}	
public int hashCode()		{			return getClass().hashCode();		}	
/**		 * Returns the fold handler with the specified name, or null if		 * there is no registered handler with that name.		 * @param name The name of the desired fold handler		 * @since jEdit 4.0pre6		 */		public static FoldHandler getFoldHandler(String name)		{			return foldHandlerProvider.getFoldHandler(name);		}	
/**		 * Returns an array containing the names of all registered fold		 * handlers.		 *		 * @since jEdit 4.0pre6		 */		public static String[] getFoldModes()		{			return foldHandlerProvider.getFoldModes();		}	
protected FoldHandler(String name)		{			this.name = name;		}	
public String toString()		{			return name;		}	
public Widget getWidget(View view) 		{			Widget fold = new FoldWidget(view);			return fold;		}	
public FoldWidget(final View view) 			{				fold = new ToolTipLabel();				this.view = view;				fold.setToolTipText(jEdit.getProperty("view.status.mode-tooltip"));				fold.addMouseListener(new MouseAdapter() 						      {							      @Override							      public void mouseClicked(MouseEvent evt)							      {								      if(evt.getClickCount() == 2)									      new BufferOptions(view,view.getBuffer());							      }						      });			}	
public JComponent getComponent() 			{				return fold;			}	
public void update() 			{				Buffer buffer = view.getBuffer();				if (buffer.isLoaded())					fold.setText((String)view.getBuffer().getProperty("folding"));			}	
public void propertiesChanged()			{			}	
/**		 * Creates a new font selector control.		 * @param font The font		 */		public FontSelector(Font font)		{			this(font,false);		}	
/**		 * Creates a new font selector control.		 * @param font The font		 * @param antiAlias Is anti-aliasing enabled?		 * @since jEdit 4.2pre7		 */		public FontSelector(Font font, boolean antiAlias)		{			setFont(font);			this.antiAlias = antiAlias;				updateText();				setRequestFocusEnabled(false);				addActionListener(new ActionHandler());		}	
public void paintComponent(Graphics g)		{			setAntiAliasEnabled(g);			super.paintComponent(g);		}	
public boolean isAntiAliasEnabled()		{			return antiAlias;		}	
public void setAntiAliasEnabled(boolean antiAlias)		{			this.antiAlias = antiAlias;		}	
private void updateText()		{			Font font = getFont();			String styleString;			switch(font.getStyle())			{			case Font.PLAIN:				styleString = jEdit.getProperty("font-selector.plain");				break;			case Font.BOLD:				styleString = jEdit.getProperty("font-selector.bold");				break;			case Font.ITALIC:				styleString = jEdit.getProperty("font-selector.italic");				break;			case Font.BOLD | Font.ITALIC:				styleString = jEdit.getProperty("font-selector.bolditalic");				break;			default:				styleString = "UNKNOWN!!!???";				break;			}				setText(font.getName() + ' ' + font.getSize() + ' ' + styleString);		}	
void setAntiAliasEnabled(Graphics g)		{			if (antiAlias)			{				Graphics2D g2 = (Graphics2D)g;				g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,					RenderingHints.VALUE_ANTIALIAS_ON);			}		}	
public void actionPerformed(ActionEvent evt)			{				Font font;					JDialog dialog = GUIUtilities.getParentDialog(FontSelector.this);				if(dialog == null)				{					font = new FontSelectorDialog(						JOptionPane.getFrameForComponent(						FontSelector.this),getFont(),						FontSelector.this)						.getSelectedFont();				}				else				{					font = new FontSelectorDialog(dialog,getFont(),						FontSelector.this)						.getSelectedFont();				}					if(font != null)				{					setFont(font);					updateText();				}			}	
FontSelectorDialog(Frame parent, Font font)		{			super(parent,jEdit.getProperty("font-selector.title"),true);			init(font);		}	
FontSelectorDialog(Dialog parent, Font font)		{			super(parent,jEdit.getProperty("font-selector.title"),true);			init(font);		}	
FontSelectorDialog(Frame parent, Font font,			FontSelector fontSelector)		{			super(parent,jEdit.getProperty("font-selector.title"),true);			this.fontSelector = fontSelector;			init(font);		}	
FontSelectorDialog(Dialog parent, Font font,			FontSelector fontSelector)		{			super(parent,jEdit.getProperty("font-selector.title"),true);			this.fontSelector = fontSelector;			init(font);		}	
public void ok()		{			isOK = true;			dispose();		}	
public void cancel()		{			dispose();		}	
public Font getSelectedFont()		{			if(!isOK)				return null;				int size;			try			{				size = Integer.parseInt(sizeField.getText());			}			catch(Exception e)			{				size = 12;			}				return new Font(familyField.getText(),styleList				.getSelectedIndex(),size);		}	
private void init(Font font)		{			JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				JPanel listPanel = new JPanel(new GridLayout(1,3,6,6));				String[] fonts;			try			{				fonts = getFontList();			}			catch(Exception e)			{				Log.log(Log.ERROR,this,"Broken Java implementation!");				/* Log.log(Log.ERROR,this,"Using deprecated Toolkit.getFontList()"); */				Log.log(Log.ERROR,this,e);					/* fonts = getToolkit().getFontList(); */				fonts = new String[] { "Broken Java implementation!" };			}				JPanel familyPanel = createTextFieldAndListPanel(				"font-selector.family",				familyField = new JTextField(),				familyList = new JList(fonts));			listPanel.add(familyPanel);				String[] sizes = { "9", "10", "12", "14", "16", "18", "24" };			JPanel sizePanel = createTextFieldAndListPanel(				"font-selector.size",				sizeField = new JTextField(),				sizeList = new JList(sizes));			listPanel.add(sizePanel);				String[] styles = {				jEdit.getProperty("font-selector.plain"),				jEdit.getProperty("font-selector.bold"),				jEdit.getProperty("font-selector.italic"),				jEdit.getProperty("font-selector.bolditalic")			};				JPanel stylePanel = createTextFieldAndListPanel(				"font-selector.style",				styleField = new JTextField(),				styleList = new JList(styles));			styleField.setEditable(false);			listPanel.add(stylePanel);				familyList.setSelectedValue(font.getFamily(),true);			familyField.setText(font.getFamily());			sizeList.setSelectedValue(String.valueOf(font.getSize()),true);			sizeField.setText(String.valueOf(font.getSize()));			styleList.setSelectedIndex(font.getStyle());			styleField.setText((String)styleList.getSelectedValue());				ListHandler listHandler = new ListHandler();			familyList.addListSelectionListener(listHandler);			sizeList.addListSelectionListener(listHandler);			styleList.addListSelectionListener(listHandler);				content.add(BorderLayout.NORTH,listPanel);				preview = new JLabel(jEdit.getProperty("font-selector.long-text"))			{				public void paintComponent(Graphics g)				{					if(fontSelector != null)						fontSelector.setAntiAliasEnabled(g);					super.paintComponent(g);				}			};			preview.setBorder(new TitledBorder(jEdit.getProperty(				"font-selector.preview")));				updatePreview();				Dimension prefSize = preview.getPreferredSize();			prefSize.height = 50;			preview.setPreferredSize(prefSize);				content.add(BorderLayout.CENTER,preview);				JPanel buttons = new JPanel();			buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));			buttons.setBorder(new EmptyBorder(12,0,0,0));			buttons.add(Box.createGlue());				ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(new ActionHandler());			getRootPane().setDefaultButton(ok);			buttons.add(ok);				buttons.add(Box.createHorizontalStrut(6));				cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(new ActionHandler());			buttons.add(cancel);				buttons.add(Box.createGlue());				content.add(BorderLayout.SOUTH,buttons);				pack();			setLocationRelativeTo(getParent());			setVisible(true);		}	
private static String[] getFontList()		{			String[] nameArray = GraphicsEnvironment				.getLocalGraphicsEnvironment()				.getAvailableFontFamilyNames();			List<String> nameVector = new ArrayList<String>(nameArray.length);				for(int i = 0, j; i < nameArray.length; i++)			{				for(j = 0; j < HIDEFONTS.length; j++)				{					if(nameArray[i].contains(HIDEFONTS[j]))						break;				}					if(j == HIDEFONTS.length)					nameVector.add(nameArray[i]);			}				String[] _array = new String[nameVector.size()];			return nameVector.toArray(_array);		}	
private static JPanel createTextFieldAndListPanel(String label,			JTextField textField, JList list)		{			GridBagLayout layout = new GridBagLayout();			JPanel panel = new JPanel(layout);				GridBagConstraints cons = new GridBagConstraints();			cons.gridx = cons.gridy = 0;			cons.gridwidth = cons.gridheight = 1;			cons.fill = GridBagConstraints.BOTH;			cons.weightx = 1.0f;				JLabel _label = new JLabel(jEdit.getProperty(label));			layout.setConstraints(_label,cons);			panel.add(_label);				cons.gridy = 1;			Component vs = Box.createVerticalStrut(6);			layout.setConstraints(vs,cons);			panel.add(vs);				cons.gridy = 2;			layout.setConstraints(textField,cons);			panel.add(textField);				cons.gridy = 3;			vs = Box.createVerticalStrut(6);			layout.setConstraints(vs,cons);			panel.add(vs);				cons.gridy = 4;			cons.gridheight = GridBagConstraints.REMAINDER;			cons.weighty = 1.0f;			JScrollPane scroller = new JScrollPane(list);			layout.setConstraints(scroller,cons);			panel.add(scroller);				return panel;		}	
private void updatePreview()		{			String family = familyField.getText();			int size;			try			{				size = Integer.parseInt(sizeField.getText());			}			catch(Exception e)			{				size = 12;			}			int style = styleList.getSelectedIndex();				preview.setFont(new Font(family,style,size));		}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == ok)					ok();				else if(evt.getSource() == cancel)					cancel();			}	
public void valueChanged(ListSelectionEvent evt)			{				Object source = evt.getSource();				if(source == familyList)				{					String family = (String)familyList.getSelectedValue();					if(family != null)						familyField.setText(family);				}				else if(source == sizeList)				{					String size = (String)sizeList.getSelectedValue();					if(size != null)						sizeField.setText(size);				}				else if(source == styleList)				{					String style = (String)styleList.getSelectedValue();					if(style != null)						styleField.setText(style);				}					updatePreview();			}	
public GeneralOptionPane()		{			super("general");		}	
@Override		protected void _init()		{				/* Line separator */			String[] lineSeps = { jEdit.getProperty("lineSep.unix"),				jEdit.getProperty("lineSep.windows"),				jEdit.getProperty("lineSep.mac") };			lineSeparator = new JComboBox(lineSeps);			String lineSep = jEdit.getProperty("buffer."+ JEditBuffer.LINESEP,				System.getProperty("line.separator"));			if("\n".equals(lineSep))				lineSeparator.setSelectedIndex(0);			else if("\r\n".equals(lineSep))				lineSeparator.setSelectedIndex(1);			else if("\r".equals(lineSep))				lineSeparator.setSelectedIndex(2);			addComponent(jEdit.getProperty("options.general.lineSeparator"),				lineSeparator);					/* Check mod status */			String[] modCheckOptions = {				jEdit.getProperty("options.general.checkModStatus.nothing"),				jEdit.getProperty("options.general.checkModStatus.prompt"),				jEdit.getProperty("options.general.checkModStatus.reload"),				jEdit.getProperty("options.general.checkModStatus.silentReload")			};			checkModStatus = new JComboBox(modCheckOptions);			if(jEdit.getBooleanProperty("autoReload"))			{				if (jEdit.getBooleanProperty("autoReloadDialog"))					// reload and notify					checkModStatus.setSelectedIndex(2);				else	// reload silently					checkModStatus.setSelectedIndex(3);			}			else			{				if (jEdit.getBooleanProperty("autoReloadDialog"))					// prompt					checkModStatus.setSelectedIndex(1);				else	// do nothing					checkModStatus.setSelectedIndex(0);			}			addComponent(jEdit.getProperty("options.general.checkModStatus"),				checkModStatus);				/* Check mod status upon */			String[] modCheckUponOptions = {				jEdit.getProperty("options.general.checkModStatusUpon.focus"),				jEdit.getProperty("options.general.checkModStatusUpon.all"),				jEdit.getProperty("options.general.checkModStatusUpon.operations"),				jEdit.getProperty("options.general.checkModStatusUpon.focusBuffer"),				jEdit.getProperty("options.general.checkModStatusUpon.none")			};			checkModStatusUpon = new JComboBox(modCheckUponOptions);			checkModStatusUpon.setSelectedIndex(jEdit.getIntegerProperty("checkFileStatus"));			addComponent(jEdit.getProperty("options.general.checkModStatusUpon"),				checkModStatusUpon);				/* Recent file list size */			recentFiles = new JTextField(jEdit.getProperty(				"options.general.recentFiles"));			recentFiles.setText(jEdit.getProperty("recentFiles"));			addComponent(jEdit.getProperty("options.general.recentFiles"),				recentFiles);				/* Sort recent file list */			sortRecent = new JCheckBox(jEdit.getProperty(				"options.general.sortRecent"));			sortRecent.setSelected(jEdit.getBooleanProperty("sortRecent"));			addComponent(sortRecent);				/* Save caret positions */			saveCaret = new JCheckBox(jEdit.getProperty(				"options.general.saveCaret"));			saveCaret.setSelected(jEdit.getBooleanProperty("saveCaret"));			addComponent(saveCaret);				/* Persistent markers */			persistentMarkers = new JCheckBox(jEdit.getProperty(				"options.general.persistentMarkers"));			persistentMarkers.setSelected(jEdit.getBooleanProperty(				"persistentMarkers"));			addComponent(persistentMarkers);				/* Session management */			restore = new JCheckBox(jEdit.getProperty(				"options.general.restore"));				restore.setSelected(jEdit.getBooleanProperty("restore"));			restore.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					restoreCLI.setEnabled(restore.isSelected());					restoreRemote.setEnabled(restore.isSelected());				}			});				addComponent(restore);				restoreRemote = new JCheckBox(jEdit.getProperty(				"options.general.restore.remote"));			restoreRemote.setSelected(jEdit.getBooleanProperty("restore.remote", false));			restoreRemote.setEnabled(restore.isSelected());			addComponent(restoreRemote);				restoreCLI = new JCheckBox(jEdit.getProperty(				"options.general.restore.cli"));			restoreCLI.setSelected(jEdit.getBooleanProperty("restore.cli"));			restoreCLI.setEnabled(restore.isSelected());			addComponent(restoreCLI);							hypersearchResultsWarning = new JTextField(jEdit.getProperty("hypersearch.maxWarningResults"));			addComponent(jEdit.getProperty("options.general.hypersearch.maxWarningResults"),				hypersearchResultsWarning);					}	
@Override		protected void _save()		{				String lineSep = null;			switch(lineSeparator.getSelectedIndex())			{			case 0:				lineSep = "\n";				break;			case 1:				lineSep = "\r\n";				break;			case 2:				lineSep = "\r";				break;			}			jEdit.setProperty("buffer."+ JEditBuffer.LINESEP,lineSep);			switch(checkModStatus.getSelectedIndex())			{			case 0:				jEdit.setBooleanProperty("autoReloadDialog",false);				jEdit.setBooleanProperty("autoReload",false);				break;			case 1:				jEdit.setBooleanProperty("autoReloadDialog",true);				jEdit.setBooleanProperty("autoReload",false);				break;			case 2:				jEdit.setBooleanProperty("autoReloadDialog",true);				jEdit.setBooleanProperty("autoReload",true);				break;			case 3:				jEdit.setBooleanProperty("autoReloadDialog",false);				jEdit.setBooleanProperty("autoReload",true);				break;			}			jEdit.setIntegerProperty("checkFileStatus",checkModStatusUpon.getSelectedIndex());			jEdit.setProperty("recentFiles",recentFiles.getText());			jEdit.setBooleanProperty("sortRecent",sortRecent.isSelected());			jEdit.setBooleanProperty("saveCaret",saveCaret.isSelected());			jEdit.setBooleanProperty("persistentMarkers",				persistentMarkers.isSelected());			jEdit.setBooleanProperty("restore",restore.isSelected());			jEdit.setBooleanProperty("restore.cli",restoreCLI.isSelected());			jEdit.setBooleanProperty("restore.remote", restoreRemote.isSelected());			try			{				jEdit.setIntegerProperty("hypersearch.maxWarningResults", Integer.parseInt(hypersearchResultsWarning.getText()));			}			catch (NumberFormatException e)			{				Log.log(Log.WARNING, this, "hypersearchResultsWarning: " + hypersearchResultsWarning.getText() + " is not a valid value for this option");			}		}	
public GlobalOptions(Frame frame)		{			super(frame,"options",jEdit.getProperty("options.last"));		}	
public GlobalOptions(Frame frame, String pane)		{			super(frame,"options",pane);		}	
public GlobalOptions(Dialog dialog)		{			super(dialog,"options",jEdit.getProperty("options.last"));		}	
public GlobalOptions(Dialog dialog, String pane)		{			super(dialog,"options",pane);		}	
protected OptionTreeModel createOptionTreeModel()		{			OptionTreeModel paneTreeModel = new OptionTreeModel();			OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();				// initialize the jEdit branch of the options tree			OptionGroup jEditGroup = new OptionGroup("jedit");				jEditGroup.addOptionPane("general");			jEditGroup.addOptionPane("abbrevs");			jEditGroup.addOptionPane("appearance");			jEditGroup.addOptionPane("context");			jEditGroup.addOptionPane("docking");			jEditGroup.addOptionPane("editing");			jEditGroup.addOptionPane("encodings");			jEditGroup.addOptionPane("gutter");			jEditGroup.addOptionPane("mouse");			jEditGroup.addOptionPane("plugin-manager");			jEditGroup.addOptionPane("print");			jEditGroup.addOptionPane("firewall");			jEditGroup.addOptionPane("save-back");			jEditGroup.addOptionPane("shortcuts");			jEditGroup.addOptionPane("status");			jEditGroup.addOptionPane("syntax");			jEditGroup.addOptionPane("textarea");			jEditGroup.addOptionPane("toolbar");			jEditGroup.addOptionPane("view");			rootGroup.addOptionGroup(jEditGroup);				OptionGroup browserGroup = new OptionGroup("browser");			browserGroup.addOptionPane("browser.general");			browserGroup.addOptionPane("browser.colors");			rootGroup.addOptionGroup(browserGroup);				return paneTreeModel;		}	
@Override		public void cancel()		{			EditBus.send(				new PropertiesChanging(null,					PropertiesChanging.State.CANCELED));			super.cancel();		}	
@Override		protected void init(String name, String pane)		{			EditBus.send(				new PropertiesChanging(null,					PropertiesChanging.State.LOADING));			super.init(name, pane);		}	
protected OptionGroup getDefaultGroup()		{			return null;		}	
public GlobVFSFileFilter(String glob)		{			this.glob = glob;		}	
public boolean accept(VFSFile file)		{			if (file.getType() == VFSFile.DIRECTORY					|| file.getType() == VFSFile.FILESYSTEM)			{				return true;			}			else			{				return accept(file.getName());			}		}	
public boolean accept(String url)		{			if (pattern == null)			{				pattern = Pattern.compile(StandardUtilities.globToRE(glob),							  Pattern.CASE_INSENSITIVE);			}			return pattern.matcher(url).matches();		}	
public String getDescription()		{			return jEdit.getProperty("vfs.browser.file_filter.glob");		}	
public String toString()		{			return glob;		}	
public void setGlob(String glob)		{			this.glob = glob;			pattern = null;		}	
public String getGlob()		{			return glob;		}	
/**		 * @deprecated use {@link org.gjt.sp.jedit.input.AbstractInputHandler#toString(java.awt.event.KeyEvent)}		 */		@Deprecated		public static String toString(KeyEvent evt)		{			return AbstractInputHandler.toString(evt);		}	
/**		 * Create and show a new modal dialog.		 *		 * @param  parent  center dialog on this component.		 * @param  binding  the action/macro that should get a binding.		 * @param  allBindings  all other key bindings.		 * @param  debugBuffer  debug info will be dumped to this buffer		 * (may be null)		 * @since jEdit 4.1pre7		 */		public GrabKeyDialog(Dialog parent, KeyBinding binding,			List<KeyBinding> allBindings, Buffer debugBuffer)		{			super(parent,jEdit.getProperty("grab-key.title"),true);				init(binding,allBindings,debugBuffer);		}	
/**		 * Create and show a new modal dialog.		 *		 * @param  parent  center dialog on this component.		 * @param  binding  the action/macro that should get a binding.		 * @param  allBindings  all other key bindings.		 * @param  debugBuffer  debug info will be dumped to this buffer		 * (may be null)		 * @since jEdit 4.1pre7		 */		public GrabKeyDialog(Frame parent, KeyBinding binding,			List<KeyBinding> allBindings, Buffer debugBuffer)		{			super(parent,jEdit.getProperty("grab-key.title"),true);				init(binding,allBindings,debugBuffer);		}	
/**		 * Returns the shortcut, or null if the current shortcut should be		 * removed or the dialog either has been cancelled. Use isOK()		 * to determine if the latter is true.		 */		public String getShortcut()		{			if(isOK)				return shortcut.getText();			else				return null;		}	
/**		 * Returns true, if the dialog has not been cancelled.		 * @since jEdit 3.2pre9		 */		public boolean isOK()		{			return isOK;		}	
/**		 * Returns if this component can be traversed by pressing the		 * Tab key. This returns false.		 */		public boolean isManagingFocus()		{			return false;		}	
/**		 * Makes the tab key work in Java 1.4.		 * @since jEdit 3.2pre4		 */		@Override		public boolean getFocusTraversalKeysEnabled()		{			return false;		}	
@Override		protected void processKeyEvent(KeyEvent evt)		{			shortcut.processKeyEvent(evt);		}	
private void init(KeyBinding binding, List<KeyBinding> allBindings, Buffer debugBuffer)		{			this.binding = binding;			this.allBindings = allBindings;			this.debugBuffer = debugBuffer;				enableEvents(AWTEvent.KEY_EVENT_MASK);				// create a panel with a BoxLayout. Can't use Box here			// because Box doesn't have setBorder().			JPanel content = new JPanel(new GridLayout(0,1,0,6))			{				/**				 * Makes the tab key work in Java 1.4.				 * @since jEdit 3.2pre4				 */				@Override				public boolean getFocusTraversalKeysEnabled()				{					return false;				}			};			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				JLabel label = new JLabel(				debugBuffer == null ? jEdit.getProperty(				"grab-key.caption",new String[] { binding.label })				: jEdit.getProperty("grab-key.keyboard-test"));				Box input = Box.createHorizontalBox();				shortcut = new InputPane();			Dimension size = shortcut.getPreferredSize();			size.width = Integer.MAX_VALUE;			shortcut.setMaximumSize(size);			input.add(shortcut);			input.add(Box.createHorizontalStrut(12));				clear = new JButton(jEdit.getProperty("grab-key.clear"));			clear.addActionListener(new ActionHandler());			input.add(clear);				assignedTo = new JLabel();			if(debugBuffer == null)				updateAssignedTo(null);				Box buttons = Box.createHorizontalBox();			buttons.add(Box.createGlue());				if(debugBuffer == null)			{				ok = new JButton(jEdit.getProperty("common.ok"));				ok.addActionListener(new ActionHandler());				buttons.add(ok);				buttons.add(Box.createHorizontalStrut(12));					if(binding.isAssigned())				{					// show "remove" button					remove = new JButton(jEdit.getProperty("grab-key.remove"));					remove.addActionListener(new ActionHandler());					buttons.add(remove);					buttons.add(Box.createHorizontalStrut(12));				}			}				cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(new ActionHandler());			buttons.add(cancel);			buttons.add(Box.createGlue());				content.add(label);			content.add(input);			if(debugBuffer == null)				content.add(assignedTo);			content.add(buttons);				setDefaultCloseOperation(DISPOSE_ON_CLOSE);				pack();			setLocationRelativeTo(getParent());			setResizable(false);			setVisible(true);		}	
public static String getSymbolicName(int keyCode)		{			if (Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,GrabKeyDialog.class,"getSymbolicName("+keyCode+").");			}				if(keyCode == KeyEvent.VK_UNDEFINED)				return null;			/* else if(keyCode == KeyEvent.VK_OPEN_BRACKET)				return "[";			else if(keyCode == KeyEvent.VK_CLOSE_BRACKET)				return "]"; */				if(keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)				return String.valueOf(Character.toLowerCase((char)keyCode));				try			{				Field[] fields = KeyEvent.class.getFields();				for(int i = 0; i < fields.length; i++)				{					Field field = fields[i];					String name = field.getName();					if(name.startsWith("VK_")						&& field.getInt(null) == keyCode)					{						return name.substring(3);					}				}			}			catch(Exception e)			{				Log.log(Log.ERROR,GrabKeyDialog.class,e);			}				return null;		}	
private void updateAssignedTo(String shortcut)		{			String text = jEdit.getProperty("grab-key.assigned-to.none");			KeyBinding kb = getKeyBinding(shortcut);				if(kb != null)				if(kb.isPrefix)					text = jEdit.getProperty(						"grab-key.assigned-to.prefix",						new String[] { shortcut });				else					text = kb.label;				if(ok != null)				ok.setEnabled(kb == null || !kb.isPrefix);				assignedTo.setText(				jEdit.getProperty("grab-key.assigned-to",					new String[] { text }));		}	
private KeyBinding getKeyBinding(String shortcut)		{			if(shortcut == null || shortcut.length() == 0)				return null;				String spacedShortcut = shortcut + ' ';				for (KeyBinding kb : allBindings)			{				if (!kb.isAssigned())					continue;					String spacedKbShortcut = kb.shortcut + ' ';					// eg, trying to bind C+n C+p if C+n already bound				if (spacedShortcut.startsWith(spacedKbShortcut))					return kb;					// eg, trying to bind C+e if C+e is a prefix				if (spacedKbShortcut.startsWith(spacedShortcut))				{					// create a temporary (synthetic) prefix					// KeyBinding, that won't be saved					return new KeyBinding(kb.name, kb.label,							      shortcut, true);				}			}				return null;		}	
public KeyBinding(String name, String label,				String shortcut, boolean isPrefix)			{				this.name = name;				this.label = label;				this.shortcut = shortcut;				this.isPrefix = isPrefix;			}	
public boolean isAssigned()			{				return shortcut != null && shortcut.length() > 0;			}	
/**			 * Makes the tab key work in Java 1.4.			 * @since jEdit 3.2pre4			 */			@Override			public boolean getFocusTraversalKeysEnabled()			{				return false;			}	
@Override			protected void processKeyEvent(KeyEvent _evt)			{				KeyEvent evt = KeyEventWorkaround.processKeyEvent(_evt);				if(!KeyEventWorkaround.isBindable(_evt.getKeyCode()))					evt = null;					if(debugBuffer != null)				{					debugBuffer.insert(debugBuffer.getLength(),						"Event " + AbstractInputHandler.toString(_evt)						+ (evt == null ? " filtered\n"						: " passed\n"));				}					if(evt == null)					return;					evt.consume();					KeyEventTranslator.Key key = KeyEventTranslator					.translateKeyEvent(evt);					if (Debug.DUMP_KEY_EVENTS)				{					Log.log(Log.DEBUG,GrabKeyDialog.class,"processKeyEvent() key="+key+", _evt="+_evt+'.');				}					if(key == null)					return;					if(debugBuffer != null)				{					debugBuffer.insert(debugBuffer.getLength(),						"==> Translated to " + key + '\n');				}					StringBuilder keyString = new StringBuilder(getText());					if(getDocument().getLength() != 0)					keyString.append(' ');					if(key.modifiers != null)				{					keyString.append(key.modifiers).append('+');				}					String symbolicName = getSymbolicName(key.key);					if(symbolicName != null)				{					keyString.append(symbolicName);				}				else				{					if (key.input != '\0')					{						if (key.input == ' ')						{							keyString.append("SPACE");						}						else						{							keyString.append(key.input);						}					}					else					{						return;					}				}					setText(keyString.toString());				if(debugBuffer == null)					updateAssignedTo(keyString.toString());			}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == ok)				{					if(canClose())						dispose();				}				else if(evt.getSource() == remove)				{					shortcut.setText(null);					isOK = true;					dispose();				}				else if(evt.getSource() == cancel)					dispose();				else if(evt.getSource() == clear)				{					shortcut.setText(null);					if(debugBuffer == null)						updateAssignedTo(null);					shortcut.requestFocus();				}			}	
private boolean canClose()			{				String shortcutString = shortcut.getText();				if(shortcutString.length() == 0					&& binding.isAssigned())				{					// ask whether to remove the old shortcut					int answer = GUIUtilities.confirm(						GrabKeyDialog.this,						"grab-key.remove-ask",						null,						JOptionPane.YES_NO_OPTION,						JOptionPane.QUESTION_MESSAGE);					if(answer == JOptionPane.YES_OPTION)					{						shortcut.setText(null);						isOK = true;					}					else						return false;				}					// check whether this shortcut already exists				KeyBinding other = getKeyBinding(shortcutString);				if(other == null || other == binding)				{					isOK = true;					return true;				}					// check whether the other shortcut is the alt. shortcut				if(other.name == binding.name)				{					// we don't need two identical shortcuts					GUIUtilities.error(GrabKeyDialog.this,						"grab-key.duplicate-alt-shortcut",						null);					return false;				}					// check whether shortcut is a prefix to others				if(other.isPrefix)				{					// can't override prefix shortcuts					GUIUtilities.error(GrabKeyDialog.this,						"grab-key.prefix-shortcut",						null);					return false;				}					// ask whether to override that other shortcut				int answer = GUIUtilities.confirm(GrabKeyDialog.this,					"grab-key.duplicate-shortcut",					new Object[] { other.label },					JOptionPane.YES_NO_OPTION,					JOptionPane.QUESTION_MESSAGE);				if(answer == JOptionPane.YES_OPTION)				{					if(other.shortcut != null						&& shortcutString.startsWith(other.shortcut))					{						other.shortcut = null;					}					isOK = true;					return true;				}				else					return false;			}	
/**		 * Sets the path where jEdit looks for icons.		 * @since jEdit 4.2pre5		 */		public static void setIconPath(String iconPath)		{			GUIUtilities.iconPath = iconPath;			if(icons != null)				icons.clear();		}	
/**		 * Loads an icon.		 * @param iconName The icon name		 * @since jEdit 2.6pre7		 */		public static Icon loadIcon(String iconName)		{			if(iconName == null)				return null;				// * Enable old icon naming scheme support			if(deprecatedIcons != null && deprecatedIcons.containsKey(iconName))				iconName = deprecatedIcons.get(iconName);				if(icons == null)				icons = new Hashtable<String, Icon>();				// check if there is a cached version first			Icon icon = icons.get(iconName);			if(icon != null)				return icon;				URL url;				try			{				// get the icon				if(MiscUtilities.isURL(iconName))					url = new URL(iconName);				else					url = new URL(iconPath + iconName);			}			catch(Exception e)			{				try				{					url = new URL(defaultIconPath + iconName);				}				catch(Exception ex)				{					Log.log(Log.ERROR,GUIUtilities.class,						"Icon not found: " + iconName);					Log.log(Log.ERROR,GUIUtilities.class,ex);					return null;				}			}				icon = new ImageIcon(url);				icons.put(iconName,icon);			return icon;		}	
/**		 * Returns the default editor window image.		 */		public static Image getEditorIcon()		{			return ((ImageIcon)loadIcon(jEdit.getProperty("logo.icon.medium"))).getImage();		}	
/**		 * Returns the default plugin window image.		 */		public static Image getPluginIcon()		{			return getEditorIcon();		}	
/**		 * Creates a menubar. Plugins should not need to call this method.		 * @param name The menu bar name		 * @since jEdit 3.2pre5		 */		public static JMenuBar loadMenuBar(String name)		{			return loadMenuBar(jEdit.getActionContext(),name);		}	
/**		 * Creates a menubar. Plugins should not need to call this method.		 * @param context An action context		 * @param name The menu bar name		 * @since jEdit 4.2pre1		 */		public static JMenuBar loadMenuBar(ActionContext context, String name)		{			String menus = jEdit.getProperty(name);			StringTokenizer st = new StringTokenizer(menus);				JMenuBar mbar = new JMenuBar();				while(st.hasMoreTokens())			{				String menuName = st.nextToken();				mbar.add(loadMenu(context, menuName));			}				return mbar;		}	
/**		 * Creates a menu. The menu label is set from the		 * <code><i>name</i>.label</code> property. The menu contents is taken		 * from the <code><i>name</i></code> property, which is a whitespace		 * separated list of action names. An action name of <code>-</code>		 * inserts a separator in the menu.		 * @param name The menu name		 * @see #loadMenuItem(String)		 * @since jEdit 2.6pre2		 */		public static JMenu loadMenu(String name)		{			return loadMenu(jEdit.getActionContext(),name);		}	
/**		 * Creates a menu. The menu label is set from the		 * <code><i>name</i>.label</code> property. The menu contents is taken		 * from the <code><i>name</i></code> property, which is a whitespace		 * separated list of action names. An action name of <code>-</code>		 * inserts a separator in the menu.		 * @param context An action context; either		 * <code>jEdit.getActionContext()</code> or		 * <code>VFSBrowser.getActionContext()</code>.		 * @param name The menu name		 * @see #loadMenuItem(String)		 * @since jEdit 4.2pre1		 */		public static JMenu loadMenu(ActionContext context, String name)		{			return new EnhancedMenu(name,				jEdit.getProperty(name.concat(".label")),				context);		}	
/**		 * Creates a popup menu.		 * @param name The menu name		 * @since jEdit 2.6pre2		 */		public static JPopupMenu loadPopupMenu(String name, JEditTextArea textArea, MouseEvent evt)		{			return loadPopupMenu(jEdit.getActionContext(), name, textArea, evt);		}	
/**		 * Creates a popup menu.			 * @param name The menu name		 * @since jEdit 2.6pre2		 */		public static JPopupMenu loadPopupMenu(String name)		{			return loadPopupMenu(jEdit.getActionContext(),name);		}	
/**		 * Creates a popup menu.			 * @param context An action context; either		 * <code>jEdit.getActionContext()</code> or		 * <code>VFSBrowser.getActionContext()</code>.		 * @param name The menu name		 * @since jEdit 4.2pre1		 */		public static JPopupMenu loadPopupMenu(ActionContext context, String name)		{			return loadPopupMenu(context, name, null, null);		}	
/**		 * Creates a popup menu.		 * @param context An action context; either		 * <code>jEdit.getActionContext()</code> or		 * <code>VFSBrowser.getActionContext()</code>.		 * @param name The menu name		 * @param textArea the textArea wanting to show the popup.		 * 	If not null, include context menu items defined by services.		 * @param evt additional context info about where the mouse was when menu was requested		 * @since jEdit 4.3pre15		 */		public static JPopupMenu loadPopupMenu(ActionContext context, String name, JEditTextArea textArea, MouseEvent evt)		{			JPopupMenu menu = new JPopupMenu();				String menuItems = jEdit.getProperty(name);			if(menuItems != null)			{				StringTokenizer st = new StringTokenizer(menuItems);				while(st.hasMoreTokens())				{					String menuItemName = st.nextToken();					if(menuItemName.equals("-"))						menu.addSeparator();					else						menu.add(loadMenuItem(context,menuItemName,false));				}			}			// load menu items defined by services			if (textArea != null)			{				List<JMenuItem> list = GUIUtilities.getServiceContextMenuItems(textArea, evt);				if (!list.isEmpty())				{					menu.addSeparator();				}				for (JMenuItem mi : list)				{					menu.add(mi);				}			}				return menu;		}	
/**		 * @return a list of menu items defined by services.		 *		 * @param textArea the TextArea desiring to display these menu items		 * @since jEdit 4.3pre15		 */		public static List<JMenuItem> getServiceContextMenuItems(JEditTextArea textArea, MouseEvent evt)		{			List<JMenuItem> list = new ArrayList<JMenuItem>();			String serviceClassName =  DynamicContextMenuService.class.getName();			String[] menuServiceList = ServiceManager.getServiceNames(serviceClassName);			for (String menuServiceName : menuServiceList)			{				if (menuServiceName != null && menuServiceName.trim().length() > 0)				{					DynamicContextMenuService dcms = (DynamicContextMenuService)							ServiceManager.getService(serviceClassName, menuServiceName);					if (dcms != null)					{						JMenuItem[] items = dcms.createMenu(textArea, evt);						if (items != null)						{							list.addAll(Arrays.asList(items));						}					}				}			}			return list;		}	
/**		 * Creates a menu item. The menu item is bound to the action named by		 * <code>name</code> with label taken from the return value of the		 * {@link EditAction#getLabel()} method.		 *		 * @param name The menu item name		 * @see #loadMenu(String)		 * @since jEdit 2.6pre1		 */		public static JMenuItem loadMenuItem(String name)		{			return loadMenuItem(jEdit.getActionContext(),name,true);		}	
/**		 * Creates a menu item.		 * @param name The menu item name		 * @param setMnemonic True if the menu item should have a mnemonic		 * @since jEdit 3.1pre1		 */		public static JMenuItem loadMenuItem(String name, boolean setMnemonic)		{			return loadMenuItem(jEdit.getActionContext(),name,setMnemonic);		}	
/**		 * Creates a menu item.		 * @param context An action context; either		 * <code>jEdit.getActionContext()</code> or		 * <code>VFSBrowser.getActionContext()</code>.		 * @param name The menu item name		 * @param setMnemonic True if the menu item should have a mnemonic		 * @since jEdit 4.2pre1		 */		public static JMenuItem loadMenuItem(ActionContext context, String name,			boolean setMnemonic)		{			if(name.charAt(0) == '%')				return loadMenu(context,name.substring(1));				return _loadMenuItem(name, context, setMnemonic);		}	
public static JMenuItem loadMenuItem(EditAction editAction,			boolean setMnemonic)		{			String name = editAction.getName();			ActionContext context = jEdit.getActionContext();				return _loadMenuItem(name, context, setMnemonic);		}	
/**		 * Creates a toolbar.		 * @param name The toolbar name		 * @since jEdit 4.2pre2		 */		public static Container loadToolBar(String name)		{			return loadToolBar(jEdit.getActionContext(),name);		}	
/**		 * Creates a toolbar.		 * @param context An action context; either		 * <code>jEdit.getActionContext()</code> or		 * <code>VFSBrowser.getActionContext()</code>.		 * @param name The toolbar name		 * @since jEdit 4.2pre2		 */		public static Container loadToolBar(ActionContext context, String name)		{			JPanel toolBar = new JPanel(new BorderLayout());			JToolBar toolB = new JToolBar();			toolB.setFloatable(false);			toolB.setMargin(new Insets(0,0,0,0));				String buttons = jEdit.getProperty(name);			if(buttons != null)			{				StringTokenizer st = new StringTokenizer(buttons);				while(st.hasMoreTokens())				{					String button = st.nextToken();					if(button.equals("-"))					{						toolB.addSeparator(new Dimension(12,12));					}					else					{						JButton b = loadToolButton(context,button);						if(b != null)							toolB.add(b);					}				}			}				toolBar.add(toolB);			return toolBar;		}	
/**		 * Loads a tool bar button. The tooltip is constructed from		 * the <code><i>name</i>.label</code> and		 * <code><i>name</i>.shortcut</code> properties and the icon is loaded		 * from the resource named '/org/gjt/sp/jedit/icons/' suffixed		 * with the value of the <code><i>name</i>.icon</code> property.		 * @param name The name of the button		 */		public static EnhancedButton loadToolButton(String name)		{			return loadToolButton(jEdit.getActionContext(),name);		}	
/**		 * Loads a tool bar button. The tooltip is constructed from		 * the <code><i>name</i>.label</code> and		 * <code><i>name</i>.shortcut</code> properties and the icon is loaded		 * from the resource named '/org/gjt/sp/jedit/icons/' suffixed		 * with the value of the <code><i>name</i>.icon</code> property.		 * @param context An action context; either		 * <code>jEdit.getActionContext()</code> or		 * <code>VFSBrowser.getActionContext()</code>.		 * @param name The name of the button		 * @since jEdit 4.2pre1		 */		public static EnhancedButton loadToolButton(ActionContext context,			String name)		{			String label = jEdit.getProperty(name + ".label");				if(label == null)				label = name;				Icon icon;			String iconName = jEdit.getProperty(name + ".icon");			if(iconName == null)				icon = loadIcon(jEdit.getProperty("broken-image.icon"));			else			{				icon = loadIcon(iconName);				if(icon == null)					icon = loadIcon(jEdit.getProperty("broken-image.icon"));			}				String toolTip = prettifyMenuLabel(label);			String shortcutLabel = getShortcutLabel(name);			if(shortcutLabel != null)			{				toolTip = toolTip + " (" + shortcutLabel + ')';			}				EnhancedButton b = new EnhancedButton(icon,toolTip,name,context);			b.setPreferredSize(new Dimension(32,32));			return b;		}	
/**		 * `Prettifies' a menu item label by removing the `$' sign. This		 * can be used to process the contents of an <i>action</i>.label		 * property.		 */		public static String prettifyMenuLabel(String label)		{			int index = label.indexOf('$');			if(index != -1)			{				label = label.substring(0,index)					.concat(label.substring(index + 1));			}			return label;		}	
/**		 * Returns a label string to show users what shortcut are		 * assigned to the action.		 */		public static String getShortcutLabel(String action)		{			if(action == null)				return null;			else			{				String shortcut1 = jEdit.getProperty(action + ".shortcut");				String shortcut2 = jEdit.getProperty(action + ".shortcut2");					if(shortcut1 == null || shortcut1.length() == 0)				{					if(shortcut2 == null || shortcut2.length() == 0)						return null;					else						return shortcut2;				}				else				{					if(shortcut2 == null || shortcut2.length() == 0)						return shortcut1;					else						return shortcut1 + " or " + shortcut2;				}			}		}	
/**		 * Displays a dialog box.		 * The title of the dialog is fetched from		 * the <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property. The message		 * is formatted by the property manager with <code>args</code> as		 * positional parameters.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param args Positional parameters to be substituted into the		 * message text		 */		public static void message(Component comp, String name, Object[] args)		{			hideSplashScreen();				JOptionPane.showMessageDialog(comp,				jEdit.getProperty(name.concat(".message"),args),				jEdit.getProperty(name.concat(".title"),args),				JOptionPane.INFORMATION_MESSAGE);		}	
/**		 * Displays an error dialog box.		 * The title of the dialog is fetched from		 * the <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property. The message		 * is formatted by the property manager with <code>args</code> as		 * positional parameters.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param args Positional parameters to be substituted into the		 * message text		 */		public static void error(Component comp, String name, Object[] args)		{			hideSplashScreen();				JOptionPane.showMessageDialog(comp,				jEdit.getProperty(name.concat(".message"),args),				jEdit.getProperty(name.concat(".title"),args),				JOptionPane.ERROR_MESSAGE);		}	
/**		 * Displays an input dialog box and returns any text the user entered.		 * The title of the dialog is fetched from		 * the <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param def The text to display by default in the input field		 */		public static String input(Component comp, String name, Object def)		{			return input(comp,name,null,def);		}	
/**		 * Displays an input dialog box and returns any text the user entered.		 * The title of the dialog is fetched from		 * the <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param def The property whose text to display in the input field		 */		public static String inputProperty(Component comp, String name,			String def)		{			return inputProperty(comp,name,null,def);		}	
/**		 * Displays an input dialog box and returns any text the user entered.		 * The title of the dialog is fetched from		 * the <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param def The text to display by default in the input field		 * @param args Positional parameters to be substituted into the		 * message text		 * @since jEdit 3.1pre3		 */		public static String input(Component comp, String name,			Object[] args, Object def)		{			hideSplashScreen();				String retVal = (String)JOptionPane.showInputDialog(comp,				jEdit.getProperty(name.concat(".message"),args),				jEdit.getProperty(name.concat(".title")),				JOptionPane.QUESTION_MESSAGE,null,null,def);			return retVal;		}	
/**		 * Displays an input dialog box and returns any text the user entered.		 * The title of the dialog is fetched from		 * the <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param args Positional parameters to be substituted into the		 * message text		 * @param def The property whose text to display in the input field		 * @since jEdit 3.1pre3		 */		public static String inputProperty(Component comp, String name,			Object[] args, String def)		{			hideSplashScreen();				String retVal = (String)JOptionPane.showInputDialog(comp,				jEdit.getProperty(name.concat(".message"),args),				jEdit.getProperty(name.concat(".title")),				JOptionPane.QUESTION_MESSAGE,				null,null,jEdit.getProperty(def));			if(retVal != null)				jEdit.setProperty(def,retVal);			return retVal;		}	
/**		 * Displays a confirm dialog box and returns the button pushed by the		 * user. The title of the dialog is fetched from the		 * <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property.		 * @param comp The component to display the dialog for		 * @param name The name of the dialog		 * @param args Positional parameters to be substituted into the		 * message text		 * @param buttons The buttons to display - for example,		 * JOptionPane.YES_NO_CANCEL_OPTION		 * @param type The dialog type - for example,		 * JOptionPane.WARNING_MESSAGE		 * @since jEdit 3.1pre3		 */		public static int confirm(Component comp, String name,			Object[] args, int buttons, int type)		{			hideSplashScreen();				return JOptionPane.showConfirmDialog(comp,				jEdit.getProperty(name + ".message",args),				jEdit.getProperty(name + ".title"),buttons,type);		}	
/**		 * Displays a confirm dialog box and returns the button pushed by the		 * user. The title of the dialog is fetched from the		 * <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property. The dialog		 * also shows a list of entries given by the <code>listModel</code>		 * parameter.		 * @param comp the parent component		 * @param name the name of the confirm dialog		 * @param args the for the message		 * @param listModel the items in the list		 * @return an integer indicating the option selected by the user		 * @since jEdit 4.3pre1		 */		public static int listConfirm(Component comp, String name, String[] args,			Object[] listModel)		{			JList list = new JList(listModel);			list.setVisibleRowCount(8);				Object[] message = {				jEdit.getProperty(name + ".message",args),				new JScrollPane(list)			};				return JOptionPane.showConfirmDialog(comp,				message,				jEdit.getProperty(name + ".title"),				JOptionPane.YES_NO_OPTION,				JOptionPane.QUESTION_MESSAGE);		}	
/**		 * Displays a confirm dialog box and returns the button pushed by the		 * user. The title of the dialog is fetched from the		 * <code><i>name</i>.title</code> property. The message is fetched		 * from the <code><i>name</i>.message</code> property. The dialog		 * also shows a list of entries given by the <code>listModel</code>		 * parameter.		 * @param comp the parent component		 * @param name the name of the confirm dialog		 * @param args the for the message		 * @param listModel the items in the list		 * @param selectedItems give an empty list, it will contains in return the selected items		 * @return an integer indicating the option selected by the user		 * @since jEdit 4.3pre12		 */		public static int listConfirm(Component comp, String name, String[] args,			Object[] listModel, List selectedItems)		{			JList list = new JList(listModel);			list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);			list.setVisibleRowCount(8);			list.addSelectionInterval(0,listModel.length - 1);				Object[] message = {				jEdit.getProperty(name + ".message",args),				new JScrollPane(list)			};				int ret = JOptionPane.showConfirmDialog(comp,								message,								jEdit.getProperty(name + ".title"),								JOptionPane.YES_NO_OPTION,								JOptionPane.QUESTION_MESSAGE);			Object[] selectedValues = list.getSelectedValues();			selectedItems.addAll(Arrays.asList(selectedValues));			return ret;		}	
/**		 * Displays a VFS file selection dialog box.		 * @param view The view, should be non-null		 * @param path The initial directory to display. May be null		 * @param type The dialog type. One of		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#OPEN_DIALOG},		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#SAVE_DIALOG}, or		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#CHOOSE_DIRECTORY_DIALOG}.		 * @param multipleSelection True if multiple selection should be allowed		 * @return The selected file(s)		 * @since jEdit 2.6pre2		 */		public static String[] showVFSFileDialog(View view, String path,			int type, boolean multipleSelection)		{			// the view should not be null, but some plugins might do this			if(view == null)			{				Log.log(Log.WARNING,GUIUtilities.class,				"showVFSFileDialog(): given null view, assuming jEdit.getActiveView()");				view = jEdit.getActiveView();			}				hideSplashScreen();				VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(				view,path,type,multipleSelection);			return fileChooser.getSelectedFiles();		}	
/**		 * Displays a VFS file selection dialog box.		 * This version can specify a dialog as the parent instead		 * of the view.		 * @param view The view, should be non-null		 * @param path The initial directory to display. May be null		 * @param type The dialog type. One of		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#OPEN_DIALOG},		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#SAVE_DIALOG}, or		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#CHOOSE_DIRECTORY_DIALOG}.		 * @param multipleSelection True if multiple selection should be allowed		 * @return The selected file(s)		 * @since jEdit 4.3pre10		 */		public static String[] showVFSFileDialog(Dialog parent, View view,			String path, int type, boolean multipleSelection)		{			hideSplashScreen();				VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(				parent, view, path, type, multipleSelection, true);			return fileChooser.getSelectedFiles();		}	
/**		 * Displays a VFS file selection dialog box.		 * This version can specify a frame as the parent instead		 * of the view.		 * @param parent The parent frame		 * @param view The view, should be non-null		 * @param path The initial directory to display. May be null		 * @param type The dialog type. One of		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#OPEN_DIALOG},		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#SAVE_DIALOG}, or		 * {@link org.gjt.sp.jedit.browser.VFSBrowser#CHOOSE_DIRECTORY_DIALOG}.		 * @param multipleSelection True if multiple selection should be allowed		 * @return The selected file(s)		 * @since jEdit 4.3pre10		 */		public static String[] showVFSFileDialog(Frame parent, View view,			String path, int type, boolean multipleSelection)		{			hideSplashScreen();			VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(				parent, view, path, type, multipleSelection, true);			return fileChooser.getSelectedFiles();		}	
/**		 * Converts a color name to a color object. The name must either be		 * a known string, such as `red', `green', etc (complete list is in		 * the <code>java.awt.Color</code> class) or a hex color value		 * prefixed with `#', for example `#ff0088'.		 * @param name The color name		 */		public static Color parseColor(String name)		{			return SyntaxUtilities.parseColor(name, Color.black);		}	
/**		 * @deprecated use {@link SyntaxUtilities#parseColor(String,Color)}		 */		@Deprecated		public static Color parseColor(String name, Color defaultColor)		{			return SyntaxUtilities.parseColor(name, defaultColor);		}	
/**		 * Converts a color object to its hex value. The hex value		 * prefixed is with `#', for example `#ff0088'.		 * @param c The color object		 * @deprecated use {@link SyntaxUtilities#parseStyle(String,String,int,boolean)}		 */		@Deprecated		public static String getColorHexString(Color c)		{			return SyntaxUtilities.getColorHexString(c);		}	
/**		 * Converts a style string to a style object.		 * @param str The style string		 * @param family Style strings only specify font style, not font family		 * @param size Style strings only specify font style, not font family		 * @exception IllegalArgumentException if the style is invalid		 * @since jEdit 3.2pre6		 */		public static SyntaxStyle parseStyle(String str, String family, int size)			throws IllegalArgumentException		{			return SyntaxUtilities.parseStyle(str,family,size,true);		}	
/**		 * Converts a style string to a style object.		 * @param str The style string		 * @param family Style strings only specify font style, not font family		 * @param size Style strings only specify font style, not font family		 * @param color If false, the styles will be monochrome		 * @exception IllegalArgumentException if the style is invalid		 * @since jEdit 4.0pre4		 * @deprecated use {@link SyntaxUtilities#parseStyle(String,String,int,boolean)}		 */		@Deprecated		public static SyntaxStyle parseStyle(String str, String family, int size,			boolean color)			throws IllegalArgumentException		{			return SyntaxUtilities.parseStyle(str,family,size,color);		}	
/**		 * Converts a style into it's string representation.		 * @param style The style		 */		public static String getStyleString(SyntaxStyle style)		{			StringBuilder buf = new StringBuilder();				if (style.getForegroundColor() != null)			{				buf.append("color:").append(SyntaxUtilities.getColorHexString(style.getForegroundColor()));			}				if (style.getBackgroundColor() != null)			{				buf.append(" bgColor:").append(SyntaxUtilities.getColorHexString(style.getBackgroundColor()));			}				Font font = style.getFont();			if (!font.isPlain())			{				buf.append(" style:");				if (font.isItalic())					buf.append('i');				if (font.isBold())					buf.append('b');			}				return buf.toString();		}	
/**		 * Loads the syntax styles from the properties, giving them the specified		 * base font family and size.		 * @param family The font family		 * @param size The font size		 * @since jEdit 3.2pre6		 * @deprecated use {@link SyntaxUtilities#loadStyles(String,int)}		 */		@Deprecated		public static SyntaxStyle[] loadStyles(String family, int size)		{			return SyntaxUtilities.loadStyles(family,size,true);		}	
/**		 * Loads the syntax styles from the properties, giving them the specified		 * base font family and size.		 * @param family The font family		 * @param size The font size		 * @param color If false, the styles will be monochrome		 * @since jEdit 4.0pre4		 * @deprecated use {@link SyntaxUtilities#loadStyles(String,int,boolean)}		 */		@Deprecated		public static SyntaxStyle[] loadStyles(String family, int size, boolean color)		{			return SyntaxUtilities.loadStyles(family, size, color);		}	
/**		 * Loads a windows's geometry from the properties.		 * The geometry is loaded from the <code><i>name</i>.x</code>,		 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and		 * <code><i>name</i>.height</code> properties.		 *		 * @param win The window to load geometry from		 * @param parent The parent frame to be relative to.		 * @param name The name of the window		 */		public static void loadGeometry(Window win, Container parent, String name )		{			Dimension size = win.getSize();			int width = jEdit.getIntegerProperty(name + ".width", size.width);			int height = jEdit.getIntegerProperty(name + ".height", size.height);			int x = jEdit.getIntegerProperty(name + ".x",50);			int y = jEdit.getIntegerProperty(name + ".y",50);			if(parent != null)			{				Point location = parent.getLocation();				x = location.x + x;				y = location.y + y;			}				int extState = jEdit.getIntegerProperty(name + ".extendedState", Frame.NORMAL);				Rectangle desired = new Rectangle(x,y,width,height);			try			{				if(!Debug.DISABLE_MULTIHEAD)					adjustForScreenBounds(desired);			}			catch(Exception e)			{				/* Workaround for OS X bug. */				Log.log(Log.ERROR,GUIUtilities.class,e);			}				if(OperatingSystem.isX11() && Debug.GEOMETRY_WORKAROUND)				new UnixWorkaround(win,name,desired,extState);			else			{				win.setBounds(desired);				if(win instanceof Frame)					((Frame)win).setExtendedState(extState);			}			}	
/**		 * Loads a windows's geometry from the properties.		 * The geometry is loaded from the <code><i>name</i>.x</code>,		 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and		 * <code><i>name</i>.height</code> properties.		 *		 * @param win The window to load geometry from		 * @param name The name of the window		 */		public static void loadGeometry(Window win, String name)		{			loadGeometry(win, win.getParent(), name);		}	
/**		 * Gives a rectangle the specified bounds, ensuring it is within the		 * screen bounds.		 * @since jEdit 4.2pre3		 */		public static void adjustForScreenBounds(Rectangle desired)		{			// Make sure the window is displayed in visible region			Rectangle osbounds = OperatingSystem.getScreenBounds(desired);				if (desired.width > osbounds.width)			{				desired.width = osbounds.width;			}			if (desired.x < osbounds.x)			{				desired.x = osbounds.x;			}			if (desired.x + desired.width > osbounds.x + osbounds.width)			{				desired.x = osbounds.x + osbounds.width - desired.width;			}			if (desired.height > osbounds.height)			{				desired.height = osbounds.height;			}			if (desired.y < osbounds.y)			{				desired.y = osbounds.y;			}			if (desired.y + desired.height > osbounds.y + osbounds.height)			{				desired.y = osbounds.y + osbounds.height - desired.height;			}		}	
public UnixWorkaround(Window win, String name, Rectangle desired,				int extState)			{				this.win = win;				this.name = name;				this.desired = desired;					int adjust_x = jEdit.getIntegerProperty(name + ".dx",0);				int adjust_y = jEdit.getIntegerProperty(name + ".dy",0);				int adjust_width = jEdit.getIntegerProperty(name + ".d-width",0);				int adjust_height = jEdit.getIntegerProperty(name + ".d-height",0);					required = new Rectangle(					desired.x - adjust_x,					desired.y - adjust_y,					desired.width - adjust_width,					desired.height - adjust_height);					Log.log(Log.DEBUG,GUIUtilities.class,"Window " + name					+ ": desired geometry is " + desired);				Log.log(Log.DEBUG,GUIUtilities.class,"Window " + name					+ ": setting geometry to " + required);					start = System.currentTimeMillis();					win.setBounds(required);				if(win instanceof Frame)					((Frame)win).setExtendedState(extState);					win.addComponentListener(new ComponentHandler());				win.addWindowListener(new WindowHandler());			}	
@Override				public void componentMoved(ComponentEvent evt)				{					if(System.currentTimeMillis() - start < 1000L)					{						Rectangle r = win.getBounds();						if(!windowOpened && r.equals(required))							return;							if(!r.equals(desired))						{							Log.log(Log.DEBUG,GUIUtilities.class,								"Window resize blocked: " + win.getBounds());							win.setBounds(desired);						}					}						win.removeComponentListener(this);				}	
@Override				public void componentResized(ComponentEvent evt)				{					if(System.currentTimeMillis() - start < 1000L)					{						Rectangle r = win.getBounds();						if(!windowOpened && r.equals(required))							return;							if(!r.equals(desired))						{							Log.log(Log.DEBUG,GUIUtilities.class,								"Window resize blocked: " + win.getBounds());							win.setBounds(desired);						}					}						win.removeComponentListener(this);				}	
@Override				public void windowOpened(WindowEvent evt)				{					windowOpened = true;						Rectangle r = win.getBounds();					Log.log(Log.DEBUG,GUIUtilities.class,"Window "						+ name + ": bounds after opening: " + r);						jEdit.setIntegerProperty(name + ".dx",						r.x - required.x);					jEdit.setIntegerProperty(name + ".dy",						r.y - required.y);					jEdit.setIntegerProperty(name + ".d-width",						r.width - required.width);					jEdit.setIntegerProperty(name + ".d-height",						r.height - required.height);						win.removeWindowListener(this);				}	
/**		 * Saves a window's geometry to the properties.		 * The geometry is saved to the <code><i>name</i>.x</code>,		 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and		 * <code><i>name</i>.height</code> properties.<br />		 * For Frame's and descendents use {@link #addSizeSaver(Frame,String)} to save the sizes		 * correct even if the Frame is in maximized or iconified state.		 * @param win The window to load geometry from		 * @param name The name of the window		 * @see #addSizeSaver(Frame,String)		 */		public static void saveGeometry(Window win, String name)		{			saveGeometry (win, win.getParent(), name);		}	
/**		 * Saves a window's geometry to the properties.		 * The geometry is saved to the <code><i>name</i>.x</code>,		 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and		 * <code><i>name</i>.height</code> properties.<br />		 * For Frame's and descendents use {@link #addSizeSaver(Frame,Container,String)} to save the sizes		 * correct even if the Frame is in maximized or iconified state.		 * @param win The window to load geometry from		 * @param parent The parent frame to be relative to.		 * @param name The name of the window		 * @see #addSizeSaver(Frame,Container,String)		 */		public static void saveGeometry(Window win, Container parent, String name)		{			if(win instanceof Frame)			{				jEdit.setIntegerProperty(name + ".extendedState",					((Frame)win).getExtendedState());			}				Rectangle bounds = win.getBounds();			int x = bounds.x;			int y = bounds.y;			if (parent != null)			{				Rectangle parentBounds = parent.getBounds();				x -= parentBounds.x;				y -= parentBounds.y;			}			jEdit.setIntegerProperty(name + ".x",x);			jEdit.setIntegerProperty(name + ".y",y);			jEdit.setIntegerProperty(name + ".width", bounds.width);			jEdit.setIntegerProperty(name + ".height", bounds.height);		}	
/**		 * Centers the given window on the screen. This method is needed because		 * JDK 1.3 does not have a <code>JWindow.setLocationRelativeTo()</code>		 * method.		 * @since jEdit 4.2pre3		 * @deprecated use {@link javax.swing.JWindow#setLocationRelativeTo(java.awt.Component)}		 */		@Deprecated		public static void centerOnScreen(Window win)		{			GraphicsDevice gd = GraphicsEnvironment				.getLocalGraphicsEnvironment()				.getDefaultScreenDevice();			Rectangle gcbounds = gd.getDefaultConfiguration().getBounds();			int x = gcbounds.x + (gcbounds.width - win.getWidth()) / 2;			int y = gcbounds.y + (gcbounds.height - win.getHeight()) / 2;			win.setLocation(x,y);		}	
/**		 * Ensures that the splash screen is not visible. This should be		 * called before displaying any dialog boxes or windows at		 * startup.		 */		public static void hideSplashScreen()		{			if(splash != null)			{				splash.dispose();				splash = null;			}		}	
/**		 * Creates a component that displays a multiple line message. This		 * is implemented by assembling a number of <code>JLabels</code> in		 * a <code>JPanel</code>.		 * @param str The string, with lines delimited by newline		 * (<code>\n</code>) characters.		 * @since jEdit 4.1pre3		 */		public static JComponent createMultilineLabel(String str)		{			JPanel panel = new JPanel(new VariableGridLayout(				VariableGridLayout.FIXED_NUM_COLUMNS,1,1,1));			int lastOffset = 0;			while(true)			{				int index = str.indexOf('\n',lastOffset);				if(index == -1)					break;				else				{					panel.add(new JLabel(str.substring(lastOffset,index)));					lastOffset = index + 1;				}			}				if(lastOffset != str.length())				panel.add(new JLabel(str.substring(lastOffset)));				return panel;		}	
/**		 * Focuses on the specified component as soon as the window becomes		 * active.		 * @param win The window		 * @param comp The component		 */		public static void requestFocus(final Window win, final Component comp)		{			win.addWindowFocusListener(new WindowAdapter()			{				@Override				public void windowGainedFocus(WindowEvent evt)				{					SwingUtilities.invokeLater(new Runnable()					{							public void run()							{								comp.requestFocusInWindow();							}					});					win.removeWindowFocusListener(this);				}			});		}	
/**		 * Returns if the specified event is the popup trigger event.		 * This implements precisely defined behavior, as opposed to		 * MouseEvent.isPopupTrigger().		 * @param evt The event		 * @since jEdit 3.2pre8		 */		public static boolean isPopupTrigger(MouseEvent evt)		{			return TextAreaMouseHandler.isRightButton(evt.getModifiers());		}	
/**		 * @param modifiers The modifiers flag from a mouse event		 * @since jEdit 4.1pre9		 */		public static boolean isMiddleButton(int modifiers)		{			return TextAreaMouseHandler.isMiddleButton(modifiers);		}	
/**		 * @param modifiers The modifiers flag from a mouse event		 * @since jEdit 4.1pre9		 */		public static boolean isRightButton(int modifiers)		{			return TextAreaMouseHandler.isRightButton(modifiers);		}	
/**		 * Returns the screen bounds, taking into account multi-screen		 * environments.		 * @since jEdit 4.3pre18		 */		public static Rectangle getScreenBounds()		{			Rectangle bounds = GraphicsEnvironment.getLocalGraphicsEnvironment().				getMaximumWindowBounds();			GraphicsDevice [] devices = GraphicsEnvironment.				getLocalGraphicsEnvironment().getScreenDevices();			if (devices.length > 1)			{				for (GraphicsDevice device: devices)				{					for (GraphicsConfiguration config: device.getConfigurations())						bounds = bounds.union(config.getBounds());				}			}			return bounds;		}	
/**		 * Shows the specified popup menu, ensuring it is displayed within		 * the bounds of the screen.		 * @param popup The popup menu		 * @param comp The component to show it for		 * @param x The x co-ordinate		 * @param y The y co-ordinate		 * @since jEdit 4.0pre1		 * @see javax.swing.JComponent#setComponentPopupMenu(javax.swing.JPopupMenu) setComponentPopupMenu		 * which works better and is simpler to use: you don't have to write the code to		 * show/hide popups in response to mouse events anymore.		 */		public static void showPopupMenu(JPopupMenu popup, Component comp,			int x, int y)		{			showPopupMenu(popup,comp,x,y,true);		}	
/**		 * Shows the specified popup menu, ensuring it is displayed within		 * the bounds of the screen.		 * @param popup The popup menu		 * @param comp The component to show it for		 * @param x The x co-ordinate		 * @param y The y co-ordinate		 * @param point If true, then the popup originates from a single point;		 * otherwise it will originate from the component itself. This affects		 * positioning in the case where the popup does not fit onscreen.		 *		 * @since jEdit 4.1pre1		 */		public static void showPopupMenu(JPopupMenu popup, Component comp,			int x, int y, boolean point)		{			int offsetX = 0;			int offsetY = 0;				int extraOffset = point ? 1 : 0;				Component win = comp;			while(!(win instanceof Window || win == null))			{				offsetX += win.getX();				offsetY += win.getY();				win = win.getParent();			}				if(win != null)			{				Dimension size = popup.getPreferredSize();					Rectangle screenSize = getScreenBounds();					if(x + offsetX + size.width + win.getX() > screenSize.width					&& x + offsetX + win.getX() >= size.width)				{					//System.err.println("x overflow");					if(point)						x -= size.width + extraOffset;					else						x = win.getWidth() - size.width - offsetX + extraOffset;				}				else				{					x += extraOffset;				}					//System.err.println("y=" + y + ",offsetY=" + offsetY				//	+ ",size.height=" + size.height				//	+ ",win.height=" + win.getHeight());				if(y + offsetY + size.height + win.getY() > screenSize.height					&& y + offsetY + win.getY() >= size.height)				{					if(point)						y = win.getHeight() - size.height - offsetY + extraOffset;					else						y = -size.height - 1;				}				else				{					y += extraOffset;				}					popup.show(comp,x,y);			}			else				popup.show(comp,x + extraOffset,y + extraOffset);			}	
/**		 * Returns if the first component is an ancestor of the		 * second by traversing up the component hierarchy.		 *		 * @param comp1 The ancestor		 * @param comp2 The component to check		 * @since jEdit 4.1pre5		 */		public static boolean isAncestorOf(Component comp1, Component comp2)		{			while(comp2 != null)			{				if(comp1 == comp2)					return true;				else					comp2 = comp2.getParent();			}				return false;		}	
/**		 * Traverses the given component's parent tree looking for an		 * instance of JDialog, and return it. If not found, return null.		 * @param c The component		 */		public static JDialog getParentDialog(Component c)		{			return (JDialog) SwingUtilities.getAncestorOfClass(JDialog.class, c);		}	
/**		 * Finds a parent of the specified component.		 * @param comp The component		 * @param clazz Looks for a parent with this class (exact match, not		 * derived).		 * @since jEdit 4.2pre1		 */		public static Component getComponentParent(Component comp, Class clazz)		{			while(true)			{				if(comp == null)					break;					if(comp instanceof JComponent)				{					Component real = (Component)((JComponent)comp)						.getClientProperty("KORTE_REAL_FRAME");					if(real != null)						comp = real;				}					if(comp.getClass().equals(clazz))					return comp;				else if(comp instanceof JPopupMenu)					comp = ((JPopupMenu)comp).getInvoker();				else if(comp instanceof FloatingWindowContainer)				{					comp = ((FloatingWindowContainer)comp)						.getDockableWindowManager();				}				else					comp = comp.getParent();			}			return null;		}	
/**		 * Call setEnabled() recursively on the container and its descendants.		 * @param c The container		 * @param enabled The enabled state to set		 * @since jEdit 4.3pre17		 */		public static void setEnabledRecursively(Container c, boolean enabled)		{			for (Component child: c.getComponents())			{				if (child instanceof Container)					setEnabledRecursively((Container)child, enabled);				else					child.setEnabled(enabled);			}			c.setEnabled(enabled);		}	
/**		 * Finds the view parent of the specified component.		 * @since jEdit 4.0pre2		 */		public static View getView(Component comp)		{			return (View)getComponentParent(comp,View.class);		}	
/**		* Adds a SizeSaver to the specified Frame. For non-Frame's use {@link #saveGeometry(Window,String)}		 *		 * @param frame The Frame for which to save the size		 * @param name The prefix for the settings		 * @since jEdit 4.3pre6		 * @see #saveGeometry(Window,String)		 */		public static void addSizeSaver(Frame frame, String name)		{			addSizeSaver(frame,frame.getParent(),name);		}	
/**		 * Adds a SizeSaver to the specified Frame. For non-Frame's use {@link #saveGeometry(Window,Container,String)}		 *		 * @param frame The Frame for which to save the size		 * @param parent The parent to be relative to		 * @param name The prefix for the settings		 * @since jEdit 4.3pre7		 * @see #saveGeometry(Window,Container,String)		 */		public static void addSizeSaver(Frame frame, Container parent, String name)		{			SizeSaver ss = new SizeSaver(frame,parent,name);			frame.addWindowStateListener(ss);			frame.addComponentListener(ss);		}	
/**		 * Init the continuous layout flag using the jEdit's property		 * appearance.continuousLayout		 *		 * @param split the split. It must never be null		 * @since jEdit 4.3pre9		 */		public static void initContinuousLayout(JSplitPane split)		{			boolean continuousLayout = split.isContinuousLayout();			if (continuousLayout != jEdit.getBooleanProperty("appearance.continuousLayout"))				split.setContinuousLayout(!continuousLayout);		}	
/**		 * Initializes a list of mappings between old icon names and new names		 */		private static void initializeDeprecatedIcons()		{			deprecatedIcons.put("File.png",       "16x16/mimetypes/text-x-generic.png");			deprecatedIcons.put("Folder.png",     "16x16/places/folder.png");			deprecatedIcons.put("OpenFolder.png", "16x16/status/folder-open.png");			deprecatedIcons.put("OpenFile.png",   "16x16/actions/edit-select-all.png");			deprecatedIcons.put("ReloadSmall.png","16x16/actions/view-refresh.png");			deprecatedIcons.put("DriveSmall.png", "16x16/devices/drive-harddisk.png");			deprecatedIcons.put("New.png",        "22x22/actions/document-new.png");			deprecatedIcons.put("NewDir.png",     "22x22/actions/folder-new.png");			deprecatedIcons.put("Reload.png",     "22x22/actions/view-refresh.png");			deprecatedIcons.put("Load.png",       "22x22/places/plugins.png");			deprecatedIcons.put("Save.png",       "22x22/actions/document-save.png");			deprecatedIcons.put("SaveAs.png",     "22x22/actions/document-save-as.png");			deprecatedIcons.put("SaveAll.png",    "22x22/actions/document-save-all.png");			deprecatedIcons.put("Open.png",       "22x22/actions/document-open.png");			deprecatedIcons.put("Print.png",      "22x22/actions/document-print.png");			deprecatedIcons.put("Drive.png",      "22x22/devices/drive-harddisk.png");			deprecatedIcons.put("Clear.png",      "22x22/actions/edit-clear.png");			deprecatedIcons.put("Run.png",        "22x22/actions/application-run.png");			deprecatedIcons.put("RunAgain.png",   "22x22/actions/application-run-again.png");			deprecatedIcons.put("RunToBuffer.png",  "22x22/actions/run-to-buffer.png");			deprecatedIcons.put("CopyToBuffer.png", "22x22/actions/copy-to-buffer.png");			deprecatedIcons.put("Plus.png",       "22x22/actions/list-add.png");			deprecatedIcons.put("Minus.png",      "22x22/actions/list-remove.png");			deprecatedIcons.put("Find.png",       "22x22/actions/edit-find.png");			deprecatedIcons.put("FindAgain.png",  "22x22/actions/edit-find-next.png");			deprecatedIcons.put("FindInDir.png",  "22x22/actions/edit-find-in-folder.png");			deprecatedIcons.put("Parse.png",      "22x22/actions/document-reload2.png");			deprecatedIcons.put("Delete.png",     "22x22/actions/edit-delete.png");			deprecatedIcons.put("Paste.png",      "22x22/actions/edit-paste.png");			deprecatedIcons.put("Cut.png",        "22x22/actions/edit-cut.png");			deprecatedIcons.put("Copy.png",       "22x22/actions/edit-copy.png");			deprecatedIcons.put("Undo.png",       "22x22/actions/edit-undo.png");			deprecatedIcons.put("Redo.png",       "22x22/actions/edit-redo.png");			deprecatedIcons.put("CurrentDir.png", "22x22/status/folder-visiting.png");			deprecatedIcons.put("ParentDir.png",  "22x22/actions/go-parent.png");			deprecatedIcons.put("PageSetup.png",  "22x22/actions/printer-setup.png");			deprecatedIcons.put("Plugins.png",    "22x22/apps/system-installer.png");			deprecatedIcons.put("Floppy.png",     "22x22/devices/media-floppy.png");			deprecatedIcons.put("Stop.png",       "22x22/actions/process-stop.png");			deprecatedIcons.put("Cancel.png",     "22x22/actions/process-stop.png");			deprecatedIcons.put("Home.png",       "22x22/actions/go-home.png");			deprecatedIcons.put("Help.png",       "22x22/apps/help-browser.png");			deprecatedIcons.put("Properties.png", "22x22/actions/document-properties.png");			deprecatedIcons.put("Preferences.png","22x22/categories/preferences-system.png");			deprecatedIcons.put("ZoomIn.png",     "22x22/actions/zoom-in.png");			deprecatedIcons.put("ZoomOut.png",    "22x22/actions/zoom-out.png");			deprecatedIcons.put("BrokenImage.png","22x22/status/image-missing.png");			deprecatedIcons.put("AdjustWidth.png","22x22/actions/resize-horisontal.png");			deprecatedIcons.put("ToolbarMenu.gif","ToolbarMenu.gif");				deprecatedIcons.put("Play.png","22x22/actions/media-playback-start.png");			deprecatedIcons.put("Pause.png","22x22/actions/media-playback-pause.png");				deprecatedIcons.put("MultipleResults.png", "22x22/actions/edit-find-multiple.png");			deprecatedIcons.put("SingleResult.png",    "22x22/actions/edit-find-single.png");				deprecatedIcons.put("NextFile.png",    "22x22/go-last.png");			deprecatedIcons.put("PreviousFile.png","22x22/go-first.png");				deprecatedIcons.put("closebox.gif",   "10x10/actions/close.png");			deprecatedIcons.put("normal.gif",   "10x10/status/document-unmodified.png");			deprecatedIcons.put("readonly.gif",   "10x10/emblem/emblem-readonly.png");			deprecatedIcons.put("dirty.gif",    "10x10/status/document-modified.png");			deprecatedIcons.put("new.gif",    "10x10/status/document-new.png");				deprecatedIcons.put("ArrowU.png", "22x22/actions/go-up.png");			deprecatedIcons.put("ArrowR.png", "22x22/actions/go-next.png");			deprecatedIcons.put("ArrowD.png", "22x22/actions/go-down.png");			deprecatedIcons.put("ArrowL.png", "22x22/actions/go-previous.png");			deprecatedIcons.put("arrow1.png", "16x16/actions/group-expand.png");			deprecatedIcons.put("arrow2.png", "16x16/actions/group-collapse.png");				deprecatedIcons.put("NewView.png", "22x22/actions/window-new.png");			deprecatedIcons.put("UnSplit.png", "22x22/actions/window-unsplit.png");			deprecatedIcons.put("SplitVertical.png", "22x22/actions/window-split-vertical.png");			deprecatedIcons.put("SplitHorizontal.png", "22x22/actions/window-split-horizontal.png");				deprecatedIcons.put("ButtonProperties.png", "22x22/actions/document-properties.png");			}	
static void init()		{			initializeDeprecatedIcons();				// Load the icon theme but fallback on the old icons			String theme = jEdit.getProperty("icon-theme", "tango");			Log.log(Log.DEBUG, GUIUtilities.class, "Icon theme set to: "+theme);			setIconPath("jeditresource:/org/gjt/sp/jedit/icons/themes/" + theme + '/');			Log.log(Log.DEBUG, GUIUtilities.class, "Loading icon theme from: "+iconPath);				// don't do this in static{} since we need jEdit.initMisc()			// run first so we have the jeditresource: protocol			NEW_BUFFER_ICON = loadIcon("new.gif");			DIRTY_BUFFER_ICON = loadIcon("dirty.gif");			READ_ONLY_BUFFER_ICON = loadIcon("readonly.gif");			NORMAL_BUFFER_ICON = loadIcon("normal.gif");			WINDOW_ICON = loadIcon(jEdit.getProperty("logo.icon.medium"));		}	
static void showSplashScreen()		{			splash = new SplashScreen();		}	
static void advanceSplashProgress()		{			if(splash != null)				splash.advance();		}	
static void advanceSplashProgress(String label)		{			if(splash != null)				splash.advance(label);		}	
private static JMenuItem _loadMenuItem(String name, ActionContext context, boolean setMnemonic)		{				String label = jEdit.getProperty(name + ".label");			if (label == null)			{				label = name;			}			char mnemonic;			int index = label.indexOf('$');			if (index != -1 && label.length() - index > 1)			{				mnemonic = Character.toLowerCase(label.charAt(index + 1));				label = label.substring(0, index).concat(label.substring(++index));			}			else			{				mnemonic = '\0';			}			JMenuItem mi;			if (jEdit.getBooleanProperty(name + ".toggle"))			{				mi = new EnhancedCheckBoxMenuItem(label, name, context);			}			else			{				mi = new EnhancedMenuItem(label, name, context);			}			if (!OperatingSystem.isMacOS() && setMnemonic && mnemonic != '\0')			{				mi.setMnemonic(mnemonic);			}			Icon itemIcon = loadIcon(jEdit.getProperty(name + ".icon.small"));			if(itemIcon != null)			{				mi.setIcon(itemIcon);			}				return mi;		}	
private GUIUtilities() {}	
/**			 * Constructs a new SizeSaver.			 *			 * @param frame The Frame for which to save the size			 * @param parent The parent to be relative to.			 * @param name The prefix for the settings			 */			SizeSaver(Frame frame, Container parent, String name)			{				if (frame == null || name == null)				{					throw new NullPointerException();				}				this.frame = frame;				this.parent = parent;				this.name = name;			}	
public void windowStateChanged(WindowEvent wse)			{				int extendedState = wse.getNewState();				jEdit.setIntegerProperty(name + ".extendedState",extendedState);				Rectangle bounds = frame.getBounds();				save(extendedState, bounds);			}	
private void save(int extendedState, Rectangle bounds)			{				switch (extendedState)				{					case Frame.MAXIMIZED_VERT:						jEdit.setIntegerProperty(name + ".x",bounds.x);						jEdit.setIntegerProperty(name + ".width",bounds.width);						break;						case Frame.MAXIMIZED_HORIZ:						jEdit.setIntegerProperty(name + ".y",bounds.y);						jEdit.setIntegerProperty(name + ".height",bounds.height);						break;						case Frame.NORMAL:						saveGeometry(frame,parent,name );						break;				}			}	
@Override			public void componentResized(ComponentEvent ce)			{				componentMoved(ce);			}	
@Override			public void componentMoved(ComponentEvent ce)			{				final Rectangle bounds = frame.getBounds();				final Runnable sizeSaver = new Runnable()				{					public void run()					{						int extendedState = frame.getExtendedState();						save(extendedState, bounds);					}				};				new Thread("Sizesavingdelay")				{					@Override					public void run()					{						try						{							Thread.sleep(500L);						}						catch (InterruptedException ie)						{						}						SwingUtilities.invokeLater(sizeSaver);					}				}.start();			}	
public void setFoldPainter(FoldPainter painter)		{			if (painter == null)				foldPainter = new TriangleFoldPainter();			else				foldPainter = painter;		}	
public Gutter(TextArea textArea)		{			this.textArea = textArea;			enabled = true;			selectionAreaEnabled = true;			selectionAreaWidth = SELECTION_GUTTER_WIDTH;				setAutoscrolls(true);			setOpaque(true);			setRequestFocusEnabled(false);				extensionMgr = new ExtensionManager();				mouseHandler = new MouseHandler();			addMouseListener(mouseHandler);			addMouseMotionListener(mouseHandler);				bufferListener = new BufferAdapter()			{				public void bufferLoaded(JEditBuffer buffer)				{					updateLineNumberWidth();				}					public void contentInserted(JEditBuffer buffer, int startLine,						int offset, int numLines, int length)				{					updateLineNumberWidth();				}					public void contentRemoved(JEditBuffer buffer, int startLine,						int offset, int numLines, int length) 				{					updateLineNumberWidth();				}			};				updateBorder();			setFoldPainter(textArea.getFoldPainter());		}	
public void paintComponent(Graphics _gfx)		{			Graphics2D gfx = (Graphics2D)_gfx;			gfx.setRenderingHints(textArea.getPainter().renderingHints);			// fill the background			Rectangle clip = gfx.getClipBounds();			gfx.setColor(getBackground());			int bgColorWidth = isSelectionAreaEnabled() ? FOLD_MARKER_SIZE :				clip.width; 			gfx.fillRect(clip.x, clip.y, bgColorWidth, clip.height);			if (isSelectionAreaEnabled())			{				if (selectionAreaBgColor == null)					selectionAreaBgColor = getBackground();				gfx.setColor(selectionAreaBgColor);				gfx.fillRect(clip.x + FOLD_MARKER_SIZE, clip.y,					clip.width - FOLD_MARKER_SIZE, clip.height);			}			// if buffer is loading, don't paint anything			if (textArea.getBuffer().isLoading())				return;				int lineHeight = textArea.getPainter().getFontMetrics()				.getHeight();				if(lineHeight == 0)				return;				int firstLine = clip.y / lineHeight;			int lastLine = (clip.y + clip.height - 1) / lineHeight;				if(lastLine - firstLine > textArea.getVisibleLines())			{				Log.log(Log.ERROR,this,"BUG: firstLine=" + firstLine);				Log.log(Log.ERROR,this,"     lastLine=" + lastLine);				Log.log(Log.ERROR,this,"     visibleLines=" + textArea.getVisibleLines());				Log.log(Log.ERROR,this,"     height=" + getHeight());				Log.log(Log.ERROR,this,"     painter.height=" + textArea.getPainter().getHeight());				Log.log(Log.ERROR,this,"     clip.y=" + clip.y);				Log.log(Log.ERROR,this,"     clip.height=" + clip.height);				Log.log(Log.ERROR,this,"     lineHeight=" + lineHeight);			}					int y = clip.y - clip.y % lineHeight;				extensionMgr.paintScreenLineRange(textArea,gfx,				firstLine,lastLine,y,lineHeight);				for (int line = firstLine; line <= lastLine;				line++, y += lineHeight)			{				paintLine(gfx,line,y);			}		}	
/**		 * Adds a text area extension, which can perform custom painting and		 * tool tip handling.		 * @param extension The extension		 * @since jEdit 4.0pre4		 */		public void addExtension(TextAreaExtension extension)		{			extensionMgr.addExtension(DEFAULT_LAYER,extension);			repaint();		}	
/**		 * Adds a text area extension, which can perform custom painting and		 * tool tip handling.		 * @param layer The layer to add the extension to. Note that more than		 * extension can share the same layer.		 * @param extension The extension		 * @since jEdit 4.0pre4		 */		public void addExtension(int layer, TextAreaExtension extension)		{			extensionMgr.addExtension(layer,extension);			repaint();		}	
/**		 * Removes a text area extension. It will no longer be asked to		 * perform custom painting and tool tip handling.		 * @param extension The extension		 * @since jEdit 4.0pre4		 */		public void removeExtension(TextAreaExtension extension)		{			extensionMgr.removeExtension(extension);			repaint();		}	
/**		 * Returns an array of registered text area extensions. Useful for		 * debugging purposes.		 * @since jEdit 4.1pre5		 */		public TextAreaExtension[] getExtensions()		{			return extensionMgr.getExtensions();		}	
/**		 * Returns the tool tip to display at the specified location.		 * @param evt The mouse event		 */		public String getToolTipText(MouseEvent evt)		{			if(textArea.getBuffer().isLoading())				return null;				return extensionMgr.getToolTipText(evt.getX(),evt.getY());		}	
/**		 * Convenience method for setting a default matte border on the right		 * with the specified border width and color		 * @param width The border width (in pixels)		 * @param color1 The focused border color		 * @param color2 The unfocused border color		 * @param color3 The gutter/text area gap color		 */		public void setBorder(int width, Color color1, Color color2, Color color3)		{			borderWidth = width;				focusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),				new MatteBorder(0,0,0,width,color1));			noFocusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),				new MatteBorder(0,0,0,width,color2));			updateBorder();		}	
/**		 * Sets the border differently if the text area has focus or not.		 */		public void updateBorder()		{			if (textArea.hasFocus())				setBorder(focusBorder);			else				setBorder(noFocusBorder);		}	
public void setBorder(Border border)		{			super.setBorder(border);				if (border == null)			{				collapsedSize.width = 0;				collapsedSize.height = 0;			}			else			{				Insets insets = border.getBorderInsets(this);				collapsedSize.width = FOLD_MARKER_SIZE + insets.right;				if (isSelectionAreaEnabled())					 collapsedSize.width += selectionAreaWidth;				collapsedSize.height = gutterSize.height					= insets.top + insets.bottom;				lineNumberWidth = fm.charWidth('5') * getLineNumberDigitCount(); 				gutterSize.width = FOLD_MARKER_SIZE + insets.right					+ lineNumberWidth;			}				revalidate();		}	
public void setMinLineNumberDigitCount(int min)		{			if (min == minLineNumberDigits)				return;			minLineNumberDigits = min;			if (textArea.getBuffer() != null)				updateLineNumberWidth();		}	
private int getMinLineNumberDigitCount()		{			return minLineNumberDigits;		}	
private int getLineNumberDigitCount()		{			JEditBuffer buf = textArea.getBuffer();			int minDigits = getMinLineNumberDigitCount();			if (buf == null)				return minDigits;			int count = buf.getLineCount();			int digits;			for (digits = 0; count > 0; digits++)				count /= 10;			return (digits < minDigits) ? minDigits : digits;		}	
void setBuffer(JEditBuffer newBuffer)		{			if (buffer != null)				buffer.removeBufferListener(bufferListener);			buffer = newBuffer;			if (buffer != null)				buffer.addBufferListener(bufferListener);			updateLineNumberWidth();		}	
private void updateLineNumberWidth()		{			Font f = getFont();			if (f != null)				setFont(getFont());		}	
void dispose()		{			if (buffer != null)			{				buffer.removeBufferListener(bufferListener);				buffer = null;			}		}	
public void setFont(Font font)		{			super.setFont(font);				fm = getFontMetrics(font);				Border border = getBorder();			if(border != null)			{				lineNumberWidth = fm.charWidth('5') * getLineNumberDigitCount(); 				gutterSize.width = FOLD_MARKER_SIZE					+ border.getBorderInsets(this).right					+ lineNumberWidth;				revalidate();			}		}	
public void setGutterEnabled(boolean enabled)		{			this.enabled = enabled;			revalidate();		}	
public boolean isSelectionAreaEnabled()		{			return selectionAreaEnabled;		}	
public void setSelectionAreaEnabled(boolean enabled)		{			if (isSelectionAreaEnabled() == enabled)				return;			selectionAreaEnabled = enabled;			if (enabled)				collapsedSize.width += selectionAreaWidth;			else				collapsedSize.width -= selectionAreaWidth;			revalidate();		}	
public void setSelectionAreaBackground(Color bgColor)		{			selectionAreaBgColor = bgColor;			repaint();		}	
public void setSelectionAreaWidth(int width)		{			selectionAreaWidth = width;			revalidate();		}	
/**		 * Get the foreground color for highlighted line numbers		 * @return The highlight color		 */		public Color getHighlightedForeground()		{			return intervalHighlight;		}	
public void setHighlightedForeground(Color highlight)		{			intervalHighlight = highlight;		}	
public Color getCurrentLineForeground()	 	{			return currentLineHighlight;		}	
public void setCurrentLineForeground(Color highlight)		{			currentLineHighlight = highlight;	 	}	
public Color getFoldColor()	 	{			return foldColor;		}	
public void setFoldColor(Color foldColor)		{			this.foldColor = foldColor;	 	}	
public Dimension getPreferredSize()		{			if (! enabled)				return disabledSize;			if (expanded)				return gutterSize;			else				return collapsedSize;		}	
public Dimension getMinimumSize()		{			return getPreferredSize();		}	
/**		 * Identifies whether the horizontal alignment of the line numbers.		 * @return Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT		 */		public int getLineNumberAlignment()		{			return alignment;		}	
/**		 * Sets the horizontal alignment of the line numbers.		 * @param alignment Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT		 */		public void setLineNumberAlignment(int alignment)		{			if (this.alignment == alignment) return;				this.alignment = alignment;				repaint();		}	
/**		 * Identifies whether the gutter is collapsed or expanded.		 * @return true if the gutter is expanded, false if it is collapsed		 */		public boolean isExpanded()		{			return expanded;		}	
/**		 * Sets whether the gutter is collapsed or expanded and force the text		 * area to update its layout if there is a change.		 * @param expanded true if the gutter is expanded,		 *                   false if it is collapsed		 */		public void setExpanded(boolean expanded)		{			if (this.expanded == expanded) return;				this.expanded = expanded;				textArea.revalidate();		}	
/**		 * Toggles whether the gutter is collapsed or expanded.		 */		public void toggleExpanded()		{			setExpanded(!expanded);		}	
/**		 * Sets the number of lines between highlighted line numbers.		 * @return The number of lines between highlighted line numbers or		 *          zero if highlighting is disabled		 */		public int getHighlightInterval()		{			return interval;		}	
/**		 * Sets the number of lines between highlighted line numbers. Any value		 * less than or equal to one will result in highlighting being disabled.		 * @param interval The number of lines between highlighted line numbers		 */		public void setHighlightInterval(int interval)		{			if (interval <= 1) interval = 0;			this.interval = interval;			repaint();		}	
public boolean isCurrentLineHighlightEnabled()		{			return currentLineHighlightEnabled;		}	
public void setCurrentLineHighlightEnabled(boolean enabled)		{			if (currentLineHighlightEnabled == enabled) return;				currentLineHighlightEnabled = enabled;				repaint();		}	
/**		 * Returns the structure highlight color.		 * @since jEdit 4.2pre3		 */		public final Color getStructureHighlightColor()		{			return structureHighlightColor;		}	
/**		 * Sets the structure highlight color.		 * @param structureHighlightColor The structure highlight color		 * @since jEdit 4.2pre3		 */		public final void setStructureHighlightColor(Color structureHighlightColor)		{			this.structureHighlightColor = structureHighlightColor;			repaint();		}	
/**		 * Returns true if structure highlighting is enabled, false otherwise.		 * @since jEdit 4.2pre3		 */		public final boolean isStructureHighlightEnabled()		{			return structureHighlight;		}	
/**		 * Enables or disables structure highlighting.		 * @param structureHighlight True if structure highlighting should be		 * enabled, false otherwise		 * @since jEdit 4.2pre3		 */		public final void setStructureHighlightEnabled(boolean structureHighlight)		{			this.structureHighlight = structureHighlight;			repaint();		}	
public void setSelectionPopupHandler(GutterPopupHandler handler)		{			mouseHandler.selectionPopupHandler = handler;		}	
public void setMouseActionsProvider(MouseActionsProvider mouseActionsProvider)		{			mouseHandler.mouseActions = mouseActionsProvider;		}	
private void paintLine(Graphics2D gfx, int line, int y)		{			JEditBuffer buffer = textArea.getBuffer();			if(buffer.isLoading())				return;				FontMetrics textAreaFm = textArea.getPainter().getFontMetrics();			int lineHeight = textAreaFm.getHeight();			int baseline = textAreaFm.getAscent();				ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(line);			int physicalLine = info.physicalLine;				// Skip lines beyond EOF			if(physicalLine == -1)				return;				boolean drawFoldMiddle = true;			//{{{ Paint fold start and end indicators			if(info.firstSubregion && buffer.isFoldStart(physicalLine))			{				drawFoldMiddle = false;				foldPainter.paintFoldStart(this, gfx, line, physicalLine,						textArea.displayManager.isLineVisible(physicalLine+1),						y, lineHeight, buffer);			}			else if(info.lastSubregion && buffer.isFoldEnd(physicalLine))			{				drawFoldMiddle = false;				foldPainter.paintFoldEnd(this, gfx, line, physicalLine, y,						lineHeight, buffer);			} //}}}			//{{{ Paint bracket scope			else if(structureHighlight)			{				StructureMatcher.Match match = textArea.getStructureMatch();				int caretLine = textArea.getCaretLine();					if(textArea.isStructureHighlightVisible()					&& physicalLine >= Math.min(caretLine,match.startLine)					&& physicalLine <= Math.max(caretLine,match.startLine))				{					int caretScreenLine;					if(caretLine > textArea.getLastPhysicalLine())						caretScreenLine = Integer.MAX_VALUE;					else if(textArea.displayManager.isLineVisible(							textArea.getCaretLine()))					{						caretScreenLine = textArea							.getScreenLineOfOffset(							textArea.getCaretPosition());					}					else					{						caretScreenLine = -1;					}						int structScreenLine;					if(match.startLine > textArea.getLastPhysicalLine())						structScreenLine = Integer.MAX_VALUE;					else if(textArea.displayManager.isLineVisible(							match.startLine))					{						structScreenLine = textArea							.getScreenLineOfOffset(							match.start);					}					else					{						structScreenLine = -1;					}						if(caretScreenLine > structScreenLine)					{						int tmp = caretScreenLine;						caretScreenLine = structScreenLine;						structScreenLine = tmp;					}						gfx.setColor(structureHighlightColor);					drawFoldMiddle = false;					if(structScreenLine == caretScreenLine)					{						// do nothing						drawFoldMiddle = true;					}					// draw |^					else if(line == caretScreenLine)					{						gfx.fillRect(5,							y							+ lineHeight / 2,							5,							2);						gfx.fillRect(5,							y							+ lineHeight / 2,							2,							lineHeight - lineHeight / 2);					}					// draw |_					else if(line == structScreenLine)					{						gfx.fillRect(5,							y,							2,							lineHeight / 2);						gfx.fillRect(5,							y + lineHeight / 2,							5,							2);					}					// draw |					else if(line > caretScreenLine						&& line < structScreenLine)					{						gfx.fillRect(5,							y,							2,							lineHeight);					}				}			} //}}}			if(drawFoldMiddle && buffer.getFoldLevel(physicalLine) > 0)			{				foldPainter.paintFoldMiddle(this, gfx, line, physicalLine,						y, lineHeight, buffer);			}				//{{{ Paint line numbers			if(info.firstSubregion && expanded)			{				String number = Integer.toString(physicalLine + 1);					int offset;				switch (alignment)				{				case RIGHT:					offset = lineNumberWidth - (fm.stringWidth(number) + 1);					break;				case CENTER:					offset = (lineNumberWidth - fm.stringWidth(number)) / 2;					break;				case LEFT: default:					offset = 0;					break;				}					if (physicalLine == textArea.getCaretLine() && currentLineHighlightEnabled)				{					gfx.setColor(currentLineHighlight);				}				else if (interval > 1 && (physicalLine + 1) % interval == 0)					gfx.setColor(intervalHighlight);				else					gfx.setColor(getForeground());					gfx.drawString(number, FOLD_MARKER_SIZE + offset,					baseline + y);			} //}}}		}	
public void mouseEntered(MouseEvent e)			{				ToolTipManager ttm = ToolTipManager.sharedInstance();				toolTipInitialDelay = ttm.getInitialDelay();				toolTipReshowDelay = ttm.getReshowDelay();				ttm.setInitialDelay(0);				ttm.setReshowDelay(0);			}	
public void mouseExited(MouseEvent evt)			{				ToolTipManager ttm = ToolTipManager.sharedInstance();				ttm.setInitialDelay(toolTipInitialDelay);				ttm.setReshowDelay(toolTipReshowDelay);			}	
public void mousePressed(MouseEvent e)			{				textArea.requestFocus();					boolean outsideGutter =					(e.getX() >= getWidth() - borderWidth * 2);				if(TextAreaMouseHandler.isPopupTrigger(e) || outsideGutter)				{					if ((selectionPopupHandler != null) &&						(! outsideGutter) &&						(e.getX() > FOLD_MARKER_SIZE))					{						int screenLine = e.getY() / textArea.getPainter()							.getFontMetrics().getHeight();						int line = textArea.chunkCache.getLineInfo(screenLine)							.physicalLine;						if (line >= 0)						{							selectionPopupHandler.handlePopup(								e.getX(), e.getY(), line);							return;						}					}					e.translatePoint(-getWidth(),0);					textArea.mouseHandler.mousePressed(e);					drag = true;				}				else				{					JEditBuffer buffer = textArea.getBuffer();						int screenLine = e.getY() / textArea.getPainter()						.getFontMetrics().getHeight();						int line = textArea.chunkCache.getLineInfo(screenLine)						.physicalLine;						if(line == -1)						return;						if (e.getX() >= FOLD_MARKER_SIZE)					{						Selection s = new Selection.Range(							textArea.getLineStartOffset(line),							getFoldEndOffset(line));						if(textArea.isMultipleSelectionEnabled())							textArea.addToSelection(s);						else							textArea.setSelection(s);						selectLines = true;						selAnchorLine = line;						return;					}						//{{{ Determine action					String defaultAction;					String variant;					if(buffer.isFoldStart(line))					{						defaultAction = "toggle-fold";						variant = "fold";					}					else if(structureHighlight						&& textArea.isStructureHighlightVisible()						&& textArea.lineInStructureScope(line))					{						defaultAction = "match-struct";						variant = "struct";					}					else						return;						String action = null;						if (mouseActions != null)						action = mouseActions.getActionForEvent(							e,variant);						if(action == null)						action = defaultAction;					//}}}						//{{{ Handle actions					StructureMatcher.Match match = textArea						.getStructureMatch();						if(action.equals("select-fold"))					{						textArea.displayManager.expandFold(line,true);						textArea.selectFold(line);					}					else if(action.equals("narrow-fold"))					{						int[] lines = buffer.getFoldAtLine(line);						textArea.displayManager.narrow(lines[0],lines[1]);					}					else if(action.startsWith("toggle-fold"))					{						if(textArea.displayManager							.isLineVisible(line + 1))						{							textArea.collapseFold(line);						}						else						{							if(action.endsWith("-fully"))							{								textArea.displayManager									.expandFold(line,									true);							}							else							{								textArea.displayManager									.expandFold(line,									false);							}						}					}					else if(action.equals("match-struct"))					{						if(match != null)							textArea.setCaretPosition(match.end);					}					else if(action.equals("select-struct"))					{						if(match != null)						{							match.matcher.selectMatch(								textArea);						}					}					else if(action.equals("narrow-struct"))					{						if(match != null)						{							int start = Math.min(								match.startLine,								textArea.getCaretLine());							int end = Math.max(								match.endLine,								textArea.getCaretLine());							textArea.displayManager.narrow(start,end);						}					} //}}}				}			}	
public void mouseDragged(MouseEvent e)			{				if(drag /* && e.getX() >= getWidth() - borderWidth * 2 */)				{					e.translatePoint(-getWidth(),0);					textArea.mouseHandler.mouseDragged(e);				}				else if(selectLines)				{					int screenLine = e.getY() / textArea.getPainter()						.getFontMetrics().getHeight();					int line;					if(e.getY() < 0)					{						textArea.scrollUpLine();						line = textArea.getFirstPhysicalLine();					}					else if(e.getY() >= getHeight())					{						textArea.scrollDownLine();						line = textArea.getLastPhysicalLine();					}					else						line = textArea.chunkCache.getLineInfo(screenLine)							.physicalLine;						int selStart, selEnd;					if(line < selAnchorLine)					{						selStart = textArea.getLineStartOffset(line);						selEnd = getFoldEndOffset(selAnchorLine);					}					else					{						selStart = textArea.getLineStartOffset(selAnchorLine);						selEnd = getFoldEndOffset(line);					}						textArea.resizeSelection(selStart, selEnd, 0, false);				}			}	
private int getFoldEndOffset(int line)			{				JEditBuffer buffer = textArea.getBuffer();				int endLine;				if ((line == buffer.getLineCount() - 1) ||					(textArea.displayManager.isLineVisible(line + 1)))				{					endLine = line;				}				else				{					int[] lines = buffer.getFoldAtLine(line);					endLine = lines[1];				}					if(endLine == buffer.getLineCount() - 1)					return buffer.getLineEndOffset(endLine) - 1;				else					return buffer.getLineEndOffset(endLine);			}	
public void mouseReleased(MouseEvent e)			{				if(drag && e.getX() >= getWidth() - borderWidth * 2)				{					e.translatePoint(-getWidth(),0);					textArea.mouseHandler.mouseReleased(e);				}					drag = false;				selectLines = false;			}	
public GutterOptionPane()		{			super("gutter");		}	
public void _init()		{			/* Gutter enable */			gutterEnabled = new JCheckBox(jEdit.getProperty(				"options.gutter.enabled"));			gutterEnabled.setSelected(isGutterEnabled());			addComponent(gutterEnabled);				/* Gutter components frame */			GridBagConstraints cons = new GridBagConstraints();			cons.gridheight = 1;			cons.gridwidth = GridBagConstraints.REMAINDER;			cons.fill = GridBagConstraints.HORIZONTAL;			cons.anchor = GridBagConstraints.WEST;			cons.weightx = 1.0f;			cons.ipadx = 0;			cons.ipady = 0;			cons.insets = new Insets(0,0,0,0);			gutterComponents = new JPanel(new GridBagLayout());			gutterComponents.setBorder(BorderFactory.createTitledBorder(				jEdit.getProperty("options.gutter.optionalComponents")));				/* Line numbering */			lineNumbersEnabled = new JCheckBox(jEdit.getProperty(				"options.gutter.lineNumbers"));			lineNumbersEnabled.setSelected(jEdit.getBooleanProperty(				"view.gutter.lineNumbers"));			gutterComponents.add(lineNumbersEnabled, cons);				InputVerifier integerInputVerifier = new InputVerifier()			{				@Override				public boolean verify(JComponent input)				{					if (! (input instanceof JTextField))						return true;					JTextField tf = (JTextField) input;					int i;					try					{						i = Integer.valueOf(tf.getText()).intValue();					}					catch (Exception e)					{						return false;					}					return (i >= 0);				}			};			minLineNumberDigits = new JTextField(String.valueOf(					getMinLineNumberDigits()),1);			minLineNumberDigits.setInputVerifier(integerInputVerifier);			JPanel minLineNumberDigitsPanel = new JPanel();			minLineNumberDigitsPanel.add(new JLabel(				jEdit.getProperty("options.gutter.minLineNumberDigits")));			minLineNumberDigitsPanel.add(minLineNumberDigits);			cons.gridy = 1;			gutterComponents.add(minLineNumberDigitsPanel, cons);				/* Selection area enable */			selectionAreaEnabled = new JCheckBox(jEdit.getProperty(				"options.gutter.selectionAreaEnabled"));			selectionAreaEnabled.setSelected(isSelectionAreaEnabled());			cons.gridy = 2;			gutterComponents.add(selectionAreaEnabled, cons);				addComponent(gutterComponents);			// Disable gutter components when 'show gutter' is unchecked			setGutterComponentsEnabledState();			gutterEnabled.addChangeListener(new ChangeListener()			{				public void stateChanged(ChangeEvent e)				{					setGutterComponentsEnabledState();				}			});				/* Selection area background color */			addComponent(jEdit.getProperty("options.gutter.selectionAreaBgColor"),				selectionAreaBgColor = new ColorWellButton(					getSelectionAreaBackground()), GridBagConstraints.VERTICAL);				/* Selection area width */			selectionAreaWidth = new JTextField(String.valueOf(				getSelectionAreaWidth()),DEFAULT_SELECTION_GUTTER_WIDTH);			selectionAreaWidth.setInputVerifier(integerInputVerifier);			addComponent(jEdit.getProperty("options.gutter.selectionAreaWidth"),				selectionAreaWidth);				/* Text font */			gutterFont = new FontSelector(				jEdit.getFontProperty("view.gutter.font",				new Font("Monospaced",Font.PLAIN,10)));				addComponent(jEdit.getProperty("options.gutter.font"),gutterFont);				/* Text color */			addComponent(jEdit.getProperty("options.gutter.foreground"),				gutterForeground = new ColorWellButton(				jEdit.getColorProperty("view.gutter.fgColor")),				GridBagConstraints.VERTICAL);				/* Background color */			addComponent(jEdit.getProperty("options.gutter.background"),				gutterBackground = new ColorWellButton(				jEdit.getColorProperty("view.gutter.bgColor")),				GridBagConstraints.VERTICAL);				/* Border width */			/* gutterBorderWidth = new JTextField(jEdit.getProperty(				"view.gutter.borderWidth"));			addComponent(jEdit.getProperty("options.gutter.borderWidth"),				gutterBorderWidth); */				/* Number alignment */			/* String[] alignments = new String[] {				"Left", "Center", "Right"			};			gutterNumberAlignment = new JComboBox(alignments);			String alignment = jEdit.getProperty("view.gutter.numberAlignment");			if("right".equals(alignment))				gutterNumberAlignment.setSelectedIndex(2);			else if("center".equals(alignment))				gutterNumberAlignment.setSelectedIndex(1);			else				gutterNumberAlignment.setSelectedIndex(0);			addComponent(jEdit.getProperty("options.gutter.numberAlignment"),				gutterNumberAlignment); */				/* Current line highlight */			gutterCurrentLineHighlightEnabled = new JCheckBox(jEdit.getProperty(				"options.gutter.currentLineHighlight"));			gutterCurrentLineHighlightEnabled.setSelected(jEdit.getBooleanProperty(				"view.gutter.highlightCurrentLine"));			addComponent(gutterCurrentLineHighlightEnabled,				gutterCurrentLineHighlight = new ColorWellButton(				jEdit.getColorProperty("view.gutter.currentLineColor")),				GridBagConstraints.VERTICAL);				/* Highlight interval and color */			gutterHighlightInterval = new JTextField(jEdit.getProperty(				"view.gutter.highlightInterval"),3);				Box gutterHighlightBox = new Box(BoxLayout.X_AXIS);			gutterHighlightBox.add(new JLabel(jEdit.getProperty(				"options.gutter.interval-1")));			gutterHighlightBox.add(Box.createHorizontalStrut(3));			gutterHighlightBox.add(gutterHighlightInterval);			gutterHighlightBox.add(Box.createHorizontalStrut(3));			gutterHighlightBox.add(new JLabel(jEdit.getProperty(				"options.gutter.interval-2")));			gutterHighlightBox.add(Box.createHorizontalStrut(12));				addComponent(gutterHighlightBox,gutterHighlightColor				= new ColorWellButton(jEdit.getColorProperty(				"view.gutter.highlightColor")),				GridBagConstraints.VERTICAL);				/* Structure highlight */			gutterStructureHighlightEnabled = new JCheckBox(jEdit.getProperty(				"options.gutter.structureHighlight"));			gutterStructureHighlightEnabled.setSelected(jEdit.getBooleanProperty(				"view.gutter.structureHighlight"));			addComponent(gutterStructureHighlightEnabled,				gutterStructureHighlight = new ColorWellButton(				jEdit.getColorProperty("view.gutter.structureHighlightColor")),				GridBagConstraints.VERTICAL);				/* Marker highlight */			gutterMarkerHighlightEnabled = new JCheckBox(jEdit.getProperty(				"options.gutter.markerHighlight"));			gutterMarkerHighlightEnabled.setSelected(jEdit.getBooleanProperty(				"view.gutter.markerHighlight"));			addComponent(gutterMarkerHighlightEnabled,				gutterMarkerHighlight = new ColorWellButton(				jEdit.getColorProperty("view.gutter.markerColor")),				GridBagConstraints.VERTICAL);				/* Fold marker color */			addComponent(jEdit.getProperty("options.gutter.foldColor"),				gutterFoldMarkers = new ColorWellButton(				jEdit.getColorProperty("view.gutter.foldColor")),				GridBagConstraints.VERTICAL);				/* Focused border color */			addComponent(jEdit.getProperty("options.gutter.focusBorderColor"),				gutterFocusBorder = new ColorWellButton(				jEdit.getColorProperty("view.gutter.focusBorderColor")),				GridBagConstraints.VERTICAL);				/* unfocused border color */			addComponent(jEdit.getProperty("options.gutter.noFocusBorderColor"),				gutterNoFocusBorder = new ColorWellButton(				jEdit.getColorProperty("view.gutter.noFocusBorderColor")),				GridBagConstraints.VERTICAL);						addFoldStyleChooser();		}	
public void _save()		{			jEdit.setBooleanProperty("view.gutter.lineNumbers", lineNumbersEnabled				.isSelected());			jEdit.setIntegerProperty("view.gutter.minDigitCount",				Integer.valueOf(minLineNumberDigits.getText()));				jEdit.setFontProperty("view.gutter.font",gutterFont.getFont());			jEdit.setColorProperty("view.gutter.fgColor",gutterForeground				.getSelectedColor());			jEdit.setColorProperty("view.gutter.bgColor",gutterBackground				.getSelectedColor());				/* jEdit.setProperty("view.gutter.borderWidth",				gutterBorderWidth.getText());				String alignment = null;			switch(gutterNumberAlignment.getSelectedIndex())			{			case 2:				alignment = "right";				break;			case 1:				alignment = "center";				break;			case 0: default:				alignment = "left";			}			jEdit.setProperty("view.gutter.numberAlignment", alignment); */				jEdit.setBooleanProperty("view.gutter.highlightCurrentLine",				gutterCurrentLineHighlightEnabled.isSelected());			jEdit.setColorProperty("view.gutter.currentLineColor",				gutterCurrentLineHighlight.getSelectedColor());			jEdit.setProperty("view.gutter.highlightInterval",				gutterHighlightInterval.getText());			jEdit.setColorProperty("view.gutter.highlightColor",				gutterHighlightColor.getSelectedColor());				jEdit.setBooleanProperty("view.gutter.structureHighlight",				gutterStructureHighlightEnabled.isSelected());			jEdit.setColorProperty("view.gutter.structureHighlightColor",				gutterStructureHighlight.getSelectedColor());			jEdit.setBooleanProperty("view.gutter.markerHighlight",				gutterMarkerHighlightEnabled.isSelected());			jEdit.setColorProperty("view.gutter.markerColor",				gutterMarkerHighlight.getSelectedColor());			jEdit.setColorProperty("view.gutter.foldColor",				gutterFoldMarkers.getSelectedColor());			jEdit.setProperty(JEditTextArea.FOLD_PAINTER_PROPERTY,				painters[foldPainter.getSelectedIndex()]);			jEdit.setColorProperty("view.gutter.focusBorderColor",				gutterFocusBorder.getSelectedColor());			jEdit.setColorProperty("view.gutter.noFocusBorderColor",				gutterNoFocusBorder.getSelectedColor());			jEdit.setBooleanProperty(GUTTER_ENABLED_PROPERTY,				gutterEnabled.isSelected());			jEdit.setBooleanProperty(SELECTION_AREA_ENABLED_PROPERTY,				selectionAreaEnabled.isSelected());			jEdit.setColorProperty(SELECTION_AREA_BGCOLOR_PROPERTY,				selectionAreaBgColor.getSelectedColor());			jEdit.setIntegerProperty("view.gutter.selectionAreaWidth",				Integer.valueOf(selectionAreaWidth.getText()));		}	
private void setGutterComponentsEnabledState()		{			GUIUtilities.setEnabledRecursively(gutterComponents,				gutterEnabled.isSelected());		}	
private void addFoldStyleChooser()		{			painters = ServiceManager.getServiceNames(JEditTextArea.FOLD_PAINTER_SERVICE);			foldPainter = new JComboBox();			String current = JEditTextArea.getFoldPainterName();			int selected = 0;			for (int i = 0; i < painters.length; i++)			{				String painter = painters[i];				foldPainter.addItem(jEdit.getProperty(					"options.gutter.foldStyleNames." + painter, painter));				if (painter.equals(current))					selected = i;			}			foldPainter.setSelectedIndex(selected);			addComponent(new JLabel(jEdit.getProperty("options.gutter.foldStyle.label")), foldPainter);		}	
public static boolean isGutterEnabled()		{			return jEdit.getBooleanProperty(GUTTER_ENABLED_PROPERTY);		}	
public static int getMinLineNumberDigits()		{			int n = jEdit.getIntegerProperty("view.gutter.minDigitCount", 2);			if (n < 0)				n = 2;			return n;		}	
public static boolean isSelectionAreaEnabled()		{			return jEdit.getBooleanProperty(SELECTION_AREA_ENABLED_PROPERTY);		}	
public static Color getSelectionAreaBackground()		{			String color = jEdit.getProperty(SELECTION_AREA_BGCOLOR_PROPERTY);			if (color == null)				return jEdit.getColorProperty("view.gutter.bgColor");			return SyntaxUtilities.parseColor(color, Color.black);		}	
public static int getSelectionAreaWidth()		{			int n = jEdit.getIntegerProperty("view.gutter.selectionAreaWidth",				DEFAULT_SELECTION_GUTTER_WIDTH);			if (n < 0)				n = DEFAULT_SELECTION_GUTTER_WIDTH;			return n;		}	
public URLConnection openConnection(URL url)			throws IOException		{			PluginResURLConnection c = new PluginResURLConnection(url);			c.connect();			return c;		}	
public HelpHistoryModel(int size)		{			history = new HistoryEntry[size];			listeners = new ArrayList<HelpHistoryModelListener>();		}	
HistoryEntry forward(HelpViewer helpViewer)		{			if(history.length - historyPos <= 1)			{				return null;			}			if (history[historyPos] == null)			{				return null;			}			setCurrentScrollPosition(helpViewer.getCurrentPage(),helpViewer.getCurrentScrollPosition());			HistoryEntry result = new HistoryEntry(history[historyPos]);			historyPos++;			fireUpdate();			return result;		}	
public boolean hasNext()		{			return !((history.length - historyPos <= 1) ||				 (history[historyPos] == null));		}	
HistoryEntry back(HelpViewer helpViewer)		{			if (historyPos <= 1)			{				return null;			}			setCurrentScrollPosition(helpViewer.getCurrentPage(),helpViewer.getCurrentScrollPosition());			HistoryEntry result = new HistoryEntry(history[--historyPos - 1]);			fireUpdate();			return result;		}	
public boolean hasPrevious()		{			return (historyPos>1);		}	
public void addToHistory(String url)		{			history[historyPos] = new HistoryEntry(url,url,0);			if(historyPos + 1 == history.length)			{				System.arraycopy(history,1,history,						 0,history.length - 1);				history[historyPos] = null;			}			else			{				historyPos++;				for (int i = historyPos ; i<history.length ; i++)				{					history[i] = null;				}			}			fireUpdate();		}	
public void setCurrentScrollPosition(URL currentPage, int scrollPosition)		{			if ((null != currentPage) && (historyPos >= 1) &&			    (currentPage.toString().equals(history[historyPos-1].url)))			{				history[historyPos-1].scrollPosition = scrollPosition;			}		}	
public void setCurrentEntry(HistoryEntry entry)		{			for (int i=0 ; i<history.length ; i++)			{				if ((history[i] != null) && (history[i].equals(entry)))				{					historyPos = i+1;					fireUpdate();					break;				}			}			// Do nothing?		}	
public void updateTitle(String url, String title)		{			for (int i=0;i<history.length;i++)			{				if ((history[i] != null) && history[i].url.equals(url))				{					history[i].title = title;				}			}			fireUpdate();		}	
HistoryEntry[] getPreviousURLs()		{			if (historyPos<=1)			{				return new HelpHistoryModel.HistoryEntry[0];			}			HistoryEntry[] previous = new HistoryEntry[historyPos-1];			System.arraycopy(history,0,previous,0,historyPos-1);			return previous;		}	
HistoryEntry[] getNextURLs()		{			if (history.length - historyPos <= 1)			{				return new HelpHistoryModel.HistoryEntry[0];			}			if (history[historyPos] == null)			{				return new HelpHistoryModel.HistoryEntry[0];			}			HistoryEntry[] next = new HistoryEntry[history.length-historyPos];			System.arraycopy(history,historyPos,next,0,history.length-historyPos);			return next;		}	
public void addHelpHistoryModelListener(HelpHistoryModelListener hhml)		{			listeners.add(hhml);		}	
public void removeHelpHistoryModelListener(HelpHistoryModelListener hhml)		{			listeners.remove(hhml);		}	
public void fireUpdate()		{			for (int i=0 ; i<listeners.size() ; i++)			{				listeners.get(i).historyUpdated();			}		}	
HistoryEntry(String url, String title)			{				this(url,title,0);			}	
HistoryEntry(HistoryEntry original)			{				this(original.url,original.title,original.scrollPosition);			}	
HistoryEntry(String url, String title, int scrollPosition)			{				this.url = url;				this.title = title;				this.scrollPosition = scrollPosition;			}	
public boolean equals(HistoryEntry he)			{				return he.url.equals(this.url) &&				       he.title.equals(this.title) &&				       (he.scrollPosition == scrollPosition);			}	
public String toString()			{				return getClass().getName() + "[url=" + url + ",title=" + title				+ ",scrollPosition=" + scrollPosition + ']';			}	
public HelpIndex()		{			words = new HashMap<String, Object>();			files = new ArrayList<HelpFile>();				ignoreWord("a");			ignoreWord("an");			ignoreWord("and");			ignoreWord("are");			ignoreWord("as");			ignoreWord("be");			ignoreWord("by");			ignoreWord("can");			ignoreWord("do");			ignoreWord("for");			ignoreWord("from");			ignoreWord("how");			ignoreWord("i");			ignoreWord("if");			ignoreWord("in");			ignoreWord("is");			ignoreWord("it");			ignoreWord("not");			ignoreWord("of");			ignoreWord("on");			ignoreWord("or");			ignoreWord("s");			ignoreWord("that");			ignoreWord("the");			ignoreWord("this");			ignoreWord("to");			ignoreWord("will");			ignoreWord("with");			ignoreWord("you");		}	
/**		 * Indexes all available help, including the jEdit user's guide, FAQ,]		 * and plugin documentation.		 */		public void indexEditorHelp()		{			try			{				String jEditHome = jEdit.getJEditHome();				if(jEditHome != null)				{					indexDirectory(MiscUtilities.constructPath(jEditHome,"doc","users-guide"));					indexDirectory(MiscUtilities.constructPath(jEditHome,"doc","FAQ"));					indexDirectory(MiscUtilities.constructPath(jEditHome,"doc","news43"));				}			}			catch(Throwable e)			{				Log.log(Log.ERROR,this,"Error indexing editor help");				Log.log(Log.ERROR,this,e);			}				PluginJAR[] jars = jEdit.getPluginJARs();			for(int i = 0; i < jars.length; i++)			{				try				{					indexJAR(jars[i].getZipFile());				}				catch(Throwable e)				{					Log.log(Log.ERROR,this,"Error indexing JAR: "						+ jars[i].getPath());					Log.log(Log.ERROR,this,e);				}			}				Log.log(Log.DEBUG,this,"Indexed " + words.size() + " words");		}	
/**		 * Indexes all HTML and text files in the specified directory.		 * @param dir The directory		 */		public void indexDirectory(String dir) throws Exception		{			String[] files = VFSManager.getFileVFS()				._listDirectory(null,dir,"*.{html,txt}",true,null);				for(int i = 0; i < files.length; i++)			{				indexURL(files[i]);			}		}	
/**		 * Indexes all HTML and text files in the specified JAR file.		 * @param jar The JAR file		 */		public void indexJAR(ZipFile jar) throws Exception		{			Enumeration e = jar.entries();			while(e.hasMoreElements())			{				ZipEntry entry = (ZipEntry)e.nextElement();				String name = entry.getName();				String lname = name.toLowerCase();				if(lname.endsWith(".html")/*  || lname.endsWith(".txt") */)				{					// only works for jEdit plugins					String url = "jeditresource:/" +						MiscUtilities.getFileName(jar.getName())						+ "!/" + name;					Log.log(Log.DEBUG,this,url);					indexStream(jar.getInputStream(entry),url);				}			}		}	
/**		 * Reads the specified HTML file and adds all words defined therein to the		 * index.		 * @param url The HTML file's URL		 */		public void indexURL(String url) throws Exception		{			InputStream _in;				if(MiscUtilities.isURL(url))				_in =  new URL(url).openStream();			else			{				_in = new FileInputStream(url);				// hack since HelpViewer needs a URL...				url = "file:" + url;			}				indexStream(_in,url);		}	
public Word lookupWord(String word)		{			Object o = words.get(word);			if(o == IGNORE)				return null;			else				return (Word)o;		}	
public HelpFile getFile(int index)		{			return files.get(index);		}	
private void ignoreWord(String word)		{			words.put(word,IGNORE);		}	
/**		 * Reads the specified HTML file and adds all words defined therein to the		 * index.		 * @param _in The input stream		 * @param fileName The file		 */		private void indexStream(InputStream _in, String fileName)			throws Exception		{			HelpFile file = new HelpFile(fileName);			files.add(file);			int index = files.size() - 1;				StringBuilder titleText = new StringBuilder();				BufferedReader in = new BufferedReader(				new InputStreamReader(_in));				try			{				StringBuilder word = new StringBuilder();				boolean insideTag = false;				boolean insideEntity = false;					boolean title = false;					int c;				while((c = in.read()) != -1)				{					char ch = (char)c;					if(insideTag)					{						if(ch == '>')						{							if(word.toString().equals("title"))								title = true;							insideTag = false;							word.setLength(0);						}						else							word.append(ch);					}					else if(insideEntity)					{						if(ch == ';')							insideEntity = false;					}					else if(ch == '<')					{						if(title)							title = false;							if(word.length() != 0)						{							addWord(word.toString(),index,title);							word.setLength(0);						}							insideTag = true;					}					else if(ch == '&')						insideEntity = true;					else if(title)						titleText.append(ch);					else if(!Character.isLetterOrDigit(ch))					{						if(word.length() != 0)						{							addWord(word.toString(),index,title);							word.setLength(0);						}					}					else						word.append(ch);				}			}			finally			{				in.close();			}				if(titleText.length() == 0)				file.title = fileName;			else				file.title = titleText.toString();		}	
private void addWord(String word, int file, boolean title)		{			word = word.toLowerCase();				Object o = words.get(word);			if(o == IGNORE)				return;				if(o == null)				words.put(word,new Word(word,file,title));			else				((Word)o).addOccurrence(file,title);		}	
Word(String word, int file, boolean title)			{				this.word = word;				occurrences = new Occurrence[5];				addOccurrence(file,title);			}	
void addOccurrence(int file, boolean title)			{				for(int i = 0; i < occurCount; i++)				{					if(occurrences[i].file == file)					{						occurrences[i].count += (title ? TITLE_OCCUR : 1);						return;					}				}					if(occurCount >= occurrences.length)				{					Occurrence[] newOccur = new Occurrence[occurrences.length * 2];					System.arraycopy(occurrences,0,newOccur,0,occurCount);					occurrences = newOccur;				}					occurrences[occurCount++] = new Occurrence(file,title);			}	
Occurrence(int file, boolean title)				{					this.file = file;					this.count = (title ? TITLE_OCCUR : 1);				}	
HelpFile(String file)			{				this.file = file;			}	
public String toString()			{				return title;			}	
public boolean equals(Object o)			{				if(o instanceof HelpFile)					return ((HelpFile)o).file.equals(file);				else					return false;			}	
public HelpSearchPanel(HelpViewerInterface helpViewer)		{			super(new BorderLayout(6,6));				this.helpViewer = helpViewer;				Box box = new Box(BoxLayout.X_AXIS);			box.add(new JLabel(jEdit.getProperty("helpviewer.search.caption")));			box.add(Box.createHorizontalStrut(6));			box.add(searchField = new HistoryTextField("helpviewer.search"));			searchField.addActionListener(new ActionHandler());				add(BorderLayout.NORTH,box);				results = new JList();			results.addMouseListener(new MouseHandler());			results.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			results.setCellRenderer(new ResultRenderer());			add(BorderLayout.CENTER,new JScrollPane(results));		}	
private HelpIndex getHelpIndex()		{			if(index == null)			{				index = new HelpIndex();				try				{					index.indexEditorHelp();				}				catch(Exception e)				{					index = null;					Log.log(Log.ERROR,this,e);					GUIUtilities.error(helpViewer.getComponent(),"helpviewer.search.error",						new String[] { e.toString() });				}			}				return index;		}	
ResultIcon(int rank)			{				this.rank = rank;			}	
public int getIconWidth()			{				return 40;			}	
public int getIconHeight()			{				return 9;			}	
public void paintIcon(Component c, Graphics g, int x, int y)			{				Graphics2D g2d = (Graphics2D)g.create();				g2d.setRenderingHints(renderingHints);					for(int i = 0; i < 4; i++)				{					if(rank > i)						g2d.setColor(UIManager.getColor("Label.foreground"));					else						g2d.setColor(UIManager.getColor("Label.disabledForeground"));					g2d.fillOval(x+i*10,y,9,9);				}			}	
public Component getListCellRendererComponent(				JList list,				Object value,				int index,				boolean isSelected,				boolean cellHasFocus)			{				super.getListCellRendererComponent(list,null,index,					isSelected,cellHasFocus);					if(value instanceof String)				{					setIcon(null);					setText((String)value);				}				else				{					Result result = (Result)value;					setIcon(new ResultIcon(result.rank));					setText(result.title);				}					return this;			}	
Result(HelpIndex.HelpFile file, int count)			{				this.file = file.file;				this.title = file.title;				rank = count;			}	
public int compare(Result r1, Result r2)			{				if(r1.rank == r2.rank)					return r1.title.compareTo(r2.title);				else					return r2.rank - r1.rank;			}	
public void actionPerformed(ActionEvent evt)			{				final HelpIndex index = getHelpIndex();				if(index == null)					return;					results.setListData(new String[] { jEdit.getProperty(					"helpviewer.searching") });					final String text = searchField.getText();				final Vector<Result> resultModel = new Vector<Result>();					VFSManager.runInWorkThread(new Runnable()				{					public void run()					{						StringTokenizer st = new StringTokenizer(text,",.;:-? ");							// we later use this to compute a relative ranking						int maxRank = 0;							while(st.hasMoreTokens())						{							String word = st.nextToken().toLowerCase();							HelpIndex.Word lookup = index.lookupWord(word);							if(lookup == null)								continue;								for(int i = 0; i < lookup.occurCount; i++)							{								HelpIndex.Word.Occurrence occur = lookup.occurrences[i];									boolean ok = false;									HelpIndex.HelpFile file = index.getFile(occur.file);								for(int j = 0; j < resultModel.size(); j++)								{									Result result = resultModel.elementAt(j);									if(result.file.equals(file.file))									{										result.rank += occur.count;										result.rank += 20; // multiple files w/ word bonus										maxRank = Math.max(result.rank,maxRank);										ok = true;										break;									}								}									if(!ok)								{									maxRank = Math.max(occur.count,maxRank);									resultModel.addElement(new Result(file,occur.count));								}							}						}							if(maxRank != 0)						{							// turn the rankings into relative rankings, from 1 to 4							for(int i = 0; i < resultModel.size(); i++)							{								Result result = resultModel.elementAt(i);								result.rank = (int)Math.ceil((double)result.rank * 4 / maxRank);							}								Collections.sort(resultModel,new ResultCompare());						}					}				});					VFSManager.runInAWTThread(new Runnable()				{					public void run()					{						if(resultModel.isEmpty())						{							results.setListData(new String[] {								jEdit.getProperty(								"helpviewer.no-results") });								getToolkit().beep();						}						else							results.setListData(resultModel);					}				});				}	
public void mouseReleased(MouseEvent evt)			{				int row = results.locationToIndex(evt.getPoint());				if(row != -1)				{					Result result = (Result)results.getModel()						.getElementAt(row);					helpViewer.gotoURL(result.file,true, 0);				}			}	
public HelpTOCPanel(HelpViewerInterface helpViewer)		{			super(new BorderLayout());				this.helpViewer = helpViewer;			nodes = new Hashtable();				toc = new TOCTree();				// looks bad with the OS X L&F, apparently...			if(!OperatingSystem.isMacOSLF())				toc.putClientProperty("JTree.lineStyle", "Angled");				toc.setCellRenderer(new TOCCellRenderer());			toc.setEditable(false);			toc.setShowsRootHandles(true);				add(BorderLayout.CENTER,new JScrollPane(toc));				load();		}	
public void selectNode(String shortURL)		{			if(tocModel == null)				return;				DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.get(shortURL);				if(node == null)				return;				TreePath path = new TreePath(tocModel.getPathToRoot(node));			toc.expandPath(path);			toc.setSelectionPath(path);			toc.scrollPathToVisible(path);		}	
public void load()		{			DefaultTreeModel empty = new DefaultTreeModel(				new DefaultMutableTreeNode(				jEdit.getProperty("helpviewer.toc.loading")));			toc.setModel(empty);			toc.setRootVisible(true);				VFSManager.runInWorkThread(new Runnable()			{				public void run()				{					createTOC();					tocModel.reload(tocRoot);					toc.setModel(tocModel);					toc.setRootVisible(false);					for(int i = 0; i <tocRoot.getChildCount(); i++)					{						DefaultMutableTreeNode node =							(DefaultMutableTreeNode)							tocRoot.getChildAt(i);						toc.expandPath(new TreePath(							node.getPath()));					}					if(helpViewer.getShortURL() != null)						selectNode(helpViewer.getShortURL());				}			});		}	
private DefaultMutableTreeNode createNode(String href, String title)		{			DefaultMutableTreeNode node = new DefaultMutableTreeNode(				new HelpNode(href,title),true);			nodes.put(href,node);			return node;		}	
private void createTOC()		{			EditPlugin[] plugins = jEdit.getPlugins();			Arrays.sort(plugins,new PluginCompare());			tocRoot = new DefaultMutableTreeNode();				tocRoot.add(createNode("welcome.html",				jEdit.getProperty("helpviewer.toc.welcome")));				tocRoot.add(createNode("README.txt",				jEdit.getProperty("helpviewer.toc.readme")));			tocRoot.add(createNode("CHANGES.txt",				jEdit.getProperty("helpviewer.toc.changes")));			tocRoot.add(createNode("TODO.txt",				jEdit.getProperty("helpviewer.toc.todo")));			tocRoot.add(createNode("COPYING.txt",				jEdit.getProperty("helpviewer.toc.copying")));			tocRoot.add(createNode("COPYING.DOC.txt",				jEdit.getProperty("helpviewer.toc.copying-doc")));			tocRoot.add(createNode("Apache.LICENSE.txt",				jEdit.getProperty("helpviewer.toc.copying-apache")));			tocRoot.add(createNode("COPYING.PLUGINS.txt",				jEdit.getProperty("helpviewer.toc.copying-plugins")));				loadTOC(tocRoot,"news43/toc.xml");			loadTOC(tocRoot,"users-guide/toc.xml");			loadTOC(tocRoot,"FAQ/toc.xml");					DefaultMutableTreeNode pluginTree = new DefaultMutableTreeNode(				jEdit.getProperty("helpviewer.toc.plugins"),true);				for(int i = 0; i < plugins.length; i++)			{				EditPlugin plugin = plugins[i];					String name = plugin.getClassName();					String docs = jEdit.getProperty("plugin." + name + ".docs");				String label = jEdit.getProperty("plugin." + name + ".name");				if(docs != null)				{					if(label != null && docs != null)					{						String path = plugin.getPluginJAR()							.getClassLoader()							.getResourceAsPath(docs);						pluginTree.add(createNode(							path,label));					}				}			}				if(pluginTree.getChildCount() != 0)				tocRoot.add(pluginTree);			else			{				// so that HelpViewer constructor doesn't try to expand				pluginTree = null;			}			loadTOC(tocRoot,"api/toc.xml");			tocModel = new DefaultTreeModel(tocRoot);		}	
private void loadTOC(DefaultMutableTreeNode root, String path)		{			TOCHandler h = new TOCHandler(root,MiscUtilities.getParentOfPath(path));			try			{				XMLUtilities.parseXML(					new URL(helpViewer.getBaseURL()						+ '/' + path).openStream(), h);			}			catch(IOException e)			{				Log.log(Log.ERROR,this,e);			}		}	
HelpNode(String href, String title)			{				this.href = href;				this.title = title;			}	
public String toString()			{				return title;			}	
TOCHandler(DefaultMutableTreeNode root, String dir)			{				nodes = new Stack();				node = root;				this.dir = dir;			}	
public void characters(char[] c, int off, int len)			{				if(tag.equals("TITLE"))				{					boolean firstNonWhitespace = false;					for(int i = 0; i < len; i++)					{						char ch = c[off + i];						if (!firstNonWhitespace && Character.isWhitespace(ch)) continue;						firstNonWhitespace = true;						title.append(ch);					}				}					}	
public void startElement(String uri, String localName,						 String name, Attributes attrs)			{				tag = name;				if (name.equals("ENTRY"))					href = attrs.getValue("HREF");			}	
public void endElement(String uri, String localName, String name)			{				if(name == null)					return;					if(name.equals("TITLE"))				{					DefaultMutableTreeNode newNode = createNode(						dir + href,title.toString());					node.add(newNode);					nodes.push(node);					node = newNode;					title.setLength(0);				}				else if(name.equals("ENTRY"))				{					node = (DefaultMutableTreeNode)nodes.pop();					href = null;				}			}	
TOCTree()			{				ToolTipManager.sharedInstance().registerComponent(this);				selectionModel.setSelectionMode(SINGLE_TREE_SELECTION);			}	
public final String getToolTipText(MouseEvent evt)			{				TreePath path = getPathForLocation(evt.getX(), evt.getY());				if(path != null)				{					Rectangle cellRect = getPathBounds(path);					if(cellRect != null && !cellRectIsVisible(cellRect))						return path.getLastPathComponent().toString();				}				return null;			}	
public void processKeyEvent(KeyEvent evt)			{				if ((KeyEvent.KEY_PRESSED == evt.getID()) &&				    (KeyEvent.VK_ENTER == evt.getKeyCode()))				{					TreePath path = getSelectionPath();					if(path != null)					{						Object obj = ((DefaultMutableTreeNode)							path.getLastPathComponent())							.getUserObject();						if(!(obj instanceof HelpNode))						{							this.expandPath(path);							return;						}							HelpNode node = (HelpNode)obj;						helpViewer.gotoURL(node.href,true,0);					}					evt.consume();				}				else				{					super.processKeyEvent(evt);				}			}	
protected void processMouseEvent(MouseEvent evt)			{				//ToolTipManager ttm = ToolTipManager.sharedInstance();					switch(evt.getID())				{				/* case MouseEvent.MOUSE_ENTERED:					toolTipInitialDelay = ttm.getInitialDelay();					toolTipReshowDelay = ttm.getReshowDelay();					ttm.setInitialDelay(200);					ttm.setReshowDelay(0);					super.processMouseEvent(evt);					break;				case MouseEvent.MOUSE_EXITED:					ttm.setInitialDelay(toolTipInitialDelay);					ttm.setReshowDelay(toolTipReshowDelay);					super.processMouseEvent(evt);					break; */				case MouseEvent.MOUSE_CLICKED:					TreePath path = getPathForLocation(evt.getX(),evt.getY());					if(path != null)					{						if(!isPathSelected(path))							setSelectionPath(path);							Object obj = ((DefaultMutableTreeNode)							path.getLastPathComponent())							.getUserObject();						if(!(obj instanceof HelpNode))						{							this.expandPath(path);							return;						}							HelpNode node = (HelpNode)obj;							helpViewer.gotoURL(node.href,true,0);					}						super.processMouseEvent(evt);					break;				default:					super.processMouseEvent(evt);					break;				}			}	
private boolean cellRectIsVisible(Rectangle cellRect)			{				Rectangle vr = TOCTree.this.getVisibleRect();				return vr.contains(cellRect.x,cellRect.y) &&					vr.contains(cellRect.x + cellRect.width,					cellRect.y + cellRect.height);			}	
public Component getTreeCellRendererComponent(JTree tree,				Object value, boolean sel, boolean expanded,				boolean leaf, int row, boolean focus)			{				super.getTreeCellRendererComponent(tree,value,sel,					expanded,leaf,row,focus);				setIcon(leaf ? FileCellRenderer.fileIcon					: (expanded ? FileCellRenderer.openDirIcon					: FileCellRenderer.dirIcon));				setBorder(border);					return this;			}	
public int compare(Object o1, Object o2)			{				EditPlugin p1 = (EditPlugin)o1;				EditPlugin p2 = (EditPlugin)o2;				return StandardUtilities.compareStrings(					jEdit.getProperty("plugin." + p1.getClassName() + ".name"),					jEdit.getProperty("plugin." + p2.getClassName() + ".name"),					true);			}	
/**		 * Creates a new help viewer with the default help page.		 * @since jEdit 4.0pre4		 */		public HelpViewer()		{			this("welcome.html");		}	
/**		 * Creates a new help viewer for the specified URL.		 * @param url The URL		 */		public HelpViewer(URL url)		{			this(url.toString());		}	
/**		 * Creates a new help viewer for the specified URL.		 * @param url The URL		 */		public HelpViewer(String url)		{			super(jEdit.getProperty("helpviewer.title"));				setIconImage(GUIUtilities.getEditorIcon());				try			{				baseURL = new File(MiscUtilities.constructPath(					jEdit.getJEditHome(),"doc")).toURL().toString();			}			catch(MalformedURLException mu)			{				Log.log(Log.ERROR,this,mu);				// what to do?			}				ActionHandler actionListener = new ActionHandler();				JTabbedPane tabs = new JTabbedPane();			tabs.addTab(jEdit.getProperty("helpviewer.toc.label"),				toc = new HelpTOCPanel(this));			tabs.addTab(jEdit.getProperty("helpviewer.search.label"),				new HelpSearchPanel(this));			tabs.setMinimumSize(new Dimension(0,0));				JPanel rightPanel = new JPanel(new BorderLayout());				Box toolBar = new Box(BoxLayout.X_AXIS);			//toolBar.setFloatable(false);				toolBar.add(title = new JLabel());			toolBar.add(Box.createGlue());			historyModel = new HelpHistoryModel(25);			back = new HistoryButton(HistoryButton.BACK,historyModel);			back.addActionListener(actionListener);			toolBar.add(back);			forward = new HistoryButton(HistoryButton.FORWARD,historyModel);			forward.addActionListener(actionListener);			toolBar.add(forward);			back.setPreferredSize(forward.getPreferredSize());			rightPanel.add(BorderLayout.NORTH,toolBar);				viewer = new JEditorPane();			viewer.setEditable(false);			viewer.addHyperlinkListener(new LinkHandler());			viewer.setFont(new Font("Monospaced",Font.PLAIN,12));			viewer.addPropertyChangeListener(new PropertyChangeHandler());			viewer.addKeyListener(new KeyHandler());				viewerScrollPane = new JScrollPane(viewer);				rightPanel.add(BorderLayout.CENTER,viewerScrollPane);				splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,						  jEdit.getBooleanProperty("appearance.continuousLayout"),						  tabs,						  rightPanel);			splitter.setBorder(null);					getContentPane().add(BorderLayout.CENTER,splitter);				historyModel.addHelpHistoryModelListener(this);			historyUpdated();				gotoURL(url,true,0);				setDefaultCloseOperation(DISPOSE_ON_CLOSE);				getRootPane().setPreferredSize(new Dimension(750,500));				pack();			GUIUtilities.loadGeometry(this,"helpviewer");			GUIUtilities.addSizeSaver(this,"helpviewer");				EditBus.addToBus(this);				setVisible(true);				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					splitter.setDividerLocation(jEdit.getIntegerProperty(						"helpviewer.splitter",250));					viewer.requestFocus();				}			});		}	
/**		 * Displays the specified URL in the HTML component.		 * 		 * @param url 		 The URL		 * @param addToHistory   Should the URL be added to the back/forward		 * 			 history?		 * @param scrollPosition The vertical scrollPosition		 */		public void gotoURL(String url, boolean addToHistory, final int scrollPosition)		{			// the TOC pane looks up user's guide URLs relative to the			// doc directory...			String shortURL;			if (MiscUtilities.isURL(url))			{				if (url.startsWith(baseURL))				{					shortURL = url.substring(baseURL.length());					if(shortURL.startsWith("/"))					{						shortURL = shortURL.substring(1);					}				}				else				{					shortURL = url;				}			}			else			{				shortURL = url;				if(baseURL.endsWith("/"))				{					url = baseURL + url;				}				else				{					url = baseURL + '/' + url;				}			}				// reset default cursor so that the hand cursor doesn't			// stick around			viewer.setCursor(Cursor.getDefaultCursor());				try			{				URL _url = new URL(url);					if(!_url.equals(viewer.getPage()))				{					title.setText(jEdit.getProperty("helpviewer.loading"));				}				else				{					/* don't show loading msg because we won't					   receive a propertyChanged */				}					historyModel.setCurrentScrollPosition(viewer.getPage(),getCurrentScrollPosition());				viewer.setPage(_url);				if (0 != scrollPosition)				{					SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							viewerScrollPane.getVerticalScrollBar().setValue(scrollPosition);						}					});				}				if(addToHistory)				{					historyModel.addToHistory(url);				}			}			catch(MalformedURLException mf)			{				Log.log(Log.ERROR,this,mf);				String[] args = { url, mf.getMessage() };				GUIUtilities.error(this,"badurl",args);				return;			}			catch(IOException io)			{				Log.log(Log.ERROR,this,io);				String[] args = { url, io.toString() };				GUIUtilities.error(this,"read-error",args);				return;			}				this.shortURL = shortURL;				// select the appropriate tree node.			if(shortURL != null)			{				toc.selectNode(shortURL);			}						viewer.requestFocus();		}	
int getCurrentScrollPosition() {			return viewerScrollPane.getVerticalScrollBar().getValue();		}	
URL getCurrentPage() {			return viewer.getPage();		}	
public void dispose()		{			EditBus.removeFromBus(this);			jEdit.setIntegerProperty("helpviewer.splitter",				splitter.getDividerLocation());			super.dispose();		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof PluginUpdate)			{				PluginUpdate pmsg = (PluginUpdate)msg;				if(pmsg.getWhat() == PluginUpdate.LOADED					|| pmsg.getWhat() == PluginUpdate.UNLOADED)				{					if(!pmsg.isExiting())					{						if(!queuedTOCReload)							queueTOCReload();						queuedTOCReload = true;					}				}			}			else if (msg instanceof PropertiesChanged)			{				GUIUtilities.initContinuousLayout(splitter);			}		}	
public String getBaseURL()		{			return baseURL;		}	
public String getShortURL()		{			return shortURL;		}	
public void historyUpdated()		{			back.setEnabled(historyModel.hasPrevious());			forward.setEnabled(historyModel.hasNext());		}	
public Component getComponent()		{			return getRootPane();		}	
public void queueTOCReload()		{			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					queuedTOCReload = false;					toc.load();				}			});		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				String actionCommand = evt.getActionCommand();				int separatorPosition = actionCommand.lastIndexOf(':');				String url;				int scrollPosition;				if (-1 == separatorPosition)				{					url = actionCommand;					scrollPosition = 0;				}				else				{					url = actionCommand.substring(0,separatorPosition);					scrollPosition = Integer.parseInt(actionCommand.substring(separatorPosition+1));				}				if (url.length() != 0)				{					gotoURL(url,false,scrollPosition);					return;				}					if(source == back)				{					HistoryEntry entry = historyModel.back(HelpViewer.this);					if(entry == null)					{						getToolkit().beep();					}					else					{						gotoURL(entry.url,false,entry.scrollPosition);					}				}				else if(source == forward)				{					HistoryEntry entry = historyModel.forward(HelpViewer.this);					if(entry == null)					{						getToolkit().beep();					}					else					{						gotoURL(entry.url,false,entry.scrollPosition);					}				}			}	
public void hyperlinkUpdate(HyperlinkEvent evt)			{				if(evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED)				{					if(evt instanceof HTMLFrameHyperlinkEvent)					{						((HTMLDocument)viewer.getDocument())							.processHTMLFrameHyperlinkEvent(							(HTMLFrameHyperlinkEvent)evt);						historyUpdated();					}					else					{						URL url = evt.getURL();						if(url != null)						{							gotoURL(url.toString(),true,0);						}					}				}				else if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED)				{					viewer.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));				}				else if (evt.getEventType() == HyperlinkEvent.EventType.EXITED)				{					viewer.setCursor(Cursor.getDefaultCursor());				}			}	
public void propertyChange(PropertyChangeEvent evt)			{				if("page".equals(evt.getPropertyName()))				{					String titleStr = (String)viewer.getDocument()						.getProperty("title");					if(titleStr == null)					{						titleStr = MiscUtilities.getFileName(							viewer.getPage().toString());					}					title.setText(titleStr);					historyModel.updateTitle(viewer.getPage().toString(),						titleStr);				}			}	
public void keyPressed(KeyEvent ke)			{				switch (ke.getKeyCode())				{				case KeyEvent.VK_UP:					JScrollBar scrollBar = viewerScrollPane.getVerticalScrollBar();					scrollBar.setValue(scrollBar.getValue()-scrollBar.getUnitIncrement(-1));					ke.consume();					break;				case KeyEvent.VK_DOWN:					scrollBar = viewerScrollPane.getVerticalScrollBar();					scrollBar.setValue(scrollBar.getValue()+scrollBar.getUnitIncrement(1));					ke.consume();					break;				case KeyEvent.VK_LEFT:					scrollBar = viewerScrollPane.getHorizontalScrollBar();					scrollBar.setValue(scrollBar.getValue()-scrollBar.getUnitIncrement(-1));					ke.consume();					break;				case KeyEvent.VK_RIGHT:					scrollBar = viewerScrollPane.getHorizontalScrollBar();					scrollBar.setValue(scrollBar.getValue()+scrollBar.getUnitIncrement(1));					ke.consume();					break;				}			}	
public HistoryButton(int type, HelpHistoryModel model)		{			super();			arrow_button = new RolloverButton(GUIUtilities.loadIcon(				jEdit.getProperty(type==BACK							? "helpviewer.back.icon"							: "helpviewer.forward.icon")));			arrow_button.setToolTipText(				jEdit.getProperty(type==BACK							? "helpviewer.back.label"							: "helpviewer.forward.label"));			Box box = new Box(BoxLayout.X_AXIS);			drop_button = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("dropdown-arrow.icon")));			drop_button.addActionListener(new DropActionHandler());			box.add(arrow_button);			box.add(drop_button);			this.setMaximumSize(new Dimension(				drop_button.getPreferredSize().width +				arrow_button.getPreferredSize().width +				5,				arrow_button.getPreferredSize().height + 10)				);			this.add(box);			this.type = type;			this.history = model;		}	
public void setEnabled(boolean state)		{			super.setEnabled(state);			drop_button.setEnabled(state);			arrow_button.setEnabled(state);		}	
public void addActionListener(ActionListener al)		{			arrow_button.addActionListener(this);			arrowActionListener = al;		}	
public void actionPerformed(ActionEvent evt)		{			arrowActionListener.actionPerformed(				new ActionEvent(this,					ActionEvent.ACTION_PERFORMED,					evt.getActionCommand(),					evt.getWhen(),					evt.getModifiers()					)				);		}	
private HistoryButton getParentHistoryButton()		{			return this;		}	
public void actionPerformed(ActionEvent evt)			{				historyList = new JPopupMenu();				HelpHistoryModel.HistoryEntry[] urls;				if (type == BACK)				{					urls = history.getPreviousURLs();				}				else				{					urls = history.getNextURLs();				}				if (urls != null)				{					if (type == BACK) {						for (int i=urls.length-1 ; i>=0 ; i--)						{							if (urls[i] != null)							{								historyList.add(new HistoryListActionHandler(urls[i]));							}						}					}					else					{						for (int i=0 ; i<urls.length ; i++)						{							if (urls[i] != null)							{								historyList.add(new HistoryListActionHandler(urls[i]));							}						}					}						historyList.show((JComponent)evt.getSource(),0,0);				}			}	
HistoryListActionHandler(HelpHistoryModel.HistoryEntry entry)			{				super(entry.title);				this.entry = entry;				this.putValue(Action.ACTION_COMMAND_KEY,entry.url + ':' + entry.scrollPosition);			}	
public void actionPerformed(ActionEvent ae)			{				getParentHistoryButton().actionPerformed(ae);				history.setCurrentEntry(entry);			}	
/**		 * Creates a new history list. Calling this is normally not		 * necessary.		 */		public HistoryModel(String name)		{			this.name = name;		}	
/**		 * Adds an item to the end of this history list, trimming the list		 * to the maximum number of items if necessary.		 * @param text The item		 */		public void addItem(String text)		{			if(text == null || text.length() == 0)				return;				int index = indexOf(text);			if(index != -1)				removeElementAt(index);				insertElementAt(text,0);				while(getSize() > max)				removeElementAt(getSize() - 1);		}	
public void insertElementAt(Object obj, int index)		{			modified = true;			super.insertElementAt(obj,index);		}	
/**		 * Returns an item from the history list.		 * @param index The index		 */		public String getItem(int index)		{			return (String)elementAt(index);		}	
public boolean removeElement(Object obj)		{			modified = true;			return super.removeElement(obj);		}	
/**		 * @deprecated Call <code>removeAllElements()</code> instead.		 */		public void clear()		{			removeAllElements();		}	
public void removeAllElements()		{			modified = true;			super.removeAllElements();		}	
/**		 * Returns the name of this history list. This can be passed		 * to the HistoryTextField constructor.		 */		public String getName()		{			return name;		}	
/**		 * Returns a named model. If the specified model does not		 * already exist, it will be created.		 * @param name The model name		 */		public static HistoryModel getModel(String name)		{			if(models == null)				models = Collections.synchronizedMap(new HashMap<String, HistoryModel>());				HistoryModel model = models.get(name);			if(model == null)			{				model = new HistoryModel(name);				models.put(name,model);			}				return model;		}	
public static void loadHistory()		{			if (saver != null)				models = saver.load(models);		}	
public static void saveHistory()		{			if (saver != null && modified && saver.save(models))				modified = false;		}	
public static void setMax(int max)		{			HistoryModel.max = max;		}	
public static void setSaver(HistoryModelSaver saver)		{			HistoryModel.saver = saver;		}	
public HistoryText(JTextComponent text, String name)		{			this.text = text;			setModel(name);			index = -1;		}	
public void fireActionPerformed()		{		}	
public int getIndex()		{			return index;		}	
public void setIndex(int index)		{			this.index = index;		}	
/**		 * Returns the underlying history controller.		 * @since jEdit 4.3pre1		 */		public HistoryModel getModel()		{			return historyModel;		}	
/**		 * Sets the history list controller.		 * @param name The model name		 * @since jEdit 4.3pre1		 */		public void setModel(String name)		{			if(name == null)				historyModel = null;			else				historyModel = HistoryModel.getModel(name);			index = -1;		}	
/**		 * Sets if selecting a value from the popup should immediately fire		 * an ActionEvent.		 */		public void setInstantPopups(boolean instantPopups)		{			this.instantPopups = instantPopups;		}	
/**		 * Returns if selecting a value from the popup should immediately fire		 * an ActionEvent.		 */		public boolean getInstantPopups()		{			return instantPopups;		}	
/**		 * Adds the currently entered item to the history.		 */		public void addCurrentToHistory()		{			if(historyModel != null)				historyModel.addItem(getText());			index = 0;		}	
public void doBackwardSearch()		{			if(historyModel == null)				return;				if(text.getSelectionEnd() != getDocument().getLength())			{				text.setCaretPosition(getDocument().getLength());			}				int start = getInputStart();			String t = getText().substring(0,				text.getSelectionStart() - start);			if(t == null)			{				historyPrevious();				return;			}				for(int i = index + 1; i < historyModel.getSize(); i++)			{				String item = historyModel.getItem(i);				if(item.startsWith(t))				{					text.replaceSelection(item.substring(t.length()));					text.select(getInputStart() + t.length(),						getDocument().getLength());					index = i;					return;				}			}				text.getToolkit().beep();		}	
public void doForwardSearch()		{			if(historyModel == null)				return;				if(text.getSelectionEnd() != getDocument().getLength())			{				text.setCaretPosition(getDocument().getLength());			}				int start = getInputStart();			String t = getText().substring(0,				text.getSelectionStart() - start);			if(t == null)			{				historyNext();				return;			}				for(int i = index - 1; i >= 0; i--)			{				String item = historyModel.getItem(i);				if(item.startsWith(t))				{					text.replaceSelection(item.substring(t.length()));					text.select(getInputStart() + t.length(),						getDocument().getLength());					index = i;					return;				}			}				text.getToolkit().beep();		}	
public void historyPrevious()		{			if(historyModel == null)				return;				if(index == historyModel.getSize() - 1)				text.getToolkit().beep();			else if(index == -1)			{				current = getText();				setText(historyModel.getItem(0));				index = 0;			}			else			{				// have to do this because setText() sets index to -1				int newIndex = index + 1;				setText(historyModel.getItem(newIndex));				index = newIndex;			}		}	
public void historyNext()		{			if(historyModel == null)				return;				if(index == -1)				text.getToolkit().beep();			else if(index == 0)				setText(current);			else			{				// have to do this because setText() sets index to -1				int newIndex = index - 1;				setText(historyModel.getItem(newIndex));				index = newIndex;			}		}	
public Document getDocument()		{			return text.getDocument();		}	
/**		 * Subclasses can override this to provide funky history behavior,		 * for JTextPanes and such.		 */		public String getText()		{			return text.getText();		}	
/**		 * Subclasses can override this to provide funky history behavior,		 * for JTextPanes and such.		 */		public void setText(String text)		{			this.index = -1;			this.text.setText(text);		}	
/**		 * Subclasses can override this to provide funky history behavior,		 * for JTextPanes and such.		 */		public int getInputStart()		{			return 0;		}	
public void showPopupMenu(String t, int x, int y)		{			if(historyModel == null)				return;				text.requestFocus();				if(popup != null && popup.isVisible())			{				popup.setVisible(false);				popup = null;				return;			}				popup = new JPopupMenu()			{				@Override				public void setVisible(boolean b)				{					if (!b)					{						popup = null;					}					super.setVisible(b);				}			};			JMenuItem caption = new JMenuItem(jEdit.getProperty(				"history.caption"));			caption.addActionListener(new ActionListener()			{			  public void actionPerformed(ActionEvent e) 			  {			    new ListModelEditor().open(historyModel);			  }			});			 		popup.add(caption);	 		popup.addSeparator();				for(int i = 0; i < historyModel.getSize(); i++)			{				String item = historyModel.getItem(i);				if(item.startsWith(t))				{					JMenuItem menuItem = new JMenuItem(item);					menuItem.setActionCommand(String.valueOf(i));					menuItem.addActionListener(						new ActionHandler());					popup.add(menuItem);				}			}				GUIUtilities.showPopupMenu(popup,text,x,y,false);		}	
public void showPopupMenu(boolean search)		{			if(search)				showPopupMenu(getText().substring(getInputStart(),					text.getSelectionStart()),0,text.getHeight());			else				showPopupMenu("",0,text.getHeight());		}	
public void actionPerformed(ActionEvent evt)			{				int ind = Integer.parseInt(evt.getActionCommand());				if(ind == -1)				{					if(index != -1)						setText(current);				}				else				{					setText(historyModel.getItem(ind));					index = ind;				}				if(instantPopups)				{					addCurrentToHistory();					fireActionPerformed();				}			}	
public HistoryTextArea(String name)		{			super(3,15);			controller = new HistoryText(this,name);			setFocusTraversalKeys(				KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,				Collections.singleton(					KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0)));			setFocusTraversalKeys(				KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,				Collections.singleton(					KeyStroke.getKeyStroke(KeyEvent.VK_TAB,						InputEvent.SHIFT_MASK)));		}	
/**		 * Returns the underlying history controller.		 * @since jEdit 4.3pre1		 */		public HistoryModel getModel()		{			return controller.getModel();		}	
/**		 * Sets the history list controller.		 * @param name The model name		 * @since jEdit 4.3pre1		 */		public void setModel(String name)		{			controller.setModel(name);		}	
/**		 * Sets if selecting a value from the popup should immediately fire		 * an ActionEvent.		 */		public void setInstantPopups(boolean instantPopups)		{			controller.setInstantPopups(instantPopups);		}	
/**		 * Returns if selecting a value from the popup should immediately fire		 * an ActionEvent.		 */		public boolean getInstantPopups()		{			return controller.getInstantPopups();		}	
/**		 * Adds the currently entered item to the history.		 */		public void addCurrentToHistory()		{			controller.addCurrentToHistory();		}	
/**		 * Sets the displayed text.		 */		public void setText(String text)		{			super.setText(text);			controller.setIndex(-1);		}	
protected void processKeyEvent(KeyEvent evt)		{			if(!isEnabled())				return;				if(evt.getID() == KeyEvent.KEY_PRESSED)			{				switch(evt.getKeyCode())				{				case KeyEvent.VK_ENTER:					if(evt.isControlDown())					{						replaceSelection("\n");						evt.consume();					}					break;				case KeyEvent.VK_TAB:					if(evt.isControlDown())					{						replaceSelection("\t");						evt.consume();					}					break;				case KeyEvent.VK_PAGE_UP:					if(evt.isShiftDown())						controller.doBackwardSearch();					else						controller.historyPrevious();					evt.consume();					break;				case KeyEvent.VK_PAGE_DOWN:					if(evt.isShiftDown())						controller.doForwardSearch();					else						controller.historyNext();					evt.consume();					break;				case KeyEvent.VK_UP:					if(evt.isAltDown())					{						controller.showPopupMenu(							evt.isShiftDown());						evt.consume();					}					break;				}			}				if(!evt.isConsumed())				super.processKeyEvent(evt);		}	
protected void processMouseEvent(MouseEvent evt)		{			if(!isEnabled())				return;				switch(evt.getID())			{			case MouseEvent.MOUSE_PRESSED:				if(GUIUtilities.isPopupTrigger(evt))					controller.showPopupMenu(evt.isShiftDown());				else					super.processMouseEvent(evt);					break;			default:				super.processMouseEvent(evt);				break;			}		}	
/**		 * Creates a new history text field.		 * @since jEdit 3.2pre5		 */		public HistoryTextField()		{			this(null);		}	
/**		 * Creates a new history text field.		 * @param name The history model name		 */		public HistoryTextField(String name)		{			this(name,false,true);		}	
/**		 * Creates a new history text field.		 * @param name The history model name		 * @param instantPopups If true, selecting a value from the history		 * popup will immediately fire an ActionEvent. If false, the user		 * will have to press 'Enter' first		 *		 * @since jEdit 2.2pre5		 */		public HistoryTextField(String name, boolean instantPopups)		{			this(name,instantPopups,true);		}	
/**		 * Creates a new history text field.		 * @param name The history model name		 * @param instantPopups If true, selecting a value from the history		 * popup will immediately fire an ActionEvent. If false, the user		 * will have to press 'Enter' first		 * @param enterAddsToHistory If true, pressing the Enter key will		 * automatically add the currently entered text to the history.		 *		 * @since jEdit 2.6pre5		 */		public HistoryTextField(String name, boolean instantPopups,			boolean enterAddsToHistory)		{			controller = new HistoryText(this,null)			{				public void fireActionPerformed()				{					HistoryTextField.this.fireActionPerformed();				}			};				setModel(name);			MouseHandler mouseHandler = new MouseHandler();			addMouseListener(mouseHandler);			addMouseMotionListener(mouseHandler);				setInstantPopups(instantPopups);			setEnterAddsToHistory(enterAddsToHistory);		}	
/**		 * Sets if selecting a value from the popup should immediately fire		 * an ActionEvent.		 * @since jEdit 4.0pre3		 */		public void setInstantPopups(boolean instantPopups)		{			controller.setInstantPopups(instantPopups);		}	
/**		 * Returns if selecting a value from the popup should immediately fire		 * an ActionEvent.		 * @since jEdit 4.0pre3		 */		public boolean getInstantPopups()		{			return controller.getInstantPopups();		}	
/**		 * Sets if pressing Enter should automatically add the currently		 * entered text to the history.		 * @since jEdit 4.0pre3		 */		public void setEnterAddsToHistory(boolean enterAddsToHistory)		{			this.enterAddsToHistory = enterAddsToHistory;		}	
/**		 * Returns if pressing Enter should automatically add the currently		 * entered text to the history.		 * @since jEdit 4.0pre3		 */		public boolean setEnterAddsToHistory()		{			return enterAddsToHistory;		}	
/**		 * Sets if all text should be selected when the field gets focus.		 * @since jEdit 4.0pre3		 */		public void setSelectAllOnFocus(boolean selectAllOnFocus)		{			this.selectAllOnFocus = selectAllOnFocus;		}	
/**		 * Returns if all text should be selected when the field gets focus.		 * @since jEdit 4.0pre3		 */		public boolean setSelectAllOnFocus()		{			return selectAllOnFocus;		}	
/**		 * Returns the underlying history model.		 */		public HistoryModel getModel()		{			return controller.getModel();		}	
/**		 * Sets the history list model.		 * @param name The model name		 * @since jEdit 2.3pre3		 */		public void setModel(String name)		{			controller.setModel(name);				if(name != null)			{				setBorder(new CompoundBorder(this.getBorder(), new HistoryBorder()));			}						repaint();		}	
/**		 * Adds the currently entered item to the history.		 */		public void addCurrentToHistory()		{			controller.addCurrentToHistory();		}	
/**		 * Sets the displayed text.		 */		public void setText(String text)		{			super.setText(text);			controller.setIndex(-1);		}	
/**		 * Make it public.		 */		public void fireActionPerformed()		{			super.fireActionPerformed();		}	
protected void processKeyEvent(KeyEvent evt)		{			if(!isEnabled())				return;				if(evt.getID() == KeyEvent.KEY_PRESSED)			{				switch(evt.getKeyCode())				{				case KeyEvent.VK_ENTER:					if(enterAddsToHistory)						addCurrentToHistory();						if(evt.getModifiers() == 0)					{						fireActionPerformed();						evt.consume();					}					break;				case KeyEvent.VK_UP:					if(evt.isShiftDown())						controller.doBackwardSearch();					else						controller.historyPrevious();					evt.consume();					break;				case KeyEvent.VK_DOWN:					if(evt.isShiftDown())						controller.doForwardSearch();					else if(evt.isAltDown())					{						controller.showPopupMenu(							evt.isShiftDown());					}					else						controller.historyNext();					evt.consume();					break;				case KeyEvent.VK_TAB:					if(evt.isControlDown())					{						controller.doBackwardSearch();						evt.consume();					}					break;				}			}				if(!evt.isConsumed())				super.processKeyEvent(evt);		}	
protected void processMouseEvent(MouseEvent evt)		{			if(!isEnabled())				return;				switch(evt.getID())			{			case MouseEvent.MOUSE_PRESSED:				Border border = getBorder();				Insets insets = border.getBorderInsets(HistoryTextField.this);					if(evt.getX() >= getWidth() - insets.right					|| GUIUtilities.isPopupTrigger(evt))				{					controller.showPopupMenu(evt.isShiftDown());				}				else					super.processMouseEvent(evt);					break;			case MouseEvent.MOUSE_EXITED:				setCursor(Cursor.getDefaultCursor());				super.processMouseEvent(evt);				break;			default:				super.processMouseEvent(evt);				break;			}		}	
public void mousePressed(MouseEvent evt)			{				selectAll = (!hasFocus() && selectAllOnFocus);			}	
public void mouseReleased(MouseEvent evt)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						if(selectAll)							selectAll();					}				});			}	
public void mouseMoved(MouseEvent evt)			{				Border border = getBorder();				Insets insets = border.getBorderInsets(HistoryTextField.this);					if(evt.getX() >= getWidth() - insets.right)					setCursor(Cursor.getDefaultCursor());				else					setCursor(Cursor.getPredefinedCursor(						Cursor.TEXT_CURSOR));			}	
public void mouseDragged(MouseEvent evt)			{				selectAll = false;			}	
public void paintBorder(Component c, Graphics g,				int x, int y, int w, int h)			{				g.translate(x+w-WIDTH,y-1);					//if(c.isEnabled())				//{				//	// vertical separation line				//	g.setColor(UIManager.getColor("controlDkShadow"));				//	g.drawLine(0,0,0,h);				//}					// down arrow				int w2 = WIDTH/2;				int h2 = h/2;				g.setColor(UIManager.getColor(c.isEnabled()					&& ((HistoryTextField)c).getModel() != null					? "TextField.foreground" : "TextField.disabledForeground"));				g.drawLine(w2-5,h2-2,w2+4,h2-2);				g.drawLine(w2-4,h2-1,w2+3,h2-1);				g.drawLine(w2-3,h2  ,w2+2,h2  );				g.drawLine(w2-2,h2+1,w2+1,h2+1);				g.drawLine(w2-1,h2+2,w2  ,h2+2);					g.translate(-(x+w-WIDTH),-(y-1));			}	
public Insets getBorderInsets(Component c)			{				return new Insets(0,0,0,WIDTH);			}	
public HyperSearchFileNode(String path)		{			this.path = path;		}	
public Buffer getBuffer(View view)		{			return jEdit.openFile(view,path);		}	
public void goTo(EditPane editPane)		{			Buffer buffer = getBuffer(editPane.getView());			if(buffer == null)				return;				editPane.setBuffer(buffer);		}	
public String toString()		{			if (showFullPath)				return path;			String[] paths = path.split(fileSep);			return paths[paths.length - 1];		}	
public boolean equals(Object compareObj)		{			if (!(compareObj instanceof HyperSearchFileNode))				return false;			HyperSearchFileNode otherResult = (HyperSearchFileNode)compareObj;						return path.equals(MiscUtilities.resolveSymlinks(otherResult.path));		}	
/**		 * Returns the result count.		 *		 * @return the result count		 * @since jEdit 4.3pre9		 */		public int getCount()		{			return count;		}	
/**		 * Set the result count.		 *		 * @param count the result count		 * @since jEdit 4.3pre9		 */		public void setCount(int count)		{			this.count = count;		}	
public File getNodeFile()		{			return nodeFile;		}	
public HyperSearchFolderNode(File nodeFile, boolean showFullPath) 		{			this.nodeFile = nodeFile;			this.showFullPath = showFullPath;		}	
public String toString()		{			if (showFullPath)				return nodeFile.getAbsolutePath();			String paths[] = nodeFile.getAbsolutePath().split(fileSep);			return paths[paths.length - 1];					}	
public HyperSearchOperationNode(String searchString, SearchMatcher searchMatcher)		{			this.searchString = searchString;			this.searchMatcher = searchMatcher;		}	
public String toString() 		{			return searchString;		}	
public boolean isTreeViewDisplayed() 		{			return treeViewDisplayed;		}	
public void setTreeViewDisplayed(boolean treeViewDisplayed) 		{			this.treeViewDisplayed = treeViewDisplayed;		}	
public void restoreFlatNodes(JTree resultTree, DefaultMutableTreeNode operNode)		{			for (int i = 0; i < resultNodes.size(); i++)			{				DefaultMutableTreeNode element = resultNodes.get(i);				if (element.getUserObject() instanceof HyperSearchFileNode)					((HyperSearchFileNode)element.getUserObject()).showFullPath = true;					operNode.insert(element, operNode.getChildCount());			}				((DefaultTreeModel)resultTree.getModel()).nodeStructureChanged(operNode);						for (Enumeration e = operNode.children(); e.hasMoreElements();)			{				DefaultMutableTreeNode node = (DefaultMutableTreeNode)e.nextElement();				resultTree.expandPath(new TreePath(node.getPath()));			}			resultTree.scrollPathToVisible(				new TreePath(operNode.getPath()));		}	
public void cacheResultNodes(DefaultMutableTreeNode operNode) 		{			resultNodes = new ArrayList<DefaultMutableTreeNode>(operNode.getChildCount());			for (Enumeration e = operNode.children(); e.hasMoreElements();)				resultNodes.add((DefaultMutableTreeNode) e.nextElement());		}	
public static void removeNodeFromCache(MutableTreeNode mnode)		{			DefaultMutableTreeNode node = (DefaultMutableTreeNode)mnode;			if (node.getUserObject() instanceof HyperSearchOperationNode)				return;						DefaultMutableTreeNode tmpNode = node;			while ((tmpNode = (DefaultMutableTreeNode) tmpNode.getParent()) != null)			{				if (!(tmpNode.getUserObject() instanceof HyperSearchOperationNode))					continue;				HyperSearchOperationNode operNode = (HyperSearchOperationNode) tmpNode.getUserObject();				if (operNode.resultNodes != null)				{					// the nodes aren't cached so no need to remove the node from cache					operNode.resultNodes.remove(node);				}				break;			}					}	
public void insertTreeNodes(JTree resultTree, DefaultMutableTreeNode operNode)		{			String fileSep = System.getProperty("file.separator");			String fileSepRegex = System.getProperty("file.separator");			if (fileSep.equals("\\"))				fileSepRegex = "\\\\";						//find the highest level common path			String[] topPathTmp = null;			int topPathNdx = -1;				for (int i = 0;i < resultNodes.size();i++)			{				DefaultMutableTreeNode fileTreeNode = resultNodes.get(i);				Object obj = fileTreeNode.getUserObject();				if (!(obj instanceof HyperSearchFileNode))					continue;				HyperSearchFileNode fileNode = (HyperSearchFileNode)obj;					int pos = fileNode.path.lastIndexOf(fileSep);				String pathName = fileNode.path.substring(0, pos);				String[] paths = pathName.split(fileSepRegex);				if (topPathNdx == -1)				{					topPathNdx = paths.length;					topPathTmp = paths;				}				else if (paths.length < topPathNdx)				{					topPathNdx = paths.length;					topPathTmp = paths;								}				else				{					for (int ndx =0 ; ndx < topPathNdx; ndx++)					{						if (!paths[ndx].equals(topPathTmp[ndx]))						{							topPathNdx = ndx;							break;						}					}				}			}			String[] topPath = new String[topPathNdx];			String topPathPath = "";			for (int ndx = 0 ; ndx < topPathNdx; ndx++)			{				topPath[ndx] = topPathTmp[ndx];				topPathPath = topPathPath.concat(topPath[ndx] + fileSep);			}			Map<String, DefaultMutableTreeNode> treeNodes = new HashMap<String, DefaultMutableTreeNode>();			HyperSearchFolderNode folderNode = 				new HyperSearchFolderNode(new File(topPathPath), true);			DefaultMutableTreeNode folderTreeNode = new DefaultMutableTreeNode(folderNode);			operNode.insert(folderTreeNode, operNode.getChildCount());			treeNodes.put(topPathPath, folderTreeNode);						for (int i = 0;i < resultNodes.size();i++)			{				DefaultMutableTreeNode fileTreeNode = resultNodes.get(i);				Object obj = fileTreeNode.getUserObject();				if (!(obj instanceof HyperSearchFileNode))					continue;				HyperSearchFileNode fileNode = (HyperSearchFileNode)obj;					fileNode.showFullPath = false;				int pos = fileNode.path.lastIndexOf(fileSep);				String pathName = fileNode.path.substring(0, pos);				String[] paths = pathName.split(fileSepRegex);								DefaultMutableTreeNode insNode = folderTreeNode;				String partialPath = topPathPath;				for (int ndx = topPathNdx; ndx < paths.length; ndx++)				{					partialPath = partialPath.concat(paths[ndx] + fileSep);					DefaultMutableTreeNode tmpNode = treeNodes.get(partialPath);					if (tmpNode == null)					{						HyperSearchFolderNode tmpFolderNode = 							new HyperSearchFolderNode(new File(partialPath), false);						tmpNode = new DefaultMutableTreeNode(tmpFolderNode);						insNode.insert(tmpNode, insNode.getChildCount());						treeNodes.put(partialPath, tmpNode);					}					insNode = tmpNode;				}				insNode.insert(fileTreeNode, insNode.getChildCount());				treeNodes.put(fileNode.path, insNode);			}					}	
public SearchMatcher getSearchMatcher()		{			return searchMatcher;		}	
public String getSearchString()		{			return searchString;		}	
HyperSearchRequest(View view, SearchMatcher matcher,			HyperSearchResults results, Selection[] selection)		{			this.view = view;			this.matcher = matcher;				this.results = results;			searchString = SearchAndReplace.getSearchString();			rootSearchNode = new DefaultMutableTreeNode(new HyperSearchOperationNode(searchString, matcher));				this.selection = selection;		}	
public void run()		{			setStatus(jEdit.getProperty("hypersearch-status"));				SearchFileSet fileset = SearchAndReplace.getSearchFileSet();			String[] files = fileset.getFiles(view);			if(files == null || files.length == 0)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						GUIUtilities.error(view,"empty-fileset",null);						results.searchDone(rootSearchNode);					}				});				return;			}				setMaximum(fileset.getFileCount(view));				// to minimize synchronization and stuff like that, we only			// show a status message at most twice a second				// initially zero, so that we always show the first message			String searchingCaption = jEdit.getProperty("hypersearch-results.searching",					new String[] { SearchAndReplace.getSearchString() }) + ' ';			try			{				if(selection != null)				{					Buffer buffer = view.getBuffer();						searchInSelection(buffer);				}				else				{					int current = 0;						long lastStatusTime = 0;					int resultCount = 0;					boolean asked = false;					int maxResults = jEdit.getIntegerProperty("hypersearch.maxWarningResults");	loop:				for(int i = 0; i < files.length; i++)					{						if(jEdit.getBooleanProperty("hyperSearch-stopButton"))						{							jEdit.setTemporaryProperty("hyperSearch-stopButton", "false");							Log.log(Log.MESSAGE, this, "Search stopped by user action (stop button)");							break;						}						if (!asked && resultCount > maxResults && maxResults != 0)						{							Log.log(Log.DEBUG, this, "Search in progress, " + resultCount +										 " occurrences found, asking the user to stop");							asked = true;							int ret = GUIUtilities.confirm(view, "hypersearch.tooManyResults",										       new Object[]{resultCount},										       JOptionPane.YES_NO_OPTION,										       JOptionPane.QUESTION_MESSAGE);							if (ret == JOptionPane.YES_OPTION)							{								Log.log(Log.MESSAGE, this, "Search stopped by user action");								break;							}						}						String file = files[i];						current++;							long currentTime = System.currentTimeMillis();						if(currentTime - lastStatusTime > 250)						{							setValue(current);							lastStatusTime = currentTime;							results.setSearchStatus(searchingCaption + file);						}							Buffer buffer = jEdit.openTemporary(null,null,file,false);						if(buffer == null)							continue loop;							resultCount += doHyperSearch(buffer, 0, buffer.getLength());					}					Log.log(Log.MESSAGE, this, resultCount +" OCCURENCES");				}			}			catch(final Exception e)			{				Log.log(Log.ERROR,this,e);				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						SearchAndReplace.handleError(view,e);					}				});			}			catch(WorkThread.Abort a)			{			}			finally			{				VFSManager.runInAWTThread(new Runnable()				{					public void run()					{						results.searchDone(rootSearchNode, selectNode);					}				});			}		}	
private int searchInSelection(Buffer buffer) throws Exception		{			setAbortable(false);				int resultCount = 0;				try			{				buffer.readLock();					for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					if(s instanceof Selection.Rect)					{						for(int j = s.getStartLine();							j <= s.getEndLine(); j++)						{							resultCount += doHyperSearch(buffer,								s.getStart(buffer,j),								s.getEnd(buffer,j));						}					}					else					{						resultCount += doHyperSearch(buffer,							s.getStart(),s.getEnd());					}				}			}			finally			{				buffer.readUnlock();			}				setAbortable(true);				return resultCount;		}	
private int doHyperSearch(Buffer buffer, int start, int end)			throws Exception		{			setAbortable(false);				HyperSearchFileNode hyperSearchFileNode = new HyperSearchFileNode(buffer.getPath());			DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(hyperSearchFileNode);				int resultCount = doHyperSearch(buffer,start,end,bufferNode);			hyperSearchFileNode.setCount(resultCount);			if(resultCount != 0)				rootSearchNode.insert(bufferNode,rootSearchNode.getChildCount());				setAbortable(true);				return resultCount;		}	
private int doHyperSearch(Buffer buffer, int start, int end,			DefaultMutableTreeNode bufferNode)		{			int resultCount = 0;			JEditTextArea textArea = jEdit.getActiveView().getTextArea();			int caretLine = textArea.getBuffer() == buffer ? textArea.getCaretLine() : -1;			try			{				buffer.readLock();					boolean endOfLine = buffer.getLineEndOffset(					buffer.getLineOfOffset(end)) - 1 == end;					int offset = start;					HyperSearchResult lastResult = null;	loop:			for(int counter = 0; ; counter++)				{					boolean startOfLine = buffer.getLineStartOffset(						buffer.getLineOfOffset(offset)) == offset;						SearchMatcher.Match match = matcher.nextMatch(						buffer.getSegment(offset, end - offset),						startOfLine,endOfLine,counter == 0,						false);					if(match == null)						break loop;						int newLine = buffer.getLineOfOffset(						offset + match.start);					if(lastResult == null || lastResult.line != newLine)					{						lastResult = new HyperSearchResult(							buffer,newLine);						DefaultMutableTreeNode child = new DefaultMutableTreeNode(							lastResult, false);						if (lastResult.line == caretLine)							selectNode = child;						bufferNode.add(child);					}						lastResult.addOccur(offset + match.start,						offset + match.end);						offset += match.end;					resultCount++;				}			}			finally			{				buffer.readUnlock();			}				return resultCount;		}	
public Buffer getBuffer(View view)		{			if(buffer == null)				buffer = jEdit.openFile(view,path);			return buffer;		}	
/**		 * Returns an array of selection objects pointing to the occurrences		 * of the search term on the current line. The buffer must be opened		 * first.		 * @since jEdit 4.2pre5		 */		public Selection[] getSelection()		{			if(buffer == null)				return null;				Selection[] returnValue = new Selection[occurCount];			Occur o = occur;			int i = 0;			while(o != null)			{				Selection.Range s = new Selection.Range(					o.startPos.getOffset(),					o.endPos.getOffset()				);				returnValue[i++] = s;				o = o.next;			}			return returnValue;		}	
public void goTo(final EditPane editPane)		{			final Buffer buffer = getBuffer(editPane.getView());			if(buffer == null)				return;			editPane.setBuffer(buffer);				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					Selection[] s = getSelection();					if(s == null)						return;						JEditTextArea textArea = editPane.getTextArea();					if(textArea.isMultipleSelectionEnabled())						textArea.addToSelection(s);					else						textArea.setSelection(s);						textArea.moveCaretPosition(occur.endPos.getOffset());				}			});		}	
public String toString()		{			return str;		}	
HyperSearchResult(Buffer buffer, int line)		{			path = buffer.getPath();				if(!buffer.isTemporary())				bufferOpened(buffer);				this.line = line;				str = (line + 1) + ": " + buffer.getLineText(line)				.replace('\t',' ').trim();		}	
void bufferOpened(Buffer buffer)		{			this.buffer = buffer;			Occur o = occur;			while(o != null)			{				o.bufferOpened();				o = o.next;			}		}	
void bufferClosed()		{			buffer = null;			Occur o = occur;			while(o != null)			{				o.bufferClosed();				o = o.next;			}		}	
void addOccur(int start, int end)		{			Occur o = new Occur(start,end);			o.next = occur;			occur = o;			occurCount++;		}	
/**		 * @param path A canonical path		 */		boolean pathEquals(String path)		{			return path.equals(MiscUtilities.resolveSymlinks(this.path));		}	
public boolean equals(Object compareObj)		{			if (!(compareObj instanceof HyperSearchResult))				return false;			HyperSearchResult otherResult = (HyperSearchResult)compareObj;			return pathEquals(otherResult.path) && line == otherResult.line				&& buffer.equals(otherResult.buffer);				}	
Occur(int start, int end)			{				this.start = start;				this.end = end;					if(buffer != null && !buffer.isTemporary())					bufferOpened();			}	
void bufferOpened()			{				startPos = buffer.createPosition(Math.min(					buffer.getLength(),start));				endPos = buffer.createPosition(Math.min(					buffer.getLength(),end));			}	
void bufferClosed()			{				start = startPos.getOffset();				end = endPos.getOffset();				startPos = endPos = null;			}	
public HyperSearchResults(View view)		{			super(new BorderLayout());				this.view = view;				caption = new JLabel();				Box toolBar = new Box(BoxLayout.X_AXIS);			toolBar.add(caption);			toolBar.add(Box.createGlue());				ActionHandler ah = new ActionHandler();				highlight = new RolloverButton();			highlight.setToolTipText(jEdit.getProperty(				"hypersearch-results.highlight.label"));			highlight.addActionListener(ah);			toolBar.add(highlight);						clear = new RolloverButton(GUIUtilities.loadIcon(				jEdit.getProperty("hypersearch-results.clear.icon")));			clear.setToolTipText(jEdit.getProperty(				"hypersearch-results.clear.label"));			clear.addActionListener(ah);			toolBar.add(clear);				multi = new RolloverButton();			multi.setToolTipText(jEdit.getProperty(				"hypersearch-results.multi.label"));			multi.addActionListener(ah);			toolBar.add(multi);				stop = new RolloverButton(GUIUtilities.loadIcon(				jEdit.getProperty("hypersearch-results.stop.icon")));			stop.setToolTipText(jEdit.getProperty(				"hypersearch-results.stop.label"));			stop.addActionListener(ah);			toolBar.add(stop);			stop.setEnabled(false);				add(BorderLayout.NORTH, toolBar);				resultTreeRoot = new DefaultMutableTreeNode();			resultTreeModel = new DefaultTreeModel(resultTreeRoot);			resultTree = new HighlightingTree(resultTreeModel);			resultTree.setToolTipText(null);			resultTree.setCellRenderer(new ResultCellRenderer());			resultTree.setVisibleRowCount(16);			resultTree.setRootVisible(false);			resultTree.setShowsRootHandles(true);			//the ESCAPE keystroke is assigned to hideTip action by swing			//it breaks the action usually assigned to close-docking-area by jEdit,			//so we remove this keystroke binding bug #1955140			KeyStroke keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);			resultTree.getInputMap().remove(keyStroke);			// looks bad with the OS X L&F, apparently...			if(!OperatingSystem.isMacOSLF())				resultTree.putClientProperty("JTree.lineStyle", "Angled");				resultTree.setEditable(false);				resultTree.addKeyListener(new KeyHandler());			resultTree.addMouseListener(new MouseHandler());				JScrollPane scrollPane = new JScrollPane(resultTree);			Dimension dim = scrollPane.getPreferredSize();			dim.width = 400;			scrollPane.setPreferredSize(dim);			add(BorderLayout.CENTER, scrollPane);			resultTree.setTransferHandler(new ResultTreeTransferHandler());		}	
public void focusOnDefaultComponent()		{			resultTree.requestFocus();		}	
public void addNotify()		{			super.addNotify();			EditBus.addToBus(this);			multiStatus = jEdit.getBooleanProperty(				"hypersearch-results.multi");			updateHighlightStatus();			updateMultiStatus();		}	
public void removeNotify()		{			super.removeNotify();			EditBus.removeFromBus(this);			jEdit.setBooleanProperty("hypersearch-results.multi",multiStatus);		}	
private void visitBuffers(final ResultVisitor visitor, final Buffer buffer)		{			// impl note: since multi-level hierarchies now allowed,			// use traverseNodes to process HyperSearchResult nodes			traverseNodes(resultTreeRoot, new TreeNodeCallbackAdapter()			{				public boolean processNode(DefaultMutableTreeNode node)				{					Object userObject = node.getUserObject();					if (!(userObject instanceof HyperSearchResult))						return true;					HyperSearchResult result = (HyperSearchResult) userObject;					if (result.pathEquals(buffer.getSymlinkPath()))						visitor.visit(buffer, result);					return true;				}			});		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof BufferUpdate)			{				BufferUpdate bmsg = (BufferUpdate)msg;				Buffer buffer = bmsg.getBuffer();				Object what = bmsg.getWhat();				if(what == BufferUpdate.LOADED)					visitBuffers(new BufferLoadedVisitor(),buffer);				else if(what == BufferUpdate.CLOSED)					visitBuffers(new BufferClosedVisitor(),buffer);			}		}	
public static boolean traverseNodes(DefaultMutableTreeNode node, 				HyperSearchTreeNodeCallback callbackInterface)		{			if (!callbackInterface.processNode(node))				return false;			for (Enumeration e = node.children(); e.hasMoreElements();)			{				DefaultMutableTreeNode childNode = (DefaultMutableTreeNode)e.nextElement();				if (!traverseNodes(childNode, callbackInterface))					return false;			}			return true;		}	
public DefaultTreeModel getTreeModel()		{			return resultTreeModel;		}	
/**		 * Returns the result tree.		 *		 * @return the result tree		 * @since jEdit 4.1pre9		 */		public JTree getTree()		{			return resultTree;		}	
public void searchStarted()		{			stop.setEnabled(true);			caption.setText(jEdit.getProperty("hypersearch-results.searching",					new String[] { SearchAndReplace.getSearchString() }));		}	
public void setSearchStatus(String status)		{			caption.setText(status);		}	
public void searchFailed()		{			caption.setText(jEdit.getProperty("hypersearch-results.no-results",					new String[] { SearchAndReplace.getSearchString() }));				// collapse all nodes, as suggested on user mailing list...			for(int i = 0; i < resultTreeRoot.getChildCount(); i++)			{				DefaultMutableTreeNode node = (DefaultMutableTreeNode)					resultTreeRoot.getChildAt(i);				resultTree.collapsePath(new TreePath(new Object[] {					resultTreeRoot, node }));			}		}	
/**		 * @param searchNode the result node		 * @param selectNode the node that must be selected, or null		 * @since jEdit 4.3pre12		 */		public void searchDone(final DefaultMutableTreeNode searchNode, final DefaultMutableTreeNode selectNode)		{			stop.setEnabled(false);			final int nodeCount = searchNode.getChildCount();			if (nodeCount < 1)			{				searchFailed();				return;			}				caption.setText(jEdit.getProperty("hypersearch-results.done",					new String [] { SearchAndReplace.getSearchString() }));				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					if(!multiStatus)					{						for(int i = 0; i < resultTreeRoot.getChildCount(); i++)						{							resultTreeRoot.remove(0);						}					}						resultTreeRoot.add(searchNode);					resultTreeModel.reload(resultTreeRoot);							for (int i = 0; i < nodeCount; i++)					{						TreePath lastNode = new TreePath(							((DefaultMutableTreeNode)							searchNode.getChildAt(i))							.getPath());							resultTree.expandPath(lastNode);					}					TreePath treePath;					if (selectNode == null)					{						treePath = new TreePath(new Object[]{							resultTreeRoot, searchNode});					}					else					{						treePath = new TreePath(selectNode.getPath());					}					resultTree.setSelectionPath(treePath);					resultTree.scrollPathToVisible(						treePath);				}			});		}	
public void searchDone(final DefaultMutableTreeNode searchNode)		{			searchDone(searchNode, null);		}	
private void updateHighlightStatus()		{			String prop = jEdit.getProperty(HIGHLIGHT_PROP);			if (prop != null && prop.length() > 0)				highlight.setIcon(GUIUtilities.loadIcon(jEdit.getProperty("hypersearch-results.match.highlight.icon")));			else				highlight.setIcon(GUIUtilities.loadIcon(jEdit.getProperty("hypersearch-results.match.normal.icon")));			resultTree.repaint();		}	
private void updateMultiStatus()		{			if(multiStatus)				multi.setIcon(GUIUtilities.loadIcon(jEdit.getProperty("hypersearch-results.multi.multiple.icon")));			else				multi.setIcon(GUIUtilities.loadIcon(jEdit.getProperty("hypersearch-results.multi.single.icon")));		}	
private void goToSelectedNode(int mode)		{			TreePath path = resultTree.getSelectionPath();			if(path == null)				return;				DefaultMutableTreeNode node = (DefaultMutableTreeNode)path				.getLastPathComponent();			Object value = node.getUserObject();				// do nothing if clicked "foo (showing n occurrences in m files)"			if(node.getParent() != resultTreeRoot && value instanceof HyperSearchNode)			{				HyperSearchNode n = (HyperSearchNode)value;				Buffer buffer = n.getBuffer(view);				if(buffer == null)					return;					EditPane pane;					switch(mode)				{				case M_OPEN:					pane = view.goToBuffer(buffer);					break;				case M_OPEN_NEW_VIEW:					pane = jEdit.newView(view,buffer,false).getEditPane();					break;				case M_OPEN_NEW_PLAIN_VIEW:					pane = jEdit.newView(view,buffer,true).getEditPane();					break;				case M_OPEN_NEW_SPLIT:					pane = view.splitHorizontally();					break;				default:					throw new IllegalArgumentException("Bad mode: " + mode);				}					n.goTo(pane);			}		}	
private void removeSelectedNode()		{			TreePath path = resultTree.getSelectionPath();			if(path == null)				return;				MutableTreeNode value = (MutableTreeNode)path				.getLastPathComponent();				if(path.getPathCount() > 1)			{				// Adjust selection so that repeating some removals				// behave naturally.				TreePath parentPath = path.getParentPath();				MutableTreeNode parent = (MutableTreeNode)parentPath					.getLastPathComponent();				int removingIndex = parent.getIndex(value);				int nextIndex = removingIndex + 1;				if(nextIndex < parent.getChildCount())				{					TreeNode next = parent.getChildAt(nextIndex);					resultTree.setSelectionPath(						parentPath.pathByAddingChild(next));				}				else				{					resultTree.setSelectionPath(parentPath);				}					resultTreeModel.removeNodeFromParent(value);			}				HyperSearchOperationNode.removeNodeFromCache(value);			if (resultTreeRoot.getChildCount() == 0)			{				hideDockable();			}		}	
private void removeAllNodes()		{			resultTreeRoot.removeAllChildren();			resultTreeModel.reload(resultTreeRoot);			setSearchStatus(null);			hideDockable();		}	
private void hideDockable()		{			view.getDockableWindowManager().hideDockableWindow(NAME);		}	
SyntaxStyle parseHighlightStyle(String style)		{			Font f = (resultTree != null) ? resultTree.getFont() :				UIManager.getFont("Tree.font");			SyntaxStyle s;			try			{				s = SyntaxUtilities.parseStyle(style, f.getFamily(), f.getSize(), true, null);			}			catch (Exception e)			{				style = "color:#000000";				s = SyntaxUtilities.parseStyle(style, f.getFamily(), f.getSize(), true);			}			return s;		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == highlight)				{					String prop = jEdit.getProperty(HIGHLIGHT_PROP);					SyntaxStyle style = new StyleEditor(jEdit.getActiveView(), parseHighlightStyle(prop),						"hypersearch").getStyle();					if (style != null)						jEdit.setProperty(HIGHLIGHT_PROP, GUIUtilities.getStyleString(style));					updateHighlightStatus();				}				else if(source == clear)				{					removeAllNodes();				}				else if(source == multi)				{					multiStatus = !multiStatus;					updateMultiStatus();						if(!multiStatus)					{						for(int i = resultTreeRoot.getChildCount() - 2; i >= 0; i--)						{							resultTreeModel.removeNodeFromParent(								(MutableTreeNode)resultTreeRoot								.getChildAt(i));						}					}				}				else if(source == stop)				{					jEdit.setTemporaryProperty("hyperSearch-stopButton", "true");				}			}	
public HighlightingTree(DefaultTreeModel model)			{				super(model);				prop = jEdit.getProperty(HIGHLIGHT_PROP);				if (prop != null && prop.length() > 0)					styleTag = style2html(prop);			}	
@Override			public String convertValueToText(Object value, boolean selected,					boolean expanded, boolean leaf, int row, boolean hasFocus)			{				String s = super.convertValueToText(value, selected, expanded, leaf,					row, hasFocus);				String newProp = jEdit.getProperty(HIGHLIGHT_PROP);				if (newProp == null || newProp.length() == 0)					return s;				DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;				while ((node != null) &&					   (! (node.getUserObject() instanceof HyperSearchOperationNode)))				{					node = (DefaultMutableTreeNode) node.getParent();				}				if (node == null)					return s;				if (! newProp.equals(prop))				{					prop = newProp;					styleTag = style2html(prop);				}				SearchMatcher matcher =					((HyperSearchOperationNode) node.getUserObject()).getSearchMatcher();				StringBuilder sb = new StringBuilder("<html><style>.highlight {");				sb.append(styleTag);				sb.append("}</style><body>");				int lineTextIndex = s.indexOf(": ");				if (lineTextIndex > 0)				{					lineTextIndex += 2;					appendString2html(sb, s.substring(0, lineTextIndex));					s = s.substring(lineTextIndex);				}				int i = 0;				Match m;				while ((m = matcher.nextMatch(s.substring(i), true, true, true, false)) != null)				{					appendString2html(sb, s.substring(i, i + m.start));					sb.append("<span class=\"highlight\">");					appendString2html(sb, s.substring(i + m.start, i + m.end));					sb.append("</span>");					i += m.end;				}				appendString2html(sb, s.substring(i));				sb.append("</body></html>");				return sb.toString();			}	
private String color2html(Color c)			{				StringBuilder cs = new StringBuilder("rgb(");				cs.append(c.getRed());				cs.append(",");				cs.append(c.getGreen());				cs.append(",");				cs.append(c.getBlue());				cs.append(");");				return cs.toString();			}	
private String style2html(String prop)			{				StringBuilder tag = new StringBuilder();				SyntaxStyle style = parseHighlightStyle(prop);				Font f = style.getFont();				Color c = style.getForegroundColor();				if (c != null)					tag.append("color:").append(color2html(c));				c = style.getBackgroundColor();				if (c != null)					tag.append("background:").append(color2html(c));				if (f.isBold())					tag.append("font-weight:bold;");				if (f.isItalic())					tag.append("font-style: italic;");				return tag.toString();			}	
private void appendString2html(StringBuilder sb, String s)			{				for (int i = 0; i < s.length(); i++)				{					char c = s.charAt(i);					String r;					switch (c)					{					case '"':						r = "&quot;";						break;					// case '\'': r = "&apos;"; break;					case '&':						r = "&amp;";						break;					case '<':						r = "&lt;";						break;					case '>':						r = "&gt;";						break;					default:						r = String.valueOf(c);						break;					}					sb.append(r);				}			}	
public void keyPressed(KeyEvent evt)			{				switch(evt.getKeyCode())				{				case KeyEvent.VK_SPACE:					goToSelectedNode(M_OPEN);						// fuck me dead					SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							resultTree.requestFocus();						}					});						evt.consume();					break;				case KeyEvent.VK_ENTER:					goToSelectedNode(M_OPEN);					evt.consume();					break;				case KeyEvent.VK_DELETE:					removeSelectedNode();					evt.consume();					break;				default:					break;				}			}	
public void mousePressed(MouseEvent evt)			{				if(evt.isConsumed())					return;					TreePath path1 = resultTree.getPathForLocation(					evt.getX(),evt.getY());				if(path1 == null)					return;					resultTree.setSelectionPath(path1);				if (GUIUtilities.isPopupTrigger(evt))					showPopupMenu(evt);				else				{					goToSelectedNode(M_OPEN);				}			}	
private void showPopupMenu(MouseEvent evt)			{				TreePath path = resultTree.getSelectionPath();				DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();								popupMenu = new JPopupMenu();				Object userObj = node.getUserObject();				if (userObj instanceof HyperSearchFileNode						|| userObj instanceof HyperSearchResult)				{					popupMenu.add(new GoToNodeAction(						"hypersearch-results.open",						M_OPEN));					popupMenu.add(new GoToNodeAction(						"hypersearch-results.open-view",						M_OPEN_NEW_VIEW));					popupMenu.add(new GoToNodeAction(						"hypersearch-results.open-plain-view",						M_OPEN_NEW_PLAIN_VIEW));					popupMenu.add(new GoToNodeAction(						"hypersearch-results.open-split",						M_OPEN_NEW_SPLIT));				}				if (!(userObj instanceof HyperSearchFolderNode))					popupMenu.add(new RemoveTreeNodeAction());				popupMenu.add(new ExpandChildTreeNodesAction());				if (userObj instanceof HyperSearchFolderNode						|| userObj instanceof HyperSearchOperationNode)				{					popupMenu.add(new CollapseChildTreeNodesAction());					if (userObj instanceof HyperSearchFolderNode)						popupMenu.add(new NewSearchAction());				}				if (userObj instanceof HyperSearchOperationNode)				{					popupMenu.add(new JPopupMenu.Separator());					HyperSearchOperationNode resultNode = (HyperSearchOperationNode)userObj;					JCheckBoxMenuItem chkItem = 						new JCheckBoxMenuItem(jEdit.getProperty("hypersearch-results.tree-view"),								resultNode.isTreeViewDisplayed());					chkItem.addActionListener(new TreeDisplayAction());					popupMenu.add(chkItem);						popupMenu.add(new RedoSearchAction((HyperSearchOperationNode)userObj));				}				popupMenu.add(new CopyToClipboardAction());					GUIUtilities.showPopupMenu(popupMenu,evt.getComponent(),					evt.getX(),evt.getY());				evt.consume();			}	
RemoveTreeNodeAction()			{				super(jEdit.getProperty("hypersearch-results.remove-node"));			}	
public void actionPerformed(ActionEvent evt)			{				removeSelectedNode();			}	
RemoveAllTreeNodesAction()			{				super(jEdit.getProperty("hypersearch-results.remove-all-nodes"));			}	
public void actionPerformed(ActionEvent evt)			{				removeAllNodes();			}	
NewSearchAction()			{				super(jEdit.getProperty("hypersearch-results.new-search"));			}	
public void actionPerformed(ActionEvent evt)			{				TreePath path = resultTree.getSelectionPath();				DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();				HyperSearchFolderNode nodeObj = (HyperSearchFolderNode)operNode.getUserObject();								String glob = "*";				SearchFileSet dirList = SearchAndReplace.getSearchFileSet();				if (dirList instanceof DirectoryListSet)					glob = ((DirectoryListSet)dirList).getFileFilter();				SearchAndReplace.setSearchFileSet(new DirectoryListSet(						nodeObj.getNodeFile().getAbsolutePath(),glob,true));				SearchDialog.showSearchDialog(view,null,SearchDialog.DIRECTORY);			}	
ExpandChildTreeNodesAction()			{				super(jEdit.getProperty("hypersearch-results.expand-child-nodes"));			}	
public void actionPerformed(ActionEvent evt)			{				TreePath path = resultTree.getSelectionPath();				DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();				expandAllNodes(operNode);			}	
CopyToClipboardAction()			{				super(jEdit.getProperty("hypersearch-results.copy-to-clipboard"));			}	
public void actionPerformed(ActionEvent evt)			{				TreePath path = resultTree.getSelectionPath();				DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)					path.getLastPathComponent();				ToStringNodes toStringNodes = new ToStringNodes();				traverseNodes(operNode, toStringNodes);				StringSelection selection = new StringSelection(					toStringNodes.nodesString.toString());				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();				clipboard.setContents(selection, null);			}	
public boolean processNode(DefaultMutableTreeNode node)			{				Object userObject = node.getUserObject();				if (userObject instanceof HyperSearchFileNode)					nodesString.append(((HyperSearchFileNode)userObject).path);				else if (userObject instanceof HyperSearchResult)				{					HyperSearchResult hsr = (HyperSearchResult)userObject;					// Copy the ORIGINAL line from the buffer!					nodesString.append(hsr.buffer == null ? hsr.toString() : hsr.buffer.getLineText(hsr.line));				}				else					nodesString.append(userObject.toString());				nodesString.append(System.getProperty("line.separator"));				return true;			}	
CollapseChildTreeNodesAction()			{				super(jEdit.getProperty("hypersearch-results.collapse-child-nodes"));			}	
public void actionPerformed(ActionEvent evt)			{				TreePath path = resultTree.getSelectionPath();				DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();				for (Enumeration e = operNode.children(); e.hasMoreElements();)				{					DefaultMutableTreeNode node = (DefaultMutableTreeNode)e.nextElement();					resultTree.collapsePath(new TreePath(node.getPath()));				}				resultTree.scrollPathToVisible(						new TreePath(operNode.getPath()));			}	
public RedoSearchAction(HyperSearchOperationNode hyperSearchOperationNode)			{				super(jEdit.getProperty("hypersearch-results.redo"));				this.hyperSearchOperationNode = hyperSearchOperationNode;			}	
/**			 * Invoked when an action occurs.			 */			public void actionPerformed(ActionEvent e)			{				SearchAndReplace.setSearchString(hyperSearchOperationNode.getSearchString());				SearchAndReplace.setSearchMatcher(hyperSearchOperationNode.getSearchMatcher());				removeSelectedNode();				SearchAndReplace.hyperSearch(view, false);			}	
public void actionPerformed(ActionEvent evt)			{				JCheckBoxMenuItem menuItem = (JCheckBoxMenuItem) evt.getSource();				boolean curState = menuItem.isSelected();								TreePath path = resultTree.getSelectionPath();				DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)path.getLastPathComponent();								HyperSearchOperationNode operNodeObj = (HyperSearchOperationNode)operNode.getUserObject();				if (curState)					operNodeObj.cacheResultNodes(operNode);				operNode.removeAllChildren();				Exception excp = null;				if (curState)				{					try					{						operNodeObj.insertTreeNodes(resultTree, operNode);					} 					catch (Exception ex)					{						operNodeObj.restoreFlatNodes(resultTree, operNode);						menuItem.setSelected(false);						excp = ex;					}					finally					{						((DefaultTreeModel)resultTree.getModel()).nodeStructureChanged(operNode);						expandAllNodes(operNode);						resultTree.scrollPathToVisible(								new TreePath(operNode.getPath()));										}					if (excp != null)						throw new RuntimeException(excp);				}				else					operNodeObj.restoreFlatNodes(resultTree, operNode);								operNodeObj.setTreeViewDisplayed(menuItem.isSelected());			}	
public void expandAllNodes(DefaultMutableTreeNode node)		{						traverseNodes(node, new TreeNodeCallbackAdapter()			{				public boolean processNode(DefaultMutableTreeNode node)				{					resultTree.expandPath(new TreePath(node.getPath()));					return true;				}			});		}	
GoToNodeAction(String labelProp, int mode)			{				super(jEdit.getProperty(labelProp));				this.mode = mode;			}	
public void actionPerformed(ActionEvent evt)			{				goToSelectedNode(mode);			}	
ResultCellRenderer()			{				plainFont = UIManager.getFont("Tree.font");				if(plainFont == null)					plainFont = jEdit.getFontProperty("metal.secondary.font");				boldFont = new Font(plainFont.getName(),Font.BOLD,					plainFont.getSize());			}	
public Component getTreeCellRendererComponent(JTree tree,				Object value, boolean sel, boolean expanded,				boolean leaf, int row, boolean hasFocus)			{				super.getTreeCellRendererComponent(tree,value,sel,					expanded,leaf,row,hasFocus);				setIcon(null);				DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;					if (node.getUserObject() instanceof HyperSearchOperationNode)				{					setFont(boldFont);						CountNodes countNodes = new CountNodes();					traverseNodes(node, countNodes);						setText(jEdit.getProperty("hypersearch-results.result-caption",								  new Object[] {								  node.toString(),								  Integer.valueOf(countNodes.resultCount),								  Integer.valueOf(countNodes.bufferCount)					}));				}				else if(node.getUserObject() instanceof HyperSearchFolderNode)				{					setFont(plainFont);					setText(node.toString() + " (" + node.getChildCount() + " files/folders)");				}				else if(node.getUserObject() instanceof HyperSearchFileNode)				{					// file name					setFont(boldFont);					HyperSearchFileNode hyperSearchFileNode = (HyperSearchFileNode) node.getUserObject();					setText(jEdit.getProperty("hypersearch-results.file-caption",								  new Object[] {								  hyperSearchFileNode,								  Integer.valueOf(hyperSearchFileNode.getCount()),								  Integer.valueOf(node.getChildCount())					}));				}				else				{					setFont(plainFont);				}					return this;			}	
public boolean processNode(DefaultMutableTreeNode node)				{					Object userObject = node.getUserObject();					if (userObject instanceof HyperSearchFileNode)					{						resultCount += ((HyperSearchFileNode)userObject).getCount();						bufferCount++;					}					return true;				}	
@Override			public void exportToClipboard(JComponent comp, Clipboard clip,					int action) throws IllegalStateException			{				TreePath [] paths = resultTree.getSelectionPaths();				ToStringNodes toStringNodes = new ToStringNodes();				for (TreePath path: paths)				{					DefaultMutableTreeNode operNode = (DefaultMutableTreeNode)						path.getLastPathComponent();					toStringNodes.processNode(operNode);				}				StringSelection selection = new StringSelection(					toStringNodes.nodesString.toString());				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();				clipboard.setContents(selection, null);			}	
public void visit(Buffer buffer, HyperSearchResult result)			{				result.bufferOpened(buffer);			}	
public void visit(Buffer buffer, HyperSearchResult result)			{				result.bufferClosed();			}	
public boolean processNode(DefaultMutableTreeNode node)			{				return false;			}	
public static String[] builtInNames()		{			return builtIn;		}	
public static String get() 		{			return jEdit.getProperty("icon-theme", "tango");		}	
public static void set(String name)		{			GUIUtilities.setIconPath("jeditresource:/org/gjt/sp/jedit/icons/themes/" + name + "/");			jEdit.setProperty("icon-theme", name);		}	
/**			 * This does nothing; it is merely a sentinel for the			 * <code>OpenBracketIndentRule</code>.			 */			public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,				int newIndent)			{				return newIndent;			}	
public boolean keepChecking()			{				return true;			}	
private Collapse()			{			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,				int newIndent)			{				return oldIndent;			}	
public boolean keepChecking()			{				return true;			}	
public Increase()			{				amount = 1;			}	
public Increase(int amount)			{				this.amount = amount;			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,				int newIndent)			{				return newIndent + buffer.getIndentSize() * amount;			}	
public boolean keepChecking()			{				return true;			}	
public boolean equals(Object o)			{				if(o instanceof Increase)					return ((Increase)o).amount == amount;				else					return false;			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,				int newIndent)			{				return newIndent - buffer.getIndentSize();			}	
public boolean keepChecking()			{				return true;			}	
public AlignOffset(int offset)			{				this.offset = offset;			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,				int newIndent)			{				return offset;			}	
public boolean keepChecking()			{				return false;			}	
public AlignParameter(int openParensColumn)			{				this.openParensColumn = openParensColumn;			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,					     int newIndent)			{				return openParensColumn + 1;			}	
public boolean keepChecking()			{				return false;			}	
public int calculateIndent(JEditBuffer buffer, int line, int oldIndent,					           int newIndent)			{				int current = StandardUtilities.getLeadingWhiteSpaceWidth(						buffer.getLineSegment(line),buffer.getTabSize());				return (current < newIndent) ? current : newIndent;			}	
public boolean keepChecking()			{				return true;			}	
public IndentFoldHandler()		{			super("indent");		}	
private int getLeadingWhitespaceWidth(Segment seg, int tabSize)		{			int offset = seg.offset;			int count = seg.count;			int whitespace = 0;				for(int i = 0; i < count; i++)			{				switch(seg.array[offset + i])				{				case ' ':					whitespace++;					break;				case '\t':					whitespace += (tabSize - whitespace % tabSize);					break;				default:					return whitespace;				}			}			return (-1);		}	
/**		 * Returns the fold level of the specified line. For a whitespace-only		 * line, returns the fold level of the next non-whitespace line, or		 * the level of the previous line if no non-whitespace line follows or if		 * the level of the previous line is higher.		 * @param buffer The buffer in question		 * @param lineIndex The line index		 * @param seg A segment the fold handler can use to obtain any		 * text from the buffer, if necessary		 * @return The fold level of the specified line		 * @since jEdit 4.0pre1		 */		public int getFoldLevel(JEditBuffer buffer, int lineIndex, Segment seg)		{			int tabSize = buffer.getTabSize();			// Look for first non-whitespace line starting at lineIndex			int prevLevel = 0;			for (int index = lineIndex; index < buffer.getLineCount(); index++)			{				buffer.getLineText(index,seg);				int whitespace = getLeadingWhitespaceWidth(seg,tabSize);				if(whitespace >= 0)	// Non-whitespace found on line					return (whitespace > prevLevel) ? whitespace : prevLevel;				if(index == 0)					return 0;				if(index == lineIndex)					prevLevel = buffer.getFoldLevel(lineIndex - 1);			}			// All lines from lineIndex are whitespace-only - use fold			// level of previous line.			return prevLevel;		}	
/**		 * Returns the fold levels of the lines preceding the specified line,		 * which depend on the specified line.		 * @param buffer The buffer in question		 * @param lineIndex The line index		 * @param seg A segment the fold handler can use to obtain any		 * @param lineFoldLevel The fold level of the specified line		 * @return The fold levels of the preceding lines, in decreasing line		 * number order (i.e. bottomost line first).		 * @since jEdit 4.3pre18		 */		public List<Integer> getPrecedingFoldLevels(JEditBuffer buffer,			int lineIndex, Segment seg, int lineFoldLevel)		{			List<Integer> precedingFoldLevels = new ArrayList<Integer>();			int tabSize = buffer.getTabSize();			int whitespace = 0;			int index;			// Find previous non-whitespace-only line			for (index = lineIndex - 1; index > 0; index--)			{				buffer.getLineText(index,seg);				whitespace = getLeadingWhitespaceWidth(seg,tabSize);				if (whitespace >= 0)					break;			}			int max = (lineFoldLevel > whitespace) ? lineFoldLevel : whitespace;			for (index++; index < lineIndex; index++)				precedingFoldLevels.add(Integer.valueOf(max));			return precedingFoldLevels;		}	
public static IndentRule indentNextLines(String regexp)			throws PatternSyntaxException		{			return new RegexpIndentRule(regexp,				null,				new IndentAction.Increase(),				null,false);		}	
public static IndentRule indentNextLine(String regexp)			throws PatternSyntaxException		{			return new RegexpIndentRule(regexp,				new IndentAction.Decrease(),				new IndentAction.Increase(),				null,true);		}	
public static IndentRule unindentThisLine(String regexp)			throws PatternSyntaxException		{			return new RegexpIndentRule(regexp,				null,				new IndentAction.Increase(),				new IndentAction.Decrease(),				false);		}	
public static IndentRule unindentNextLines(String regexp)			throws PatternSyntaxException		{			return new RegexpIndentRule(regexp,				null,				new IndentAction.Decrease(),				null,				false);		}	
public static IndentRule indentOpenBracket(char bracket)			throws PatternSyntaxException		{			return new OpenBracketIndentRule(bracket,true);		}	
public static IndentRule indentCloseBracket(char bracket)			throws PatternSyntaxException		{			return new CloseBracketIndentRule(bracket,true);		}	
public static IndentRule unalignedOpenBracket(char bracket)			throws PatternSyntaxException		{			return new OpenBracketIndentRule(bracket,false);		}	
public static IndentRule unalignedCloseBracket(char bracket)			throws PatternSyntaxException		{			return new CloseBracketIndentRule(bracket,false);		}	
/**		 * Creates a new input handler.		 * @param view The view		 */		protected InputHandler(View view)		{			this.view = view;		}	
/**		 * Handles a keystroke.		 * @param keyStroke The key stroke.		 * @return true if the input could be handled.		 * @since jEdit 4.2pre5		 */		public final boolean handleKey(KeyEventTranslator.Key keyStroke)		{			return handleKey(keyStroke, false);		}	
/**		 * Forwards key events directly to the input handler.		 * This is slightly faster than using a KeyListener		 * because some Swing overhead is avoided.		 * @since 4.3pre7		 */		@Override		public void processKeyEvent(KeyEvent evt, int from, boolean global)		{			if(Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,this,"Key event                 : "					+ AbstractInputHandler.toString(evt) + " from " + from);				Log.log(Log.DEBUG,this,view+".isFocused()="+view.isFocused()+'.',new Exception());			}				if(view.getTextArea().hasFocus() && from == View.VIEW)				return;				evt = _preprocessKeyEvent(evt);			if(evt == null)				return;				if(Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,this,"Key event after workaround: "					+ AbstractInputHandler.toString(evt) + " from " + from);			}				Component prefixFocusOwner = view.getPrefixFocusOwner();			boolean focusOnTextArea = false;			switch(evt.getID())			{			case KeyEvent.KEY_TYPED:				// if the user pressed eg C+e n n in the				// search bar we want focus to go back there				// after the prefix is done				if(prefixFocusOwner != null)				{					if(prefixFocusOwner.isShowing())					{						prefixFocusOwner.requestFocus();						focusOnTextArea = true;					}				}					if(keyEventInterceptor != null)					keyEventInterceptor.keyTyped(evt);				else if(from == View.ACTION_BAR					|| isPrefixActive()					|| view.getTextArea().hasFocus())				{					processKeyEventKeyStrokeHandling(evt,from,"type ",global);				}						processKeyEventSub(focusOnTextArea);					break;			case KeyEvent.KEY_PRESSED:				if(keyEventInterceptor != null)					keyEventInterceptor.keyPressed(evt);				else if(KeyEventWorkaround.isBindable(evt.getKeyCode()))				{					if(prefixFocusOwner != null)					{						if(prefixFocusOwner.isShowing())						{							prefixFocusOwner.requestFocus();							focusOnTextArea = true;						}						view.setPrefixFocusOwner(null);					}						processKeyEventKeyStrokeHandling(evt,from,"press",global);						processKeyEventSub(focusOnTextArea);					}				break;			case KeyEvent.KEY_RELEASED:				if(keyEventInterceptor != null)					keyEventInterceptor.keyReleased(evt);				break;			}		}	
private KeyEvent _preprocessKeyEvent(KeyEvent evt)		{			if(view.isClosed())				return null;			Component focusOwner = view.getFocusOwner();			if(focusOwner instanceof JComponent)			{				JComponent comp = (JComponent)focusOwner;				InputMap map = comp.getInputMap();				ActionMap am = comp.getActionMap();					if(map != null && am != null && comp.isEnabled())				{					KeyStroke keyStroke = KeyStroke.getKeyStrokeForEvent(evt);					Object binding = map.get(keyStroke);					if(binding != null && am.get(binding) != null)					{						return null;					}				}			}						if(focusOwner instanceof JTextComponent)			{				// fix for the bug where key events in JTextComponents				// inside views are also handled by the input handler				if(evt.getID() == KeyEvent.KEY_PRESSED)				{					switch(evt.getKeyCode())					{					case KeyEvent.VK_ENTER:					case KeyEvent.VK_TAB:					case KeyEvent.VK_BACK_SPACE:					case KeyEvent.VK_SPACE:						return null;					}				}			}				if(evt.isConsumed())				return null;				if(Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,this,"Key event (preprocessing) : "						+ AbstractInputHandler.toString(evt));			}				return KeyEventWorkaround.processKeyEvent(evt);		}	
private void processKeyEventSub(boolean focusOnTextArea)		{			// we might have been closed as a result of			// the above			if(view.isClosed())				return;				// this is a weird hack.			// we don't want C+e a to insert 'a' in the			// search bar if the search bar has focus...			if(isPrefixActive())			{				Component focusOwner = view.getFocusOwner();				if(focusOwner instanceof JTextComponent)				{					view.setPrefixFocusOwner(focusOwner);					view.getTextArea().requestFocus();				}				else if(focusOnTextArea)				{					view.getTextArea().requestFocus();				}				else				{					view.setPrefixFocusOwner(null);				}			}			else			{				view.setPrefixFocusOwner(null);			}		}	
/**		 * Returns the number of times the next action will be repeated.		 */		public int getRepeatCount()		{			return repeatCount;		}	
/**		 * Sets the number of times the next action will be repeated.		 * @param repeatCount The repeat count		 */		public void setRepeatCount(int repeatCount)		{			int oldRepeatCount = this.repeatCount;			this.repeatCount = repeatCount;			if(oldRepeatCount != repeatCount)				view.getStatus().setMessage(null);		}	
/**		 * Returns the last executed action.		 * @since jEdit 2.5pre5		 */		public EditAction getLastAction()		{			return lastAction;		}	
/**		 * Invokes the specified BeanShell code, replacing __char__ in the		 * code with the next input character.		 * @param msg The prompt to display in the status bar		 * @param code The code		 * @since jEdit 3.2pre2		 */		public void readNextChar(String msg, String code)		{			view.getStatus().setMessage(msg);			readNextChar = code;		}	
/**		 * @deprecated Use the other form of this method instead		 */		@Deprecated		public void readNextChar(String code)		{			readNextChar = code;		}	
/**		 * Invokes the specified action, repeating and recording it as		 * necessary.		 * @param action The action		 * @since jEdit 4.2pre1		 */		@Override		public void invokeAction(String action)		{			invokeAction(jEdit.getAction(action));		}	
/**		 * Invokes the specified action, repeating and recording it as		 * necessary.		 * @param action The action		 */		@Override		public void invokeAction(EditAction action)		{			JEditBuffer buffer = view.getBuffer();				/* if(buffer.insideCompoundEdit())				buffer.endCompoundEdit(); */				// remember the last executed action			if(!action.noRememberLast())			{				HistoryModel.getModel("action").addItem(action.getName());				if(lastAction == action)					lastActionCount++;				else				{					lastAction = action;					lastActionCount = 1;				}			}				// remember old values, in case action changes them			int _repeatCount = repeatCount;				// execute the action			if(action.noRepeat() || _repeatCount == 1)				action.invoke(view);			else			{				// stop people doing dumb stuff like C+ENTER 100 C+n				if(_repeatCount > REPEAT_COUNT_THRESHOLD)				{					String label = action.getLabel();					if(label == null)						label = action.getName();					else						label = GUIUtilities.prettifyMenuLabel(label);						Object[] pp = { label, _repeatCount };						if(GUIUtilities.confirm(view,"large-repeat-count",pp,						JOptionPane.WARNING_MESSAGE,						JOptionPane.YES_NO_OPTION)						!= JOptionPane.YES_OPTION)					{						repeatCount = 1;						view.getStatus().setMessage(null);						return;					}				}					try				{					buffer.beginCompoundEdit();						for(int i = 0; i < _repeatCount; i++)						action.invoke(view);				}				finally				{					buffer.endCompoundEdit();				}			}				Macros.Recorder recorder = view.getMacroRecorder();				if(recorder != null && !action.noRecord())				recorder.record(_repeatCount,action.getCode());				// If repeat was true originally, clear it			// Otherwise it might have been set by the action, etc			if(_repeatCount != 1)			{				// first of all, if this action set a				// readNextChar, do not clear the repeat				if(readNextChar != null)					return;					repeatCount = 1;				view.getStatus().setMessage(null);			}		}	
public void invokeLastAction()		{			if(lastAction == null)				view.getToolkit().beep();			else				invokeAction(lastAction);		}	
protected void userInput(char ch)		{			lastActionCount = 0;				JEditTextArea textArea = view.getTextArea();				/* Buffer buffer = view.getBuffer();			if(!buffer.insideCompoundEdit())				buffer.beginCompoundEdit(); */				if(repeatCount == 1)				textArea.userInput(ch);			else			{				// stop people doing dumb stuff like C+ENTER 100 C+n				if(repeatCount > REPEAT_COUNT_THRESHOLD)				{					Object[] pp = { String.valueOf(ch),						repeatCount };						if(GUIUtilities.confirm(view,						"large-repeat-count.user-input",pp,						JOptionPane.WARNING_MESSAGE,						JOptionPane.YES_NO_OPTION)						!= JOptionPane.YES_OPTION)					{						repeatCount = 1;						view.getStatus().setMessage(null);						return;					}				}					JEditBuffer buffer = view.getBuffer();				try				{					if(repeatCount != 1)						buffer.beginCompoundEdit();					for(int i = 0; i < repeatCount; i++)						textArea.userInput(ch);				}				finally				{					if(repeatCount != 1)						buffer.endCompoundEdit();				}			}				Macros.Recorder recorder = view.getMacroRecorder();				if(recorder != null)			{				recorder.recordInput(repeatCount,ch,					textArea.isOverwriteEnabled());			}				repeatCount = 1;		}	
protected void invokeReadNextChar(char ch)		{			JEditBuffer buffer = view.getBuffer();				/* if(buffer.insideCompoundEdit())				buffer.endCompoundEdit(); */				String charStr = StandardUtilities.charsToEscapes(String.valueOf(ch));				// this might be a bit slow if __char__ occurs a lot			int index;			while((index = readNextChar.indexOf("__char__")) != -1)			{				readNextChar = readNextChar.substring(0,index)					+ '\'' + charStr + '\''					+ readNextChar.substring(index + 8);			}				Macros.Recorder recorder = view.getMacroRecorder();			if(recorder != null)				recorder.record(getRepeatCount(),readNextChar);				view.getStatus().setMessage(null);				if(getRepeatCount() != 1)			{				try				{					buffer.beginCompoundEdit();						BeanShell.eval(view,BeanShell.getNameSpace(),						"for(int i = 1; i < "						+ getRepeatCount() + "; i++)\n{\n"						+ readNextChar + "\n}");				}				finally				{					buffer.endCompoundEdit();				}			}			else				BeanShell.eval(view,BeanShell.getNameSpace(),readNextChar);				readNextChar = null;		}	
public InputMethodSupport(TextArea owner)		{			this.owner = owner;			owner.addInputMethodListener(this);			owner.getPainter().addExtension(TextAreaPainter.HIGHEST_LAYER, this);		}	
private Rectangle getCaretRectangle(int x, int y)		{			TextAreaPainter painter = owner.getPainter();			Point origin = painter.getLocationOnScreen();			int height = painter.getFontMetrics().getHeight();			return new Rectangle(origin.x + x, origin.y + y, 0, height);		}	
public void paintValidLine(Graphics2D gfx, int screenLine,					   int physicalLine, int start, int end, int y)		{			if(composedTextLayout != null)			{				int caret = owner.getCaretPosition();				if(start <= caret && caret < end)				{					TextAreaPainter painter = owner.getPainter();					// The hight and baseline are taken from					// painter's FontMetrics instead of TextLayout					// so that the composed text is rendered at					// the same position with text in the TextArea.					FontMetrics fm = painter.getFontMetrics();					int x = owner.offsetToXY(caret).x;					int width = Math.round(composedTextLayout.getAdvance());					int height = fm.getHeight();					int offset_to_baseline = height						- (fm.getLeading()+1) - fm.getDescent();					int caret_x = x + composedCaretX;						gfx.setColor(painter.getBackground());					gfx.fillRect(x, y, width, height);					gfx.setColor(painter.getForeground());					composedTextLayout.draw(gfx, x, y + offset_to_baseline);					gfx.setColor(painter.getCaretColor());					gfx.drawLine(caret_x, y, caret_x, y + height - 1);				}			}		}	
public Rectangle getTextLocation(TextHitInfo offset)		{			if(composedTextLayout != null)			{				// return location of composed text.				Point caret = owner.offsetToXY(owner.getCaretPosition());				return getCaretRectangle(caret.x + composedCaretX, caret.y);			}			else			{				// return location of selected text.				Selection selection_on_caret = owner.getSelectionAtOffset(owner.getCaretPosition());				if(selection_on_caret != null)				{					Point selection_start = owner.offsetToXY(selection_on_caret.getStart());					return getCaretRectangle(selection_start.x, selection_start.y);				}			}			return null;		}	
public TextHitInfo getLocationOffset(int x, int y)		{			if(composedTextLayout != null)			{				Point origin = owner.getPainter().getLocationOnScreen();				Point caret = owner.offsetToXY(owner.getCaretPosition());				float local_x = x - origin.x - caret.x;				float local_y = y - origin.y - caret.y					- (composedTextLayout.getLeading()+1)					- composedTextLayout.getAscent();				return composedTextLayout.hitTestChar(local_x, local_y);			}			return null;		}	
public int getInsertPositionOffset()		{			return owner.getCaretPosition();		}	
public AttributedCharacterIterator getCommittedText(int beginIndex , int endIndex			, AttributedCharacterIterator.Attribute[] attributes)		{			return (new AttributedString(owner.getText(beginIndex, endIndex - beginIndex))).getIterator();		}	
public int getCommittedTextLength()		{			return owner.getBufferLength();		}	
public AttributedCharacterIterator cancelLatestCommittedText(AttributedCharacterIterator.Attribute[] attributes)		{			if(lastCommittedText != null)			{				int offset = lastCommittedAt;				int length = lastCommittedText.length();				String sample = owner.getText(offset, length);				if(sample != null && sample.equals(lastCommittedText))				{					AttributedCharacterIterator canceled = (new AttributedString(sample)).getIterator();					owner.getBuffer().remove(offset, length);					owner.setCaretPosition(offset);					lastCommittedText = null;					return canceled;				}				// Cleare last committed information to prevent				// accidental match.				lastCommittedText = null;			}			return null;		}	
public AttributedCharacterIterator getSelectedText(AttributedCharacterIterator.Attribute[] attributes)		{			Selection selection_on_caret = owner.getSelectionAtOffset(owner.getCaretPosition());			if(selection_on_caret != null)			{				return (new AttributedString(owner.getSelectedText(selection_on_caret))).getIterator();			}			return null;		}	
public void inputMethodTextChanged(InputMethodEvent event)		{			composedTextLayout = null;			AttributedCharacterIterator text = event.getText();			if(text != null)			{				int committed_count = event.getCommittedCharacterCount();				if(committed_count > 0)				{					lastCommittedText = null;					lastCommittedAt = owner.getCaretPosition();					StringBuilder committed = new StringBuilder(committed_count);					char c;					int count;					for(c = text.first(), count = committed_count						; c != AttributedCharacterIterator.DONE && count > 0						; c = text.next(), --count)					{						owner.userInput(c);						committed.append(c);					}					lastCommittedText = committed.toString();				}				int end_index = text.getEndIndex();				if(committed_count < end_index)				{					AttributedString composed = new AttributedString(text, committed_count, end_index);					TextAreaPainter painter = owner.getPainter();					composed.addAttribute(TextAttribute.FONT, painter.getFont());					composedTextLayout = new TextLayout(composed.getIterator()						, painter.getFontRenderContext());				}			}			// Also updates caret.			caretPositionChanged(event);		}	
public void caretPositionChanged(InputMethodEvent event)		{			composedCaretX = 0;			if(composedTextLayout != null)			{				TextHitInfo caret = event.getCaret();				if(caret != null)				{					composedCaretX = Math.round(composedTextLayout.getCaretInfo(caret)[0]);				}				// Adjust visiblity.				int insertion_x = owner.offsetToXY(owner.getCaretPosition()).x;				TextHitInfo visible = event.getVisiblePosition();				int composed_visible_x = (visible != null)					? Math.round(composedTextLayout.getCaretInfo(visible)[0])					: composedCaretX;				int visible_x = insertion_x + composed_visible_x;				int painter_width = owner.getPainter().getWidth();				int adjustment = 0;				if(visible_x < 0)				{					adjustment = visible_x;				}				if(visible_x >= painter_width)				{					adjustment = visible_x - (painter_width - 1);				}				if(adjustment != 0)				{					owner.setHorizontalOffset(owner.getHorizontalOffset() - adjustment);				}			}			else			{				/* Cancel horizontal adjustment for composed text.				   FIXME:				     The horizontal offset may be beyond the max				     value of owner's horizontal scroll bar.				*/				owner.scrollToCaret(false);			}			/* Invalidate one more line below the caret because			   the underline for composed text goes beyond the caret			   line in some font settings. */			int caret_line = owner.getCaretLine();			owner.invalidateLineRange(caret_line, caret_line + 1);			event.consume();		}	
InstallPanel(PluginManager window, boolean updates)		{			super(new BorderLayout(12,12));				this.window = window;			this.updates = updates;				setBorder(new EmptyBorder(12,12,12,12));				final JSplitPane split = new JSplitPane(				JSplitPane.VERTICAL_SPLIT, jEdit.getBooleanProperty("appearance.continuousLayout"));			split.setResizeWeight(0.75);			/* Setup the table */			table = new JTable(pluginModel = new PluginTableModel());			table.setShowGrid(false);			table.setIntercellSpacing(new Dimension(0,0));			table.setRowHeight(table.getRowHeight() + 2);			table.setPreferredScrollableViewportSize(new Dimension(500,200));			table.setDefaultRenderer(Object.class, new TextRenderer(				(DefaultTableCellRenderer)table.getDefaultRenderer(Object.class)));			table.addFocusListener(new TableFocusHandler());			InputMap tableInputMap = table.getInputMap(JComponent.WHEN_FOCUSED);			ActionMap tableActionMap = table.getActionMap();			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0),"tabOutForward");			tableActionMap.put("tabOutForward",new KeyboardAction(KeyboardCommand.TAB_OUT_FORWARD));			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,InputEvent.SHIFT_MASK),"tabOutBack");			tableActionMap.put("tabOutBack",new KeyboardAction(KeyboardCommand.TAB_OUT_BACK));			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,0),"editPlugin");			tableActionMap.put("editPlugin",new KeyboardAction(KeyboardCommand.EDIT_PLUGIN));			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),"closePluginManager");			tableActionMap.put("closePluginManager",new KeyboardAction(KeyboardCommand.CLOSE_PLUGIN_MANAGER));				TableColumn col1 = table.getColumnModel().getColumn(0);			TableColumn col2 = table.getColumnModel().getColumn(1);			TableColumn col3 = table.getColumnModel().getColumn(2);			TableColumn col4 = table.getColumnModel().getColumn(3);			TableColumn col5 = table.getColumnModel().getColumn(4);				col1.setPreferredWidth(30);			col1.setMinWidth(30);			col1.setMaxWidth(30);			col1.setResizable(false);				col2.setPreferredWidth(180);			col3.setPreferredWidth(130);			col4.setPreferredWidth(70);			col5.setPreferredWidth(70);				JTableHeader header = table.getTableHeader();			header.setReorderingAllowed(false);			header.addMouseListener(new HeaderMouseHandler());			header.setDefaultRenderer(new HeaderRenderer(				(DefaultTableCellRenderer)header.getDefaultRenderer()));				scrollpane = new JScrollPane(table);			scrollpane.getViewport().setBackground(table.getBackground());			split.setTopComponent(scrollpane);				/* Create description */			JScrollPane infoPane = new JScrollPane(				infoBox = new PluginInfoBox());			infoPane.setPreferredSize(new Dimension(500,100));			split.setBottomComponent(infoPane);				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					split.setDividerLocation(0.75);				}			});				add(BorderLayout.CENTER,split);				/* Create buttons */			Box buttons = new Box(BoxLayout.X_AXIS);				buttons.add(new InstallButton());			buttons.add(Box.createHorizontalStrut(12));			buttons.add(new SelectallButton());			buttons.add(chooseButton = new ChoosePluginSet());			buttons.add(new ClearPluginSet());			buttons.add(Box.createGlue());			buttons.add(new SizeLabel());					add(BorderLayout.SOUTH,buttons);			String path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET, "");			if (!path.equals(""))			{				loadPluginSet(path);			}		}	
/** loads a pluginSet xml file and updates the model to reflect		    certain checked selections		    @since jEdit 4.3pre10		    @author Alan Ezust		*/		boolean loadPluginSet(String path)		{			VFS vfs = VFSManager.getVFSForPath(path);			Object session = vfs.createVFSSession(path, InstallPanel.this);			try			{				InputStream is = vfs._createInputStream(session, path, false, InstallPanel.this);				XMLUtilities.parseXML(is, new StringMapHandler());			}			catch (Exception e)			{				Log.log(Log.WARNING, this, "Loading Pluginset failed:" + e.getMessage());				return false;			}			pluginModel.update();			return true;		}	
public void updateModel()		{			final Set<String> savedChecked = new HashSet<String>();			final Set<String> savedSelection = new HashSet<String>();			pluginModel.saveSelection(savedChecked, savedSelection);			pluginModel.clear();			infoBox.setText(jEdit.getProperty("plugin-manager.list-download"));				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					infoBox.setText(null);					pluginModel.update();					pluginModel.restoreSelection(savedChecked, savedSelection);				}			});		}	
public void handleMessage(EBMessage message)		{			 if (message.getSource() == PluginManager.getInstance())			 {				 chooseButton.path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET, "");				 if (chooseButton.path.length() > 0)				 {					 loadPluginSet(chooseButton.path);					 pluginModel.restoreSelection(new HashSet<String>(), new HashSet<String>());					 chooseButton.updateUI();				 }			}		}	
private static String formatSize(int size)		{			NumberFormat df = NumberFormat.getInstance();			df.setMaximumFractionDigits(1);			df.setMinimumFractionDigits(0);			String sizeText;			if (size < 1048576)				sizeText = (size >> 10) + "KB";			else				sizeText = df.format(size/ 1048576.0d) + "MB";			return sizeText;		}	
@Override			public Class getColumnClass(int columnIndex)			{				switch (columnIndex)				{					case 0: return Boolean.class;					case 1:					case 2:					case 3:					case 4:					case 5: return Object.class;					default: throw new Error("Column out of range");				}			}	
public int getColumnCount()			{				return 6;			}	
@Override			public String getColumnName(int column)			{				switch (column)				{					case 0: return " ";					case 1: return ' '+jEdit.getProperty("install-plugins.info.name");					case 2: return ' '+jEdit.getProperty("install-plugins.info.category");					case 3: return ' '+jEdit.getProperty("install-plugins.info.version");					case 4: return ' '+jEdit.getProperty("install-plugins.info.size");					case 5: return ' '+"Release date";					default: throw new Error("Column out of range");				}			}	
public int getRowCount()			{				return entries.size();			}	
public Object getValueAt(int rowIndex,int columnIndex)			{				Object obj = entries.get(rowIndex);				if(obj instanceof String)				{					if(columnIndex == 1)						return obj;					else						return null;				}				else				{					Entry entry = (Entry)obj;						switch (columnIndex)					{						case 0:							return entry.install;						case 1:							return entry.name;						case 2:							return entry.set;						case 3:							if (updates)								return entry.installedVersion + "->" + entry.version;							return entry.version;						case 4:							return formatSize(entry.size);						case 5:							return entry.date;						default:							throw new Error("Column out of range");					}				}			}	
@Override			public boolean isCellEditable(int rowIndex, int columnIndex)			{				return columnIndex == 0;			}	
public void setSelectAll(boolean b)			{				if(isDownloadingList())					return;					int length = getRowCount();				for (int i = 0; i < length; i++)				{					if (b)						setValueAt(Boolean.TRUE,i,0);					else					{						Entry entry = (Entry)entries.get(i);						entry.parents = new LinkedList<Entry>();						entry.install = false;					}				}				fireTableChanged(new TableModelEvent(this));			}	
public void setSortType(int type)			{				sortType = type;				sort(type);			}	
private void deselectParents(Entry entry)			{				Entry[] parents = entry.getParents();					if (parents.length == 0)					return;					String[] args = { entry.name };					int result = GUIUtilities.listConfirm(					window,"plugin-manager.dependency",					args,parents);				if (result != JOptionPane.OK_OPTION)				{					entry.install = true;					return;				}					for(int i = 0; i < parents.length; i++)					 parents[i].install = false;					fireTableRowsUpdated(0,getRowCount() - 1);			}	
@Override			public void setValueAt(Object aValue, int row, int column)			{				if (column != 0) return;					Object obj = entries.get(row);				if(obj instanceof String)					return;					Entry entry = (Entry)obj;				entry.install = Boolean.TRUE.equals(aValue);					if (!entry.install)					deselectParents(entry);					List<PluginList.Dependency> deps = entry.plugin.getCompatibleBranch().deps;					for (int i = 0; i < deps.size(); i++)				{					PluginList.Dependency dep = deps.get(i);					if (dep.what.equals("plugin"))					{						for (int j = 0; j < entries.size(); j++)						{							Entry temp = (Entry)entries.get(j);							if (temp.plugin == dep.plugin)							{								if (entry.install)								{									temp.parents.add(entry);									setValueAt(Boolean.TRUE,j,0);								}								else									temp.parents.remove(entry);							}						}					}				}					fireTableCellUpdated(row,column);			}	
public void sort(int type)			{				Set<String> savedChecked = new HashSet<String>();				Set<String> savedSelection = new HashSet<String>();				saveSelection(savedChecked,savedSelection);					if (sortType != type)				{					sortDirection = 1;				}				sortType = type;					if(isDownloadingList())					return;					Collections.sort(entries,new EntryCompare(type, sortDirection));				fireTableChanged(new TableModelEvent(this));				restoreSelection(savedChecked,savedSelection);				table.getTableHeader().repaint();			}	
private boolean isDownloadingList()			{				return entries.size() == 1 && entries.get(0) instanceof String;			}	
public void clear()			{				entries = new ArrayList();				fireTableChanged(new TableModelEvent(this));			}	
public void update()			{				Set<String> savedChecked = new HashSet<String>();				Set<String> savedSelection = new HashSet<String>();				saveSelection(savedChecked,savedSelection);					PluginList pluginList = window.getPluginList();					if (pluginList == null) return;					entries = new ArrayList();					for(int i = 0; i < pluginList.pluginSets.size(); i++)				{					PluginList.PluginSet set = pluginList.pluginSets.get(i);					for(int j = 0; j < set.plugins.size(); j++)					{						PluginList.Plugin plugin = pluginList.pluginHash.get(set.plugins.get(j));						PluginList.Branch branch = plugin.getCompatibleBranch();						String installedVersion =							plugin.getInstalledVersion();						if (updates)						{							if(branch != null								&& branch.canSatisfyDependencies()								&& installedVersion != null								&& StandardUtilities.compareStrings(branch.version,								installedVersion,false) > 0)							{								entries.add(new Entry(plugin, set.name));							}						}						else						{							if(installedVersion == null && plugin.canBeInstalled())								entries.add(new Entry(plugin,set.name));						}					}				}					sort(sortType);					fireTableChanged(new TableModelEvent(this));				restoreSelection(savedChecked, savedSelection);			}	
public void saveSelection(Set<String> savedChecked, Set<String> savedSelection)			{				if (entries.isEmpty())					return;				for (int i=0, c=getRowCount() ; i<c ; i++)				{					if ((Boolean)getValueAt(i,0))					{						savedChecked.add(entries.get(i).toString());					}				}				int[] rows = table.getSelectedRows();				for (int i=0 ; i<rows.length ; i++)				{					savedSelection.add(entries.get(rows[i]).toString());				}			}	
public void restoreSelection(Set<String> savedChecked, Set<String> savedSelection)			{				for (int i=0, c=getRowCount() ; i<c ; i++)				{					String name = entries.get(i).toString();					if (pluginSet.contains(name))						setValueAt(true, i, 0);					else setValueAt(savedChecked.contains(name), i, 0);				}					if (null != table)				{					table.setColumnSelectionInterval(0,0);					if (!savedSelection.isEmpty())					{						int i = 0;						int rowCount = getRowCount();						for ( ; i<rowCount ; i++)						{							String name = entries.get(i).toString();							if (savedSelection.contains(name))							{								table.setRowSelectionInterval(i,i);								break;							}						}						ListSelectionModel lsm = table.getSelectionModel();						for ( ; i<rowCount ; i++)						{							String name = entries.get(i).toString();							if (savedSelection.contains(name))							{								lsm.addSelectionInterval(i,i);							}						}					}					else					{						if (table.getRowCount() != 0)							table.setRowSelectionInterval(0,0);						JScrollBar scrollbar = scrollpane.getVerticalScrollBar();						scrollbar.setValue(scrollbar.getMinimum());					}				}			}	
Entry(PluginList.Plugin plugin, String set)			{				PluginList.Branch branch = plugin.getCompatibleBranch();				boolean downloadSource = jEdit.getBooleanProperty("plugin-manager.downloadSource");				int size = downloadSource ? branch.downloadSourceSize : branch.downloadSize;					this.name = plugin.name;				this.author = plugin.author;				this.installedVersion = plugin.getInstalledVersion();				this.version = branch.version;				this.size = size;				this.date = branch.date;				this.description = plugin.description;				this.set = set;				this.install = false;				this.plugin = plugin;				SimpleDateFormat format = new SimpleDateFormat("d MMMM yyyy", Locale.ENGLISH);				try				{					timestamp = format.parse(date).getTime();				}				catch (ParseException e)				{					Log.log(Log.ERROR, this, e);				}			}	
private void getParents(List<Entry> list)			{				for (Entry entry : parents)				{					if (entry.install && !list.contains(entry))					{						list.add(entry);						entry.getParents(list);					}				}			}	
Entry[] getParents()			{				List<Entry> list = new ArrayList<Entry>();				getParents(list);				Entry[] array = list.toArray(new Entry[list.size()]);				Arrays.sort(array,new StandardUtilities.StringCompare<Entry>(true));				return array;			}	
@Override			public String toString()			{				return name;			}	
PluginInfoBox()			{				setBackground(jEdit.getColorProperty("view.bgColor"));				setForeground(jEdit.getColorProperty("view.fgColor"));				putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, true);				setEditable(false);				setEditorKit(new HTMLEditorKit());	//			setLineWrap(true);	//			setWrapStyleWord(true);				params = new String[3];				table.getSelectionModel().addListSelectionListener(this);			}	
public void valueChanged(ListSelectionEvent e)			{				String text = "";				if (table.getSelectedRowCount() == 1)				{					Entry entry = (Entry) pluginModel.entries						.get(table.getSelectedRow());					params[0] = entry.author;					params[1] = entry.date;					params[2] = entry.description;					text = jEdit.getProperty("install-plugins.info", params);					text = text.replace("\n", "<br>");					text = "<html>" + text + "</html>";				}				setText(text);				setCaretPosition(0);			}	
SizeLabel()			{				size = 0;				setText(jEdit.getProperty("install-plugins.totalSize")+formatSize(size));				pluginModel.addTableModelListener(this);			}	
public void tableChanged(TableModelEvent e)			{				if (e.getType() == TableModelEvent.UPDATE)				{					if(pluginModel.isDownloadingList())						return;						size = 0;					int length = pluginModel.getRowCount();					for (int i = 0; i < length; i++)					{						Entry entry = (Entry)pluginModel							.entries.get(i);						if (entry.install)							size += entry.size;					}					setText(jEdit.getProperty("install-plugins.totalSize")+formatSize(size));				}			}	
SelectallButton()			{				super(jEdit.getProperty("install-plugins.select-all"));				addActionListener(this);				pluginModel.addTableModelListener(this);				setEnabled(false);			}	
public void actionPerformed(ActionEvent evt)			{				pluginModel.setSelectAll(isSelected());			}	
public void tableChanged(TableModelEvent e)			{				if(pluginModel.isDownloadingList())					return;					setEnabled(pluginModel.getRowCount() != 0);				if (e.getType() == TableModelEvent.UPDATE)				{					int length = pluginModel.getRowCount();					for (int i = 0; i < length; i++)						if (!((Boolean)pluginModel.getValueAt(i,0)).booleanValue())						{							setSelected(false);							return;						}					if (length > 0)						setSelected(true);				}			}	
StringMapHandler()			{				pluginSet.clear();			}	
@Override			public void startElement(String uri, String localName, String qName, Attributes attrs) throws SAXException			{				if (localName.equals("plugin"))				{					pluginSet.add(attrs.getValue("name"));				}			}	
ChoosePluginSet()			{				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("install-plugins.choose-plugin-set.icon")));				addActionListener(this);				updateUI();			}	
@Override			public void updateUI()			{				path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET, "");				if (path.length()<1) setToolTipText ("Click here to choose a predefined plugin set");				else setToolTipText ("Choose pluginset (" + path + ')');				super.updateUI();			}	
public void actionPerformed(ActionEvent ae)			{				path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET,					jEdit.getSettingsDirectory() + File.separator);				String[] selectedFiles = GUIUtilities.showVFSFileDialog(InstallPanel.this.window,					jEdit.getActiveView(), path, VFSBrowser.OPEN_DIALOG, false);				if (selectedFiles == null || selectedFiles.length != 1) return;				path = selectedFiles[0];				boolean success = loadPluginSet(path);				if (success)				{					jEdit.setProperty(PluginManager.PROPERTY_PLUGINSET, path);				}				updateUI();			}	
ClearPluginSet()			{				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("install-plugins.clear-plugin-set.icon")));				setToolTipText("clear plugin set");				addActionListener(this);			}	
public void actionPerformed(ActionEvent e)			{				pluginSet.clear();				pluginModel.restoreSelection(new HashSet<String>(), new HashSet<String>());				jEdit.unsetProperty(PluginManager.PROPERTY_PLUGINSET);				chooseButton.updateUI();			}	
InstallButton()			{				super(jEdit.getProperty("install-plugins.install"));				pluginModel.addTableModelListener(this);				addActionListener(this);				setEnabled(false);			}	
public void actionPerformed(ActionEvent evt)			{				if(pluginModel.isDownloadingList())					return;					boolean downloadSource = jEdit.getBooleanProperty(					"plugin-manager.downloadSource");				boolean installUser = jEdit.getBooleanProperty(					"plugin-manager.installUser");				Roster roster = new Roster();				String installDirectory;				if(installUser)				{					installDirectory = MiscUtilities.constructPath(						jEdit.getSettingsDirectory(),"jars");				}				else				{					installDirectory = MiscUtilities.constructPath(						jEdit.getJEditHome(),"jars");				}					int length = pluginModel.getRowCount();				int instcount = 0;				for (int i = 0; i < length; i++)				{					Entry entry = (Entry)pluginModel.entries.get(i);					if (entry.install)					{						entry.plugin.install(roster,installDirectory,downloadSource);						if (updates)							entry.plugin.getCompatibleBranch().satisfyDependencies(							roster,installDirectory,downloadSource);						instcount++;					}				}					if(roster.isEmpty())					return;					boolean cancel = false;				if (updates && roster.getOperationCount() > instcount)					if (GUIUtilities.confirm(window,						"install-plugins.depend",						null,						JOptionPane.OK_CANCEL_OPTION,						JOptionPane.WARNING_MESSAGE) == JOptionPane.CANCEL_OPTION)						cancel = true;					if (!cancel)				{					new PluginManagerProgress(window,roster);						roster.performOperationsInAWTThread(window);					pluginModel.update();				}			}	
public void tableChanged(TableModelEvent e)			{				if(pluginModel.isDownloadingList())					return;					if (e.getType() == TableModelEvent.UPDATE)				{					int length = pluginModel.getRowCount();					for (int i = 0; i < length; i++)						if (((Boolean)pluginModel.getValueAt(i,0)).booleanValue())						{							setEnabled(true);							return;						}					setEnabled(false);				}			}	
EntryCompare(int type, int sortDirection)			{				this.type = type;				this.sortDirection = sortDirection;			}	
public int compare(Entry e1, Entry e2)			{				int result;					switch (type)				{					case COLUMN_INSTALL:						result = (e1.install == e2.install) ? 0 : (e1.install ? 1 : -1);						break;					case COLUMN_NAME:						result = e1.name.compareToIgnoreCase(e2.name);						break;					case COLUMN_CATEGORY:						result = e1.set.compareToIgnoreCase(e2.set);						if (result == 0)						{							result = e1.name.compareToIgnoreCase(e2.name);						}						break;					case COLUMN_VERSION:						// lets avoid NPE. Maybe we should move						// this code to StandardUtilities.compareStrings						if (e1.version == e2.version)						{							result = 0;						}						else if (e1.version == null)						{							result = -1;						}						else if(e2.version == null)						{							result = 1;						}						else						{							result = StandardUtilities.compareStrings(e1.version,												  e2.version,												  true);						}						break;					case COLUMN_SIZE:						result = (e1.size < e2.size)							 ? -1							 : ((e1.size == e2.size)							    ? 0							    : 1);						break;					case COLUMN_RELEASE:						result = (e1.timestamp < e2.timestamp)							 ? -1							 : ((e1.timestamp == e2.timestamp)							    ? 0							    : 1);						break;					default:						result = 0;				}				return result * sortDirection;			}	
@Override			public void mouseClicked(MouseEvent evt)			{				int column = table.getTableHeader().columnAtPoint(evt.getPoint());				pluginModel.sortDirection *= -1;				pluginModel.sort(column);			}	
TextRenderer(DefaultTableCellRenderer tcr)			{				this.tcr = tcr;			}	
@Override			public Component getTableCellRendererComponent(JTable table, Object value,				boolean isSelected, boolean hasFocus, int row, int column)			{				if (column == 5)					tcr.setHorizontalAlignment(TRAILING);				else					tcr.setHorizontalAlignment(LEADING);				return tcr.getTableCellRendererComponent(table,value,isSelected,false,row,column);			}	
KeyboardAction(KeyboardCommand command)			{				this.command = command;			}	
public void actionPerformed(ActionEvent evt)			{				switch (command)				{				case TAB_OUT_FORWARD:					KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent();					break;				case TAB_OUT_BACK:					KeyboardFocusManager.getCurrentKeyboardFocusManager().focusPreviousComponent();					break;				case EDIT_PLUGIN:					int[] rows = table.getSelectedRows();					Object[] state = new Object[rows.length];					for (int i=0 ; i<rows.length ; i++)					{						state[i] = pluginModel.getValueAt(rows[i],0);					}					for (int i=0 ; i<rows.length ; i++)					{						pluginModel.setValueAt(state[i].equals(Boolean.FALSE),rows[i],0);					}					break;				case CLOSE_PLUGIN_MANAGER:					window.ok();					break;				default:					throw new InternalError();				}			}	
@Override			public void focusGained(FocusEvent fe)			{				if (-1 == table.getSelectedRow() && table.getRowCount() > 0)				{					table.setRowSelectionInterval(0,0);					JScrollBar scrollbar = scrollpane.getVerticalScrollBar();					scrollbar.setValue(scrollbar.getMinimum());				}				if (-1 == table.getSelectedColumn())				{					table.setColumnSelectionInterval(0,0);				}			}	
HeaderRenderer(DefaultTableCellRenderer tcr)			{				this.tcr = tcr;			}	
@Override			public Component getTableCellRendererComponent(JTable table, Object value,								       boolean isSelected, boolean hasFocus,								       int row, int column)			{				JLabel l = (JLabel)tcr.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);				PluginTableModel model = (PluginTableModel) table.getModel();				Icon icon = (column == model.sortType)					? (model.sortDirection == 1) ? ASC_ICON : DESC_ICON					: null;				l.setIcon(icon);				// l.setHorizontalTextPosition(l.LEADING);				return l;			}	
public IntegerArray()		{			this(2000);		}	
public IntegerArray(int initialSize)		{			array = new int[initialSize];		}	
public void add(int num)		{			if(len >= array.length)			{				int[] arrayN = new int[len * 2];				System.arraycopy(array,0,arrayN,0,len);				array = arrayN;			}				array[len++] = num;		}	
public final int get(int index)		{			return array[index];		}	
public final int getSize()		{			return len;		}	
public final void setSize(int len)		{			this.len = len;		}	
public final void clear()		{			len = 0;		}	
public int[] getArray()		{			return array;		}	
/**			The main constructor.			All constructors should now pass through here.				@param namespace If namespace is non-null then this interpreter's			root namespace will be set to the one provided.  If it is null a new			one will be created for it.			@param parent The parent interpreter if this interpreter is a child				of another.  May be null.  Children share a BshClassManager with				their parent instance.			@param sourceFileInfo An informative string holding the filename			or other description of the source from which this interpreter is			reading... used for debugging.  May be null.		*/	    public Interpreter(			Reader in, PrintStream out, PrintStream err,			boolean interactive, NameSpace namespace,			Interpreter parent, String sourceFileInfo )	    {			//System.out.println("New Interpreter: "+this +", sourcefile = "+sourceFileInfo );			parser = new Parser( in );			long t1=System.currentTimeMillis();	        this.in = in;	        this.out = out;	        this.err = err;	        this.interactive = interactive;			debug = err;			this.parent = parent;			if ( parent != null )				setStrictJava( parent.getStrictJava() );			this.sourceFileInfo = sourceFileInfo;				BshClassManager bcm = BshClassManager.createClassManager( this );			if ( namespace == null )	        	this.globalNameSpace = new NameSpace( bcm, "global");			else				this.globalNameSpace = namespace;				// now done in NameSpace automatically when root			// The classes which are imported by default			//globalNameSpace.loadDefaultImports();				/*				Create the root "bsh" system object if it doesn't exist.			*/			if ( ! ( getu("bsh") instanceof org.gjt.sp.jedit.bsh.This ) )				initRootSystemObject();				if ( interactive )				loadRCFiles();				long t2=System.currentTimeMillis();			if ( Interpreter.DEBUG )				Interpreter.debug("Time to initialize interpreter: "+(t2-t1));	    }	
public Interpreter(			Reader in, PrintStream out, PrintStream err,			boolean interactive, NameSpace namespace)	    {			this( in, out, err, interactive, namespace, null, null );		}	
public Interpreter(			Reader in, PrintStream out, PrintStream err, boolean interactive)	    {	        this(in, out, err, interactive, null);	    }	
/**			Construct a new interactive interpreter attached to the specified			console using the specified parent namespace.		*/	    public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {		        this( console.getIn(), console.getOut(), console.getErr(),				true, globalNameSpace );				setConsole( console );	    }	
/**			Construct a new interactive interpreter attached to the specified			console.		*/	    public Interpreter(ConsoleInterface console) {	        this(console, null);	    }	
/**			Create an interpreter for evaluation only.		*/	    public Interpreter()	    {			this( new StringReader(""),				System.out, System.err, false, null );	        evalOnly = true;			setu( "bsh.evalOnly", new Primitive(true) );	    }	
/**			Attach a console			Note: this method is incomplete.		*/		public void setConsole( ConsoleInterface console ) {			this.console = console;			setu( "bsh.console", console );			// redundant with constructor			setOut( console.getOut() );			setErr( console.getErr() );			// need to set the input stream - reinit the parser?		}	
private void initRootSystemObject()		{			BshClassManager bcm = getClassManager();			// bsh			setu("bsh", new NameSpace( bcm, "Bsh Object" ).getThis( this ) );				// init the static shared sharedObject if it's not there yet			if ( sharedObject == null )				sharedObject = new NameSpace(					bcm, "Bsh Shared System Object" ).getThis( this );			// bsh.system			setu( "bsh.system", sharedObject );			setu( "bsh.shared", sharedObject ); // alias				// bsh.help			This helpText = new NameSpace(				bcm, "Bsh Command Help Text" ).getThis( this );			setu( "bsh.help", helpText );				// bsh.cwd			try {				setu( "bsh.cwd", System.getProperty("user.dir") );			} catch ( SecurityException e ) {				// applets can't see sys props				setu( "bsh.cwd", "." );			}				// bsh.interactive			setu( "bsh.interactive", new Primitive(interactive) );			// bsh.evalOnly			setu( "bsh.evalOnly", new Primitive(evalOnly) );		}	
/**			Set the global namespace for this interpreter.			<p>				Note: This is here for completeness.  If you're using this a lot			it may be an indication that you are doing more work than you have			to.  For example, caching the interpreter instance rather than the			namespace should not add a significant overhead.  No state other			than the debug status is stored in the interpreter.			<p>				All features of the namespace can also be accessed using the			interpreter via eval() and the script variable 'this.namespace'			(or global.namespace as necessary).		*/		public void setNameSpace( NameSpace globalNameSpace ) {			this.globalNameSpace = globalNameSpace;		}	
/**			Get the global namespace of this interpreter.			<p>				Note: This is here for completeness.  If you're using this a lot			it may be an indication that you are doing more work than you have			to.  For example, caching the interpreter instance rather than the			namespace should not add a significant overhead.  No state other than			the debug status is stored in the interpreter.			<p>				All features of the namespace can also be accessed using the			interpreter via eval() and the script variable 'this.namespace'			(or global.namespace as necessary).		*/		public NameSpace getNameSpace() {			return globalNameSpace;		}	
/**			Run the text only interpreter on the command line or specify a file.		*/	    public static void main( String [] args )		{	        if ( args.length > 0 ) {				String filename = args[0];					String [] bshArgs;				if ( args.length > 1 ) {					bshArgs = new String [ args.length -1 ];					System.arraycopy( args, 1, bshArgs, 0, args.length-1 );				} else					bshArgs = new String [0];		            Interpreter interpreter = new Interpreter();				//System.out.println("run i = "+interpreter);				interpreter.setu( "bsh.args", bshArgs );				try {					Object result =						interpreter.source( filename, interpreter.globalNameSpace );					if ( result instanceof Class )						try {							invokeMain( (Class)result, bshArgs );						} catch ( Exception e )						{							Object o = e;							if ( e instanceof InvocationTargetException )								o = ((InvocationTargetException)e)									.getTargetException();							System.err.println(								"Class: "+result+" main method threw exception:"+o);						}				} catch ( FileNotFoundException e ) {					System.out.println("File not found: "+e);				} catch ( TargetError e ) {					System.out.println("Script threw exception: "+e);					if ( e.inNativeCode() )						e.printStackTrace( DEBUG, System.err );				} catch ( EvalError e ) {					System.out.println("Evaluation Error: "+e);				} catch ( IOException e ) {					System.out.println("I/O Error: "+e);				}	        } else			{				// Workaround for JDK bug 4071281, where system.in.available()				// returns too large a value. This bug has been fixed in JDK 1.2.				InputStream src;				if ( System.getProperty("os.name").startsWith("Windows")					&& System.getProperty("java.version").startsWith("1.1."))				{					src = new FilterInputStream(System.in) {						public int available() throws IOException {							return 0;						}					};				}				else					src = System.in;		            Reader in = new CommandLineReader( new InputStreamReader(src));	            Interpreter interpreter =					new Interpreter( in, System.out, System.err, true );	        	interpreter.run();	        }	    }	
public static void invokeMain( Class clas, String [] args )			throws Exception		{	    	Method main = Reflect.resolveJavaMethod(				null/*BshClassManager*/, clas, "main",				new Class [] { String [].class }, true/*onlyStatic*/ );			if ( main != null )				main.invoke( null, new Object [] { args } );		}	
/**			Run interactively.  (printing prompts, etc.)		*/	    public void run()		{	        if(evalOnly)	            throw new RuntimeException("bsh Interpreter: No stream");		        /*	          We'll print our banner using eval(String) in order to	          exercise the parser and get the basic expression classes loaded...	          This ameliorates the delay after typing the first statement.	        */	        if ( interactive )				try {					eval("printBanner();");				} catch ( EvalError e ) {					println(						"BeanShell "+VERSION+" - by Pat Niemeyer (pat@pat.net)");				}				// init the callstack.			CallStack callstack = new CallStack( globalNameSpace );		        boolean eof = false;	        while( !eof )	        {	            try	            {	                // try to sync up the console	                System.out.flush();	                System.err.flush();	                Thread.yield();  // this helps a little		                if ( interactive )	                    print( getBshPrompt() );		                eof = Line();		                if( get_jjtree().nodeArity() > 0 )  // number of child nodes	                {	                    SimpleNode node = (SimpleNode)(get_jjtree().rootNode());		                    if(DEBUG)	                        node.dump(">");		                    Object ret = node.eval( callstack, this );							// sanity check during development						if ( callstack.depth() > 1 )							throw new InterpreterError(								"Callstack growing: "+callstack);		                    if(ret instanceof ReturnControl)	                        ret = ((ReturnControl)ret).value;		                    if( ret != Primitive.VOID )	                    {	                        setu("$_", ret);							if ( showResults )	                            println("<" + ret + ">");	                    }	                }	            }	            catch(ParseException e)	            {	                error("Parser Error: " + e.getMessage(DEBUG));					if ( DEBUG )	                	e.printStackTrace();	                if(!interactive)	                    eof = true;		                parser.reInitInput(in);	            }	            catch(InterpreterError e)	            {	                error("Internal Error: " + e.getMessage());	                e.printStackTrace();	                if(!interactive)	                    eof = true;	            }	            catch(TargetError e)	            {	                error("// Uncaught Exception: " + e );					if ( e.inNativeCode() )						e.printStackTrace( DEBUG, err );	                if(!interactive)	                    eof = true;					setu("$_e", e.getTarget());	            }	            catch (EvalError e)	            {					if ( interactive )						error( "EvalError: "+e.toString() );					else						error( "EvalError: "+e.getMessage() );		                if(DEBUG)	                    e.printStackTrace();		                if(!interactive)	                    eof = true;	            }	            catch(Exception e)	            {	                error("Unknown error: " + e);					if ( DEBUG )	                	e.printStackTrace();	                if(!interactive)	                    eof = true;	            }	            catch(TokenMgrError e)	            {					error("Error parsing input: " + e);						/*						We get stuck in infinite loops here when unicode escapes						fail.  Must re-init the char stream reader						(ASCII_UCodeESC_CharStream.java)					*/					parser.reInitTokenInput( in );		                if(!interactive)	                    eof = true;	            }	            finally	            {	                get_jjtree().reset();					// reinit the callstack					if ( callstack.depth() > 1 ) {						callstack.clear();						callstack.push( globalNameSpace );					}	            }	        }				if ( interactive && exitOnEOF )				System.exit(0);	    }	
/**			Read text from fileName and eval it.		*/	    public Object source( String filename, NameSpace nameSpace )			throws FileNotFoundException, IOException, EvalError		{			File file = pathToFile( filename );			if ( Interpreter.DEBUG ) debug("Sourcing file: "+file);			Reader sourceIn = new BufferedReader( new FileReader(file) );			try {				return eval( sourceIn, nameSpace, filename );			} finally {				sourceIn.close();			}		}	
/**			Read text from fileName and eval it.			Convenience method.  Use the global namespace.		*/	    public Object source( String filename )			throws FileNotFoundException, IOException, EvalError		{			return source( filename, globalNameSpace );		}	
/**	        Spawn a non-interactive local interpreter to evaluate text in the			specified namespace.				Return value is the evaluated object (or corresponding primitive			wrapper).				@param sourceFileInfo is for information purposes only.  It is used to			display error messages (and in the future may be made available to			the script).			@throws EvalError on script problems			@throws TargetError on unhandled exceptions from the script	    */		/*			Note: we need a form of eval that passes the callstack through...		*/		/*		Can't this be combined with run() ?		run seems to have stuff in it for interactive vs. non-interactive...		compare them side by side and see what they do differently, aside from the		exception handling.		*/		    public Object eval(			Reader in, NameSpace nameSpace, String sourceFileInfo				/*, CallStack callstack */ )			throws EvalError		{			Object retVal = null;			if ( Interpreter.DEBUG ) debug("eval: nameSpace = "+nameSpace);				/*				Create non-interactive local interpreter for this namespace				with source from the input stream and out/err same as				this interpreter.			*/	        Interpreter localInterpreter =				new Interpreter(					in, out, err, false, nameSpace, this, sourceFileInfo  );				CallStack callstack = new CallStack( nameSpace );		        boolean eof = false;	        while(!eof)	        {				SimpleNode node = null;	            try	            {	                eof = localInterpreter.Line();	                if (localInterpreter.get_jjtree().nodeArity() > 0)	                {	                    node = (SimpleNode)localInterpreter.get_jjtree().rootNode();						// nodes remember from where they were sourced						node.setSourceFile( sourceFileInfo );							if ( TRACE )							println( "// " +node.getText() );		                    retVal = node.eval( callstack, localInterpreter );							// sanity check during development						if ( callstack.depth() > 1 )							throw new InterpreterError(								"Callstack growing: "+callstack);		                    if ( retVal instanceof ReturnControl ) {	                        retVal = ((ReturnControl)retVal).value;							break; // non-interactive, return control now						}							if ( localInterpreter.showResults							&& retVal != Primitive.VOID )							println("<" + retVal + ">");	                }	            } catch(ParseException e) {					/*	                throw new EvalError(						"Sourced file: "+sourceFileInfo+" parser Error: "						+ e.getMessage( DEBUG ), node, callstack );					*/					if ( DEBUG )						// show extra "expecting..." info						error( e.getMessage(DEBUG) );						// add the source file info and throw again					e.setErrorSourceFile( sourceFileInfo );					throw e;		            } catch ( InterpreterError e ) {	                e.printStackTrace();	                throw new EvalError(						"Sourced file: "+sourceFileInfo+" internal Error: "						+ e.getMessage(), node, callstack);	            } catch ( TargetError e ) {					// failsafe, set the Line as the origin of the error.					if ( e.getNode()==null )						e.setNode( node );					e.reThrow("Sourced file: "+sourceFileInfo);	            } catch ( EvalError e) {	                if ( DEBUG)	                    e.printStackTrace();					// failsafe, set the Line as the origin of the error.					if ( e.getNode()==null )						e.setNode( node );					e.reThrow( "Sourced file: "+sourceFileInfo );	            } catch ( Exception e) {	                if ( DEBUG)	                	e.printStackTrace();	                throw new EvalError(						"Sourced file: "+sourceFileInfo+" unknown error: "						+ e.getMessage(), node, callstack);	            } catch(TokenMgrError e) {	                throw new EvalError(						"Sourced file: "+sourceFileInfo+" Token Parsing Error: "						+ e.getMessage(), node, callstack );	            } finally {	                localInterpreter.get_jjtree().reset();						// reinit the callstack					if ( callstack.depth() > 1 ) {						callstack.clear();						callstack.push( nameSpace );					}	            }	        }			return Primitive.unwrap( retVal );	    }	
/**			Evaluate the inputstream in this interpreter's global namespace.		*/	    public Object eval( Reader in ) throws EvalError		{			return eval( in, globalNameSpace, "eval stream" );		}	
/**			Evaluate the string in this interpreter's global namespace.		*/	    public Object eval( String statements ) throws EvalError {			if ( Interpreter.DEBUG ) debug("eval(String): "+statements);			return eval(statements, globalNameSpace);		}	
/**			Evaluate the string in the specified namespace.		*/	    public Object eval( String statements, NameSpace nameSpace )			throws EvalError		{				String s = ( statements.endsWith(";") ? statements : statements+";" );	        return eval(				new StringReader(s), nameSpace,				"inline evaluation of: ``"+ showEvalString(s)+"''" );	    }	
private String showEvalString( String s ) {			s = s.replace('\n', ' ');			s = s.replace('\r', ' ');			if ( s.length() > 80 )				s = s.substring( 0, 80 ) + " . . . ";			return s;		}	
/**			Print an error message in a standard format on the output stream			associated with this interpreter. On the GUI console this will appear			in red, etc.		*/	    public final void error( Object o ) {			if ( console != null )					console.error( "// Error: " + o +"\n" );			else {				err.println("// Error: " + o );				err.flush();			}	    }	
/**			Get the input stream associated with this interpreter.			This may be be stdin or the GUI console.		*/		public Reader getIn() { return in; }	
/**			Get the outptut stream associated with this interpreter.			This may be be stdout or the GUI console.		*/		public PrintStream getOut() { return out; }	
/**			Get the error output stream associated with this interpreter.			This may be be stderr or the GUI console.		*/		public PrintStream getErr() { return err; }	
public final void println( Object o )	    {	        print( String.valueOf(o) + systemLineSeparator );	    }	
public final void print( Object o )	    {			if (console != null) {	            console.print(o);	        } else {	            out.print(o);	            out.flush();	        }	    }	
/**			Print a debug message on debug stream associated with this interpreter			only if debugging is turned on.		*/	    public final static void debug(String s)	    {	        if ( DEBUG )	            debug.println("// Debug: " + s);	    }	
/**			Get the value of the name.			name may be any value. e.g. a variable or field		*/	    public Object get( String name ) throws EvalError {			try {				Object ret = globalNameSpace.get( name, this );				return Primitive.unwrap( ret );			} catch ( UtilEvalError e ) {				throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() );			}		}	
/**			Unchecked get for internal use		*/	    Object getu( String name ) {			try {				return get( name );			} catch ( EvalError e ) {				throw new InterpreterError("set: "+e);			}		}	
/**			Assign the value to the name.			name may evaluate to anything assignable. e.g. a variable or field.		*/	    public void set( String name, Object value )			throws EvalError		{			// map null to Primtive.NULL coming in...			if ( value == null )				value = Primitive.NULL;				CallStack callstack = new CallStack();			try {				if ( Name.isCompound( name ) )				{					LHS lhs = globalNameSpace.getNameResolver( name ).toLHS(						callstack, this );					lhs.assign( value, false );				} else // optimization for common case					globalNameSpace.setVariable( name, value, false );			} catch ( UtilEvalError e ) {				throw e.toEvalError( SimpleNode.JAVACODE, callstack );			}		}	
/**			Unchecked set for internal use		*/	    void setu(String name, Object value) {			try {				set(name, value);			} catch ( EvalError e ) {				throw new InterpreterError("set: "+e);			}		}	
public void set(String name, long value) throws EvalError {	        set(name, new Primitive(value));		}	
public void set(String name, int value) throws EvalError {	        set(name, new Primitive(value));		}	
public void set(String name, double value) throws EvalError {	        set(name, new Primitive(value));		}	
public void set(String name, float value) throws EvalError {	        set(name, new Primitive(value));		}	
public void set(String name, boolean value) throws EvalError {	        set(name, new Primitive(value));		}	
/**			Unassign the variable name.			Name should evaluate to a variable.		*/	    public void unset( String name )			throws EvalError		{			/*				We jump through some hoops here to handle arbitrary cases like				unset("bsh.foo");			*/			CallStack callstack = new CallStack();			try {				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS(					callstack, this );					if ( lhs.type != LHS.VARIABLE )					throw new EvalError("Can't unset, not a variable: "+name,						SimpleNode.JAVACODE, new CallStack() );					//lhs.assign( null, false );				lhs.nameSpace.unsetVariable( name );			} catch ( UtilEvalError e ) {				throw new EvalError( e.getMessage(),					SimpleNode.JAVACODE, new CallStack() );			}		}	
/**			Get a reference to the interpreter (global namespace), cast			to the specified interface type.  Assuming the appropriate			methods of the interface are defined in the interpreter, then you may			use this interface from Java, just like any other Java object.			<p>				For example:			<pre>				Interpreter interpreter = new Interpreter();				// define a method called run()				interpreter.eval("run() { ... }");					// Fetch a reference to the interpreter as a Runnable				Runnable runnable =					(Runnable)interpreter.getInterface( Runnable.class );			</pre>			<p>				Note that the interpreter does *not* require that any or all of the			methods of the interface be defined at the time the interface is			generated.  However if you attempt to invoke one that is not defined			you will get a runtime exception.			<p>				Note also that this convenience method has exactly the same effect as			evaluating the script:			<pre>				(Type)this;			</pre>			<p>				For example, the following is identical to the previous example:			<p>				<pre>				// Fetch a reference to the interpreter as a Runnable				Runnable runnable =					(Runnable)interpreter.eval( "(Runnable)this" );			</pre>			<p>				<em>Version requirement</em> Although standard Java interface types			are always available, to be used with arbitrary interfaces this			feature requires that you are using Java 1.3 or greater.			<p>				@throws EvalError if the interface cannot be generated because the			version of Java does not support the proxy mechanism.		*/		public Object getInterface( Class interf ) throws EvalError		{			try {				return globalNameSpace.getThis( this ).getInterface( interf );			} catch ( UtilEvalError e ) {				throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() );			}		}	
private JJTParserState get_jjtree() {			return parser.jjtree;		}	
private JavaCharStream get_jj_input_stream() {			return parser.jj_input_stream;		}	
private boolean Line() throws ParseException {			return parser.Line();		}	
void loadRCFiles() {			try {				String rcfile =					// Default is c:\windows under win98, $HOME under Unix					System.getProperty("user.home") + File.separator + ".bshrc";				source( rcfile, globalNameSpace );			} catch ( Exception e ) {				// squeltch security exception, filenotfoundexception				if ( Interpreter.DEBUG ) debug("Could not find rc file: "+e);			}		}	
/**			Localize a path to the file name based on the bsh.cwd interpreter			working directory.		*/	    public File pathToFile( String fileName )			throws IOException		{			File file = new File( fileName );				// if relative, fix up to bsh.cwd			if ( !file.isAbsolute() ) {				String cwd = (String)getu("bsh.cwd");				file = new File( cwd + File.separator + fileName );			}				// The canonical file name is also absolute.			// No need for getAbsolutePath() here...			return new File( file.getCanonicalPath() );		}	
public static void redirectOutputToFile( String filename )		{			try {				PrintStream pout = new PrintStream(					new FileOutputStream( filename ) );				System.setOut( pout );				System.setErr( pout );			} catch ( IOException e ) {				System.err.println("Can't redirect output to file: "+filename );			}		}	
/**			Set an external class loader to be used as the base classloader			for BeanShell.  The base classloader is used for all classloading			unless/until the addClasspath()/setClasspath()/reloadClasses()			commands are called to modify the interpreter's classpath.  At that			time the new paths /updated paths are added on top of the base			classloader.			<p>				BeanShell will use this at the same point it would otherwise use the			plain Class.forName().			i.e. if no explicit classpath management is done from the script			(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will			only use the supplied classloader.  If additional classpath management			is done then BeanShell will perform that in addition to the supplied			external classloader.			However BeanShell is not currently able to reload			classes supplied through the external classloader.			<p>				@see BshClassManager#setClassLoader( ClassLoader )		*/		public void setClassLoader( ClassLoader externalCL ) {			getClassManager().setClassLoader( externalCL );		}	
/**			Get the class manager associated with this interpreter			(the BshClassManager of this interpreter's global namespace).			This is primarily a convenience method.		*/		public BshClassManager getClassManager()		{			return getNameSpace().getClassManager();		}	
/**			Set strict Java mode on or off.			This mode attempts to make BeanShell syntax behave as Java			syntax, eliminating conveniences like loose variables, etc.			When enabled, variables are required to be declared or initialized			before use and method arguments are reqired to have types.			<p>				This mode will become more strict in a future release when			classes are interpreted and there is an alternative to scripting			objects as method closures.		*/		public void setStrictJava( boolean b ) {			this.strictJava = b;		}	
/**			@see #setStrictJava( boolean )		*/		public boolean getStrictJava() {			return this.strictJava;		}	
static void staticInit()		{		/*			Apparently in some environments you can't catch the security exception			at all...  e.g. as an applet in IE  ... will probably have to work			around		*/			try {				systemLineSeparator = System.getProperty("line.separator");	    		debug = System.err;	    		DEBUG = Boolean.getBoolean("debug");	    		TRACE = Boolean.getBoolean("trace");	    		LOCALSCOPING = Boolean.getBoolean("localscoping");				String outfilename = System.getProperty("outfile");				if ( outfilename != null )					redirectOutputToFile( outfilename );			} catch ( SecurityException e ) {				System.err.println("Could not init static:"+e);			} catch ( Exception e ) {				System.err.println("Could not init static(2):"+e);			} catch ( Throwable e ) {				System.err.println("Could not init static(3):"+e);			}		}	
/**			Specify the source of the text from which this interpreter is reading.			Note: there is a difference between what file the interrpeter is			sourcing and from what file a method was originally parsed.  One			file may call a method sourced from another file.  See SimpleNode			for origination file info.			@see org.gjt.sp.jedit.bsh.SimpleNode#getSourceFile()		*/		public String getSourceFileInfo() {			if ( sourceFileInfo != null )				return sourceFileInfo;			else				return "<unknown source>";		}	
/**			Get the parent Interpreter of this interpreter, if any.			Currently this relationship implies the following:				1) Parent and child share a BshClassManager				2) Children indicate the parent's source file information in error				reporting.			When created as part of a source() / eval() the child also shares			the parent's namespace.  But that is not necessary in general.		*/		public Interpreter getParent() {			return parent;		}	
public void setOut( PrintStream out ) {			this.out = out;		}	
public void setErr( PrintStream err ) {			this.err = err;		}	
/**			De-serialization setup.			Default out and err streams to stdout, stderr if they are null.		*/		private void readObject(ObjectInputStream stream)			throws java.io.IOException, ClassNotFoundException		{			stream.defaultReadObject();				// set transient fields			if ( console != null ) {				setOut( console.getOut() );				setErr( console.getErr() );			} else {				setOut( System.out );				setErr( System.err );			}		}	
/**			Get the prompt string defined by the getBshPrompt() method in the			global namespace.  This may be from the getBshPrompt() command or may			be defined by the user as with any other method.			Defaults to "bsh % " if the method is not defined or there is an error.		*/		private String getBshPrompt()		{			try {				return (String)eval("getBshPrompt()");			} catch ( Exception e ) {				return "bsh % ";			}		}	
/**			Specify whether, in interactive mode, the interpreter exits Java upon			end of input.  If true, when in interactive mode the interpreter will			issue a System.exit(0) upon eof.  If false the interpreter no			System.exit() will be done.			<p/>			Note: if you wish to cause an EOF externally you can try closing the			input stream.  This is not guaranteed to work in older versions of Java			due to Java limitations, but should work in newer JDK/JREs.  (That was			the motivation for the Java NIO package).		*/		public void setExitOnEOF( boolean value ) {			exitOnEOF = value; // ug		}	
/**			Turn on/off the verbose printing of results as for the show()			 command.		 	If this interpreter has a parent the call is delegated.		 	See the BeanShell show() command.		*/		public void setShowResults( boolean showResults ) {			this.showResults = showResults;		}	
/**		 Show on/off verbose printing status for the show() command.		 See the BeanShell show() command.		 If this interpreter has a parent the call is delegated.		 */		public boolean getShowResults()  {			return showResults;		}	
public InterpreterError(String s)		{			super(s);		}	
public IOProgressMonitor()		{			super(new BorderLayout());			caption = new JLabel();			updateCaption();			add(BorderLayout.NORTH,caption);				threads = new ThreadProgress[VFSManager.getIOThreadPool()				.getThreadCount()];				Box box = new Box(BoxLayout.Y_AXIS);			for(int i = 0; i < threads.length; i++)			{				if(i != 0)					box.add(Box.createVerticalStrut(6));					threads[i] = new ThreadProgress(i);				box.add(threads[i]);			}				JPanel threadPanel = new JPanel(new BorderLayout());			threadPanel.setBorder(new EmptyBorder(6,6,6,6));			threadPanel.add(BorderLayout.NORTH,box);				add(BorderLayout.CENTER,new JScrollPane(threadPanel));				workThreadHandler = new WorkThreadHandler();		}	
public void addNotify()		{			VFSManager.getIOThreadPool().addProgressListener(workThreadHandler);			super.addNotify();		}	
public void removeNotify()		{			VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);			super.removeNotify();		}	
private void updateCaption()		{			String[] args = { String.valueOf(VFSManager.getIOThreadPool()				.getRequestCount()) };			caption.setText(jEdit.getProperty("io-progress-monitor.caption",args));		}	
public void statusUpdate(final WorkThreadPool threadPool, final int threadIndex)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						updateCaption();						threads[threadIndex].update();					}				});			}	
public void progressUpdate(final WorkThreadPool threadPool, final int threadIndex)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						updateCaption();						threads[threadIndex].update();					}				});			}	
public ThreadProgress(int index)			{				super(new BorderLayout(12,12));					this.index = index;					Box box = new Box(BoxLayout.Y_AXIS);				box.add(Box.createGlue());				box.add(progress = new JProgressBar());				progress.setStringPainted(true);				box.add(Box.createGlue());				ThreadProgress.this.add(BorderLayout.CENTER,box);					abort = new JButton(jEdit.getProperty("io-progress-monitor.abort"));				abort.addActionListener(new ActionHandler());				ThreadProgress.this.add(BorderLayout.EAST,abort);					update();			}	
public void update()			{				WorkThread thread = VFSManager.getIOThreadPool().getThread(index);				if(thread.isRequestRunning())				{					if (progress.isIndeterminate())					{						if (thread.getProgressMaximum() != 0)							progress.setIndeterminate(false);					}					else if (thread.getProgressMaximum() == 0)						progress.setIndeterminate(true);										abort.setEnabled(true);					String status = thread.getStatus();					if(status == null)						status = "";					progress.setString(status);					progress.setMaximum(thread.getProgressMaximum());					//System.err.println("value: " + thread.getProgressValue());					progress.setValue(thread.getProgressValue());				}				else				{					abort.setEnabled(false);					progress.setString(jEdit.getProperty("io-progress-monitor"						+ ".idle"));					progress.setIndeterminate(false);					progress.setValue(0);				}			}	
public void actionPerformed(ActionEvent evt)				{					if(evt.getSource() == abort)					{						int result = GUIUtilities.confirm(							IOProgressMonitor.this,"abort",null,							JOptionPane.YES_NO_OPTION,							JOptionPane.QUESTION_MESSAGE);						if(result == JOptionPane.YES_OPTION)						{							VFSManager.getIOThreadPool().getThread(index)								.abortCurrentRequest();						}					}				}	
/**		 * Moves the source file to the destination.		 *		 * If the destination cannot be created or is a read-only file, the		 * method returns <code>false</code>. Otherwise, the contents of the		 * source are copied to the destination, the source is deleted,		 * and <code>true</code> is returned.		 *		 * @param source The source file to move.		 * @param dest   The destination where to move the file.		 * @return true on success, false otherwise.		 *		 * @since jEdit 4.3pre9		 */		public static boolean moveFile(File source, File dest)		{			boolean ok = false;				if ((dest.exists() && dest.canWrite())				|| (!dest.exists() && dest.getParentFile().canWrite()))				{					OutputStream fos = null;					InputStream fis = null;					try					{						fos = new FileOutputStream(dest);						fis = new FileInputStream(source);						ok = copyStream(32768,null,fis,fos,false);					}					catch (IOException ioe)					{						Log.log(Log.WARNING, IOUtilities.class,								"Error moving file: " + ioe + " : " + ioe.getMessage());					}					finally					{						closeQuietly(fos);						closeQuietly(fis);					}						if(ok)						source.delete();				}			return ok;		}	
/**		 * Copy an input stream to an output stream.		 *		 * @param bufferSize the size of the buffer		 * @param progress the progress observer it could be null		 * @param in the input stream		 * @param out the output stream		 * @param canStop if true, the copy can be stopped by interrupting the thread		 * @return <code>true</code> if the copy was done, <code>false</code> if it was interrupted		 * @throws IOException  IOException If an I/O error occurs		 */		public static boolean copyStream(int bufferSize, ProgressObserver progress,						InputStream in, OutputStream out, boolean canStop)			throws IOException		{			byte[] buffer = new byte[bufferSize];			int n;			long copied = 0L;			while (-1 != (n = in.read(buffer)))			{				out.write(buffer, 0, n);				copied += n;				if(progress != null)					progress.setValue(copied);				if(canStop && Thread.interrupted()) return false;			}			return true;		}	
/**		 * Copy an input stream to an output stream with a buffer of 4096 bytes.		 *		 * @param progress the progress observer it could be null		 * @param in the input stream		 * @param out the output stream		 * @param canStop if true, the copy can be stopped by interrupting the thread		 * @return <code>true</code> if the copy was done, <code>false</code> if it was interrupted		 * @throws IOException  IOException If an I/O error occurs		 */		public static boolean copyStream(ProgressObserver progress,						 InputStream in, OutputStream out, boolean canStop)			throws IOException		{			return copyStream(4096,progress, in, out, canStop);		}	
/**		 * Returns the length of a file. If it is a directory it will calculate recursively the length.		 *		 * @param file the file or directory		 * @return the length of the file or directory. If the file doesn't exist it will return 0		 * @since 4.3pre10		 */		public static long fileLength(File file)		{			long length = 0L;			if (file.isFile())				length = file.length();			else if (file.isDirectory())			{				File[] files = file.listFiles();				for (int i = 0; i < files.length; i++)				{					length += fileLength(files[i]);				}			}			return length;		}	
/**		 * Method that will close an {@link InputStream} ignoring it if it is null and ignoring exceptions.		 *		 * @param in the InputStream to close.		 */		public static void closeQuietly(InputStream in)		{			if(in != null)			{				try				{					in.close();				}				catch (IOException e)				{					//ignore				}			}		}	
/**		 * Method that will close an {@link OutputStream} ignoring it if it is null and ignoring exceptions.		 *		 * @param out the OutputStream to close.		 */		public static void closeQuietly(OutputStream out)		{			if(out != null)			{				try {					if (out instanceof Flushable)					{						((Flushable)out).flush();					}				}				catch (IOException e)				{					// ignore				}				try				{					out.close();				}				catch (IOException e)				{					//ignore				}			}		}	
/**		 * Method that will close an {@link Reader} ignoring it if it is null and ignoring exceptions.		 *		 * @param r the Reader to close.		 * @since jEdit 4.3pre5		 */		public static void closeQuietly(Reader r)		{			if(r != null)			{				try				{					r.close();				}				catch (IOException e)				{					//ignore				}			}		}	
/**		 * Method that will close a {@link Writer} ignoring it if it is null and ignoring exceptions.		 *		 * @param out the Writer to close.		 */		public static void closeQuietly(Writer out)		{			if(out != null)			{				try {					if (out instanceof Flushable)					{						((Flushable)out).flush();					}				}				catch (IOException e)				{					// ignore				}				try				{					out.close();				}				catch (IOException e)				{					//ignore				}			}		}	
/**		 * Method that will close an {@link java.io.Closeable} ignoring it if it is null and ignoring exceptions.		 *		 * @param closeable the closeable to close.		 * @since jEdit 4.3pre8		 */		public static void closeQuietly(Closeable closeable)		{			if(closeable != null)			{				try {					if (closeable instanceof Flushable)					{						((Flushable)closeable).flush();					}				}				catch (IOException e)				{					// ignore				}				try				{					closeable.close();				}				catch (IOException e)				{					//ignore				}			}		}	
private IOUtilities()		{		}	
/**	   * Constructs an uninitialized {@link Item Item} object.	   */		  Item () {	  }	
/**	   * Constructs a copy of the given item.	   *	   * @param index index of the item to be constructed.	   * @param i the item that must be copied into the item to be constructed.	   */		  Item (final short index, final Item i) {	    this.index = index;	    type = i.type;	    intVal = i.intVal;	    longVal = i.longVal;	    floatVal = i.floatVal;	    doubleVal = i.doubleVal;	    strVal1 = i.strVal1;	    strVal2 = i.strVal2;	    strVal3 = i.strVal3;	    hashCode = i.hashCode;	  }	
/**	   * Sets this item to an {@link ClassWriter#INT INT} item.	   *	   * @param intVal the value of this item.	   */		  void set (final int intVal) {	    this.type = ClassWriter.INT;	    this.intVal = intVal;	    this.hashCode = type + intVal;	  }	
/**	   * Sets this item to a {@link ClassWriter#LONG LONG} item.	   *	   * @param longVal the value of this item.	   */		  void set (final long longVal) {	    this.type = ClassWriter.LONG;	    this.longVal = longVal;	    this.hashCode = type + (int)longVal;	  }	
/**	   * Sets this item to a {@link ClassWriter#FLOAT FLOAT} item.	   *	   * @param floatVal the value of this item.	   */		  void set (final float floatVal) {	    this.type = ClassWriter.FLOAT;	    this.floatVal = floatVal;	    this.hashCode = type + (int)floatVal;	  }	
/**	   * Sets this item to a {@link ClassWriter#DOUBLE DOUBLE} item.	   *	   * @param doubleVal the value of this item.	   */		  void set (final double doubleVal) {	    this.type = ClassWriter.DOUBLE;	    this.doubleVal = doubleVal;	    this.hashCode = type + (int)doubleVal;	  }	
/**	   * Sets this item to an item that do not hold a primitive value.	   *	   * @param type the type of this item.	   * @param strVal1 first part of the value of this item.	   * @param strVal2 second part of the value of this item.	   * @param strVal3 third part of the value of this item.	   */		  void set (	    final int type,	    final String strVal1,	    final String strVal2,	    final String strVal3)	  {	    this.type = type;	    this.strVal1 = strVal1;	    this.strVal2 = strVal2;	    this.strVal3 = strVal3;	    switch (type) {	      case ClassWriter.UTF8:	      case ClassWriter.STR:	      case ClassWriter.CLASS:	        hashCode = type + strVal1.hashCode();	        return;	      case ClassWriter.NAME_TYPE:	        hashCode = type + strVal1.hashCode()*strVal2.hashCode();	        return;	      //case ClassWriter.FIELD:	      //case ClassWriter.METH:	      //case ClassWriter.IMETH:	      default:	        hashCode = type + strVal1.hashCode()*strVal2.hashCode()*strVal3.hashCode();	        return;	    }	  }	
/**	   * Indicates if the given item is equal to this one.	   *	   * @param i the item to be compared to this one.	   * @return <tt>true</tt> if the given item if equal to this one,	   *      <tt>false</tt> otherwise.	   */		  boolean isEqualTo (final Item i) {	    if (i.type == type) {	      switch (type) {	        case ClassWriter.INT:	          return i.intVal == intVal;	        case ClassWriter.LONG:	          return i.longVal == longVal;	        case ClassWriter.FLOAT:	          return i.floatVal == floatVal;	        case ClassWriter.DOUBLE:	          return i.doubleVal == doubleVal;	        case ClassWriter.UTF8:	        case ClassWriter.STR:	        case ClassWriter.CLASS:	          return i.strVal1.equals(strVal1);	        case ClassWriter.NAME_TYPE:	          return i.strVal1.equals(strVal1) &&	                 i.strVal2.equals(strVal2);	        //case ClassWriter.FIELD:	        //case ClassWriter.METH:	        //case ClassWriter.IMETH:	        default:	          return i.strVal1.equals(strVal1) &&	                 i.strVal2.equals(strVal2) &&	                 i.strVal3.equals(strVal3);	      }	    }	    return false;	  }	
/**		 * This constructor creates a class loader for loading classes from all		 * plugins. For example BeanShell uses one of these so that scripts can		 * use plugin classes.		 */		public JARClassLoader()		{			this(true);		}	
/**		 * Creates a class loader that will optionally delegate the		 * finding of classes to the parent class loader by default.		 *		 * @since jEdit 4.3pre6		 */		public JARClassLoader(boolean delegateFirst)		{			this.delegateFirst = delegateFirst;			// for debugging			id = INDEX++;			live++;		}	
/**		 * @exception ClassNotFoundException if the class could not be found		 */		public Class loadClass(String clazz, boolean resolveIt)			throws ClassNotFoundException		{			ClassNotFoundException pending = null;			if (delegateFirst)			{				try				{					return loadFromParent(clazz);				}				catch (ClassNotFoundException cnf)				{					// keep going if class was not found.					pending = cnf;				}			}				Object obj = classHash.get(clazz);			if(obj == NO_CLASS)			{				// we remember which classes we don't exist				// because BeanShell tries loading all possible				// <imported prefix>.<class name> combinations				throw new ClassNotFoundException(clazz);			}			else if(obj instanceof JARClassLoader)			{				JARClassLoader classLoader = (JARClassLoader)obj;				try				{					return classLoader._loadClass(clazz,resolveIt);				} catch (ClassNotFoundException cnf2)				{					classHash.put(clazz,NO_CLASS);					throw cnf2;				}			}			else if (delegateFirst)			{				// if delegating, reaching this statement means				// the class was really not found. Otherwise				// we'll try loading from the parent class loader.				throw pending;			}				return loadFromParent(clazz);		}	
public InputStream getResourceAsStream(String name)		{			try			{				// try in current jar first				if(jar != null)				{					ZipFile zipFile = jar.getZipFile();					ZipEntry entry = zipFile.getEntry(name);					if(entry != null)					{						return zipFile.getInputStream(entry);					}				}				// then try from another jar				Object obj = resourcesHash.get(name);				if(obj instanceof JARClassLoader)				{					JARClassLoader classLoader = (JARClassLoader)obj;					return classLoader.getResourceAsStream(name);				}				// finally try from the system class loader				return getSystemResourceAsStream(name);			}			catch(IOException io)			{				Log.log(Log.ERROR,this,io);					return null;			}		}	
/**		 * overriding getResource() because we want to search FIRST in this		 * ClassLoader, then the parent, the path, etc.		 */		public URL getResource(String name)		{			try			{				if(jar != null)				{					ZipFile zipFile = jar.getZipFile();					ZipEntry entry = zipFile.getEntry(name);					if(entry != null)					{						return new URL(getResourceAsPath(name));					}				}								Object obj = resourcesHash.get(name);				if(obj instanceof JARClassLoader)				{					JARClassLoader classLoader = (JARClassLoader)obj;					return classLoader.getResource(name);				} else				{					URL ret = getSystemResource(name); 					if(ret != null)					{						Log.log(Log.DEBUG,JARClassLoader.class,"Would have returned null for getResource("+name+")");						Log.log(Log.DEBUG,JARClassLoader.class,"returning("+ret+")");					}					return ret;				}			}			catch(IOException io)			{				Log.log(Log.ERROR,this,io);				return null;			}		}	
/**		 * construct a jeditresource:/etc path from the name		 * of a resource in the associated jar.		 * The existence of the resource is not actually checked.		 *		 * @param name name of the resource		 * @return jeditresource:/path_to_the_jar!name_of_the_resource		 * @throws UnsupportedOperationException if this is an anonymous		 * JARClassLoader (no associated jar).		 */		public String getResourceAsPath(String name)		{			// this must be fixed during plugin development			if(jar == null)				throw new UnsupportedOperationException(					"don't call getResourceAsPath() on anonymous JARClassLoader");				if(!name.startsWith("/"))				name = '/' + name;				return "jeditresource:/" + MiscUtilities.getFileName(				jar.getPath()) + '!' + name;		}	
/**		 * @deprecated Call <code>PluginJAR.getZipFile()</code> instead.		 */		public ZipFile getZipFile()		{			try			{				return jar.getZipFile();			}			catch(IOException io)			{				Log.log(Log.ERROR,this,io);				return null;			}		}	
/**		 * For debugging.		 */		public static void dump()		{			Log.log(Log.DEBUG,JARClassLoader.class,				"Total instances created: " + INDEX);			Log.log(Log.DEBUG,JARClassLoader.class,				"Live instances: " + live);			synchronized(classHash)			{				for (Map.Entry<String, Object> entry : classHash.entrySet())				{					if (entry.getValue() != NO_CLASS)					{						Log.log(Log.DEBUG, JARClassLoader.class,							entry.getKey() + " ==> "								+ entry.getValue());					}				}			}		}	
public String toString()		{			if(jar == null)				return "<anonymous>(" + id + ')';			else				return jar.getPath() + " (" + id + ')';		}	
/**		 * @return zero or one resource, as returned by getResource()		 */		public Enumeration getResources(String name) throws IOException		{			class SingleElementEnumeration implements Enumeration			{				private Object element;					SingleElementEnumeration(Object element)				{					this.element = element;				}					public boolean hasMoreElements()				{					return element != null;				}					public Object nextElement()				{					if(element != null)					{						Object retval = element;						element = null;						return retval;					}					else						throw new NoSuchElementException();				}			}				URL resource = getResource(name);			return new SingleElementEnumeration(resource);		}	
protected void finalize()		{			live--;		}	
/**		 * @since jEdit 4.2pre1		 */		JARClassLoader(PluginJAR jar)		{			this();			this.jar = jar;		}	
void activate()		{			if (jar.getPlugin() != null)			{				String _delegate = jEdit.getProperty(					"plugin." + jar.getPlugin().getClassName() + ".class_loader_delegate");				delegateFirst = _delegate == null || "true".equals(_delegate);			}				String[] classes = jar.getClasses();			if(classes != null)			{				for(int i = 0; i < classes.length; i++)				{					classHash.put(classes[i],this);				}			}				String[] resources = jar.getResources();			if(resources != null)			{				for(int i = 0; i < resources.length; i++)				{					resourcesHash.put(resources[i],this);				}			}		}	
void deactivate()		{			String[] classes = jar.getClasses();			if(classes != null)			{				for(int i = 0; i < classes.length; i++)				{					Object loader = classHash.get(classes[i]);					if(loader == this)						classHash.remove(classes[i]);					else						/* two plugins provide same class! */;				}			}				String[] resources = jar.getResources();			if(resources == null)				return;				for(int i = 0; i < resources.length; i++)			{				Object loader = resourcesHash.get(resources[i]);				if(loader == this)					resourcesHash.remove(resources[i]);				else					/* two plugins provide same resource! */;			}		}	
/**		 * Load class from this JAR only.		 */		private synchronized Class _loadClass(String clazz, boolean resolveIt)			throws ClassNotFoundException		{			jar.activatePlugin();				synchronized(this)			{				Class cls = findLoadedClass(clazz);				if(cls != null)				{					if(resolveIt)						resolveClass(cls);					return cls;				}					String name = MiscUtilities.classToFile(clazz);					try				{					definePackage(clazz);					ZipFile zipFile = jar.getZipFile();					ZipEntry entry = zipFile.getEntry(name);						if(entry == null)						throw new ClassNotFoundException(clazz);						InputStream in = zipFile.getInputStream(entry);						int len = (int)entry.getSize();					byte[] data = new byte[len];					int success = 0;					int offset = 0;					while(success < len)					{						len -= success;						offset += success;						success = in.read(data,offset,len);						if(success == -1)						{							Log.log(Log.ERROR,this,"Failed to load class "								+ clazz + " from " + zipFile.getName());							throw new ClassNotFoundException(clazz);						}					}						cls = defineClass(clazz,data,0,data.length);						if(resolveIt)						resolveClass(cls);						return cls;				}				catch(IOException io)				{					Log.log(Log.ERROR,this,io);						throw new ClassNotFoundException(clazz);				}			}		}	
private void definePackage(String clazz) throws IOException		{			int idx = clazz.lastIndexOf('.');			if (idx != -1)			{				String name = clazz.substring(0, idx);				if (getPackage(name) == null) definePackage(name, new JarFile(jar.getFile()).getManifest());			}		}	
private static String getMfValue(Attributes sectionAttrs, Attributes mainAttrs, Attributes.Name name)		{			String value=null;			if (sectionAttrs != null)				value = sectionAttrs.getValue(name);			else if (mainAttrs != null)			{				value = mainAttrs.getValue(name);			}			return value;		}	
private void definePackage(String name, Manifest mf)		{			if (mf==null)			{				definePackage(name, null, null, null, null, null,				null, null);				return;			}				Attributes sa = mf.getAttributes(name.replace('.', '/') + '/');			Attributes ma = mf.getMainAttributes();				URL sealBase = null;			if (Boolean.valueOf(getMfValue(sa, ma, Name.SEALED)).booleanValue())			{				try				{					sealBase = jar.getFile().toURL();				}				catch (MalformedURLException e) {}			}				Package pkg=definePackage(				name,				getMfValue(sa, ma, Name.SPECIFICATION_TITLE),				getMfValue(sa, ma, Name.SPECIFICATION_VERSION),				getMfValue(sa, ma, Name.SPECIFICATION_VENDOR),				getMfValue(sa, ma, Name.IMPLEMENTATION_TITLE),				getMfValue(sa, ma, Name.IMPLEMENTATION_VERSION),				getMfValue(sa, ma, Name.IMPLEMENTATION_VENDOR),				sealBase);		}	
private Class loadFromParent(String clazz)			throws ClassNotFoundException		{			Class cls;				ClassLoader parentLoader = getClass().getClassLoader();			if (parentLoader != null)				cls = parentLoader.loadClass(clazz);			else				cls = findSystemClass(clazz);				return cls;		}	
static final int hexval(char c) throws java.io.IOException {	    switch(c)	    {	       case '0' :	          return 0;	       case '1' :	          return 1;	       case '2' :	          return 2;	       case '3' :	          return 3;	       case '4' :	          return 4;	       case '5' :	          return 5;	       case '6' :	          return 6;	       case '7' :	          return 7;	       case '8' :	          return 8;	       case '9' :	          return 9;		       case 'a' :	       case 'A' :	          return 10;	       case 'b' :	       case 'B' :	          return 11;	       case 'c' :	       case 'C' :	          return 12;	       case 'd' :	       case 'D' :	          return 13;	       case 'e' :	       case 'E' :	          return 14;	       case 'f' :	       case 'F' :	          return 15;	    }		    throw new java.io.IOException(); // Should never come here	  }	
protected void ExpandBuff(boolean wrapAround)	  {	     char[] newbuffer = new char[bufsize + 2048];	     int newbufline[] = new int[bufsize + 2048];	     int newbufcolumn[] = new int[bufsize + 2048];		     try	     {	        if (wrapAround)	        {	           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);	           System.arraycopy(buffer, 0, newbuffer,	                                             bufsize - tokenBegin, bufpos);	           buffer = newbuffer;		           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);	           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);	           bufline = newbufline;		           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);	           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);	           bufcolumn = newbufcolumn;		           bufpos += (bufsize - tokenBegin);	        }	        else	        {	           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);	           buffer = newbuffer;		           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);	           bufline = newbufline;		           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);	           bufcolumn = newbufcolumn;		           bufpos -= tokenBegin;	        }	     }	     catch (Throwable t)	     {	        throw new Error(t.getMessage());	     }		     available = (bufsize += 2048);	     tokenBegin = 0;	  }	
protected void FillBuff() throws java.io.IOException	  {	     int i;	     if (maxNextCharInd == 4096)	        maxNextCharInd = nextCharInd = 0;		     try {	        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,	                                            4096 - maxNextCharInd)) == -1)	        {	           inputStream.close();	           throw new java.io.IOException();	        }	        else	           maxNextCharInd += i;	        return;	     }	     catch(java.io.IOException e) {	        if (bufpos != 0)	        {	           --bufpos;	           backup(0);	        }	        else	        {	           bufline[bufpos] = line;	           bufcolumn[bufpos] = column;	        }	        throw e;	     }	  }	
protected char ReadByte() throws java.io.IOException	  {	     if (++nextCharInd >= maxNextCharInd)	        FillBuff();		     return nextCharBuf[nextCharInd];	  }	
public char BeginToken() throws java.io.IOException	  {     	     if (inBuf > 0)	     {	        --inBuf;		        if (++bufpos == bufsize)	           bufpos = 0;		        tokenBegin = bufpos;	        return buffer[bufpos];	     }		     tokenBegin = 0;	     bufpos = -1;		     return readChar();	  }	
protected void AdjustBuffSize()	  {	     if (available == bufsize)	     {	        if (tokenBegin > 2048)	        {	           bufpos = 0;	           available = tokenBegin;	        }	        else	           ExpandBuff(false);	     }	     else if (available > tokenBegin)	        available = bufsize;	     else if ((tokenBegin - available) < 2048)	        ExpandBuff(true);	     else	        available = tokenBegin;	  }	
protected void UpdateLineColumn(char c)	  {	     column++;		     if (prevCharIsLF)	     {	        prevCharIsLF = false;	        line += (column = 1);	     }	     else if (prevCharIsCR)	     {	        prevCharIsCR = false;	        if (c == '\n')	        {	           prevCharIsLF = true;	        }	        else	           line += (column = 1);	     }		     switch (c)	     {	        case '\r' :	           prevCharIsCR = true;	           break;	        case '\n' :	           prevCharIsLF = true;	           break;	        case '\t' :	           column--;	           column += (8 - (column & 07));	           break;	        default :	           break;	     }		     bufline[bufpos] = line;	     bufcolumn[bufpos] = column;	  }	
public char readChar() throws java.io.IOException	  {	     if (inBuf > 0)	     {	        --inBuf;		        if (++bufpos == bufsize)	           bufpos = 0;		        return buffer[bufpos];	     }		     char c;		     if (++bufpos == available)	        AdjustBuffSize();		     if ((buffer[bufpos] = c = ReadByte()) == '\\')	     {	        UpdateLineColumn(c);		        int backSlashCnt = 1;		        for (;;) // Read all the backslashes	        {	           if (++bufpos == available)	              AdjustBuffSize();		           try	           {	              if ((buffer[bufpos] = c = ReadByte()) != '\\')	              {	                 UpdateLineColumn(c);	                 // found a non-backslash char.	                 if ((c == 'u') && ((backSlashCnt & 1) == 1))	                 {	                    if (--bufpos < 0)	                       bufpos = bufsize - 1;		                    break;	                 }		                 backup(backSlashCnt);	                 return '\\';	              }	           }	           catch(java.io.IOException e)	           {	              if (backSlashCnt > 1)	                 backup(backSlashCnt);		              return '\\';	           }		           UpdateLineColumn(c);	           backSlashCnt++;	        }		        // Here, we have seen an odd number of backslash's followed by a 'u'	        try	        {	           while ((c = ReadByte()) == 'u')	              ++column;		           buffer[bufpos] = c = (char)(hexval(c) << 12 |	                                       hexval(ReadByte()) << 8 |	                                       hexval(ReadByte()) << 4 |	                                       hexval(ReadByte()));		           column += 4;	        }	        catch(java.io.IOException e)	        {	           throw new Error("Invalid escape character at line " + line +	                                         " column " + column + ".");	        }		        if (backSlashCnt == 1)	           return c;	        else	        {	           backup(backSlashCnt - 1);	           return '\\';	        }	     }	     else	     {	        UpdateLineColumn(c);	        return (c);	     }	  }	
/**	   * @deprecated 	   * @see #getEndColumn	   */		  public int getColumn() {	     return bufcolumn[bufpos];	  }	
/**	   * @deprecated 	   * @see #getEndLine	   */		  public int getLine() {	     return bufline[bufpos];	  }	
public int getEndColumn() {	     return bufcolumn[bufpos];	  }	
public int getEndLine() {	     return bufline[bufpos];	  }	
public int getBeginColumn() {	     return bufcolumn[tokenBegin];	  }	
public int getBeginLine() {	     return bufline[tokenBegin];	  }	
public void backup(int amount) {		    inBuf += amount;	    if ((bufpos -= amount) < 0)	       bufpos += bufsize;	  }	
public JavaCharStream(java.io.Reader dstream,	                 int startline, int startcolumn, int buffersize)	  {	    inputStream = dstream;	    line = startline;	    column = startcolumn - 1;		    available = bufsize = buffersize;	    buffer = new char[buffersize];	    bufline = new int[buffersize];	    bufcolumn = new int[buffersize];	    nextCharBuf = new char[4096];	  }	
public JavaCharStream(java.io.Reader dstream,	                                        int startline, int startcolumn)	  {	     this(dstream, startline, startcolumn, 4096);	  }	
public JavaCharStream(java.io.Reader dstream)	  {	     this(dstream, 1, 1, 4096);	  }	
public void ReInit(java.io.Reader dstream,	                 int startline, int startcolumn, int buffersize)	  {	    inputStream = dstream;	    line = startline;	    column = startcolumn - 1;		    if (buffer == null || buffersize != buffer.length)	    {	      available = bufsize = buffersize;	      buffer = new char[buffersize];	      bufline = new int[buffersize];	      bufcolumn = new int[buffersize];	      nextCharBuf = new char[4096];	    }	    prevCharIsLF = prevCharIsCR = false;	    tokenBegin = inBuf = maxNextCharInd = 0;	    nextCharInd = bufpos = -1;	  }	
public void ReInit(java.io.Reader dstream,	                                        int startline, int startcolumn)	  {	     ReInit(dstream, startline, startcolumn, 4096);	  }	
public void ReInit(java.io.Reader dstream)	  {	     ReInit(dstream, 1, 1, 4096);	  }	
public JavaCharStream(java.io.InputStream dstream, int startline,	  int startcolumn, int buffersize)	  {	     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);	  }	
public JavaCharStream(java.io.InputStream dstream, int startline,	                                                           int startcolumn)	  {	     this(dstream, startline, startcolumn, 4096);	  }	
public JavaCharStream(java.io.InputStream dstream)	  {	     this(dstream, 1, 1, 4096);	  }	
public void ReInit(java.io.InputStream dstream, int startline,	  int startcolumn, int buffersize)	  {	     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);	  }	
public void ReInit(java.io.InputStream dstream, int startline,	                                                           int startcolumn)	  {	     ReInit(dstream, startline, startcolumn, 4096);	  }	
public void ReInit(java.io.InputStream dstream)	  {	     ReInit(dstream, 1, 1, 4096);	  }	
public String GetImage()	  {	     if (bufpos >= tokenBegin)	        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);	     else	        return new String(buffer, tokenBegin, bufsize - tokenBegin) +	                              new String(buffer, 0, bufpos + 1);	  }	
public char[] GetSuffix(int len)	  {	     char[] ret = new char[len];		     if ((bufpos + 1) >= len)	        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);	     else	     {	        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,	                                                          len - bufpos - 1);	        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);	     }		     return ret;	  }	
public void Done()	  {	     nextCharBuf = null;	     buffer = null;	     bufline = null;	     bufcolumn = null;	  }	
/**	   * Method to adjust line and column numbers for the start of a token.<BR>	   */	  public void adjustBeginLineColumn(int newLine, int newCol)	  {	     int start = tokenBegin;	     int len;		     if (bufpos >= tokenBegin)	     {	        len = bufpos - tokenBegin + inBuf + 1;	     }	     else	     {	        len = bufsize - tokenBegin + bufpos + 1 + inBuf;	     }		     int i = 0, j = 0, k = 0;	     int nextColDiff = 0, columnDiff = 0;		     while (i < len &&	            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])	     {	        bufline[j] = newLine;	        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];	        bufcolumn[j] = newCol + columnDiff;	        columnDiff = nextColDiff;	        i++;	     } 		     if (i < len)	     {	        bufline[j] = newLine++;	        bufcolumn[j] = newCol + columnDiff;		        while (i++ < len)	        {	           if (bufline[j = start % bufsize] != bufline[++start % bufsize])	              bufline[j] = newLine++;	           else	              bufline[j] = newLine;	        }	     }		     line = bufline[j];	     column = bufcolumn[j];	  }	
/**		 * Creates a checkbox list with the given list of objects. The elements		 * of this array can either be Entry instances, or other objects (if the		 * latter, they will default to being unchecked).		 */		public JCheckBoxList(Object[] items)		{			setModel(items);		}	
/**		 * Creates a checkbox list with the given list of objects. The elements		 * of this vector can either be Entry instances, or other objects (if the		 * latter, they will default to being unchecked).		 */		public JCheckBoxList(Vector items)		{			setModel(items);		}	
/**		 * Sets the model to the given list of objects. The elements of this		 * array can either be Entry instances, or other objects (if the		 * latter, they will default to being unchecked).		 */		public void setModel(Object[] items)		{			setModel(new CheckBoxListModel(items));			init();		}	
/**		 * Sets the model to the given list of objects. The elements of this		 * vector can either be Entry instances, or other objects (if the		 * latter, they will default to being unchecked).		 */		public void setModel(Vector items)		{			setModel(new CheckBoxListModel(items));			init();		}	
public Object[] getCheckedValues()		{			List<Object> values = new ArrayList<Object>();			CheckBoxListModel model = (CheckBoxListModel)getModel();			for(int i = 0; i < model.items.size(); i++)			{				Entry entry = model.items.get(i);				if(entry.checked && !entry.caption)				{					values.add(entry.value);				}			}				Object[] retVal = new Object[values.size()];			return values.toArray(retVal);		}	
@Override		public void selectAll()		{			CheckBoxListModel model = (CheckBoxListModel)getModel();			for(int i = 0; i < model.items.size(); i++)			{				Entry entry = model.items.elementAt(i);				if(!entry.caption)					entry.checked = true;			}				model.fireTableRowsUpdated(0,model.getRowCount());		}	
public Entry[] getValues()		{			CheckBoxListModel model = (CheckBoxListModel)getModel();			Entry[] retVal = new Entry[model.items.size()];			model.items.copyInto(retVal);			return retVal;		}	
public Object getSelectedValue()		{			int row = getSelectedRow();			if(row == -1)			{				return null;			}			else			{				return getModel().getValueAt(row,1);			}		}	
@Override		public TableCellRenderer getCellRenderer(int row, int column)		{			if(column == 0)			{				Entry entry = ((CheckBoxListModel)getModel()).items.get(row);				if(entry.caption)					return dummy;			}				return super.getCellRenderer(row,column);		}	
private void init()		{			dummy = new DummyRenderer();			getSelectionModel().setSelectionMode(ListSelectionModel				.SINGLE_SELECTION);			setShowGrid(false);			setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);			TableColumn column = getColumnModel().getColumn(0);			int checkBoxWidth = new JCheckBox().getPreferredSize().width;			column.setPreferredWidth(checkBoxWidth);			column.setMinWidth(checkBoxWidth);			column.setWidth(checkBoxWidth);			column.setMaxWidth(checkBoxWidth);			column.setResizable(false);				column = getColumnModel().getColumn(1);			column.setCellRenderer(new LabelRenderer());		}	
public Entry(Object value)			{				this.caption = true;				this.value = value;			}	
public Entry(boolean checked, Object value)			{				this.checked = checked;				this.value = value;			}	
public boolean isChecked()			{				return checked;			}	
public Object getValue()			{				return value;			}	
@Override			public Component getTableCellRendererComponent(JTable table, Object value,				boolean isSelected, boolean hasFocus, int row, int column)			{				return super.getTableCellRendererComponent(table,null /* value */,					isSelected,false /* hasFocus */,row,column);			}	
LabelRenderer()			{				plainFont = UIManager.getFont("Tree.font");				boldFont = plainFont.deriveFont(Font.BOLD);			}	
@Override			public Component getTableCellRendererComponent(JTable table, Object value,				boolean isSelected, boolean hasFocus, int row, int column)			{				super.getTableCellRendererComponent(table,value,isSelected,					hasFocus,row,column);					Entry entry = ((CheckBoxListModel)getModel()).items.get(row);				if(entry.caption)					setFont(boldFont);				else					setFont(plainFont);				return this;			}	
CheckBoxListModel(Vector _items)		{			items = new Vector<JCheckBoxList.Entry>(_items.size());			for(int i = 0; i < _items.size(); i++)			{				items.add(createEntry(_items.elementAt(i)));			}		}	
CheckBoxListModel(Object[] _items)		{			items = new Vector<JCheckBoxList.Entry>(_items.length);			for(int i = 0; i < _items.length; i++)			{				items.add(createEntry(_items[i]));			}		}	
private static JCheckBoxList.Entry createEntry(Object obj)		{			if(obj instanceof JCheckBoxList.Entry)				return (JCheckBoxList.Entry)obj;			else				return new JCheckBoxList.Entry(false,obj);		}	
public int getRowCount()		{			return items.size();		}	
public int getColumnCount()		{			return 2;		}	
@Override		public String getColumnName(int col)		{			return null;		}	
public Object getValueAt(int row, int col)		{			JCheckBoxList.Entry entry = items.get(row);			switch(col)			{			case 0:				return Boolean.valueOf(entry.checked);			case 1:				return entry.value;			default:				throw new InternalError();			}		}	
@Override		public Class getColumnClass(int col)		{			switch(col)			{			case 0:				return Boolean.class;			case 1:				return String.class;			default:				throw new InternalError();			}		}	
@Override		public boolean isCellEditable(int row, int col)		{			JCheckBoxList.Entry entry = items.get(row);			return col == 0 && !entry.caption;		}	
@Override		public void setValueAt(Object value, int row, int col)		{			if(col == 0)			{				JCheckBoxList.Entry entry = items.get(row);				if(!entry.caption)				{					entry.checked = value.equals(Boolean.TRUE);					fireTableRowsUpdated(row,row);				}			}		}	
/**		 * Returns the jEdit version as a human-readable string.		 */		public static String getVersion()		{			return MiscUtilities.buildToVersion(getBuild());		}	
/**		 * Returns the internal version. MiscUtilities.compareStrings() can be used		 * to compare different internal versions.		 */		public static String getBuild()		{			// (major).(minor).(<99 = preX, 99 = "final").(bug fix)			return "04.03.99.00";		}	
/**		 * The main method of the jEdit application.		 * This should never be invoked directly.		 * @param args The command line arguments		 */		public static void main(String[] args)		{			//{{{ Check for Java 1.5 or later			String javaVersion = System.getProperty("java.version");			if(javaVersion.compareTo("1.5") < 0)			{				System.err.println("You are running Java version "					+ javaVersion + '.');				System.err.println("jEdit requires Java 1.5 or later.");				System.exit(1);			} //}}}				startupDone.add(false);				// later on we need to know if certain code is called from			// the main thread			mainThread = Thread.currentThread();				settingsDirectory = ".jedit";			// On mac, different rules (should) apply			if(OperatingSystem.isMacOS())				settingsDirectory = "Library/jEdit";				// MacOS users expect the app to keep running after all windows			// are closed			background = OperatingSystem.isMacOS();				//{{{ Parse command line			boolean endOpts = false;			int level = Log.WARNING;			String portFile = "server";			boolean restore = true;			boolean newView = true;			boolean newPlainView = false;			boolean gui = true; // open initial view?			boolean loadPlugins = true;			boolean runStartupScripts = true;			boolean quit = false;			boolean wait = false;			boolean shouldRelocateSettings = true;			String userDir = System.getProperty("user.dir");				// script to run			String scriptFile = null;				for(int i = 0; i < args.length; i++)			{				String arg = args[i];				if(arg == null)					continue;				else if(arg.length() == 0)					args[i] = null;				else if(arg.startsWith("-") && !endOpts)				{					if(arg.equals("--"))						endOpts = true;					else if(arg.equals("-usage"))					{						version();						System.err.println();						usage();						System.exit(1);					}					else if(arg.equals("-version"))					{						version();						System.exit(1);					}					else if(arg.startsWith("-log="))					{						try						{							level = Integer.parseInt(arg.substring("-log=".length()));						}						catch(NumberFormatException nf)						{							System.err.println("Malformed option: " + arg);						}					}					else if(arg.equals("-nosettings"))						settingsDirectory = null;					else if(arg.startsWith("-settings="))					{						settingsDirectory = arg.substring(10);						shouldRelocateSettings = false;					}					else if(arg.startsWith("-noserver"))						portFile = null;					else if(arg.equals("-server"))						portFile = "server";					else if(arg.startsWith("-server="))						portFile = arg.substring(8);					else if(arg.startsWith("-background"))						background = true;					else if(arg.startsWith("-nobackground"))						background = false;					else if(arg.equals("-gui"))						gui = true;					else if(arg.equals("-nogui"))						gui = false;					else if(arg.equals("-newview"))						newView = true;					else if(arg.equals("-newplainview"))						newPlainView = true;					else if(arg.equals("-reuseview"))						newPlainView = newView = false;					else if(arg.equals("-restore"))						restore = true;					else if(arg.equals("-norestore"))						restore = false;					else if(arg.equals("-plugins"))						loadPlugins = true;					else if(arg.equals("-noplugins"))						loadPlugins = false;					else if(arg.equals("-startupscripts"))						runStartupScripts = true;					else if(arg.equals("-nostartupscripts"))						runStartupScripts = false;					else if(arg.startsWith("-run="))						scriptFile = arg.substring(5);					else if(arg.equals("-wait"))						wait = true;					else if(arg.equals("-quit"))						quit = true;					else					{						System.err.println("Unknown option: "							+ arg);						usage();						System.exit(1);					}					args[i] = null;				}			} //}}}				//{{{ We need these initializations very early on			if(settingsDirectory != null)			{				settingsDirectory = MiscUtilities.constructPath(					System.getProperty("user.home"),					settingsDirectory);				settingsDirectory = MiscUtilities.resolveSymlinks(					settingsDirectory);			}				if(settingsDirectory != null && portFile != null)				portFile = MiscUtilities.constructPath(settingsDirectory,portFile);			else				portFile = null;				Log.init(true,level);			//}}}				//{{{ Try connecting to another running jEdit instance			if(portFile != null && new File(portFile).exists())			{				try				{					BufferedReader in = new BufferedReader(new FileReader(portFile));					String check = in.readLine();					if(!check.equals("b"))						throw new Exception("Wrong port file format");						int port = Integer.parseInt(in.readLine());					int key = Integer.parseInt(in.readLine());						Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),port);					DataOutputStream out = new DataOutputStream(						socket.getOutputStream());					out.writeInt(key);						String script;					if(quit)					{						script = "socket.close();\n"							+ "jEdit.exit(null,true);\n";					}					else					{						script = makeServerScript(wait,restore,							newView,newPlainView,args,							scriptFile);					}						out.writeUTF(script);						Log.log(Log.DEBUG,jEdit.class,"Waiting for server");					// block until its closed					try					{						socket.getInputStream().read();					}					catch(Exception e)					{					}						in.close();					out.close();						System.exit(0);				}				catch(Exception e)				{					// ok, this one seems to confuse newbies					// endlessly, so log it as NOTICE, not					// ERROR					Log.log(Log.NOTICE,jEdit.class,"An error occurred"						+ " while connecting to the jEdit server instance.");					Log.log(Log.NOTICE,jEdit.class,"This probably means that"						+ " jEdit crashed and/or exited abnormally");					Log.log(Log.NOTICE,jEdit.class,"the last time it was run.");					Log.log(Log.NOTICE,jEdit.class,"If you don't"						+ " know what this means, don't worry.");					Log.log(Log.NOTICE,jEdit.class,e);				}			}				if(quit)			{				// if no server running and user runs jedit -quit,				// just exit				System.exit(0);			} //}}}				// don't show splash screen if there is a file named			// 'nosplash' in the settings directory			if(!new File(settingsDirectory,"nosplash").exists())				GUIUtilities.showSplashScreen();				//{{{ Mac settings migration code. Should eventually be removed			if(OperatingSystem.isMacOS() && shouldRelocateSettings && settingsDirectory != null)			{				relocateSettings();			}			// }}}				//{{{ Initialize settings directory			Writer stream;			if(settingsDirectory != null)			{				File _settingsDirectory = new File(settingsDirectory);				if(!_settingsDirectory.exists())					_settingsDirectory.mkdirs();				File _macrosDirectory = new File(settingsDirectory,"macros");				if(!_macrosDirectory.exists())					_macrosDirectory.mkdir();					String logPath = MiscUtilities.constructPath(					settingsDirectory,"activity.log");					backupSettingsFile(new File(logPath));					try				{					stream = new BufferedWriter(new FileWriter(logPath));						// Write a warning message:					String lineSep = System.getProperty("line.separator");					stream.write("Log file created on " + new Date());					stream.write(lineSep);					stream.write("IMPORTANT:");					stream.write(lineSep);					stream.write("Because updating this file after "						+ "every log message would kill");					stream.write(lineSep);					stream.write("performance, it will be *incomplete* "						+ "unless you invoke the");					stream.write(lineSep);					stream.write("Utilities->Troubleshooting->Update "						+ "Activity Log on Disk command!");					stream.write(lineSep);				}				catch(Exception e)				{					e.printStackTrace();					stream = null;				}			}			else			{				stream = null;			} //}}}				Log.setLogWriter(stream);				Log.log(Log.NOTICE,jEdit.class,"jEdit version " + getVersion());			Log.log(Log.MESSAGE,jEdit.class,"Settings directory is "				+ settingsDirectory);				//{{{ Get things rolling			GUIUtilities.advanceSplashProgress("init");			initMisc();			GUIUtilities.advanceSplashProgress("init system properties");			initSystemProperties();				GUIUtilities.advanceSplashProgress("init beanshell");			BeanShell.init();				GUIUtilities.advanceSplashProgress("loading site properties");			if(jEditHome != null)				initSiteProperties();				GUIUtilities.advanceSplashProgress("loading user properties");			initUserProperties();				GUIUtilities.advanceSplashProgress("init GUI");			GUIUtilities.init();				globalBufferSet = new BufferSet();			bufferSetManager = new BufferSetManager();				///Options.SIMPLIFIED_KEY_HANDLING = jEdit.getBooleanProperty("newkeyhandling");			//}}}				//{{{ Initialize server			if(portFile != null)			{				GUIUtilities.advanceSplashProgress("init server");				server = new EditServer(portFile);				if(!server.isOK())					server = null;			}			else			{				GUIUtilities.advanceSplashProgress();				if(background)				{					background = false;					Log.log(Log.WARNING,jEdit.class,"You cannot specify both the"						+ " -background and -noserver switches");				}			} //}}}				//{{{ Do more stuff			GUIUtilities.advanceSplashProgress("init look and feel");			initPLAF();			GUIUtilities.advanceSplashProgress("init VFS Manager");			VFSManager.init();			GUIUtilities.advanceSplashProgress("init resources");			initResources();			SearchAndReplace.load();						if(loadPlugins)			{				GUIUtilities.advanceSplashProgress("init plugins");				initPlugins();			}			else				GUIUtilities.advanceSplashProgress();				Registers.setSaver(new JEditRegisterSaver());			Registers.setListener(new JEditRegistersListener());			GUIUtilities.advanceSplashProgress("init history model");			HistoryModel.setSaver(new JEditHistoryModelSaver());			HistoryModel.loadHistory();			GUIUtilities.advanceSplashProgress("init buffer history");			BufferHistory.load();			GUIUtilities.advanceSplashProgress("init killring");			KillRing.setInstance(new JEditKillRing());			KillRing.getInstance().load();			GUIUtilities.advanceSplashProgress("init various properties");			propertiesChanged();				GUIUtilities.advanceSplashProgress("init modes");				// Buffer sort			sortBuffers = getBooleanProperty("sortBuffers");			sortByName = getBooleanProperty("sortByName");				reloadModes();				GUIUtilities.advanceSplashProgress("activate plugins");			//}}}				//{{{ Activate plugins that must be activated at startup			for(int i = 0; i < jars.size(); i++)			{				jars.elementAt(i).activatePluginIfNecessary();			} //}}}				//{{{ Load macros and run startup scripts, after plugins and settings are loaded			GUIUtilities.advanceSplashProgress("init macros");			Macros.loadMacros();			Macros.getMacroActionSet().initKeyBindings();				if(runStartupScripts && jEditHome != null)			{				String path = MiscUtilities.constructPath(jEditHome,"startup");				File file = new File(path);				if(file.exists())				{					runStartupScripts(file);				}				else					GUIUtilities.advanceSplashProgress();			}			else				GUIUtilities.advanceSplashProgress("run startup scripts");				if(runStartupScripts && settingsDirectory != null)			{				String path = MiscUtilities.constructPath(settingsDirectory,"startup");				File file = new File(path);				if (file.exists())				{					GUIUtilities.advanceSplashProgress("run startup scripts");					runStartupScripts(file);				}				else				{					GUIUtilities.advanceSplashProgress();					file.mkdirs();				}			}			else			{				GUIUtilities.advanceSplashProgress();			} //}}}				//{{{ Run script specified with -run= parameter			if(scriptFile != null)			{				GUIUtilities.advanceSplashProgress("run script file");				scriptFile = MiscUtilities.constructPath(userDir,scriptFile);				try				{					BeanShell.getNameSpace().setVariable("args",args);				}				catch(UtilEvalError e)				{					Log.log(Log.ERROR,jEdit.class,e);				}				BeanShell.runScript(null,scriptFile,null,false);			}			else			{				GUIUtilities.advanceSplashProgress();			}			//}}}				GUIUtilities.advanceSplashProgress();				// Create dynamic actions for switching to saved layouts.			// The list of saved layouts is retrieved from the docking framework,			// which can be provided by a plugin, so this must be called only after			// the plugins are loaded.			DockingLayoutManager.init();				// Open files, create the view and hide the splash screen.			SyntaxUtilities.propertyManager = jEdit.propertyManager;			finishStartup(gui,restore,newPlainView,userDir,args);		}	
/**		 * Returns the properties object which contains all known		 * jEdit properties. Note that as of jEdit 4.2pre10, this returns a		 * new collection, not the existing properties instance.		 * @since jEdit 3.1pre4		 */		public static Properties getProperties()		{			return propMgr.getProperties();		}	
/**		 * Fetches a property, returning null if it's not defined.		 * @param name The property		 */		public static String getProperty(String name)		{			return propMgr.getProperty(name);		}	
/**		 * Fetches a property, returning the default value if it's not		 * defined.		 * @param name The property		 * @param def The default value		 */		public static String getProperty(String name, String def)		{			String value = propMgr.getProperty(name);			if(value == null)				return def;			else				return value;		}	
/**		 * Returns the property with the specified name.<p>		 *		 * The elements of the <code>args</code> array are substituted		 * into the value of the property in place of strings of the		 * form <code>{<i>n</i>}</code>, where <code><i>n</i></code> is an index		 * in the array.<p>		 *		 * You can find out more about this feature by reading the		 * documentation for the <code>format</code> method of the		 * <code>java.text.MessageFormat</code> class.		 *		 * @param name The property		 * @param args The positional parameters		 */		public static String getProperty(String name, Object[] args)		{			if(name == null)				return null;			if(args == null)				return getProperty(name);			else			{				String value = getProperty(name);				if(value == null)					return null;				else					return MessageFormat.format(value,args);			}		}	
/**		 * Returns the value of a boolean property.		 * @param name The property		 */		public static boolean getBooleanProperty(String name)		{			return getBooleanProperty(name,false);		}	
/**		 * Returns the value of a boolean property.		 * @param name The property		 * @param def The default value		 */		public static boolean getBooleanProperty(String name, boolean def)		{			String value = getProperty(name);			return StandardUtilities.getBoolean(value, def);		}	
/**		 * Returns the value of an integer property.		 * @param name The property		 */		public static int getIntegerProperty(String name)		{			return getIntegerProperty(name,0);		}	
/**		 * Returns the value of an integer property.		 * @param name The property		 * @param def The default value		 * @since jEdit 4.0pre1		 */		public static int getIntegerProperty(String name, int def)		{			String value = getProperty(name);			if(value == null)				return def;			else			{				try				{					return Integer.parseInt(value.trim());				}				catch(NumberFormatException nf)				{					return def;				}			}		}	
public static double getDoubleProperty(String name, double def)		{			String value = getProperty(name);			if(value == null)				return def;			else			{				try				{					return Double.parseDouble(value.trim());				}				catch(NumberFormatException nf)				{					return def;				}			}		}	
/**		 * Returns the value of a font property. The family is stored		 * in the <code><i>name</i></code> property, the font size is stored		 * in the <code><i>name</i>size</code> property, and the font style is		 * stored in <code><i>name</i>style</code>. For example, if		 * <code><i>name</i></code> is <code>view.gutter.font</code>, the		 * properties will be named <code>view.gutter.font</code>,		 * <code>view.gutter.fontsize</code>, and		 * <code>view.gutter.fontstyle</code>.		 *		 * @param name The property		 * @since jEdit 4.0pre1		 */		public static Font getFontProperty(String name)		{			return getFontProperty(name,null);		}	
/**		 * Returns the value of a font property. The family is stored		 * in the <code><i>name</i></code> property, the font size is stored		 * in the <code><i>name</i>size</code> property, and the font style is		 * stored in <code><i>name</i>style</code>. For example, if		 * <code><i>name</i></code> is <code>view.gutter.font</code>, the		 * properties will be named <code>view.gutter.font</code>,		 * <code>view.gutter.fontsize</code>, and		 * <code>view.gutter.fontstyle</code>.		 *		 * @param name The property		 * @param def The default value		 * @since jEdit 4.0pre1		 */		public static Font getFontProperty(String name, Font def)		{			String family = getProperty(name);			String sizeString = getProperty(name + "size");			String styleString = getProperty(name + "style");				if(family == null || sizeString == null || styleString == null)				return def;			else			{				int size, style;					try				{					size = Integer.parseInt(sizeString);				}				catch(NumberFormatException nf)				{					return def;				}					try				{					style = Integer.parseInt(styleString);				}				catch(NumberFormatException nf)				{					return def;				}					return new Font(family,style,size);			}		}	
/**		 * Returns the value of a color property.		 * @param name The property name		 * @since jEdit 4.0pre1		 */		public static Color getColorProperty(String name)		{			return getColorProperty(name,Color.black);		}	
/**		 * Returns the value of a color property.		 * @param name The property name		 * @param def The default value		 * @since jEdit 4.0pre1		 */		public static Color getColorProperty(String name, Color def)		{			String value = getProperty(name);			if(value == null)				return def;			else				return SyntaxUtilities.parseColor(value, def);		}	
/**		 * Sets the value of a color property.		 * @param name The property name		 * @param value The value		 * @since jEdit 4.0pre1		 */		public static void setColorProperty(String name, Color value)		{			setProperty(name, SyntaxUtilities.getColorHexString(value));		}	
/**		 * Sets a property to a new value.		 * @param name The property		 * @param value The new value		 */		public static void setProperty(String name, String value)		{			propMgr.setProperty(name,value);		}	
/**		 * Sets a property to a new value. Properties set using this		 * method are not saved to the user properties list.		 * @param name The property		 * @param value The new value		 * @since jEdit 2.3final		 */		public static void setTemporaryProperty(String name, String value)		{			propMgr.setTemporaryProperty(name,value);		}	
/**		 * Sets a boolean property.		 * @param name The property		 * @param value The value		 */		public static void setBooleanProperty(String name, boolean value)		{			setProperty(name,value ? "true" : "false");		}	
/**		 * Sets the value of an integer property.		 * @param name The property		 * @param value The value		 * @since jEdit 4.0pre1		 */		public static void setIntegerProperty(String name, int value)		{			setProperty(name,String.valueOf(value));		}	
public static void setDoubleProperty(String name, double value)		{			setProperty(name,String.valueOf(value));		}	
/**		 * Sets the value of a font property. The family is stored		 * in the <code><i>name</i></code> property, the font size is stored		 * in the <code><i>name</i>size</code> property, and the font style is		 * stored in <code><i>name</i>style</code>. For example, if		 * <code><i>name</i></code> is <code>view.gutter.font</code>, the		 * properties will be named <code>view.gutter.font</code>,		 * <code>view.gutter.fontsize</code>, and		 * <code>view.gutter.fontstyle</code>.		 *		 * @param name The property		 * @param value The value		 * @since jEdit 4.0pre1		 */		public static void setFontProperty(String name, Font value)		{			setProperty(name,value.getFamily());			setIntegerProperty(name + "size",value.getSize());			setIntegerProperty(name + "style",value.getStyle());		}	
/**		 * Unsets (clears) a property.		 * @param name The property		 */		public static void unsetProperty(String name)		{			propMgr.unsetProperty(name);		}	
/**		 * Resets a property to its default value.		 * @param name The property		 *		 * @since jEdit 2.5pre3		 */		public static void resetProperty(String name)		{			propMgr.resetProperty(name);		}	
/**		 * Reloads various settings from the properties.		 */		public static void propertiesChanged()		{			initKeyBindings();				Autosave.setInterval(getIntegerProperty("autosave",30));				saveCaret = getBooleanProperty("saveCaret");				UIDefaults defaults = UIManager.getDefaults();				// give all text areas the same font			Font font = getFontProperty("view.font");				//defaults.put("TextField.font",font);			defaults.put("TextArea.font",font);			defaults.put("TextPane.font",font);				// Enable/Disable tooltips			ToolTipManager.sharedInstance().setEnabled(				jEdit.getBooleanProperty("showTooltips"));				initProxy();				// we do this here instead of adding buffers to the bus.			Buffer buffer = buffersFirst;			while(buffer != null)			{				buffer.resetCachedProperties();				buffer.propertiesChanged();				buffer = buffer.next;			}				HistoryModel.setMax(getIntegerProperty("history",25));			KillRing.getInstance().propertiesChanged(getIntegerProperty("history",25));				EditBus.send(new PropertiesChanged(null));		}	
/**		 * Returns a list of plugin JARs pathnames that are not currently loaded		 * by examining the user and system plugin directories.		 * @since jEdit 3.2pre1		 */		public static String[] getNotLoadedPluginJARs()		{			List<String> returnValue = new ArrayList<String>();				if(jEditHome != null)			{				String systemPluginDir = MiscUtilities					.constructPath(jEditHome,"jars");					String[] list = new File(systemPluginDir).list();				if(list != null)					getNotLoadedPluginJARs(returnValue,systemPluginDir,list);			}				if(settingsDirectory != null)			{				String userPluginDir = MiscUtilities					.constructPath(settingsDirectory,"jars");				String[] list = new File(userPluginDir).list();				if(list != null)				{					getNotLoadedPluginJARs(returnValue,						userPluginDir,list);				}			}				String[] _returnValue = new String[returnValue.size()];			returnValue.toArray(_returnValue);			return _returnValue;		}	
/**		 * Returns the plugin with the specified class name.		 * Only works for plugins that were loaded.		 */		public static EditPlugin getPlugin(String name)		{			return getPlugin(name, false);		}	
/**		 * Returns the plugin with the specified class name.		 * If * <code>loadIfNecessary</code> is true, the plugin will be searched for,		 * loaded, and activated in case it has not yet been loaded.		 *		 * @param name the classname of the main Plugin class.		 * @param loadIfNecessary - loads plugin + dependencies if it is not loaded yet.		 * @since jEdit 4.2pre4		 */		public static EditPlugin getPlugin(String name, boolean loadIfNecessary)		{			EditPlugin[] plugins = getPlugins();			EditPlugin plugin = null;			for(int i = 0; i < plugins.length; i++)			{				if(plugins[i].getClassName().equals(name))					plugin = plugins[i];				if(loadIfNecessary)				{					if(plugin instanceof EditPlugin.Deferred)					{						plugin.getPluginJAR().activatePlugin();						plugin = plugin.getPluginJAR().getPlugin();						break;					}				}			}			if (!loadIfNecessary) return plugin;			String jarPath = PluginJAR.findPlugin(name);			PluginJAR pjar = PluginJAR.load(jarPath, true);			return pjar.getPlugin();		}	
/**		 * Returns an array of installed plugins.		 */		public static EditPlugin[] getPlugins()		{			List<EditPlugin> pluginList = new ArrayList<EditPlugin>();			for(int i = 0; i < jars.size(); i++)			{				EditPlugin plugin = jars.elementAt(i).getPlugin();				if(plugin != null)					pluginList.add(plugin);			}				EditPlugin[] array = new EditPlugin[pluginList.size()];			pluginList.toArray(array);			return array;		}	
/**		 * Returns an array of installed plugins.		 * @since jEdit 4.2pre1		 */		public static PluginJAR[] getPluginJARs()		{			PluginJAR[] array = new PluginJAR[jars.size()];			jars.copyInto(array);			return array;		}	
/**		 * Returns the JAR with the specified path name.		 * @param path The path name		 * @since jEdit 4.2pre1		 */		public static PluginJAR getPluginJAR(String path)		{			for(int i = 0; i < jars.size(); i++)			{				PluginJAR jar = jars.elementAt(i);				if(jar.getPath().equals(path))					return jar;			}				return null;		}	
/**		 * Loads the plugin JAR with the specified path. Some notes about this		 * method:		 *		 * <ul>		 * <li>Calling this at a time other than jEdit startup can have		 * unpredictable results if the plugin has not been updated for the		 * jEdit 4.2 plugin API.		 * <li>You must make sure yourself the plugin is not already loaded.		 * <li>After loading, you just make sure all the plugin's dependencies		 * are satisified before activating the plugin, using the		 * {@link PluginJAR#checkDependencies()} method.		 * </ul>		 *		 * @param path The JAR file path		 * @since jEdit 4.2pre1		 */		public static void addPluginJAR(String path)		{			PluginJAR jar = new PluginJAR(new File(path));			jars.addElement(jar);			jar.init();			jEdit.unsetProperty("plugin-blacklist."+MiscUtilities.getFileName(path));			EditBus.send(new PluginUpdate(jar,PluginUpdate.LOADED,false));			if(!isMainThread())			{				EditBus.send(new DynamicMenuChanged("plugins"));				initKeyBindings();			}		}	
/**		 * Loads all plugins in a directory.		 * @param directory The directory		 * @since jEdit 4.2pre1		 */		private static void addPluginJARsFromDirectory(String directory)		{			Log.log(Log.NOTICE,jEdit.class,"Loading plugins from "				+ directory);				File file = new File(directory);			if(!(file.exists() && file.isDirectory()))				return;			String[] plugins = file.list();			if(plugins == null)				return;				for(int i = 0; i < plugins.length; i++)			{				String plugin = plugins[i];				if(!plugin.toLowerCase().endsWith(".jar"))					continue;					String path = MiscUtilities.constructPath(directory,plugin);				if (jEdit.getBooleanProperty("plugin-blacklist."+plugin))					continue;				// remove this when 4.1 plugin API is deprecated				if(plugin.equals("EditBuddy.jar")					|| plugin.equals("PluginManager.jar")					|| plugin.equals("Firewall.jar")					|| plugin.equals("Tidy.jar")					|| plugin.equals("DragAndDrop.jar"))				{					pluginError(path,"plugin-error.obsolete",null);					continue;				}					addPluginJAR(path);			}		}	
/**		 * Unloads the given plugin JAR with the specified path. Note that		 * calling this at a time other than jEdit shutdown can have		 * unpredictable results if the plugin has not been updated for the		 * jEdit 4.2 plugin API.		 *		 * @param jar The <code>PluginJAR</code> instance		 * @param exit Set to true if jEdit is exiting; enables some		 * shortcuts so the editor can close faster.		 * @since jEdit 4.2pre1		 */		public static void removePluginJAR(PluginJAR jar, boolean exit)		{			if(exit)			{				jar.uninit(true);			}			else			{				jar.uninit(false);				jars.removeElement(jar);				initKeyBindings();			}				EditBus.send(new PluginUpdate(jar,PluginUpdate.UNLOADED,exit));			if(!isMainThread() && !exit)				EditBus.send(new DynamicMenuChanged("plugins"));		}	
/**		 * Returns the action context used to store editor actions.		 * @since jEdit 4.2pre1		 */		public static ActionContext getActionContext()		{			return actionContext;		}	
/**		 * Adds a new action set to jEdit's list of ActionSets (viewable from the shortcuts		 * option pane). By default, each plugin has one ActionSet,		 * but some plugins may create dynamic action sets, such as ProjectViewer and Console.		 * These plugins must call removeActionSet() when the plugin is unloaded.		 *		 * @since jEdit 4.0pre1		 * @see #removeActionSet(ActionSet)		 */		public static void addActionSet(ActionSet actionSet)		{			actionContext.addActionSet(actionSet);		}	
/**		 * Removes an action set from jEdit's list.		 * Plugins that add a dynamic action set must call this method at plugin		 * unload time.		 * @since jEdit 4.2pre1		 */		public static void removeActionSet(ActionSet actionSet)		{			actionContext.removeActionSet(actionSet);		}	
/**		 * Returns the set of commands built into jEdit.		 * @since jEdit 4.2pre1		 */		public static ActionSet getBuiltInActionSet()		{			return builtInActionSet;		}	
/**		 * Returns all registered action sets.		 *		 * @return the ActionSet(s)		 * @since jEdit 4.0pre1		 */		public static ActionSet[] getActionSets()		{			return actionContext.getActionSets();		}	
/**		 * Returns the specified action.		 * @param name The action name		 */		public static EditAction getAction(String name)		{			return actionContext.getAction(name);		}	
/**		 * Returns the action set that contains the specified action.		 *		 * @param action The action		 * @since jEdit 4.2pre1		 */		public static ActionSet getActionSetForAction(String action)		{			return actionContext.getActionSetForAction(action);		}	
/**		 * @deprecated Use the form that takes a String instead		 */		@Deprecated		public static ActionSet getActionSetForAction(EditAction action)		{			return actionContext.getActionSetForAction(action.getName());		}	
/**		 * @deprecated Call getActionNames() instead		 */		@Deprecated		public static EditAction[] getActions()		{			String[] names = actionContext.getActionNames();			EditAction[] actions = new EditAction[names.length];			for(int i = 0; i < actions.length; i++)			{				actions[i] = actionContext.getAction(names[i]);				if(actions[i] == null)					Log.log(Log.ERROR,jEdit.class,"wtf: " + names[i]);			}			return actions;		}	
/**		 * Returns all registered action names.		 */		public static String[] getActionNames()		{			return actionContext.getActionNames();		}	
/**		 * Reloads all edit modes.		 * @since jEdit 3.2pre2		 */		public static void reloadModes()		{			/* Try to guess the eventual size to avoid unnecessary			 * copying */			ModeProvider.instance.removeAll();				//{{{ Load the global catalog			if(jEditHome == null)				loadModeCatalog("/modes/catalog",true);			else			{				loadModeCatalog(MiscUtilities.constructPath(jEditHome,					"modes","catalog"),false);			} //}}}				//{{{ Load user catalog			if(settingsDirectory != null)			{				File userModeDir = new File(MiscUtilities.constructPath(					settingsDirectory,"modes"));				if(!userModeDir.exists())					userModeDir.mkdirs();					File userCatalog = new File(MiscUtilities.constructPath(					settingsDirectory,"modes","catalog"));				if(!userCatalog.exists())				{					// create dummy catalog					FileWriter out = null;					try					{						out = new FileWriter(userCatalog);						out.write(jEdit.getProperty("defaultCatalog"));					}					catch(IOException io)					{						Log.log(Log.ERROR,jEdit.class,io);					}					finally					{						IOUtilities.closeQuietly(out);					}				}					loadModeCatalog(userCatalog.getPath(),false);			} //}}}				Buffer buffer = buffersFirst;			while(buffer != null)			{				// This reloads the token marker and sends a message				// which causes edit panes to repaint their text areas				buffer.setMode();					buffer = buffer.next;			}		}	
/**		 * Returns the edit mode with the specified name.		 * @param name The edit mode		 */		public static Mode getMode(String name)		{			return ModeProvider.instance.getMode(name);		}	
/**		 * Returns an array of installed edit modes.		 */		public static Mode[] getModes()		{			return ModeProvider.instance.getModes();		}	
/**		 * Opens the file names specified in the argument array. This		 * handles +line and +marker arguments just like the command		 * line parser.		 * @param parent The parent directory		 * @param args The file names to open		 * @since jEdit 3.2pre4		 */		public static Buffer openFiles(View view, String parent, String[] args)		{			Buffer retVal = null;			Buffer lastBuffer = null;				for(int i = 0; i < args.length; i++)			{				String arg = args[i];				if(arg == null)					continue;				else if(arg.startsWith("+line:") || arg.startsWith("+marker:"))				{					if(lastBuffer != null)						gotoMarker(view,lastBuffer,arg);					continue;				}					lastBuffer = openFile((View)null,parent,arg,false,null);					if(retVal == null && lastBuffer != null)					retVal = lastBuffer;			}				if(view != null && retVal != null)				view.setBuffer(retVal,true);				return retVal;		}	
/**		 * Opens a file. Note that as of jEdit 2.5pre1, this may return		 * null if the buffer could not be opened.		 * @param view The view to open the file in		 * @param path The file path		 *		 * @return the buffer, or null if jEdit was unable to load it		 *		 * @since jEdit 2.4pre1		 */		public static Buffer openFile(View view, String path)		{			return openFile(view,null,path,false,new Hashtable());		}	
/**		 * @deprecated The openFile() forms with the readOnly parameter		 * should not be used. The readOnly prameter is no longer supported.		 */		@Deprecated		public static Buffer openFile(View view, String parent,			String path, boolean readOnly, boolean newFile)		{			return openFile(view,parent,path,newFile,new Hashtable());		}	
/**		 * @deprecated The openFile() forms with the readOnly parameter		 * should not be used. The readOnly prameter is no longer supported.		 */		@Deprecated		public static Buffer openFile(View view, String parent,			String path, boolean readOnly, boolean newFile,			Hashtable props)		{			return openFile(view,parent,path,newFile,props);		}	
/**		 * Opens a file. This may return null if the buffer could not be		 * opened for some reason.		 * @param view The view to open the file in. If it is null, the file		 * will be opened and added to the bufferSet of the current edit pane,		 * but not selected		 * @param parent The parent directory of the file		 * @param path The path name of the file		 * @param newFile True if the file should not be loaded from disk		 * be prompted if it should be reloaded		 * @param props Buffer-local properties to set in the buffer		 *		 * @return the buffer, or null if jEdit was unable to load it		 *		 * @since jEdit 3.2pre10		 */		public static Buffer openFile(View view, String parent,			String path, boolean newFile, Hashtable props)		{			return openFile(view == null ? null : view.getEditPane(), parent, path, newFile, props);		}	
/**		 * Opens a file. Note that as of jEdit 2.5pre1, this may return		 * null if the buffer could not be opened.		 * @param editPane the EditPane to open the file in.		 * @param path The file path		 *		 * @return the buffer, or null if jEdit was unable to load it		 *		 * @since jEdit 4.3pre17		 */		public static Buffer openFile(EditPane editPane, String path)		{			return openFile(editPane,null,path,false,new Hashtable());		}	
/**		 * Opens a file. This may return null if the buffer could not be		 * opened for some reason.		 * @param editPane the EditPane to open the file in.		 * @param parent The parent directory of the file		 * @param path The path name of the file		 * @param newFile True if the file should not be loaded from disk		 * be prompted if it should be reloaded		 * @param props Buffer-local properties to set in the buffer		 *		 * @return the buffer, or null if jEdit was unable to load it		 *		 * @since jEdit 4.3pre17		 */		public static Buffer openFile(EditPane editPane, String parent,			String path, boolean newFile, Hashtable props)		{			PerspectiveManager.setPerspectiveDirty(true);				if(editPane != null && parent == null && editPane.getBuffer() != null)				parent = editPane.getBuffer().getDirectory();				try			{				URL u = new URL(path);				if (u.getProtocol().equals("file"))					path = URLDecoder.decode(u.getPath());			}			catch (MalformedURLException mue)			{				path = MiscUtilities.constructPath(parent,path);			}					if(props == null)				props = new Hashtable();			composeBufferPropsFromHistory(props, path);				Buffer newBuffer;				synchronized (editBusOrderingLock)			{				View view = editPane == null ? null : editPane.getView();				synchronized(bufferListLock)				{					Buffer buffer = getBuffer(path);					if(buffer != null)					{						if(editPane != null)							editPane.setBuffer(buffer,true);							return buffer;					}						newBuffer = new Buffer(path,newFile,false,props);						if(!newBuffer.load(view,false))						return null;					addBufferToList(newBuffer);					if (editPane != null)						bufferSetManager.addBuffer(editPane.getBufferSet(), newBuffer);					else						bufferSetManager.addBuffer(jEdit.getActiveView(), newBuffer);				}					EditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));			}				if(editPane != null)				editPane.setBuffer(newBuffer,true);				return newBuffer;		}	
/**		 * Opens a temporary buffer. A temporary buffer is like a normal		 * buffer, except that an event is not fired, the the buffer is		 * not added to the buffers list.		 *		 * @param view The view to open the file in		 * @param parent The parent directory of the file		 * @param path The path name of the file		 * @param newFile True if the file should not be loaded from disk		 *		 * @return the buffer, or null if jEdit was unable to load it		 *		 * @since jEdit 3.2pre10		 */		public static Buffer openTemporary(View view, String parent,			String path, boolean newFile)		{			return openTemporary(view, parent, path, newFile, null);		}	
/**		 * Opens a temporary buffer. A temporary buffer is like a normal		 * buffer, except that an event is not fired, the the buffer is		 * not added to the buffers list.		 *		 * @param view The view to open the file in		 * @param parent The parent directory of the file		 * @param path The path name of the file		 * @param newFile True if the file should not be loaded from disk		 * @param props Buffer-local properties to set in the buffer		 *		 * @return the buffer, or null if jEdit was unable to load it		 *		 * @since jEdit 4.3pre10		 */		public static Buffer openTemporary(View view, String parent,			String path, boolean newFile, Hashtable props)		{			if(view != null && parent == null)				parent = view.getBuffer().getDirectory();				if(MiscUtilities.isURL(path))			{				if(MiscUtilities.getProtocolOfURL(path).equals("file"))					path = path.substring(5);			}				path = MiscUtilities.constructPath(parent,path);				if(props == null)				props = new Hashtable();			composeBufferPropsFromHistory(props, path);				synchronized(bufferListLock)			{				Buffer buffer = getBuffer(path);				if(buffer != null)					return buffer;					buffer = new Buffer(path,newFile,true,props);				buffer.setBooleanProperty(Buffer.ENCODING_AUTODETECT, true);				if(!buffer.load(view,false))					return null;				else					return buffer;			}		}	
/**		 * Adds a temporary buffer to the buffer list. This must be done		 * before allowing the user to interact with the buffer in any		 * way.		 * @param buffer The buffer		 */		public static void commitTemporary(Buffer buffer)		{			if(!buffer.isTemporary())				return;				PerspectiveManager.setPerspectiveDirty(true);				addBufferToList(buffer);			buffer.commitTemporary();				// send full range of events to avoid breaking plugins			EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));			EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOAD_STARTED));			EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOADED));		}	
/**		 * Creates a new `untitled' file.		 *		 * @param view The view to create the file in		 *		 * @return the new buffer		 */		public static Buffer newFile(View view)		{			return newFile(view == null ? null : view.getEditPane());		}	
/**		 * Creates a new `untitled' file.		 * @param view The view to create the file in		 * @param dir The directory to create the file in		 *		 * @return the new buffer		 *		 * @since jEdit 3.1pre2		 */		public static Buffer newFile(View view, String dir)		{			EditPane editPane = null;			if (view != null)			{				editPane = view.getEditPane();			}			else			{				View v = getActiveView();				if (v != null)				{					editPane = v.getEditPane();				}			}			return newFile(editPane, dir);		}	
/**		 * Creates a new `untitled' file.		 *		 * @param editPane The editPane to create the file in		 *		 * @return the new buffer		 * @since jEdit 4.3pre17		 */		public static Buffer newFile(EditPane editPane)		{			String path;				if(editPane != null && editPane.getBuffer() != null)			{				path = editPane.getBuffer().getDirectory();				VFS vfs = VFSManager.getVFSForPath(path);				// don't want 'New File' to create a read only buffer				// if current file is on SQL VFS or something				if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)					path = System.getProperty("user.home");			}			else				path = null;				return newFile(editPane,path);		}	
/**		 * Creates a new `untitled' file.		 *		 * @param editPane The editPane to create the file in		 * @param dir The directory to create the file in		 *		 * @return the new buffer		 *		 * @since jEdit 4.3pre17		 */		public static Buffer newFile(EditPane editPane, String dir)		{			if (editPane != null)			{				BufferSet bufferSet = editPane.getBufferSet();				Buffer[] buffers = bufferSet.getAllBuffers();				for (Buffer buf:buffers)				{					if (buf.isUntitled() && !buf.isDirty())					{							if (!MiscUtilities.getParentOfPath(buf.getPath()).equals(dir))						{							// Find the highest Untitled-n file							int untitledCount = getNextUntitledBufferId();								Buffer newBuffer = openFile(editPane,dir,"Untitled-" + untitledCount,true,null);							jEdit.closeBuffer(editPane, buf);							return newBuffer;						}						/*  if  "never mark untitled buffers dirty"						 *  is selected, we might have contents in non-dirty						 *  untitled buffers. We must clear those contents						 *  if user requested new file.						 */						int l = buf.getLength();						if (l > 0)							buf.remove(0, l);						editPane.setBuffer(buf);						return buf;					}				}			}				// Find the highest Untitled-n file			int untitledCount = getNextUntitledBufferId();				return openFile(editPane,dir,"Untitled-" + untitledCount,true,null);		}	
/**		 * Closes a buffer. If there are unsaved changes, the user is		 * prompted if they should be saved first.		 * @param view The view		 * @param buffer The buffer		 * @return True if the buffer was really closed, false otherwise		 */		public static boolean closeBuffer(View view, Buffer buffer)		{			// Wait for pending I/O requests			if(buffer.isPerformingIO())			{				VFSManager.waitForRequests();				if(VFSManager.errorOccurred())					return false;			}				if(buffer.isDirty())			{				Object[] args = { buffer.getName() };				int result = GUIUtilities.confirm(view,"notsaved",args,					JOptionPane.YES_NO_CANCEL_OPTION,					JOptionPane.WARNING_MESSAGE);				if(result == JOptionPane.YES_OPTION)				{					if(!buffer.save(view,null,true))						return false;						VFSManager.waitForRequests();					if(buffer.getBooleanProperty(BufferIORequest						.ERROR_OCCURRED))					{						return false;					}				}				else if(result != JOptionPane.NO_OPTION)					return false;			}				_closeBuffer(view,buffer);				return true;		}	
/**		 * Close a buffer.		 * The buffer is first removed from the EditPane's bufferSet.		 * If the buffer is not in any bufferSet after that, it is closed		 * @param editPane the edit pane (it cannot be null)		 * @param buffer the buffer (it cannot be null)		 * @since jEdit 4.3pre15		 */		public static void closeBuffer(EditPane editPane, Buffer buffer)		{			int bufferSetsCount = bufferSetManager.countBufferSets(buffer);			if (bufferSetsCount < 2)			{				closeBuffer(editPane.getView(), buffer);			}			else			{				bufferSetManager.removeBuffer(editPane, buffer);			}		}	
/**		 * Closes the buffer, even if it has unsaved changes.		 * @param view The view, may be null		 * @param buffer The buffer		 *		 * @exception NullPointerException if the buffer is null		 *		 * @since jEdit 2.2pre1		 */		public static void _closeBuffer(View view, Buffer buffer)		{			if(buffer.isClosed())			{				// can happen if the user presses C+w twice real				// quick and the buffer has unsaved changes				return;			}				PerspectiveManager.setPerspectiveDirty(true);				if(!buffer.isNewFile())			{				if(view != null)					view.getEditPane().saveCaretInfo();				Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);				int caret = _caret == null ? 0 : _caret.intValue();					BufferHistory.setEntry(buffer.getPath(),caret,					(Selection[])buffer.getProperty(Buffer.SELECTION),					buffer.getStringProperty(JEditBuffer.ENCODING),					buffer.getMode().getName());			}				String path = buffer.getSymlinkPath();			if((VFSManager.getVFSForPath(path).getCapabilities()				& VFS.CASE_INSENSITIVE_CAP) != 0)			{				path = path.toLowerCase();			}			EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSING));			bufferHash.remove(path);			removeBufferFromList(buffer);			buffer.close();			DisplayManager.bufferClosed(buffer);			bufferSetManager.removeBuffer(buffer);			EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));			if(jEdit.getBooleanProperty("persistentMarkers"))				buffer.updateMarkersFile(view);		}	
/**		 * Closes all open buffers.		 * @param view The view		 *		 * @return true if all buffers were closed, false otherwise		 */		public static boolean closeAllBuffers(View view)		{			return closeAllBuffers(view,false);		}	
/**		 * Closes all open buffers.		 * @param view The view		 * @param isExiting This must be false unless this method is		 * being called by the exit() method		 *		 * @return true if all buffers were closed, false otherwise		 */		public static boolean closeAllBuffers(View view, boolean isExiting)		{			if(view != null)				view.getEditPane().saveCaretInfo();				boolean dirty = false;				boolean saveRecent = !(isExiting && jEdit.getBooleanProperty("restore"));				Buffer buffer = buffersFirst;			while(buffer != null)			{				if(buffer.isDirty())				{					dirty = true;					break;				}				buffer = buffer.next;			}				if(dirty)			{				boolean ok = new CloseDialog(view).isOK();				if(!ok)					return false;			}				// Wait for pending I/O requests			VFSManager.waitForRequests();			if(VFSManager.errorOccurred())				return false;				// close remaining buffers (the close dialog only deals with			// dirty ones)				buffer = buffersFirst;				// zero it here so that BufferTabs doesn't have any problems			buffersFirst = buffersLast = null;			bufferHash.clear();			bufferCount = 0;				while(buffer != null)			{				if(!buffer.isNewFile() && saveRecent)				{					Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);					int caret = _caret == null ? 0 : _caret.intValue();					BufferHistory.setEntry(buffer.getPath(),caret,						(Selection[])buffer.getProperty(Buffer.SELECTION),						buffer.getStringProperty(JEditBuffer.ENCODING),						buffer.getMode().getName());				}					buffer.close();				DisplayManager.bufferClosed(buffer);				if(!isExiting)				{					bufferSetManager.removeBuffer(buffer);					EditBus.send(new BufferUpdate(buffer,view,						BufferUpdate.CLOSED));				}				if(jEdit.getBooleanProperty("persistentMarkers"))					buffer.updateMarkersFile(view);				buffer = buffer.next;			}				PerspectiveManager.setPerspectiveDirty(true);				return true;		}	
/**		 * Saves all open buffers.		 * @param view The view		 * @since jEdit 4.2pre1		 */		public static void saveAllBuffers(View view)		{			saveAllBuffers(view,jEdit.getBooleanProperty("confirmSaveAll"));		}	
/**		 * Saves all open buffers.		 * @param view The view		 * @param confirm If true, a confirmation dialog will be shown first		 * @since jEdit 2.7pre2		 */		public static void saveAllBuffers(View view, boolean confirm)		{			if(confirm)			{				int result = GUIUtilities.confirm(view,"saveall",null,					JOptionPane.YES_NO_OPTION,					JOptionPane.QUESTION_MESSAGE);				if(result != JOptionPane.YES_OPTION)					return;			}				Buffer current = view.getBuffer();				Buffer buffer = buffersFirst;			while(buffer != null)			{				if(buffer.isDirty())				{					if(buffer.isNewFile())						view.setBuffer(buffer,true);					buffer.save(view,null,true,true);				}					buffer = buffer.next;			}				view.setBuffer(current,true);		}	
/**		 * Reloads all open buffers.		 * @param view The view		 * @param confirm If true, a confirmation dialog will be shown first		 *	if any buffers are dirty		 * @since jEdit 2.7pre2		 */		public static void reloadAllBuffers(View view, boolean confirm)		{			boolean hasDirty = false;			Buffer[] buffers = jEdit.getBuffers();				for(int i = 0; i < buffers.length && !hasDirty; i++)				hasDirty = !buffers[i].isUntitled() && buffers[i].isDirty();				if(confirm && hasDirty)			{				int result = GUIUtilities.confirm(view,"reload-all",null,					JOptionPane.YES_NO_OPTION,					JOptionPane.QUESTION_MESSAGE);				if(result != JOptionPane.YES_OPTION)					return;			}				// save caret info. Buffer.load() will load it.			visit(new SaveCaretInfoVisitor());					for(int i = 0; i < buffers.length; i++)			{				Buffer buffer = buffers[i];				if (buffer.isUntitled())					continue;				buffer.load(view,true);			}		}	
/**		 * Returns the buffer with the specified path name. The path name		 * must be an absolute, canonical, path.		 *		 * @param path The path name		 *		 * @return the searched buffer, or null if it is not already open		 *		 * @see MiscUtilities#constructPath(String,String)		 * @see MiscUtilities#resolveSymlinks(String)		 * @see #getBuffer(String)		 *		 * @since jEdit 4.2pre7		 */		public static Buffer _getBuffer(String path)		{			// paths on case-insensitive filesystems are stored as lower			// case in the hash.			if((VFSManager.getVFSForPath(path).getCapabilities()				& VFS.CASE_INSENSITIVE_CAP) != 0)			{				path = path.toLowerCase();			}				synchronized(bufferListLock)			{				return bufferHash.get(path);			}		}	
/**		 * Returns the buffer with the specified path name. The path name		 * must be an absolute path. This method automatically resolves		 * symbolic links. If performance is critical, cache the canonical		 * path and call {@link #_getBuffer(String)} instead.		 *		 * @param path The path name		 *		 * @return the searched buffer, or null if it is not already open		 *		 * @see MiscUtilities#constructPath(String,String)		 * @see MiscUtilities#resolveSymlinks(String)		 */		public static Buffer getBuffer(String path)		{			return _getBuffer(MiscUtilities.resolveSymlinks(path));		}	
/**		 * Returns an array of open buffers.		 * @return  an array of all open buffers		 */		public static Buffer[] getBuffers()		{			synchronized(bufferListLock)			{				Buffer[] buffers = new Buffer[bufferCount];				Buffer buffer = buffersFirst;				for(int i = 0; i < bufferCount; i++)				{					buffers[i] = buffer;					buffer = buffer.next;				}				return buffers;			}		}	
/**		 * Returns the number of open buffers.		 */		public static int getBufferCount()		{			return bufferCount;		}	
/**		 * Returns the first buffer.		 */		public static Buffer getFirstBuffer()		{			return buffersFirst;		}	
/**		 * Returns the last buffer.		 * @return the last buffer		 */		public static Buffer getLastBuffer()		{			return buffersLast;		}	
/**		 * Moves a buffer from a old position to a new position in the		 * BufferSet used in an EditPane.		 * @param editPane The EditPane in which a buffer is moved		 * @param oldPosition The position before the move		 * @param newPosition The position after the move		 */		public static void moveBuffer(EditPane editPane,			int oldPosition, int newPosition)		{			bufferSetManager.moveBuffer(editPane, oldPosition, newPosition);		}	
/**		 * Returns the global buffer set, which can be shared by several		 * views/editpanes.		 * @return the global buffer set		 * @since jEdit 4.3pre17		 */		public static BufferSet getGlobalBufferSet()		{			return globalBufferSet;		}	
/**		 * Returns the bufferSet manager.		 * @return the bufferSetManager		 * @since jEdit 4.3pre15		 */		public static BufferSetManager getBufferSetManager()		{			return bufferSetManager;		}	
/**		 * @return the propertyManager		 * @since jEdit 4.3pre15		 */		public static JEditPropertyManager getPropertyManager()		{			return propertyManager;		}	
/**		 * Checks each buffer's status on disk and shows the dialog box		 * informing the user that buffers changed on disk, if necessary.		 * @param view The view		 * @since jEdit 4.2pre1		 */		public static void checkBufferStatus(View view)		{			checkBufferStatus(view,false);		}	
/**		 * Checks buffer status on disk and shows the dialog box		 * informing the user that buffers changed on disk, if necessary.		 * @param view The view		 * @param currentBuffer indicates whether to check only the current buffer		 * @since jEdit 4.2pre1		 */		public static void checkBufferStatus(View view, boolean currentBuffer)		{			// still need to call the status check even if the option is			// off, so that the write protection is updated if it changes			// on disk				// auto reload changed buffers?			boolean autoReload = getBooleanProperty("autoReload");				// the problem with this is that if we have two edit panes			// looking at the same buffer and the file is reloaded both			// will jump to the same location			visit(new SaveCaretInfoVisitor());				Buffer buffer;			buffer = buffersFirst;				int[] states = new int[bufferCount];			int i = 0;			boolean notifyFileChanged = false;			while(buffer != null)			{				if(currentBuffer && buffer != view.getBuffer())				{					buffer = buffer.next;					i++;					continue;				}					states[i] = buffer.checkFileStatus(view);					switch(states[i])				{				case Buffer.FILE_CHANGED:					if(buffer.getAutoReload())					{						if(buffer.isDirty())							notifyFileChanged = true;						else							buffer.load(view,true);					}					else	// no automatic reload even if general setting is true						autoReload = false;					// don't notify user if "do nothing" was chosen					if(buffer.getAutoReloadDialog())						notifyFileChanged = true;					break;				case Buffer.FILE_DELETED:					notifyFileChanged = true;					break;				}					buffer = buffer.next;				i++;			}				if(notifyFileChanged)				new FilesChangedDialog(view,states,autoReload);		}	
/**		 * Returns the current input handler (key binding to action mapping)		 * @see org.gjt.sp.jedit.gui.InputHandler		 */		public static InputHandler getInputHandler()		{			return inputHandler;		}	
/**		 * Creates a new view.		 * @param view An existing view		 * @since jEdit 3.2pre2		 */		public static View newView(View view)		{			return newView(view,null,false);		}	
/**		 * Creates a new view of a buffer.		 * @param view An existing view		 * @param buffer The buffer		 */		public static View newView(View view, Buffer buffer)		{			return newView(view,buffer,false);		}	
/**		 * Creates a new view of a buffer.		 * @param view An existing view		 * @param buffer The buffer		 * @param plainView If true, the view will not have dockable windows or		 * tool bars.		 *		 * @since 4.1pre2		 */		public static View newView(View view, Buffer buffer, boolean plainView)		{			View.ViewConfig config;			if(view != null && (plainView == view.isPlainView()))			{				config = view.getViewConfig();				config.x -= 20;				config.y += 20;			}			else			{				config = new View.ViewConfig(plainView);			}			return newView(view,buffer,config);		}	
/**		 * Creates a new view.		 * @param view An existing view		 * @param buffer A buffer to display, or null		 * @param config Encapsulates the view geometry, split configuration		 * and if the view is a plain view		 * @since jEdit 4.2pre1		 */		public static View newView(View view, Buffer buffer, View.ViewConfig config)		{			// Mark the perspective as dirty, unless the new view is created			// during jEdit startup, by the loading of the perspective.			if (isStartupDone())				PerspectiveManager.setPerspectiveDirty(true);				try			{				if(view != null)				{					view.showWaitCursor();					view.getEditPane().saveCaretInfo();				}					View newView = new View(buffer,config);				addViewToList(newView);					newView.pack();				newView.adjust(view, config);					EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));					newView.setVisible(true);					if(!config.plainView)				{					int index;					synchronized (startupDone)					{						index = startupDone.size();						startupDone.add(false);					}					SwingUtilities.invokeLater(new DockingLayoutSetter(						newView, config, index));				}					// show tip of the day				if(newView == viewsFirst)				{					newView.getTextArea().requestFocus();						// Don't show the welcome message if jEdit was started					// with the -nosettings switch					if(settingsDirectory != null && getBooleanProperty("firstTime"))						new HelpViewer("welcome.html");					else if(jEdit.getBooleanProperty("tip.show"))						new TipOfTheDay(newView);						setBooleanProperty("firstTime",false);				}				else					GUIUtilities.requestFocus(newView,newView.getTextArea());					return newView;			}			finally			{				if(view != null)					view.hideWaitCursor();			}		}	
/**		 * Closes a view.		 *		 * jEdit will exit if this was the last open view.		 */		public static void closeView(View view)		{			closeView(view,true);		}	
/**		 * Returns an array of all open views.		 */		public static View[] getViews()		{			View[] views = new View[viewCount];			View view = viewsFirst;			for(int i = 0; i < viewCount; i++)			{				views[i] = view;				view = view.next;			}			return views;		}	
/**		 * Returns the number of open views.		 */		public static int getViewCount()		{			return viewCount;		}	
/**		 * Returns the first view.		 */		public static View getFirstView()		{			return viewsFirst;		}	
/**		 * Returns the last view.		 */		public static View getLastView()		{			return viewsLast;		}	
/**		 * Returns the currently focused view.		 * @since jEdit 4.1pre1		 */		public static View getActiveView()		{			if(activeView == null)			{				// eg user just closed a view and didn't focus another				return viewsFirst;			}			else				return activeView;		}	
public static void relocateSettings()		{			String oldSettingsPath = MiscUtilities.constructPath(					System.getProperty("user.home"),					".jedit");			File oldSettingsDir = new File(oldSettingsPath);			File newSettingsDir = new File(settingsDirectory);			if(oldSettingsDir.exists() && !newSettingsDir.exists())			{				Log.log(Log.NOTICE,jEdit.class,"Old settings directory found (HOME/.jedit). Moving to new location ("+newSettingsDir+")");				try				{					oldSettingsDir.renameTo(newSettingsDir);				}				catch(SecurityException se)				{					Log.log(Log.ERROR,jEdit.class,se);				}			}		}	
/**		 * Whether jEdit startup is over.		 * @since jEdit 4.3pre17		 */		public static boolean isStartupDone()		{			return (! startupDone.contains(false));		}	
/**		 * Returns true if the currently running thread is the main thread.		 * @since jEdit 4.2pre1		 */		public static boolean isMainThread()		{			return Thread.currentThread() == mainThread;		}	
/**		 * Returns true if jEdit was started with the <code>-background</code>		 * command-line switch.		 * @since jEdit 4.0pre4		 */		public static boolean isBackgroundModeEnabled()		{			return background;		}	
/**		 * Performs garbage collection and displays a dialog box showing		 * memory status.		 * @param view The view		 * @since jEdit 4.0pre1		 */		public static void showMemoryDialog(View view)		{			Runtime rt = Runtime.getRuntime();			long usedBefore = rt.totalMemory() - rt.freeMemory();			System.gc();			long free = rt.freeMemory();			long total = rt.totalMemory();			long used = total - free;				int totalKb = (int) (total / 1024);			int usedKb = (int) (used / 1024);			JProgressBar progress = new JProgressBar(0,totalKb);			progress.setValue(usedKb);			progress.setStringPainted(true);			progress.setString(jEdit.getProperty("memory-status.use",				new Object[] { usedKb, totalKb }));				Object[] message = new Object[4];			message[0] = getProperty("memory-status.gc",				new Object[] { (usedBefore - used) / 1024 });			message[1] = Box.createVerticalStrut(12);			message[2] = progress;			message[3] = Box.createVerticalStrut(6);				JOptionPane.showMessageDialog(view,message,				jEdit.getProperty("memory-status.title"),				JOptionPane.INFORMATION_MESSAGE);		}	
/**		 * Returns the jEdit install directory.		 */		public static String getJEditHome()		{			return jEditHome;		}	
/**		 * Returns the path of the directory where user-specific settings		 * are stored. This will be <code>null</code> if jEdit was		 * started with the <code>-nosettings</code> command-line switch; do not		 * blindly use this method without checking for a <code>null</code>		 * return value first.		 */		public static String getSettingsDirectory()		{			return settingsDirectory;		}	
/**		 * Returns the directory where plugin cache files are stored.		 * @since jEdit 4.2pre1		 */		public static String getJARCacheDirectory()		{			return jarCacheDirectory;		}	
/**		 * Backs up the specified file in the settings directory.		 * You should call this on any settings files your plugin		 * writes.		 * @param file The file		 * @since jEdit 4.0pre1		 */		public static void backupSettingsFile(File file)		{			if(settingsDirectory == null || !file.exists())				return;				String backupDir = MiscUtilities.constructPath(				settingsDirectory,"settings-backup");			File dir = new File(backupDir);			if(!dir.exists())				dir.mkdirs();				// ... sweet. saveBackup() will create backupDir if it			// doesn't exist.				MiscUtilities.saveBackup(file,5,null,"~",backupDir);		}	
/**		 * Saves all user preferences to disk.		 */		public static void saveSettings()		{			if(settingsDirectory == null)				return;				Abbrevs.save();			FavoritesVFS.saveFavorites();			HistoryModel.saveHistory();			Registers.saveRegisters();			SearchAndReplace.save();			BufferHistory.save();			KillRing.getInstance().save();				File file1 = new File(MiscUtilities.constructPath(				settingsDirectory,"#properties#save#"));			File file2 = new File(MiscUtilities.constructPath(				settingsDirectory,"properties"));			if(file2.exists() && file2.lastModified() != propsModTime)			{				Log.log(Log.WARNING,jEdit.class,file2 + " changed"					+ " on disk; will not save user properties");			}			else			{				backupSettingsFile(file2);				OutputStream out = null;				try				{					out = new FileOutputStream(file1);					propMgr.saveUserProps(out);				}				catch(IOException io)				{					Log.log(Log.ERROR,jEdit.class,io);				}				finally				{					IOUtilities.closeQuietly(out);				}				file2.delete();				if (! file1.renameTo(file2))				{					Log.log(Log.ERROR,jEdit.class,"Failed to rename \"" + file1 +						"\" to the user properties file \"" + file2 + "\".");				}				propsModTime = file2.lastModified();			}		}	
/**		 * Create a standalone TextArea.		 *		 * @return a textarea		 * @since 4.3pre13		 * @deprecated use new JEditEmbeddedTextArea() instead		 */		@Deprecated		public static TextArea createTextArea()		{			return new JEditEmbeddedTextArea();		}	
/**		 * Exits cleanly from jEdit, prompting the user if any unsaved files		 * should be saved first.		 * @param view The view from which this exit was called		 * @param reallyExit If background mode is enabled and this parameter		 * is true, then jEdit will close all open views instead of exiting		 * entirely.		 */		public static void exit(View view, boolean reallyExit)		{			// Close dialog, view.close() call need a view...			if(view == null)				view = activeView;				// Wait for pending I/O requests			VFSManager.waitForRequests();				// Create a new EditorExitRequested			EditorExitRequested eer = new EditorExitRequested(view);				// Send EditorExitRequested			EditBus.send(eer);				// Check if the ExitRequest has been cancelled			// if so, do not proceed anymore in the exiting			if (eer.hasBeenExitCancelled())			{				Log.log(Log.MESSAGE, jEdit.class, "Exit has been cancelled");				return;			}				// Even if reallyExit is false, we still exit properly			// if background mode is off			reallyExit |= !background;				PerspectiveManager.savePerspective(false);				try			{				PerspectiveManager.setPerspectiveEnabled(false);					// Close all buffers				if(!closeAllBuffers(view,reallyExit))					return;			}			finally			{				PerspectiveManager.setPerspectiveEnabled(true);			}				// If we are running in background mode and			// reallyExit was not specified, then return here.			if(!reallyExit)			{				// in this case, we can't directly call				// view.close(); we have to call closeView()				// for all open views				view = viewsFirst;				while(view != null)				{					closeView(view,false);					view = view.next;				}					// Save settings in case user kills the backgrounded				// jEdit process				saveSettings();			}			else			{					// Send EditorExiting				EditBus.send(new EditorExiting(null));					// Save view properties here				if(view != null)				{					view.close();					removeViewFromList(view);				}					// Stop autosave timer				Autosave.stop();					// Stop server				if(server != null)					server.stopServer();					// Stop all plugins				PluginJAR[] plugins = getPluginJARs();				for(int i = 0; i < plugins.length; i++)				{					removePluginJAR(plugins[i],true);				}						// Save settings				saveSettings();					// Close activity log stream				Log.closeStream();					// Byebye...				System.exit(0);			}		}	
/**		 * Returns the edit server instance. You can use this to find out the		 * port number jEdit is listening on.		 * @since jEdit 4.2pre10		 */		public static EditServer getEditServer()		{			return server;		}	
/**		 * Visit the views, editpanes and textareas		 * @param visitor the visitor		 * @since jEdit 4.3pre13		 */		public static void visit(JEditVisitor visitor)		{			View view = jEdit.getFirstView();			while (view != null)			{				visitor.visit(view);				view.visit(visitor);				view = view.getNext();			}		}	
/**		 * Returns the status prompt for the given register action. Only		 * intended to be called from <code>actions.xml</code>.		 * @since jEdit 4.3pre16		 */		public static String getRegisterStatusPrompt(String action)		{			String registerNameString = Registers.getRegisterNameString();			return jEdit.getProperty("view.status." + action,				new String[] {registerNameString == null ?					      jEdit.getProperty("view.status.no-registers") :					      registerNameString});		}	
/**		 * If buffer sorting is enabled, this repositions the buffer.		 */		static void updatePosition(String oldPath, Buffer buffer)		{			if((VFSManager.getVFSForPath(oldPath).getCapabilities()				& VFS.CASE_INSENSITIVE_CAP) != 0)			{				oldPath = oldPath.toLowerCase();			}				bufferHash.remove(oldPath);				String path = buffer.getSymlinkPath();			if((VFSManager.getVFSForPath(path).getCapabilities()				& VFS.CASE_INSENSITIVE_CAP) != 0)			{				path = path.toLowerCase();			}				bufferHash.put(path,buffer);				if(sortBuffers)			{				removeBufferFromList(buffer);				addBufferToList(buffer);			}		}	
/**		 * Loads an XML-defined edit mode from the specified reader.		 * @param mode The edit mode		 */		/* package-private */ static void loadMode(Mode mode)		{			final String fileName = (String)mode.getProperty("file");			XModeHandler xmh = new XModeHandler(mode.getName())			{				@Override				public void error(String what, Object subst)				{					String msg;						Object line = "<unknown>";					if(subst == null)						msg = jEdit.getProperty("xmode-error." + what);					else					{						msg = jEdit.getProperty("xmode-error." + what,							new String[] { subst.toString() });						if(subst instanceof Throwable)							Log.log(Log.ERROR,this,subst);						if (subst instanceof SAXParseException)						{							line = ((SAXParseException)subst).getLineNumber();						}					}						Object[] args = { fileName, line, null, msg };					GUIUtilities.error(null,"xmode-error",args);				}					@Override				public TokenMarker getTokenMarker(String modeName)				{					Mode mode = getMode(modeName);					if(mode == null)						return null;					else						return mode.getTokenMarker();				}			};			ModeProvider.instance.loadMode(mode, xmh);		}	
static void addPluginProps(Properties map)		{			propMgr.addPluginProps(map);		}	
static void removePluginProps(Properties map)		{			propMgr.removePluginProps(map);		}	
/**		 *		 * @param messageProp - a property of a message to print		 * @param args a list of arguments whch correspond to {0} and {1} in the string to print.		 */		static void pluginError(String path, String messageProp,			Object[] args)		{			synchronized(pluginErrorLock)			{				if(pluginErrors == null)					pluginErrors = new Vector<ErrorListDialog.ErrorEntry>();					ErrorListDialog.ErrorEntry newEntry =					new ErrorListDialog.ErrorEntry(					path,messageProp,args);					for(int i = 0; i < pluginErrors.size(); i++)				{					if(pluginErrors.get(i).equals(newEntry))						return;				}				pluginErrors.addElement(newEntry);					if(isStartupDone())				{					SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							showPluginErrorDialog();						}					});				}			}		}	
static void setActiveView(View view)		{			jEdit.activeView = view;		}	
/**		 * Returns the internal active view, which might be null.		 *		 * @since 4.3pre10		 */		public static View getActiveViewInternal()		{			return activeView;		}	
private jEdit() {}	
private static void usage()		{			System.out.println("Usage: jedit [<options>] [<files>]");				System.out.println("	<file> +marker:<marker>: Positions caret"				+ " at marker <marker>");			System.out.println("	<file> +line:<line>: Positions caret"				+ " at line number <line>");			System.out.println("	<file> +line:<line>,<column>: Positions caret"				+ " at line number <line> and column number <column>");			System.out.println("	--: End of options");			System.out.println("	-background: Run in background mode");			System.out.println("	-nobackground: Disable background mode (default)");			System.out.println("	-gui: Only if running in background mode; open initial view (default)");			System.out.println("	-nogui: Only if running in background mode; don't open initial view");			System.out.println("	-log=<level>: Log messages with level equal to or higher than this to");			System.out.println("	 standard error. <level> must be between 1 and 9. Default is 7.");			System.out.println("	-newplainview: Client instance opens a new plain view");			System.out.println("	-newview: Client instance opens a new view (default)");			System.out.println("	-plugins: Load plugins (default)");			System.out.println("	-noplugins: Don't load any plugins");			System.out.println("	-restore: Restore previously open files (default)");			System.out.println("	-norestore: Don't restore previously open files");			System.out.println("	-reuseview: Client instance reuses existing view");			System.out.println("	-quit: Quit a running instance");			System.out.println("	-run=<script>: Run the specified BeanShell script");			System.out.println("	-server: Read/write server info from/to $HOME/.jedit/server (default)");			System.out.println("	-server=<name>: Read/write server info from/to $HOME/.jedit/<name>");			System.out.println("	-noserver: Don't start edit server");			System.out.println("	-settings=<path>: Load user-specific settings from <path>");			System.out.println("	-nosettings: Don't load user-specific settings");			System.out.println("	-startupscripts: Run startup scripts (default)");			System.out.println("	-nostartupscripts: Don't run startup scripts");			System.out.println("	-usage: Print this message and exit");			System.out.println("	-version: Print jEdit version and exit");			System.out.println("	-wait: Wait until the user closes the specified buffer in the server");			System.out.println("	 instance. Does nothing if passed to the initial jEdit instance.");			System.out.println();			System.out.println("Report bugs to http://sourceforge.net/tracker/?group_id=588&atid=100588");		}	
private static void version()		{			System.out.println("jEdit " + getVersion());		}	
/**		 * Creates a BeanShell script that can be sent to a running edit server.		 */		private static String makeServerScript(boolean wait,			boolean restore, boolean newView,			boolean newPlainView, String[] args,			String scriptFile)		{			StringBuilder script = new StringBuilder();				String userDir = System.getProperty("user.dir");				script.append("parent = \"");			script.append(StandardUtilities.charsToEscapes(userDir));			script.append("\";\n");				script.append("args = new String[");			script.append(args.length);			script.append("];\n");				for(int i = 0; i < args.length; i++)			{				script.append("args[");				script.append(i);				script.append("] = ");					if(args[i] == null)					script.append("null");				else				{					script.append('"');					script.append(StandardUtilities.charsToEscapes(args[i]));					script.append('"');				}					script.append(";\n");			}				script.append("view = jEdit.getLastView();\n");			script.append("buffer = EditServer.handleClient(");			script.append(restore).append(',').append(newView).append(',').append(newPlainView);			script.append(",parent,args);\n");			script.append("if(buffer != null && ").append(wait).append(") {\n");			script.append("\tbuffer.setWaitSocket(socket);\n");			script.append("\tdoNotCloseSocket = true;\n");			script.append("}\n");			script.append("if(view != jEdit.getLastView() && ").append(wait).append(") {\n");			script.append("\tjEdit.getLastView().setWaitSocket(socket);\n");			script.append("\tdoNotCloseSocket = true;\n");			script.append("}\n");			script.append("if(doNotCloseSocket == void)\n");			script.append("\tsocket.close();\n");				if(scriptFile != null)			{				scriptFile = MiscUtilities.constructPath(userDir,scriptFile);				script.append("BeanShell.runScript(view,\"")					.append(StandardUtilities.charsToEscapes(scriptFile))					.append("\",null,this.namespace);\n");			}				return script.toString();		}	
/**		 * Initialise various objects, register protocol handlers.		 */		private static void initMisc()		{			ModeProvider.instance = new ModeProvider()			{				@Override				protected void error(String fileName, Throwable e)				{					Log.log(Log.ERROR, this, e);					if (e instanceof SAXParseException)					{						String message = e.getMessage();						int line = ((SAXParseException)e).getLineNumber();						int col = ((SAXParseException)e).getColumnNumber();							Object[] args = { fileName, line, col, message };						GUIUtilities.error(null,"xmode-error",args);					}				}			};			jars = new Vector<PluginJAR>();			FoldHandler.foldHandlerProvider = new ServiceManager.ServiceFoldHandlerProvider();			actionContext = new ActionContext()			{				@Override				public void invokeAction(EventObject evt,					EditAction action)				{					View view = GUIUtilities.getView(						(Component)evt.getSource());						boolean actionBarVisible;					if(view.getActionBar() == null						|| !view.getActionBar().isShowing())						actionBarVisible = false;					else					{						actionBarVisible = view.getActionBar()							.isVisible();					}						view.getInputHandler().invokeAction(action);						if(actionBarVisible)					{						// XXX: action bar might not be 'temp'						ActionBar actionBar = view							.getActionBar();						if(actionBar != null)							view.removeToolBar(actionBar);					}				}			};				bufferHash = new HashMap<String, Buffer>();				inputHandler = new DefaultInputHandler(null);			// Add our protocols to java.net.URL's list			System.getProperties().put("java.protocol.handler.pkgs",				"org.gjt.sp.jedit.proto|" +				System.getProperty("java.protocol.handler.pkgs",""));				// Set the User-Agent string used by the java.net HTTP handler			String userAgent = "jEdit/" + getVersion()				+ " (Java " + System.getProperty("java.version")				+ ". " + System.getProperty("java.vendor")				+ "; " + System.getProperty("os.arch") + ')';			System.getProperties().put("http.agent",userAgent);				/* Determine installation directory.			 * If the jedit.home property is set, use that.			 * Then, look for jedit.jar in the classpath.			 * If that fails, assume this is the web start version. */			jEditHome = System.getProperty("jedit.home");			if(jEditHome == null)			{				String classpath = System					.getProperty("java.class.path");				int index = classpath.toLowerCase()					.indexOf("jedit.jar");				int start = classpath.lastIndexOf(File					.pathSeparator,index) + 1;				// if started with java -jar jedit.jar				if(start == index)				{					jEditHome = System.getProperty("user.dir");				}				else if(index > start)				{					jEditHome = classpath.substring(start,						index - 1);				}				else				{					// check if web start					/* if(jEdit.class.getResource("/modes/catalog") != null)					{						// modes bundled in; hence web start						jEditHome = null;					}					else */					{						// use user.dir as last resort						jEditHome = System.getProperty("user.dir");							Log.log(Log.WARNING,jEdit.class,"jedit.jar not in class path!");						Log.log(Log.WARNING,jEdit.class,"Assuming jEdit is installed in "							+ jEditHome + '.');						Log.log(Log.WARNING,jEdit.class,"Override with jedit.home "							+ "system property.");					}				}			}				jEditHome = MiscUtilities.resolveSymlinks(jEditHome);				Log.log(Log.MESSAGE,jEdit.class,"jEdit home directory is " + jEditHome);				if(settingsDirectory != null)			{				jarCacheDirectory = MiscUtilities.constructPath(					settingsDirectory,"jars-cache");				new File(jarCacheDirectory).mkdirs();			}				//if(jEditHome == null)			//	Log.log(Log.DEBUG,jEdit.class,"Web start mode");				// Add an EditBus component that will reload edit modes and			// macros if they are changed from within the editor			EditBus.addToBus(new SettingsReloader());				// Perhaps if Xerces wasn't slightly brain-damaged, we would			// not need this			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					Thread.currentThread().setContextClassLoader(						new JARClassLoader());				}			});			// Also set the ContextClassLoader for the main jEdit thread.			// This way, the ContextClassLoader will be a JARClassLoader			// even at plugin activation.			Thread.currentThread().setContextClassLoader(new JARClassLoader());		}	
/**		 * Load system properties.		 */		private static void initSystemProperties()		{			propMgr = new PropertyManager();				try			{				propMgr.loadSystemProps(jEdit.class.getResourceAsStream(					"/org/gjt/sp/jedit/jedit.props"));				propMgr.loadSystemProps(jEdit.class.getResourceAsStream(					"/org/gjt/sp/jedit/jedit_gui.props"));				propMgr.loadSystemProps(jEdit.class.getResourceAsStream(					"/org/gjt/sp/jedit/jedit_keys.props"));			}			catch(Exception e)			{				Log.log(Log.ERROR,jEdit.class,					"Error while loading system properties!");				Log.log(Log.ERROR,jEdit.class,					"One of the following property files could not be loaded:\n"					+ "- jedit.props\n"					+ "- jedit_gui.props\n"					+ "- jedit_keys.props\n"					+ "jedit.jar is probably corrupt.");				Log.log(Log.ERROR,jEdit.class,e);				System.exit(1);			}		}	
/**		 * Load site properties.		 */		private static void initSiteProperties()		{			// site properties are loaded as default properties, overwriting			// jEdit's system properties				String siteSettingsDirectory = MiscUtilities.constructPath(				jEditHome, "properties");			File siteSettings = new File(siteSettingsDirectory);				if (!(siteSettings.exists() && siteSettings.isDirectory()))				return;				String[] snippets = siteSettings.list();			if (snippets == null)				return;				Arrays.sort(snippets,				new StandardUtilities.StringCompare<String>(true));				for (int i = 0; i < snippets.length; ++i)			{				String snippet = snippets[i];				if(!snippet.toLowerCase().endsWith(".props"))					continue;					try				{					String path = MiscUtilities.constructPath(						siteSettingsDirectory,snippet);					Log.log(Log.DEBUG,jEdit.class,						"Loading site snippet: " + path);						propMgr.loadSiteProps(new FileInputStream(new File(path)));				}				catch(FileNotFoundException fnf)				{					Log.log(Log.DEBUG,jEdit.class,fnf);				}				catch(IOException e)				{					Log.log(Log.ERROR,jEdit.class,"Cannot load site snippet "						+ snippet);					Log.log(Log.ERROR,jEdit.class,e);				}			}		}	
private static void initResources()		{			builtInActionSet = new ActionSet(null,null,null,				jEdit.class.getResource("actions.xml"));			builtInActionSet.setLabel(getProperty("action-set.jEdit"));			builtInActionSet.load();				actionContext.addActionSet(builtInActionSet);				DockableWindowFactory.getInstance()				.loadDockableWindows(null,				jEdit.class.getResource("dockables.xml"),				null);				ServiceManager.loadServices(null,				jEdit.class.getResource("services.xml"),				null);		}	
/**		 * Loads plugins.		 */		private static void initPlugins()		{			if(jEditHome != null)			{				addPluginJARsFromDirectory(MiscUtilities.constructPath(					jEditHome,"jars"));			}				if(settingsDirectory != null)			{				File jarsDirectory = new File(settingsDirectory,"jars");				if(!jarsDirectory.exists())					jarsDirectory.mkdir();				addPluginJARsFromDirectory(jarsDirectory.getPath());			}				PluginJAR[] jars = getPluginJARs();			for(int i = 0; i < jars.length; i++)			{				jars[i].checkDependencies();			}		}	
/**		 * Loads user properties.		 */		private static void initUserProperties()		{			if(settingsDirectory != null)			{				File file = new File(MiscUtilities.constructPath(					settingsDirectory,"properties"));				propsModTime = file.lastModified();					try				{					propMgr.loadUserProps(						new FileInputStream(file));				}				catch(FileNotFoundException fnf)				{					//Log.log(Log.DEBUG,jEdit.class,fnf);				}				catch(Exception e)				{					Log.log(Log.ERROR,jEdit.class,e);				}			}		}	
private static String fontStyleToString(int style)		{			if(style == 0)				return "PLAIN";			else if(style == Font.BOLD)				return "BOLD";			else if(style == Font.ITALIC)				return "ITALIC";			else if(style == (Font.BOLD | Font.ITALIC))				return "BOLDITALIC";			else				throw new RuntimeException("Invalid style: " + style);		}	
private static String fontToString(Font font)		{			return font.getFamily()				+ '-'				+ fontStyleToString(font.getStyle())				+ '-'				+ font.getSize();		}	
/**		 * Sets the Swing look and feel.		 */		private static void initPLAF()		{			Font primaryFont = jEdit.getFontProperty(				"metal.primary.font");			if(primaryFont != null)			{				String primaryFontString =					fontToString(primaryFont);					System.getProperties().put(					"swing.plaf.metal.controlFont",					primaryFontString);				System.getProperties().put(					"swing.plaf.metal.menuFont",					primaryFontString);			}				Font secondaryFont = jEdit.getFontProperty(				"metal.secondary.font");			if(secondaryFont != null)			{				String secondaryFontString =					fontToString(secondaryFont);					System.getProperties().put(					"swing.plaf.metal.systemFont",					secondaryFontString);				System.getProperties().put(					"swing.plaf.metal.userFont",					secondaryFontString);			}				try			{				String lf = getProperty("lookAndFeel");				if(lf != null && lf.length() != 0)					UIManager.setLookAndFeel(lf);				else if(OperatingSystem.isMacOS())				{					UIManager.setLookAndFeel(UIManager						.getSystemLookAndFeelClassName());				}				else				{					UIManager.setLookAndFeel(UIManager						.getCrossPlatformLookAndFeelClassName());				}			}			catch(Exception e)			{				Log.log(Log.ERROR,jEdit.class,e);			}				UIDefaults defaults = UIManager.getDefaults();				// give all Swing components our colors			if(jEdit.getBooleanProperty("textColors"))			{				Color background = new javax.swing.plaf.ColorUIResource(					jEdit.getColorProperty("view.bgColor"));				Color foreground = new javax.swing.plaf.ColorUIResource(					jEdit.getColorProperty("view.fgColor"));				Color caretColor = new javax.swing.plaf.ColorUIResource(					jEdit.getColorProperty("view.caretColor"));				Color selectionColor = new javax.swing.plaf.ColorUIResource(					jEdit.getColorProperty("view.selectionColor"));					String[] prefixes = { "PasswordField", "TextField", "TextArea", "List", "Table" };				for(int i = 0; i < prefixes.length; i++)				{					String prefix = prefixes[i];					defaults.put(prefix + ".foreground",foreground);					defaults.put(prefix + ".background",background);					defaults.put(prefix + ".disabledForeground",foreground);					defaults.put(prefix + ".disabledBackground",background);					defaults.put(prefix + ".caretForeground",caretColor);					defaults.put(prefix + ".selectionForeground",foreground);					defaults.put(prefix + ".selectionBackground",selectionColor);				}					defaults.put("ComboBox.foreground",foreground);				defaults.put("ComboBox.background",background);				defaults.put("ComboBox.disabledForeground",foreground);				defaults.put("ComboBox.disabledBackground",background);				defaults.put("ComboBox.selectedForeground",foreground);				defaults.put("ComboBox.selectedBackground",selectionColor);					defaults.put("Tree.background",background);				defaults.put("Tree.foreground",foreground);				defaults.put("Tree.textBackground",background);				defaults.put("Tree.textForeground",foreground);				defaults.put("Tree.selectionForeground",foreground);				defaults.put("Tree.selectionBackground",selectionColor);			}				defaults.remove("SplitPane.border");			defaults.remove("SplitPaneDivider.border");				JFrame.setDefaultLookAndFeelDecorated(				getBooleanProperty("decorate.frames"));			JDialog.setDefaultLookAndFeelDecorated(				getBooleanProperty("decorate.dialogs"));				KeyboardFocusManager.setCurrentKeyboardFocusManager(				new MyFocusManager());		}	
public static int getNextUntitledBufferId()		{			int untitledCount = 0;			Buffer buffer = buffersFirst;			while(buffer != null)			{				if(buffer.getName().startsWith("Untitled-"))				{					try					{						untitledCount = Math.max(untitledCount,							Integer.parseInt(buffer.getName()							.substring(9)));					}					catch(NumberFormatException nf)					{					}				}				buffer = buffer.next;			}			return untitledCount + 1;		}	
/**		 * Runs scripts in a directory.		 */		private static void runStartupScripts(File directory)		{			if (!directory.isDirectory())				return;				File[] snippets = directory.listFiles();			if (snippets == null)				return;				Arrays.sort(snippets,				new StandardUtilities.StringCompare<File>(true));				/*			 * Force the default encoding to UTF-8 temporarily.			 * The shipped scripts use that encoding, so we need			 * to make sure we can load them correctly. If users			 * want to write script with a different encoding,			 * they can use buffer-local properties on the			 * script to set it.			 */			String defaultEncoding = getProperty("buffer.encoding");			setProperty("buffer.encoding", "UTF-8");				for(int i = 0; i < snippets.length; ++i)			{				File snippet = snippets[i];					Macros.Handler handler = Macros.getHandlerForPathName(					snippet.getPath());				if(handler == null)					continue;					try				{					Macros.Macro newMacro = handler.createMacro(						snippet.getName(),						snippet.getPath());					handler.runMacro(null,newMacro,false);				}				catch(Exception e)				{					Log.log(Log.ERROR,jEdit.class,e);				}			}				setProperty("buffer.encoding", defaultEncoding);		}	
private static void initProxy()		{			boolean socksEnabled = jEdit.getBooleanProperty("socks.enabled");			if(!socksEnabled)			{				Log.log(Log.DEBUG,jEdit.class,"SOCKS proxy disabled");				System.getProperties().remove("socksProxyHost");				System.getProperties().remove("socksProxyPort");			}			else			{				String socksHost = jEdit.getProperty("firewall.socks.host");				if( socksHost != null )				{					System.setProperty("socksProxyHost", socksHost);					Log.log(Log.DEBUG, jEdit.class,						"SOCKS proxy enabled: " + socksHost);				}					String socksPort = jEdit.getProperty("firewall.socks.port");				if(socksPort != null)					System.setProperty("socksProxyPort", socksPort);			}				boolean httpEnabled = jEdit.getBooleanProperty("firewall.enabled");			if (!httpEnabled)			{				Log.log(Log.DEBUG, jEdit.class, "HTTP proxy disabled");				System.getProperties().remove("proxySet");				System.getProperties().remove("proxyHost");				System.getProperties().remove("proxyPort");				System.getProperties().remove("http.proxyHost");				System.getProperties().remove("http.proxyPort");				System.getProperties().remove("http.nonProxyHosts");				Authenticator.setDefault(null);			}			else			{				// set proxy host				String host = jEdit.getProperty("firewall.host");				if (host == null)					return;					System.setProperty("http.proxyHost", host);				Log.log(Log.DEBUG, jEdit.class, "HTTP proxy enabled: " + host);				// set proxy port				String port = jEdit.getProperty("firewall.port");				if (port != null)					System.setProperty("http.proxyPort", port);					// set non proxy hosts list				String nonProxyHosts = jEdit.getProperty("firewall.nonProxyHosts");				if (nonProxyHosts != null)					System.setProperty("http.nonProxyHosts", nonProxyHosts);					// set proxy authentication				String username = jEdit.getProperty("firewall.user");				String password = jEdit.getProperty("firewall.password");					// null not supported?				if(password == null)					password = "";					if(username == null || username.length()==0)				{					Log.log(Log.DEBUG, jEdit.class, "HTTP proxy without user");					Authenticator.setDefault(new FirewallAuthenticator(null));				}				else				{					Log.log(Log.DEBUG, jEdit.class, "HTTP proxy user: " + username);					PasswordAuthentication pw = new PasswordAuthentication(						username,password.toCharArray()					);					Authenticator.setDefault(new FirewallAuthenticator(pw));				}			}		}	
FirewallAuthenticator(PasswordAuthentication pw)			{				this.pw = pw;			}	
@Override			protected PasswordAuthentication getPasswordAuthentication()			{				return pw;			}	
private static void finishStartup(final boolean gui, final boolean restore,			final boolean newPlainView, final String userDir, final String[] args)		{			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					int count = getBufferCount();						boolean restoreFiles = restore						&& jEdit.getBooleanProperty("restore")						&& (count == 0 ||						jEdit.getBooleanProperty("restore.cli"));						if(gui || count != 0)					{						View view;						if (newPlainView)							view = newView(null,null,true);						else							view = PerspectiveManager.loadPerspective(restoreFiles);							if(view == null)							view = newView(null,null);							Buffer buffer = openFiles(null,userDir,args);						if(buffer != null)							view.setBuffer(buffer,true);					}					else					{						openFiles(null,userDir,args);					}						// Start I/O threads					EditBus.send(new EditorStarted(null));						VFSManager.start();						// Start edit server					if(server != null)						server.start();						GUIUtilities.hideSplashScreen();						Log.log(Log.MESSAGE,jEdit.class,"Startup "						+ "complete");						//{{{ Report any plugin errors					if(pluginErrors != null)					{						showPluginErrorDialog();					} //}}}						startupDone.set(0, true);						// in one case not a single AWT class will					// have been touched (splash screen off +					// -nogui -nobackground switches on command					// line)					Toolkit.getDefaultToolkit();				}			});		}	
private static void showPluginErrorDialog()		{			if(pluginErrors == null)				return;				String caption = getProperty(				"plugin-error.caption" + (pluginErrors.size() == 1				? "-1" : ""));				Frame frame = (PluginManager.getInstance() == null				? viewsFirst				: PluginManager.getInstance());				new ErrorListDialog(frame,				getProperty("plugin-error.title"),				caption,pluginErrors,true);			pluginErrors = null;		}	
private static void getNotLoadedPluginJARs(List<String> returnValue,			String dir, String[] list)		{	loop:		for(int i = 0; i < list.length; i++)			{				String name = list[i];				if(!name.toLowerCase().endsWith(".jar"))					continue loop;					String path = MiscUtilities.constructPath(dir,name);					for(int j = 0; j < jars.size(); j++)				{					PluginJAR jar = jars.elementAt(j);					String jarPath = jar.getPath();					String jarName = MiscUtilities.getFileName(jarPath);						if(path.equals(jarPath))						continue loop;					else if(!new File(jarPath).exists()						&& name.equals(jarName))						continue loop;				}					returnValue.add(path);			}		}	
private static void gotoMarker(final View view, final Buffer buffer,			final String marker)		{			VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					int pos;						// Handle line number					if(marker.startsWith("+line:"))					{						try						{							String arg = marker.substring(6);							String[] lineCol = arg.split(",");							int line, col;							if(lineCol.length > 1)							{								line = Integer.parseInt(lineCol[0]);								col = Integer.parseInt(lineCol[1]);							}							else							{								line = Integer.parseInt(marker.substring(6));								col = 1;							}							pos = buffer.getLineStartOffset(line - 1) + (col - 1);						}						catch(Exception e)						{							return;						}					}					// Handle marker					else if(marker.startsWith("+marker:"))					{						if(marker.length() != 9)							return;							Marker m = buffer.getMarker(marker.charAt(8));						if(m == null)							return;						pos = m.getPosition();					}					// Can't happen					else						throw new InternalError();						if(view != null && view.getBuffer() == buffer)					{						view.getTextArea().setCaretPosition(pos);						buffer.setIntegerProperty(Buffer.CARET,pos);						buffer.setBooleanProperty(Buffer.CARET_POSITIONED,true);					}					else					{						buffer.setIntegerProperty(Buffer.CARET,pos);						buffer.setBooleanProperty(Buffer.CARET_POSITIONED,true);						buffer.unsetProperty(Buffer.SCROLL_VERT);					}				}			});		}	
private static void addBufferToList(Buffer buffer)		{			synchronized(bufferListLock)			{				String symlinkPath = buffer.getSymlinkPath();				if((VFSManager.getVFSForPath(symlinkPath).getCapabilities()					& VFS.CASE_INSENSITIVE_CAP) != 0)				{					symlinkPath = symlinkPath.toLowerCase();				}					bufferCount++;					bufferHash.put(symlinkPath,buffer);					if(buffersFirst == null)				{					buffersFirst = buffersLast = buffer;					return;				}				//{{{ Sort buffer list				else if(sortBuffers)				{					String str11, str12;					if(sortByName)					{						str11 = buffer.getName();						str12 = buffer.getDirectory();					}					else					{						str11 = buffer.getDirectory();						str12 = buffer.getName();					}						Buffer _buffer = buffersFirst;					while(_buffer != null)					{						String str21, str22;						if(sortByName)						{							str21 = _buffer.getName();							str22 = _buffer.getDirectory();						}						else						{							str21 = _buffer.getDirectory();							str22 = _buffer.getName();						}							int comp = StandardUtilities.compareStrings(str11,str21,true);						if(comp < 0 || (comp == 0 && StandardUtilities.compareStrings(str12,str22,true) < 0))						{							buffer.next = _buffer;							buffer.prev = _buffer.prev;							_buffer.prev = buffer;							if(_buffer != buffersFirst)								buffer.prev.next = buffer;							else								buffersFirst = buffer;							return;						}							_buffer = _buffer.next;					}				} //}}}					buffer.prev = buffersLast;				// fixes the hang that can occur if we 'save as' to a				// new filename which requires re-sorting				buffer.next = null;				buffersLast.next = buffer;				buffersLast = buffer;			}		}	
private static void removeBufferFromList(Buffer buffer)		{			synchronized(bufferListLock)			{				bufferCount--;					String path = buffer.getPath();				if(OperatingSystem.isCaseInsensitiveFS())					path = path.toLowerCase();					bufferHash.remove(path);					if(buffer == buffersFirst && buffer == buffersLast)				{					buffersFirst = buffersLast = null;					return;				}					if(buffer == buffersFirst)				{					buffersFirst = buffer.next;					buffer.next.prev = null;				}				else				{					if (buffer.prev != null)						buffer.prev.next = buffer.next;				}					if(buffer == buffersLast)				{					buffersLast = buffersLast.prev;					buffer.prev.next = null;				}				else				{					if (buffer.next != null)						buffer.next.prev = buffer.prev;				}					// fixes the hang that can occur if we 'save as' to a new				// filename which requires re-sorting				buffer.next = buffer.prev = null;			}		}	
private static void addViewToList(View view)		{			viewCount++;				if(viewsFirst == null)				viewsFirst = viewsLast = view;			else			{				view.prev = viewsLast;				viewsLast.next = view;				viewsLast = view;			}		}	
private static void removeViewFromList(View view)		{			viewCount--;				if(viewsFirst == viewsLast)			{				viewsFirst = viewsLast = null;				return;			}				if(view == viewsFirst)			{				viewsFirst = view.next;				view.next.prev = null;			}			else			{				view.prev.next = view.next;			}				if(view == viewsLast)			{				viewsLast = viewsLast.prev;				view.prev.next = null;			}			else			{				view.next.prev = view.prev;			}		}	
/**		 * closeView() used by exit().		 */		private static boolean closeView(View view, boolean callExit)		{			PerspectiveManager.setPerspectiveDirty(true);				if(viewsFirst == viewsLast && callExit)			{				exit(view,false); /* exit does editor event & save */				// Coming here means the request has been canceled.				return false;			}			else			{				if (!view.confirmToCloseDirty())					return false;					view.close();				view.dispose();				removeViewFromList(view);					if(view == activeView)					activeView = null;					return true;			}		}	
/**		 * Loads a mode catalog file.		 * @since jEdit 3.2pre2		 */		private static void loadModeCatalog(String path, boolean resource)		{			Log.log(Log.MESSAGE,jEdit.class,"Loading mode catalog file " + path);				ModeCatalogHandler handler = new ModeCatalogHandler(				MiscUtilities.getParentOfPath(path),resource)			{				@Override				protected Mode instantiateMode(String modeName)				{					return new JEditMode(modeName);				}			};			try			{				InputStream _in;				if(resource)					_in = jEdit.class.getResourceAsStream(path);				else					_in = new FileInputStream(path);				XMLUtilities.parseXML(_in, handler);			}			catch(IOException e)			{				Log.log(Log.ERROR,jEdit.class,e);			}		}	
/**		 * Loads all key bindings from the properties.		 *		 * @since 3.1pre1		 */		private static void initKeyBindings()		{			inputHandler.removeAllKeyBindings();				ActionSet[] actionSets = getActionSets();			for (int i = 0; i < actionSets.length; i++)			{				actionSets[i].initKeyBindings();			}		}	
/**		 * Compose buffer-local properties which can be got from history.		 * @since 4.3pre10		 */		private static void composeBufferPropsFromHistory(Map props, String path)		{			BufferHistory.Entry entry = BufferHistory.getEntry(path);				if(entry != null && saveCaret && props.get(Buffer.CARET) == null)			{				props.put(Buffer.CARET, entry.caret);				/* if(entry.selection != null)				{					// getSelection() converts from string to					// Selection[]					props.put(Buffer.SELECTION,entry.getSelection());				} */			}				if(entry != null && props.get(JEditBuffer.ENCODING) == null)			{				if(entry.encoding != null)					props.put(JEditBuffer.ENCODING,entry.encoding);			}				if (entry != null && props.get("mode") == null)			{				if (entry.mode != null)					props.put("mode", entry.mode);			}		}	
MyFocusManager()			{				setDefaultFocusTraversalPolicy(new LayoutFocusTraversalPolicy());			}	
@Override			public boolean postProcessKeyEvent(KeyEvent evt)			{				if(!evt.isConsumed())				{					Component comp = (Component)evt.getSource();					if(!comp.isShowing())						return true;						for(;;)					{						if(comp instanceof View)						{							((View)comp).getInputHandler().processKeyEvent(evt,								View.VIEW, false);							return true;						}						else if(comp == null || comp instanceof Window							|| comp instanceof JEditTextArea)						{							if (comp instanceof PluginManager)							{								evt.setSource(comp);								((PluginManager)comp).processKeyEvents(evt);							}							break;						}						else							comp = comp.getParent();					}				}					return super.postProcessKeyEvent(evt);			}	
public String getProperty(String name)			{				return jEdit.getProperty(name);			}	
DockingLayoutSetter(View view, ViewConfig config, int startupDoneIndex)			{				this.view = view;				this.config = config;				this.startupDoneIndex = startupDoneIndex;			}	
public void run()			{				DockableWindowManager wm = view.getDockableWindowManager();				wm.setDockingLayout(config.docking);				startupDone.set(startupDoneIndex, true);			}	
/**		 * Creates a new edit action with the specified name.		 * @param name The action name		 */		protected JEditAbstractEditAction(String name)		{			this.name = name;		}	
protected JEditAbstractEditAction(String name, Object[] newArgs)		{			this.name = name;			this.args = newArgs;		}	
/**		 * Returns the internal name of this action.		 * @return the action name		 */		public String getName()		{			return name;		}	
/**		 * Changes the name of an action		 * @param newName the new name of the action		 * @since jEdit 4.3pre4		 */		public void setName(String newName)		{			name = newName;		}	
/**		 * @param arg the arguments of the action		 * @param newArgs new argument list		 */		public final void invoke(E arg, Object[] newArgs)		{			args = newArgs;			invoke(arg);		}	
@Override		public String toString()		{			return name;		}	
/**		 * Adds a new action set to the context.		 * @since jEdit 4.3pre13		 */		public void addActionSet(E actionSet)		{			actionNames = null;			actionSets.addElement(actionSet);			actionSet.context = this;			String[] actions = actionSet.getActionNames();			for(int i = 0; i < actions.length; i++)			{				/* Is it already there? */				if (actionHash.containsKey(actions[i])) 				{					/* Save it for plugin unloading time */					E oldAction = actionHash.get(actions[i]);					overriddenActions.put(actions[i], oldAction);				}				actionHash.put(actions[i],actionSet);			}		}	
/**		 * Removes an action set from the context.		 * @since jEdit 4.23pre13		 */		public void removeActionSet(E actionSet)		{			actionNames = null;			actionSets.removeElement(actionSet);			actionSet.context = null;			String[] actions = actionSet.getActionNames();			for(int i = 0; i < actions.length; i++)			{				actionHash.remove(actions[i]);				if (overriddenActions.containsKey(actions[i])) 				{					E oldAction = overriddenActions.remove(actions[i]);					actionHash.put(actions[i], oldAction);				}			}		}	
/**		 * Returns all registered action sets.		 * @since jEdit 4.3pre13		 */		public E[] getActionSets()		{			if (actionSets.isEmpty())				return null;			Class clazz = actionSets.get(0).getClass();			E[] retVal =(E[]) Array.newInstance(clazz, actionSets.size());			actionSets.copyInto(retVal);			return retVal;		}	
/**		 * Returns the specified action.		 * @param name The action name		 * @return a JEditAbstractEditAction or null if it doesn't exist		 * @since jEdit 4.3pre13		 */		public F getAction(String name)		{			E set = actionHash.get(name);			if(set == null)				return null;			else				return set.getAction(name);		}	
/**		 * Returns the action set that contains the specified action.		 *		 * @param action The action		 * @return the actionSet that contains the given action		 * @since jEdit 4.3pre13		 */		public E getActionSetForAction(String action)		{			return actionHash.get(action);		}	
/**		 * Returns all registered action names.		 */		public String[] getActionNames()		{			if(actionNames == null)			{				List<String> vec = new LinkedList<String>();				for(int i = 0; i < actionSets.size(); i++)					(actionSets.elementAt(i)).getActionNames(vec);					actionNames = vec.toArray(new String[vec.size()]);				Arrays.sort(actionNames,					new StandardUtilities.StringCompare<String>(true));			}				return actionNames;		}	
/**		 * Creates a new action set.		 * @since jEdit 4.3pre13		 */		public JEditActionSet()		{			actions = new Hashtable<String, Object>();			loaded = true;		}	
/**		 * Creates a new action set.		 * @param cachedActionNames The list of cached action names		 * @param uri The actions.xml URI		 * @since jEdit 4.3pre13		 */		public JEditActionSet(String[] cachedActionNames, URL uri)		{			this();			this.uri = uri;			if(cachedActionNames != null)			{				for(int i = 0; i < cachedActionNames.length; i++)				{					actions.put(cachedActionNames[i],placeholder);				}			}			loaded = false;		}	
/**		 * Adds an action to the action set.		 * @param action The action		 * @since jEdit 4.0pre1		 */		public void addAction(E action)		{			actions.put(action.getName(),action);			if(context != null)			{				context.actionNames = null;				context.actionHash.put(action.getName(),this);			}		}	
/**		 * Removes an action from the action set.		 * @param name The action name		 * @since jEdit 4.0pre1		 */		public void removeAction(String name)		{			actions.remove(name);			if(context != null)			{				context.actionNames = null;				context.actionHash.remove(name);			}		}	
/**		 * Removes all actions from the action set.		 * @since jEdit 4.0pre1		 */		public void removeAllActions()		{			if(context != null)			{				context.actionNames = null;				String[] actions = getActionNames();				for(int i = 0; i < actions.length; i++)				{					context.actionHash.remove(actions[i]);				}			}			this.actions.clear();		}	
/**		 * Returns an action with the specified name.<p>		 *		 * <b>Deferred loading:</b> this will load the action set if necessary.		 *		 * @param name The action name		 * @since jEdit 4.0pre1		 */		public E getAction(String name)		{			Object obj = actions.get(name);			if(obj == placeholder)			{				load();				obj = actions.get(name);				if(obj == placeholder)				{					Log.log(Log.WARNING,this,"Outdated cache");					obj = null;				}			}				return (E) obj;		}	
/**		 * Returns the number of actions in the set.		 * @since jEdit 4.0pre1		 */		public int getActionCount()		{			return actions.size();		}	
/**		 * Returns an array of all action names in this action set.		 * @since jEdit 4.2pre1		 */		public String[] getActionNames()		{			String[] retVal = new String[actions.size()];			Enumeration e = actions.keys();			int i = 0;			while(e.hasMoreElements())			{				retVal[i++] = (String)e.nextElement();			}			return retVal;		}	
/**		 * Returns an array of all action names in this action set that should		 * be cached; namely, <code>BeanShellAction</code>s.		 * @since jEdit 4.2pre1		 */		public String[] getCacheableActionNames()		{			LinkedList<String> retVal = new LinkedList<String>();			Enumeration e = actions.elements();			while(e.hasMoreElements())			{				Object obj = e.nextElement();				if(obj == placeholder)				{					// ??? this should only be called with					// fully loaded action set					Log.log(Log.WARNING,this,"Action set not up "						+ "to date");				}				else if(obj instanceof JEditBeanShellAction)					retVal.add(((JEditBeanShellAction)obj).getName());			}			return retVal.toArray(new String[retVal.size()]);		}	
/**		 * Returns an array of all actions in this action set.<p>		 *		 * <b>Deferred loading:</b> this will load the action set if necessary.		 *		 * @since jEdit 4.0pre1		 */		public E[] getActions()		{			load();			E[] retVal = getArray(actions.size());			Enumeration e = actions.elements();			int i = 0;			while(e.hasMoreElements())			{				retVal[i++] = (E) e.nextElement();			}			return retVal;		}	
/**		 * Returns if this action set contains the specified action.		 * @param action The action		 * @since jEdit 4.2pre1		 */		public boolean contains(String action)		{			boolean retval = actions.containsKey(action);			return retval;	//		return actions.containsKey(action);		}	
/**		 * Returns the number of actions in this action set.		 * @since jEdit 4.2pre2		 */		public int size()		{			return actions.size();		}	
/**		 * Forces the action set to be loaded. Plugins and macros should not		 * call this method.		 * @since jEdit 4.2pre1		 */		public void load()		{			if(loaded)				return;				loaded = true;			//actions.clear();				if (uri == null)				return;			try			{				Log.log(Log.DEBUG,this,"Loading actions from " + uri);				ActionListHandler ah = new ActionListHandler(uri.toString(),this);				if ( XMLUtilities.parseXML(uri.openStream(), ah))				{					Log.log(Log.ERROR, this, "Unable to parse: " + uri);				}			}			catch(IOException e)			{				Log.log(Log.ERROR,this,uri,e);			}		}	
/**		 * Initializes the action set's key bindings.		 * jEdit calls this method for all registered action sets when the		 * user changes key bindings in the <b>Global Options</b> dialog box.<p>		 *		 * Note if your plugin adds a custom action set to jEdit's collection,		 * it must also call this method on the action set after adding it.		 *		 * @since jEdit 4.2pre1		 */		public void initKeyBindings()		{			AbstractInputHandler inputHandler = getInputHandler();				Iterator<Map.Entry<String,Object>> iter = actions.entrySet().iterator();			while(iter.hasNext())			{				Map.Entry<String,Object> entry = iter.next();				String name = entry.getKey();					String shortcut1 = getProperty(name + ".shortcut");				if(shortcut1 != null)					inputHandler.addKeyBinding(shortcut1,name);					String shortcut2 = getProperty(name + ".shortcut2");				if(shortcut2 != null)					inputHandler.addKeyBinding(shortcut2,name);			}		}	
void getActionNames(List<String> vec)		{			Enumeration<String> e = actions.keys();			while(e.hasMoreElements())				vec.add(e.nextElement());		}	
public JEditBeanShellAction(String name, String code, String isSelected,			boolean noRepeat, boolean noRecord, boolean noRememberLast)		{			super(name);				this.code = code;			this.isSelected = isSelected;			this.noRepeat = noRepeat;			this.noRecord = noRecord;			this.noRememberLast = noRememberLast;				/* Some characters that we like to use in action names			 * ('.', '-') are not allowed in BeanShell identifiers. */			sanitizedName = name.replace('.','_').replace('-','_');		}	
public void invoke(TextArea textArea)		{			try			{				if(cachedCode == null)				{					String cachedCodeName = "action_" + sanitizedName;					cachedCode = bsh.cacheBlock(cachedCodeName,code,true);				}					bsh.runCachedBlock(cachedCode,textArea,					new NameSpace(bsh.getNameSpace(),					"BeanShellAction.invoke()"));			}			catch(Throwable e)			{				Log.log(Log.ERROR,this,e);			}		}	
public boolean isSelected(Component comp)		{			if(isSelected == null)				return false;				NameSpace global = bsh.getNameSpace();				try			{				if(cachedIsSelected == null)				{					String cachedIsSelectedName = "selected_" + sanitizedName;					cachedIsSelected = bsh.cacheBlock(cachedIsSelectedName,						isSelected,true);				}					// undocumented hack to allow browser actions to work.				// XXX - clean up in 4.3				global.setVariable("_comp",comp);					return Boolean.TRUE.equals(bsh.runCachedBlock(					cachedIsSelected,null,					new NameSpace(bsh.getNameSpace(),					"BeanShellAction.isSelected()")));			}			catch(Throwable e)			{				Log.log(Log.ERROR,this,e);					// dialogs fuck things up if a menu is visible, etc!				//new BeanShellErrorDialog(view,e);					// so that in the future we don't see streams of				// exceptions				isSelected = null;					return false;			}			finally			{				try				{					global.setVariable("_comp",null);				}				catch(UtilEvalError err)				{					Log.log(Log.ERROR,this,err);				}			}		}	
public boolean noRepeat()		{			return noRepeat;		}	
public boolean noRecord()		{			return noRecord;		}	
/**		 * Returns if this edit action should not be remembered as the most		 * recently invoked action.		 * @since jEdit 4.2pre1		 */		public boolean noRememberLast()		{			return noRememberLast;		}	
public String getCode()		{			return code.trim();		}	
@Override			protected void setupDefaultVariables(NameSpace namespace, TextArea textArea) throws UtilEvalError 			{				if(textArea != null)				{					namespace.setVariable("buffer",textArea.getBuffer(), false);					namespace.setVariable("textArea",textArea, false);				}			}	
@Override			protected void resetDefaultVariables(NameSpace namespace) throws UtilEvalError			{				namespace.setVariable("buffer",null, false);				namespace.setVariable("textArea",null, false);			}	
@Override			protected void handleException(TextArea textArea, String path, Throwable t)			{				Log.log(Log.ERROR,this, t, t);	//			new BeanShellErrorDialog(null,t);			}	
public JEditBuffer(Map props)		{			bufferListeners = new Vector<Listener>();			undoListeners = new Vector<BufferUndoListener>();			lock = new ReentrantReadWriteLock();			contentMgr = new ContentManager();			lineMgr = new LineManager();			positionMgr = new PositionManager(this);			undoMgr = new UndoManager(this);			integerArray = new IntegerArray();			propertyLock = new Object();			properties = new HashMap<Object, PropValue>();				//{{{ need to convert entries of 'props' to PropValue instances			Set<Map.Entry> set = props.entrySet();			for (Map.Entry entry : set)			{				properties.put(entry.getKey(),new PropValue(entry.getValue(),false));			} //}}}				// fill in defaults for these from system properties if the			// corresponding buffer.XXX properties not set			if(getProperty(ENCODING) == null)				properties.put(ENCODING,new PropValue(System.getProperty("file.encoding"),false));			if(getProperty(LINESEP) == null)				properties.put(LINESEP,new PropValue(System.getProperty("line.separator"),false));		}	
/**		 * Create a new JEditBuffer.		 * It is used by independent textarea only		 */		public JEditBuffer()		{			bufferListeners = new Vector<Listener>();			undoListeners = new Vector<BufferUndoListener>();			lock = new ReentrantReadWriteLock();			contentMgr = new ContentManager();			lineMgr = new LineManager();			positionMgr = new PositionManager(this);			undoMgr = new UndoManager(this);			integerArray = new IntegerArray();			propertyLock = new Object();			properties = new HashMap<Object, PropValue>();				properties.put("wrap",new PropValue("none",false));			properties.put("folding",new PropValue("none",false));			tokenMarker = new TokenMarker();			tokenMarker.addRuleSet(new ParserRuleSet("text","MAIN"));			setTokenMarker(tokenMarker);				loadText(null,null);			// corresponding buffer.XXX properties not set			if(getProperty(ENCODING) == null)				properties.put(ENCODING,new PropValue(System.getProperty("file.encoding"),false));			if(getProperty(LINESEP) == null)				properties.put(LINESEP,new PropValue(System.getProperty("line.separator"),false));				setFoldHandler(new DummyFoldHandler());		}	
/**		 * Returns whether there have been unsaved changes to this buffer.		 * This method is thread-safe.		 */		public boolean isDirty()		{			return dirty;		}	
public boolean isLoading()		{			return loading;		}	
public void setLoading(boolean loading)		{			this.loading = loading;		}	
/**		 * Returns true if the buffer is currently performing I/O.		 * This method is thread-safe.		 * @since jEdit 2.7pre1		 */		public boolean isPerformingIO()		{			return isLoading() || io;		}	
/**		 * Returns true if the buffer is currently performing I/O.		 * This method is thread-safe.		 * @since jEdit 2.7pre1		 */		public void setPerformingIO(boolean io)		{			this.io = io;		}	
/**		 * Returns true if this file is editable, false otherwise. A file may		 * become uneditable if it is read only, or if I/O is in progress.		 * This method is thread-safe.		 * @since jEdit 2.7pre1		 */		public boolean isEditable()		{			return !(isReadOnly() || isPerformingIO());		}	
/**		 * Returns true if this file is read only, false otherwise.		 * This method is thread-safe.		 */		public boolean isReadOnly()		{			return readOnly || readOnlyOverride;		}	
/**		 * Sets the read only flag.		 * @param readOnly The read only flag		 */		public void setReadOnly(boolean readOnly)		{			readOnlyOverride = readOnly;		}	
/**		 * Sets the 'dirty' (changed since last save) flag of this buffer.		 */		public void setDirty(boolean d)		{			boolean editable = isEditable();				if(d)			{				if(editable)					dirty = true;			}			else			{				dirty = false;					// fixes dirty flag not being reset on				// save/insert/undo/redo/undo				if(!isUndoInProgress())				{					// this ensures that undo can clear the dirty flag properly					// when all edits up to a save are undone					undoMgr.resetClearDirty();				}			}		}	
/**		 * The buffer is guaranteed not to change between calls to		 * {@link #readLock()} and {@link #readUnlock()}.		 */		public void readLock()		{			lock.readLock().lock();		}	
/**		 * The buffer is guaranteed not to change between calls to		 * {@link #readLock()} and {@link #readUnlock()}.		 */		public void readUnlock()		{			lock.readLock().unlock();		}	
/**		 * Attempting to obtain read lock will block between calls to		 * {@link #writeLock()} and {@link #writeUnlock()}.		 */		public void writeLock()		{			lock.writeLock().lock();		}	
/**		 * Attempting to obtain read lock will block between calls to		 * {@link #writeLock()} and {@link #writeUnlock()}.		 */		public void writeUnlock()		{			lock.writeLock().unlock();		}	
/**		 * Returns the number of characters in the buffer. This method is thread-safe.		 */		public int getLength()		{			// no need to lock since this just returns a value and that's it			return contentMgr.getLength();		}	
/**		 * Returns the number of physical lines in the buffer.		 * This method is thread-safe.		 * @since jEdit 3.1pre1		 */		public int getLineCount()		{			// no need to lock since this just returns a value and that's it			return lineMgr.getLineCount();		}	
/**		 * Returns the line containing the specified offset.		 * This method is thread-safe.		 * @param offset The offset		 * @since jEdit 4.0pre1		 */		public int getLineOfOffset(int offset)		{			try			{				readLock();					if(offset < 0 || offset > getLength())					throw new ArrayIndexOutOfBoundsException(offset);					return lineMgr.getLineOfOffset(offset);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the start offset of the specified line.		 * This method is thread-safe.		 * @param line The line		 * @return The start offset of the specified line		 * @since jEdit 4.0pre1		 */		public int getLineStartOffset(int line)		{			try			{				readLock();					if(line < 0 || line >= lineMgr.getLineCount())					throw new ArrayIndexOutOfBoundsException(line);				else if(line == 0)					return 0;					return lineMgr.getLineEndOffset(line - 1);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the end offset of the specified line.		 * This method is thread-safe.		 * @param line The line		 * @return The end offset of the specified line		 * invalid.		 * @since jEdit 4.0pre1		 */		public int getLineEndOffset(int line)		{			try			{				readLock();					if(line < 0 || line >= lineMgr.getLineCount())					throw new ArrayIndexOutOfBoundsException(line);					return lineMgr.getLineEndOffset(line);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the length of the specified line.		 * This method is thread-safe.		 * @param line The line		 * @since jEdit 4.0pre1		 */		public int getLineLength(int line)		{			try			{				readLock();					return getLineEndOffset(line)					- getLineStartOffset(line) - 1;			}			finally			{				readUnlock();			}		}	
/**		 * Auto indent needs this.		 */		public int getPriorNonEmptyLine(int lineIndex)		{			int returnValue = -1;				if (!mode.getIgnoreWhitespace())			{				return lineIndex - 1;			}				for(int i = lineIndex - 1; i >= 0; i--)			{				Segment seg = new Segment();				getLineText(i,seg);				if(seg.count != 0)					returnValue = i;				for(int j = 0; j < seg.count; j++)				{					char ch = seg.array[seg.offset + j];					if(!Character.isWhitespace(ch))						return i;				}			}				// didn't find a line that contains non-whitespace chars			// so return index of prior whitespace line			return returnValue;		}	
/**		 * Returns the text on the specified line.		 * This method is thread-safe.		 * @param line The line		 * @return The text, or null if the line is invalid		 * @since jEdit 4.0pre1		 */		public String getLineText(int line)		{			if(line < 0 || line >= lineMgr.getLineCount())				throw new ArrayIndexOutOfBoundsException(line);				try			{				readLock();					int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);				int end = lineMgr.getLineEndOffset(line);					return getText(start,end - start - 1);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the specified line in a <code>Segment</code>.<p>		 *		 * Using a <classname>Segment</classname> is generally more		 * efficient than using a <classname>String</classname> because it		 * results in less memory allocation and array copying.<p>		 *		 * This method is thread-safe.		 *		 * @param line The line		 * @since jEdit 4.0pre1		 */		public void getLineText(int line, Segment segment)		{			if(line < 0 || line >= lineMgr.getLineCount())				throw new ArrayIndexOutOfBoundsException(line);				try			{				readLock();					int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);				int end = lineMgr.getLineEndOffset(line);					getText(start,end - start - 1,segment);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the text on the specified line.		 * This method is thread-safe.		 *		 * @param line The line index.		 * @return The text, or null if the line is invalid		 *		 * @since jEdit 4.3pre15		 */		public CharSequence getLineSegment(int line)		{			if(line < 0 || line >= lineMgr.getLineCount())				throw new ArrayIndexOutOfBoundsException(line);				try			{				readLock();					int start = line == 0 ? 0 : lineMgr.getLineEndOffset(line - 1);				int end = lineMgr.getLineEndOffset(line);					return getSegment(start,end - start - 1);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the specified text range. This method is thread-safe.		 * @param start The start offset		 * @param length The number of characters to get		 */		public String getText(int start, int length)		{			try			{				readLock();					if(start < 0 || length < 0					|| start + length > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(start + ":" + length);					return contentMgr.getText(start,length);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the specified text range in a <code>Segment</code>.<p>		 *		 * Using a <classname>Segment</classname> is generally more		 * efficient than using a <classname>String</classname> because it		 * results in less memory allocation and array copying.<p>		 *		 * This method is thread-safe.		 *		 * @param start The start offset		 * @param length The number of characters to get		 * @param seg The segment to copy the text to		 */		public void getText(int start, int length, Segment seg)		{			try			{				readLock();					if(start < 0 || length < 0					|| start + length > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(start + ":" + length);					contentMgr.getText(start,length,seg);			}			finally			{				readUnlock();			}		}	
/**		 * Returns the specified text range. This method is thread-safe.		 *		 * @param start The start offset		 * @param length The number of characters to get		 *		 * @since jEdit 4.3pre15		 */		public CharSequence getSegment(int start, int length)		{			try			{				readLock();					if(start < 0 || length < 0					|| start + length > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(start + ":" + length);					return contentMgr.getSegment(start,length);			}			finally			{				readUnlock();			}		}	
/**		 * Inserts a string into the buffer.		 * @param offset The offset		 * @param str The string		 * @since jEdit 4.0pre1		 */		public void insert(int offset, String str)		{			if(str == null)				return;				int len = str.length();				if(len == 0)				return;				if(isReadOnly())				throw new RuntimeException("buffer read-only");				try			{				writeLock();					if(offset < 0 || offset > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(offset);					contentMgr.insert(offset,str);					integerArray.clear();					for(int i = 0; i < len; i++)				{					if(str.charAt(i) == '\n')						integerArray.add(i + 1);				}					if(!undoInProgress)				{					undoMgr.contentInserted(offset,len,str,!dirty);				}					contentInserted(offset,len,integerArray);			}			finally			{				writeUnlock();			}		}	
/**		 * Inserts a string into the buffer.		 * @param offset The offset		 * @param seg The segment		 * @since jEdit 4.0pre1		 */		public void insert(int offset, Segment seg)		{			if(seg.count == 0)				return;				if(isReadOnly())				throw new RuntimeException("buffer read-only");				try			{				writeLock();					if(offset < 0 || offset > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(offset);					contentMgr.insert(offset,seg);					integerArray.clear();					for(int i = 0; i < seg.count; i++)				{					if(seg.array[seg.offset + i] == '\n')						integerArray.add(i + 1);				}					if(!undoInProgress)				{					undoMgr.contentInserted(offset,seg.count,						seg.toString(),!dirty);				}					contentInserted(offset,seg.count,integerArray);			}			finally			{				writeUnlock();			}		}	
/**		 * Removes the specified rang efrom the buffer.		 * @param offset The start offset		 * @param length The number of characters to remove		 */		public void remove(int offset, int length)		{			if(length == 0)				return;				if(isReadOnly())				throw new RuntimeException("buffer read-only");				try			{				transaction = true;					writeLock();					if(offset < 0 || length < 0					|| offset + length > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(offset + ":" + length);					int startLine = lineMgr.getLineOfOffset(offset);				int endLine = lineMgr.getLineOfOffset(offset + length);					int numLines = endLine - startLine;					if(!undoInProgress && !loading)				{					undoMgr.contentRemoved(offset,length,						getText(offset,length),						!dirty);				}					firePreContentRemoved(startLine,offset,numLines,length);					contentMgr.remove(offset,length);				lineMgr.contentRemoved(startLine,offset,numLines,length);				positionMgr.contentRemoved(offset,length);					fireContentRemoved(startLine,offset,numLines,length);					/* otherwise it will be delivered later */				if(!undoInProgress && !insideCompoundEdit())					fireTransactionComplete();					setDirty(true);			}			finally			{				transaction = false;					writeUnlock();			}		}	
/**		 * Removes trailing whitespace from all lines in the specified list.		 * @param lines The line numbers		 * @since jEdit 3.2pre1		 */		public void removeTrailingWhiteSpace(int[] lines)		{			try			{				beginCompoundEdit();					for(int i = 0; i < lines.length; i++)				{					int pos, lineStart, lineEnd, tail;					Segment seg = new Segment();					getLineText(lines[i],seg);						// blank line					if (seg.count == 0) continue;						lineStart = seg.offset;					lineEnd = seg.offset + seg.count - 1;						for (pos = lineEnd; pos >= lineStart; pos--)					{						if (!Character.isWhitespace(seg.array[pos]))							break;					}						tail = lineEnd - pos;						// no whitespace					if (tail == 0) continue;						remove(getLineEndOffset(lines[i]) - 1 - tail,tail);				}			}			finally			{				endCompoundEdit();			}		}	
/**		 * Shifts the indent of each line in the specified list to the left.		 * @param lines The line numbers		 * @since jEdit 3.2pre1		 */		public void shiftIndentLeft(int[] lines)		{			int tabSize = getTabSize();			int indentSize = getIndentSize();			boolean noTabs = getBooleanProperty("noTabs");				try			{				beginCompoundEdit();					for(int i = 0; i < lines.length; i++)				{					int lineStart = getLineStartOffset(lines[i]);					CharSequence line = getLineSegment(lines[i]);					int whiteSpace = StandardUtilities						.getLeadingWhiteSpace(line);					if(whiteSpace == 0)						continue;					int whiteSpaceWidth = Math.max(0,StandardUtilities						.getLeadingWhiteSpaceWidth(line,tabSize)						- indentSize);						insert(lineStart + whiteSpace,StandardUtilities						.createWhiteSpace(whiteSpaceWidth,						noTabs ? 0 : tabSize));					remove(lineStart,whiteSpace);				}				}			finally			{				endCompoundEdit();			}		}	
/**		 * Shifts the indent of each line in the specified list to the right.		 * @param lines The line numbers		 * @since jEdit 3.2pre1		 */		public void shiftIndentRight(int[] lines)		{			try			{				beginCompoundEdit();					int tabSize = getTabSize();				int indentSize = getIndentSize();				boolean noTabs = getBooleanProperty("noTabs");				for(int i = 0; i < lines.length; i++)				{					int lineStart = getLineStartOffset(lines[i]);					CharSequence line = getLineSegment(lines[i]);					int whiteSpace = StandardUtilities						.getLeadingWhiteSpace(line);						// silly usability hack					//if(lines.length != 1 && whiteSpace == 0)					//	continue;						int whiteSpaceWidth = StandardUtilities						.getLeadingWhiteSpaceWidth(						line,tabSize) + indentSize;					insert(lineStart + whiteSpace,StandardUtilities						.createWhiteSpace(whiteSpaceWidth,						noTabs ? 0 : tabSize));					remove(lineStart,whiteSpace);				}			}			finally			{				endCompoundEdit();			}		}	
/**		 * Indents all specified lines.		 * @param start The first line to indent		 * @param end The last line to indent		 * @since jEdit 3.1pre3		 */		public void indentLines(int start, int end)		{			try			{				beginCompoundEdit();				for(int i = start; i <= end; i++)					indentLine(i,true);			}			finally			{				endCompoundEdit();			}		}	
/**		 * Indents all specified lines.		 * @param lines The line numbers		 * @since jEdit 3.2pre1		 */		public void indentLines(int[] lines)		{			try			{				beginCompoundEdit();				for(int i = 0; i < lines.length; i++)					indentLine(lines[i],true);			}			finally			{				endCompoundEdit();			}		}	
/**		 * @deprecated Use {@link #indentLine(int,boolean)} instead.		 */		 @Deprecated		 public boolean indentLine(int lineIndex, boolean canIncreaseIndent,			boolean canDecreaseIndent)		{			return indentLine(lineIndex,canDecreaseIndent);		}	
/**		 * Indents the specified line.		 * @param lineIndex The line number to indent		 * @param canDecreaseIndent If true, the indent can be decreased as a		 * result of this. Set this to false for Tab key.		 * @return true If indentation took place, false otherwise.		 * @since jEdit 4.2pre2		 */		public boolean indentLine(int lineIndex, boolean canDecreaseIndent)		{			int[] whitespaceChars = new int[1];			int currentIndent = getCurrentIndentForLine(lineIndex,				whitespaceChars);			int prevLineIndex = getPriorNonEmptyLine(lineIndex);			int prevLineIndent = (prevLineIndex == -1) ? 0 :				StandardUtilities.getLeadingWhiteSpaceWidth(getLineSegment(					prevLineIndex), getTabSize());			int idealIndent = getIdealIndentForLine(lineIndex, prevLineIndex,				prevLineIndent);				if (idealIndent == -1 || idealIndent == currentIndent ||				(!canDecreaseIndent && idealIndent < currentIndent))				return false;				// Do it			try			{				beginCompoundEdit();					int start = getLineStartOffset(lineIndex);					remove(start,whitespaceChars[0]);				String prevIndentString = (prevLineIndex >= 0) ?					StandardUtilities.getIndentString(getLineText(						prevLineIndex)) : null;				String indentString;				if (prevIndentString == null)				{					indentString = StandardUtilities.createWhiteSpace(						idealIndent,						getBooleanProperty("noTabs") ? 0 : getTabSize());				}				else if (idealIndent == prevLineIndent)					indentString = prevIndentString;				else if (idealIndent < prevLineIndent)					indentString = StandardUtilities.truncateWhiteSpace(						idealIndent, getTabSize(), prevIndentString);				else					indentString = prevIndentString +						StandardUtilities.createWhiteSpace(							idealIndent - prevLineIndent,							getBooleanProperty("noTabs") ? 0 : getTabSize(),							prevLineIndent);				insert(start, indentString);			}			finally			{				endCompoundEdit();			}				return true;		}	
/**		 * Returns the line's current leading indent.		 * @param lineIndex The line number		 * @param whitespaceChars If this is non-null, the number of whitespace		 * characters is stored at the 0 index		 * @since jEdit 4.2pre2		 */		public int getCurrentIndentForLine(int lineIndex, int[] whitespaceChars)		{			Segment seg = new Segment();			getLineText(lineIndex,seg);				int tabSize = getTabSize();				int currentIndent = 0;	loop:		for(int i = 0; i < seg.count; i++)			{				char c = seg.array[seg.offset + i];				switch(c)				{				case ' ':					currentIndent++;					if(whitespaceChars != null)						whitespaceChars[0]++;					break;				case '\t':					currentIndent += tabSize - (currentIndent						% tabSize);					if(whitespaceChars != null)						whitespaceChars[0]++;					break;				default:					break loop;				}			}				return currentIndent;		}	
/**		 * Returns the ideal leading indent for the specified line.		 * This will apply the various auto-indent rules.		 * @param lineIndex The line number		 */		public int getIdealIndentForLine(int lineIndex)		{			int prevLineIndex = getPriorNonEmptyLine(lineIndex);			int oldIndent = prevLineIndex == -1 ? 0 :				StandardUtilities.getLeadingWhiteSpaceWidth(				getLineSegment(prevLineIndex),				getTabSize());			return getIdealIndentForLine(lineIndex, prevLineIndex,				oldIndent);		}	
/**		 * Returns the ideal leading indent for the specified line.		 * This will apply the various auto-indent rules.		 * @param lineIndex The line number		 * @param prevLineIndex The index of the previous non-empty line		 * @param oldIndent The indent width of the previous line (or 0)		 */		private int getIdealIndentForLine(int lineIndex, int prevLineIndex,			int oldIndent)		{			int prevPrevLineIndex = prevLineIndex < 0 ? -1				: getPriorNonEmptyLine(prevLineIndex);			int newIndent = oldIndent;				List<IndentRule> indentRules = getIndentRules(lineIndex);			List<IndentAction> actions = new LinkedList<IndentAction>();			for (int i = 0;i<indentRules.size();i++)			{				IndentRule rule = indentRules.get(i);				rule.apply(this,lineIndex,prevLineIndex,					prevPrevLineIndex,actions);			}					for (IndentAction action : actions)			{				newIndent = action.calculateIndent(this, lineIndex,						oldIndent, newIndent);				if (!action.keepChecking())					break;			}			if (newIndent < 0)				newIndent = 0;				return newIndent;		}	
/**		 * Returns the virtual column number (taking tabs into account) of the		 * specified position.		 *		 * @param line The line number		 * @param column The column number		 * @since jEdit 4.1pre1		 */		public int getVirtualWidth(int line, int column)		{			try			{				readLock();					int start = getLineStartOffset(line);				Segment seg = new Segment();				getText(start,column,seg);					return StandardUtilities.getVirtualWidth(seg,getTabSize());			}			finally			{				readUnlock();			}		}	
/**		 * Returns the offset of a virtual column number (taking tabs		 * into account) relative to the start of the line in question.		 *		 * @param line The line number		 * @param column The virtual column number		 * @param totalVirtualWidth If this array is non-null, the total		 * virtual width will be stored in its first location if this method		 * returns -1.		 *		 * @return -1 if the column is out of bounds		 *		 * @since jEdit 4.1pre1		 */		public int getOffsetOfVirtualColumn(int line, int column,			int[] totalVirtualWidth)		{			try			{				readLock();					Segment seg = new Segment();				getLineText(line,seg);					return StandardUtilities.getOffsetOfVirtualColumn(seg,					getTabSize(),column,totalVirtualWidth);			}			finally			{				readUnlock();			}		}	
/**		 * Like the {@link #insert(int,String)} method, but inserts the string at		 * the specified virtual column. Inserts spaces as appropriate if		 * the line is shorter than the column.		 * @param line The line number		 * @param col The virtual column number		 * @param str The string		 */		public void insertAtColumn(int line, int col, String str)		{			try			{				writeLock();					int[] total = new int[1];				int offset = getOffsetOfVirtualColumn(line,col,total);				if(offset == -1)				{					offset = getLineEndOffset(line) - 1;					str = StandardUtilities.createWhiteSpace(col - total[0],0) + str;				}				else					offset += getLineStartOffset(line);					insert(offset,str);			}			finally			{				writeUnlock();			}		}	
/**		 * Inserts a string into the buffer, indenting each line of the string		 * to match the indent of the first line.		 *		 * @param offset The offset		 * @param text The text		 *		 * @return The number of characters of indent inserted on each new		 * line. This is used by the abbreviations code.		 *		 * @since jEdit 4.2pre14		 */		public int insertIndented(int offset, String text)		{			try			{				beginCompoundEdit();					// obtain the leading indent for later use				int firstLine = getLineOfOffset(offset);				CharSequence lineText = getLineSegment(firstLine);				int leadingIndent					= StandardUtilities.getLeadingWhiteSpaceWidth(					lineText,getTabSize());					String whiteSpace = StandardUtilities.createWhiteSpace(					leadingIndent,getBooleanProperty("noTabs")					? 0 : getTabSize());					insert(offset,text);					int lastLine = getLineOfOffset(offset + text.length());					// note that if firstLine == lastLine, loop does not				// execute				for(int i = firstLine + 1; i <= lastLine; i++)				{					insert(getLineStartOffset(i),whiteSpace);				}					return whiteSpace.length();			}			finally			{				endCompoundEdit();			}		}	
/**		 * Should inserting this character trigger a re-indent of		 * the current line?		 * @since jEdit 4.3pre2		 * @deprecated Use #isElectricKey(char,int)		 */		public boolean isElectricKey(char ch)		{			return mode.isElectricKey(ch);		}	
/**		 * Should inserting this character trigger a re-indent of		 * the current line?		 * @since jEdit 4.3pre9		 */		public boolean isElectricKey(char ch, int line)		{			TokenMarker.LineContext ctx = lineMgr.getLineContext(line);			Mode mode = ModeProvider.instance.getMode(ctx.rules.getModeName());				// mode can be null, though that's probably an error "further up":			if (mode == null)				return false;			return mode.isElectricKey(ch);		}	
/**		 * Returns the syntax tokens for the specified line.		 * @param lineIndex The line number		 * @param tokenHandler The token handler that will receive the syntax		 * tokens		 * @since jEdit 4.1pre1		 */		public void markTokens(int lineIndex, TokenHandler tokenHandler)		{			Segment seg = new Segment();				if(lineIndex < 0 || lineIndex >= lineMgr.getLineCount())				throw new ArrayIndexOutOfBoundsException(lineIndex);				int firstInvalidLineContext = lineMgr.getFirstInvalidLineContext();			int start;			if(textMode || firstInvalidLineContext == -1)			{				start = lineIndex;			}			else			{				start = Math.min(firstInvalidLineContext,					lineIndex);			}				if(Debug.TOKEN_MARKER_DEBUG)				Log.log(Log.DEBUG,this,"tokenize from " + start + " to " + lineIndex);			TokenMarker.LineContext oldContext = null;			TokenMarker.LineContext context = null;			for(int i = start; i <= lineIndex; i++)			{				getLineText(i,seg);					oldContext = lineMgr.getLineContext(i);					TokenMarker.LineContext prevContext = (					(i == 0 || textMode) ? null					: lineMgr.getLineContext(i - 1)				);					context = tokenMarker.markTokens(prevContext,					(i == lineIndex ? tokenHandler					: DummyTokenHandler.INSTANCE), seg);				lineMgr.setLineContext(i,context);			}				int lineCount = lineMgr.getLineCount();			if(lineCount - 1 == lineIndex)				lineMgr.setFirstInvalidLineContext(-1);			else if(oldContext != context)				lineMgr.setFirstInvalidLineContext(lineIndex + 1);			else if(firstInvalidLineContext == -1)				/* do nothing */;			else			{				lineMgr.setFirstInvalidLineContext(Math.max(					firstInvalidLineContext,lineIndex + 1));			}		}	
public TokenMarker getTokenMarker()		{			return tokenMarker;		}	
public void setTokenMarker(TokenMarker tokenMarker)		{			TokenMarker oldTokenMarker = this.tokenMarker;				this.tokenMarker = tokenMarker;				// don't do this on initial token marker			if(oldTokenMarker != null && tokenMarker != oldTokenMarker)			{				lineMgr.setFirstInvalidLineContext(0);			}		}	
/**		 * Creates a floating position.		 * @param offset The offset		 */		public Position createPosition(int offset)		{			try			{				readLock();					if(offset < 0 || offset > contentMgr.getLength())					throw new ArrayIndexOutOfBoundsException(offset);					return positionMgr.createPosition(offset);			}			finally			{				readUnlock();			}		}	
/**		 * Reloads settings from the properties. This should be called		 * after the <code>syntax</code> or <code>folding</code>		 * buffer-local properties are changed.		 */		public void propertiesChanged()		{			String folding = getStringProperty("folding");			FoldHandler handler = FoldHandler.getFoldHandler(folding);				if(handler != null)			{				setFoldHandler(handler);			}			else			{				if (folding != null)					Log.log(Log.WARNING, this, "invalid 'folding' property: " + folding);				setFoldHandler(new DummyFoldHandler());			}		}	
/**		 * Returns the tab size used in this buffer. This is equivalent		 * to calling <code>getProperty("tabSize")</code>.		 * This method is thread-safe.		 */		public int getTabSize()		{			int tabSize = getIntegerProperty("tabSize",8);			if(tabSize <= 0)				return 8;			else				return tabSize;		}	
/**		 * Returns the indent size used in this buffer. This is equivalent		 * to calling <code>getProperty("indentSize")</code>.		 * This method is thread-safe.		 * @since jEdit 2.7pre1		 */		public int getIndentSize()		{			int indentSize = getIntegerProperty("indentSize",8);			if(indentSize <= 0)				return 8;			else				return indentSize;		}	
/**		 * Returns the value of a buffer-local property.<p>		 *		 * Using this method is generally discouraged, because it returns an		 * <code>Object</code> which must be cast to another type		 * in order to be useful, and this can cause problems if the object		 * is of a different type than what the caller expects.<p>		 *		 * The following methods should be used instead:		 * <ul>		 * <li>{@link #getStringProperty(String)}</li>		 * <li>{@link #getBooleanProperty(String)}</li>		 * <li>{@link #getIntegerProperty(String,int)}</li>		 * </ul>		 *		 * This method is thread-safe.		 *		 * @param name The property name. For backwards compatibility, this		 * is an <code>Object</code>, not a <code>String</code>.		 */		public Object getProperty(Object name)		{			synchronized(propertyLock)			{				// First try the buffer-local properties				PropValue o = properties.get(name);				if(o != null)					return o.value;					// For backwards compatibility				if(!(name instanceof String))					return null;					Object retVal = getDefaultProperty((String)name);					if(retVal == null)					return null;				else				{					properties.put(name,new PropValue(retVal,true));					return retVal;				}			}		}	
public Object getDefaultProperty(String key)		{			return null;		}	
/**		 * Sets the value of a buffer-local property.		 * @param name The property name		 * @param value The property value		 * @since jEdit 4.0pre1		 */		public void setProperty(String name, Object value)		{			if(value == null)				properties.remove(name);			else			{				PropValue test = properties.get(name);				if(test == null)					properties.put(name,new PropValue(value,false));				else if(test.value.equals(value))				{					// do nothing				}				else				{					test.value = value;					test.defaultValue = false;				}			}		}	
public void setDefaultProperty(String name, Object value)		{			properties.put(name,new PropValue(value,true));		}	
/**		 * Clears the value of a buffer-local property.		 * @param name The property name		 * @since jEdit 4.0pre1		 */		public void unsetProperty(String name)		{			properties.remove(name);		}	
public void resetCachedProperties()		{			// Need to reset properties that were cached defaults,			// since the defaults might have changed.			Iterator<PropValue> iter = properties.values().iterator();			while(iter.hasNext())			{				PropValue value = iter.next();				if(value.defaultValue)					iter.remove();			}		}	
/**		 * Returns the value of a string property. This method is thread-safe.		 * @param name The property name		 * @since jEdit 4.0pre1		 */		public String getStringProperty(String name)		{			Object obj = getProperty(name);			if(obj != null)				return obj.toString();			else				return null;		}	
/**		 * Sets a string property.		 * @param name The property name		 * @param value The value		 * @since jEdit 4.0pre1		 */		public void setStringProperty(String name, String value)		{			setProperty(name,value);		}	
/**		 * Returns the value of a boolean property. This method is thread-safe.		 * @param name The property name		 * @since jEdit 4.0pre1		 */		public boolean getBooleanProperty(String name)		{			return getBooleanProperty(name, false);		}	
/**		 * Returns the value of a boolean property. This method is thread-safe.		 * @param name The property name		 * @param def The default value		 * @since jEdit 4.3pre17		 */		public boolean getBooleanProperty(String name, boolean def)		{			Object obj = getProperty(name);			return StandardUtilities.getBoolean(obj, def);		}	
/**		 * Sets a boolean property.		 * @param name The property name		 * @param value The value		 * @since jEdit 4.0pre1		 */		public void setBooleanProperty(String name, boolean value)		{			setProperty(name,value ? Boolean.TRUE : Boolean.FALSE);		}	
/**		 * Returns the value of an integer property. This method is thread-safe.		 * @param name The property name		 * @since jEdit 4.0pre1		 */		public int getIntegerProperty(String name, int defaultValue)		{			boolean defaultValueFlag;			Object obj;			PropValue value = properties.get(name);			if(value != null)			{				obj = value.value;				defaultValueFlag = value.defaultValue;			}			else			{				obj = getProperty(name);				// will be cached from now on...				defaultValueFlag = true;			}				if(obj == null)				return defaultValue;			else if(obj instanceof Number)				return ((Number)obj).intValue();			else			{				try				{					int returnValue = Integer.parseInt(						obj.toString().trim());					properties.put(name,new PropValue(						returnValue,						defaultValueFlag));					return returnValue;				}				catch(Exception e)				{					return defaultValue;				}			}		}	
/**		 * Sets an integer property.		 * @param name The property name		 * @param value The value		 * @since jEdit 4.0pre1		 */		public void setIntegerProperty(String name, int value)		{			setProperty(name,value);		}	
/**		 * Returns the value of a property as a regular expression.		 * This method is thread-safe.		 * @param name The property name		 * @param flags Regular expression compilation flags		 * @since jEdit 4.3pre5		 */		public Pattern getPatternProperty(String name, int flags)		{			synchronized(propertyLock)			{				boolean defaultValueFlag;				Object obj;				PropValue value = properties.get(name);				if(value != null)				{					obj = value.value;					defaultValueFlag = value.defaultValue;				}				else				{					obj = getProperty(name);					// will be cached from now on...					defaultValueFlag = true;				}					if(obj == null)					return null;				else if (obj instanceof Pattern)					return (Pattern) obj;				else				{					Pattern re = Pattern.compile(obj.toString(),flags);					properties.put(name,new PropValue(re,						defaultValueFlag));					return re;				}			}		}	
/**		 * Returns the syntax highlighting ruleset at the specified offset.		 * @since jEdit 4.1pre1		 */		public ParserRuleSet getRuleSetAtOffset(int offset)		{			int line = getLineOfOffset(offset);			offset -= getLineStartOffset(line);			if(offset != 0)				offset--;				DefaultTokenHandler tokens = new DefaultTokenHandler();			markTokens(line,tokens);			Token token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);			return token.rules;		}	
/**		 * Returns the syntax highlighting keyword map in effect at the		 * specified offset. Used by the <b>Complete Word</b> command to		 * complete keywords.		 * @param offset The offset		 * @since jEdit 4.0pre3		 */		public KeywordMap getKeywordMapAtOffset(int offset)		{			return getRuleSetAtOffset(offset).getKeywords();		}	
/**		 * Some settings, like comment start and end strings, can		 * vary between different parts of a buffer (HTML text and inline		 * JavaScript, for example).		 * @param offset The offset		 * @param name The property name		 * @since jEdit 4.0pre3		 */		public String getContextSensitiveProperty(int offset, String name)		{			ParserRuleSet rules = getRuleSetAtOffset(offset);				Object value = null;				Map<String, String> rulesetProps = rules.getProperties();			if(rulesetProps != null)				value = rulesetProps.get(name);				if(value == null)				return null;			else				return String.valueOf(value);		}	
/**		 * Returns this buffer's edit mode. This method is thread-safe.		 */		public Mode getMode()		{			return mode;		}	
/**		 * Sets this buffer's edit mode. Note that calling this before a buffer		 * is loaded will have no effect; in that case, set the "mode" property		 * to the name of the mode. A bit inelegant, I know...		 * @param mode The mode name		 * @since jEdit 4.2pre1		 */		public void setMode(String mode)		{			setMode(ModeProvider.instance.getMode(mode));		}	
/**		 * Sets this buffer's edit mode. Note that calling this before a buffer		 * is loaded will have no effect; in that case, set the "mode" property		 * to the name of the mode. A bit inelegant, I know...		 * @param mode The mode		 */		public void setMode(Mode mode)		{			/* This protects against stupid people (like me)			 * doing stuff like buffer.setMode(jEdit.getMode(...)); */			if(mode == null)				throw new NullPointerException("Mode must be non-null");				this.mode = mode;				textMode = "text".equals(mode.getName());				setTokenMarker(mode.getTokenMarker());				resetCachedProperties();			propertiesChanged();		}	
/**		 * Returns if the specified line begins a fold.		 * @since jEdit 3.1pre1		 */		public boolean isFoldStart(int line)		{			return line != getLineCount() - 1				&& getFoldLevel(line) < getFoldLevel(line + 1);		}	
/**		 * Returns if the specified line ends a fold.		 * @since jEdit 4.2pre5		 */		public boolean isFoldEnd(int line)		{			return line != getLineCount() - 1				&& getFoldLevel(line) > getFoldLevel(line + 1);		}	
/**		 * Invalidates all cached fold level information.		 * @since jEdit 4.1pre11		 */		public void invalidateCachedFoldLevels()		{			lineMgr.setFirstInvalidFoldLevel(0);			fireFoldLevelChanged(0,getLineCount());		}	
/**		 * Returns the fold level of the specified line.		 * @param line A physical line index		 * @since jEdit 3.1pre1		 */		public int getFoldLevel(int line)		{			if(line < 0 || line >= lineMgr.getLineCount())				throw new ArrayIndexOutOfBoundsException(line);				if(foldHandler instanceof DummyFoldHandler)				return 0;				int firstInvalidFoldLevel = lineMgr.getFirstInvalidFoldLevel();			if(firstInvalidFoldLevel == -1 || line < firstInvalidFoldLevel)			{				return lineMgr.getFoldLevel(line);			}			else			{				if(Debug.FOLD_DEBUG)					Log.log(Log.DEBUG,this,"Invalid fold levels from " + firstInvalidFoldLevel + " to " + line);					int newFoldLevel = 0;				boolean changed = false;				int firstUpdatedFoldLevel = firstInvalidFoldLevel;					for(int i = firstInvalidFoldLevel; i <= line; i++)				{					Segment seg = new Segment();					newFoldLevel = foldHandler.getFoldLevel(this,i,seg);					if(newFoldLevel != lineMgr.getFoldLevel(i))					{						if(Debug.FOLD_DEBUG)							Log.log(Log.DEBUG,this,i + " fold level changed");						changed = true;						// Update preceding fold levels if necessary						if (i == firstInvalidFoldLevel)						{							List<Integer> precedingFoldLevels =								foldHandler.getPrecedingFoldLevels(									this,i,seg,newFoldLevel);							if (precedingFoldLevels != null)							{								int j = i;								for (Integer foldLevel: precedingFoldLevels)								{									j--;									lineMgr.setFoldLevel(j,foldLevel.intValue());								}								if (j < firstUpdatedFoldLevel)									firstUpdatedFoldLevel = j;							}						}					}					lineMgr.setFoldLevel(i,newFoldLevel);				}					if(line == lineMgr.getLineCount() - 1)					lineMgr.setFirstInvalidFoldLevel(-1);				else					lineMgr.setFirstInvalidFoldLevel(line + 1);					if(changed)				{					if(Debug.FOLD_DEBUG)						Log.log(Log.DEBUG,this,"fold level changed: " + firstUpdatedFoldLevel + ',' + line);					fireFoldLevelChanged(firstUpdatedFoldLevel,line);				}					return newFoldLevel;			}		}	
/**		 * Returns an array. The first element is the start line, the		 * second element is the end line, of the fold containing the		 * specified line number.		 * @param line The line number		 * @since jEdit 4.0pre3		 */		public int[] getFoldAtLine(int line)		{			int start, end;				if(isFoldStart(line))			{				start = line;				int foldLevel = getFoldLevel(line);					line++;					while(getFoldLevel(line) > foldLevel)				{					line++;						if(line == getLineCount())						break;				}					end = line - 1;			}			else			{				start = line;				int foldLevel = getFoldLevel(line);				while(getFoldLevel(start) >= foldLevel)				{					if(start == 0)						break;					else						start--;				}					end = line;				while(getFoldLevel(end) >= foldLevel)				{					end++;						if(end == getLineCount())						break;				}					end--;			}				while(getLineLength(end) == 0 && end > start)				end--;				return new int[] { start, end };		}	
/**		 * Returns the current buffer's fold handler.		 * @since jEdit 4.2pre1		 */		public FoldHandler getFoldHandler()		{			return foldHandler;		}	
/**		 * Sets the buffer's fold handler.		 * @since jEdit 4.2pre2		 */		public void setFoldHandler(FoldHandler foldHandler)		{			FoldHandler oldFoldHandler = this.foldHandler;				if(foldHandler.equals(oldFoldHandler))				return;				this.foldHandler = foldHandler;				lineMgr.setFirstInvalidFoldLevel(0);				fireFoldHandlerChanged();		}	
/**		 * Undoes the most recent edit.		 *		 * @since jEdit 4.0pre1		 */		public void undo(TextArea textArea)		{			if(undoMgr == null)				return;				if(!isEditable())			{				textArea.getToolkit().beep();				return;			}				try			{				writeLock();					undoInProgress = true;				fireBeginUndo();				int caret = undoMgr.undo();				if(caret == -1)					textArea.getToolkit().beep();				else					textArea.setCaretPosition(caret);					fireEndUndo();				fireTransactionComplete();			}			finally			{				undoInProgress = false;					writeUnlock();			}		}	
/**		 * Redoes the most recently undone edit.		 *		 * @since jEdit 2.7pre2		 */		public void redo(TextArea textArea)		{			if(undoMgr == null)				return;				if(!isEditable())			{				Toolkit.getDefaultToolkit().beep();				return;			}				try			{				writeLock();					undoInProgress = true;				fireBeginRedo();				int caret = undoMgr.redo();				if(caret == -1)					textArea.getToolkit().beep();				else					textArea.setCaretPosition(caret);					fireEndRedo();				fireTransactionComplete();			}			finally			{				undoInProgress = false;					writeUnlock();			}		}	
/**		 * Returns if an undo or compound edit is currently in progress. If this		 * method returns true, then eventually a		 * {@link org.gjt.sp.jedit.buffer.BufferListener#transactionComplete(JEditBuffer)}		 * buffer event will get fired.		 * @since jEdit 4.0pre6		 */		public boolean isTransactionInProgress()		{			return transaction || undoInProgress || insideCompoundEdit();		}	
/**		 * Starts a compound edit. All edits from now on until		 * {@link #endCompoundEdit()} are called will be merged		 * into one. This can be used to make a complex operation		 * undoable in one step. Nested calls to		 * {@link #beginCompoundEdit()} behave as expected,		 * requiring the same number of {@link #endCompoundEdit()}		 * calls to end the edit.		 * @see #endCompoundEdit()		 */		public void beginCompoundEdit()		{			try			{				writeLock();					undoMgr.beginCompoundEdit();			}			finally			{				writeUnlock();			}		}	
/**		 * Ends a compound edit. All edits performed since		 * {@link #beginCompoundEdit()} was called can now		 * be undone in one step by calling {@link #undo(TextArea)}.		 * @see #beginCompoundEdit()		 */		public void endCompoundEdit()		{			try			{				writeLock();					undoMgr.endCompoundEdit();					if(!insideCompoundEdit())					fireTransactionComplete();			}			finally			{				writeUnlock();			}		}	
/**		 * Returns if a compound edit is currently active.		 * @since jEdit 3.1pre1		 */		public boolean insideCompoundEdit()		{			return undoMgr.insideCompoundEdit();		}	
/**		 * Returns if an undo or redo is currently being performed.		 * @since jEdit 4.3pre3		 */		public boolean isUndoInProgress()		{			return undoInProgress;		}	
/**		 * Returns an object that identifies the undo operation to which the		 * current content change belongs. This method can be used by buffer		 * listeners during content changes (contentInserted/contentRemoved)		 * to find out which content changes belong to the same "undo" operation.		 * The same undoId object will be returned for all content changes		 * belonging to the same undo operation. Only the identity of the		 * undoId can be used, by comparing it with a previously-returned undoId		 * using "==".		 * @since jEdit 4.3pre18		 */		public Object getUndoId()		{			return undoMgr.getUndoId();		}	
Listener(BufferListener listener, int priority)			{				this.listener = listener;				this.priority = priority;			}	
/**		 * Adds a buffer change listener.		 * @param listener The listener		 * @param priority Listeners with HIGH_PRIORITY get the event before		 * listeners with NORMAL_PRIORITY		 * @since jEdit 4.3pre3		 */		public void addBufferListener(BufferListener listener,			int priority)		{			Listener l = new Listener(listener,priority);			for(int i = 0; i < bufferListeners.size(); i++)			{				Listener _l = bufferListeners.get(i);				if(_l.priority < priority)				{					bufferListeners.add(i,l);					return;				}			}			bufferListeners.add(l);		}	
/**		 * Adds a buffer change listener.		 * @param listener The listener		 * @since jEdit 4.3pre3		 */		public void addBufferListener(BufferListener listener)		{			addBufferListener(listener,NORMAL_PRIORITY);		}	
/**		 * Removes a buffer change listener.		 * @param listener The listener		 * @since jEdit 4.3pre3		 */		public void removeBufferListener(BufferListener listener)		{			for(int i = 0; i < bufferListeners.size(); i++)			{				if(bufferListeners.get(i).listener == listener)				{					bufferListeners.remove(i);					return;				}			}		}	
/**		 * Returns an array of registered buffer change listeners.		 * @since jEdit 4.3pre3		 */		public BufferListener[] getBufferListeners()		{			BufferListener[] returnValue				= new BufferListener[				bufferListeners.size()];			for(int i = 0; i < returnValue.length; i++)			{				returnValue[i] = bufferListeners.get(i).listener;			}			return returnValue;		}	
/**		 * Adds a buffer undo listener.		 * @param listener The listener		 * @since jEdit 4.3pre18		 */		public void addBufferUndoListener(BufferUndoListener listener)		{			undoListeners.add(listener);		}	
/**		 * Removes a buffer undo listener.		 * @param listener The listener		 * @since jEdit 4.3pre18		 */		public void removeBufferUndoListener(BufferUndoListener listener)		{			undoListeners.remove(listener);		}	
/**		 * Set the undo limit of the Undo Manager.		 *		 * @param limit the new limit		 * @since jEdit 4.3pre16		 */		public void setUndoLimit(int limit)		{			if (undoMgr != null)				undoMgr.setLimit(limit);		}	
/**		 * Returns true if an undo operation can be performed.		 * @since jEdit 4.3pre18		 */		public boolean canUndo()		{			if (undoMgr == null)				return false;			return undoMgr.canUndo();		}	
/**		 * Returns true if a redo operation can be performed.		 * @since jEdit 4.3pre18		 */		public boolean canRedo()		{			if (undoMgr == null)				return false;			return undoMgr.canRedo();		}	
protected void fireFoldLevelChanged(int start, int end)		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.foldLevelChanged(this,start,end);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireContentInserted(int startLine, int offset,			int numLines, int length)		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.contentInserted(this,startLine,						offset,numLines,length);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireContentRemoved(int startLine, int offset,			int numLines, int length)		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.contentRemoved(this,startLine,						offset,numLines,length);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void firePreContentInserted(int startLine, int offset,			int numLines, int length)		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.preContentInserted(this,startLine,						offset,numLines,length);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void firePreContentRemoved(int startLine, int offset,			int numLines, int length)		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.preContentRemoved(this,startLine,						offset,numLines,length);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireBeginUndo()		{			for (BufferUndoListener listener: undoListeners)			{				try				{					listener.beginUndo(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer undo event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireEndUndo()		{			for (BufferUndoListener listener: undoListeners)			{				try				{					listener.endUndo(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer undo event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireBeginRedo()		{			for (BufferUndoListener listener: undoListeners)			{				try				{					listener.beginRedo(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer begin redo event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireEndRedo()		{			for (BufferUndoListener listener: undoListeners)			{				try				{					listener.endRedo(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer end redo event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireTransactionComplete()		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.transactionComplete(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireFoldHandlerChanged()		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.foldHandlerChanged(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected void fireBufferLoaded()		{			for(int i = 0; i < bufferListeners.size(); i++)			{				BufferListener listener = getListener(i);				try				{					listener.bufferLoaded(this);				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Exception while sending buffer event to "+ listener +" :");					Log.log(Log.ERROR,this,t);				}			}		}	
protected boolean isFileReadOnly()		{			return readOnly;		}	
protected void setFileReadOnly(boolean readOnly)		{			this.readOnly = readOnly;		}	
protected void loadText(Segment seg, IntegerArray endOffsets)		{			if(seg == null)				seg = new Segment(new char[1024],0,0);				if(endOffsets == null)			{				endOffsets = new IntegerArray();				endOffsets.add(1);			}				try			{				writeLock();					// For `reload' command				// contentMgr.remove() changes this!				int length = getLength();					firePreContentRemoved(0,0,getLineCount()					- 1,length);					contentMgr.remove(0,length);				lineMgr.contentRemoved(0,0,getLineCount()					- 1,length);				positionMgr.contentRemoved(0,length);				fireContentRemoved(0,0,getLineCount()					- 1,length);					firePreContentInserted(0, 0, endOffsets.getSize() - 1, seg.count - 1);				// theoretically a segment could				// have seg.offset != 0 but				// SegmentBuffer never does that				contentMgr._setContent(seg.array,seg.count);					lineMgr._contentInserted(endOffsets);				positionMgr.contentInserted(0,seg.count);					fireContentInserted(0,0,					endOffsets.getSize() - 1,					seg.count - 1);			}			finally			{				writeUnlock();			}		}	
protected void invalidateFoldLevels()		{			lineMgr.setFirstInvalidFoldLevel(0);		}	
protected void parseBufferLocalProperties()		{			int lastLine = Math.min(9,getLineCount() - 1);			parseBufferLocalProperties(getSegment(0,getLineEndOffset(lastLine) - 1));				// first line for last 10 lines, make sure not to overlap			// with the first 10			int firstLine = Math.max(lastLine + 1, getLineCount() - 10);			if(firstLine < getLineCount())			{				int length = getLineEndOffset(getLineCount() - 1)					- (getLineStartOffset(firstLine) + 1);				parseBufferLocalProperties(getSegment(getLineStartOffset(firstLine),length));			}		}	
PropValue(Object value, boolean defaultValue)			{				if(value == null)					throw new NullPointerException();				this.value = value;				this.defaultValue = defaultValue;			}	
/**			 * For debugging purposes.			 */			public String toString()			{				return value.toString();			}	
private BufferListener getListener(int index)		{			return bufferListeners.get(index).listener;		}	
private void contentInserted(int offset, int length,			IntegerArray endOffsets)		{			try			{				transaction = true;					int startLine = lineMgr.getLineOfOffset(offset);				int numLines = endOffsets.getSize();					if (!loading)				{					firePreContentInserted(startLine, offset, numLines, length);				}					lineMgr.contentInserted(startLine,offset,numLines,length,					endOffsets);				positionMgr.contentInserted(offset,length);					setDirty(true);					if(!loading)				{					fireContentInserted(startLine,offset,numLines,length);						if(!undoInProgress && !insideCompoundEdit())						fireTransactionComplete();				}				}			finally			{				transaction = false;			}		}	
private void parseBufferLocalProperties(CharSequence prop)		{			StringBuilder buf = new StringBuilder();			String name = null;			boolean escape = false;			for(int i = 0; i < prop.length(); i++)			{				char c = prop.charAt(i);				switch(c)				{				case ':':					if(escape)					{						escape = false;						buf.append(':');						break;					}					if(name != null)					{						// use the low-level property setting code						// so that if we have a buffer-local						// property with the same value as a default,						// later changes in the default don't affect						// the buffer-local property						properties.put(name,new PropValue(buf.toString(),false));						name = null;					}					buf.setLength(0);					break;				case '=':					if(escape)					{						escape = false;						buf.append('=');						break;					}					name = buf.toString();					buf.setLength(0);					break;				case '\\':					if(escape)						buf.append('\\');					escape = !escape;					break;				case 'n':					if(escape)					{	buf.append('\n');						escape = false;						break;					}				case 'r':					if(escape)					{	buf.append('\r');						escape = false;						break;					}				case 't':					if(escape)					{						buf.append('\t');						escape = false;						break;					}				default:					buf.append(c);					break;				}			}		}	
private List<IndentRule> getIndentRules(int line)		{			String modeName = null;			TokenMarker.LineContext ctx = lineMgr.getLineContext(line);			if (ctx != null && ctx.rules != null)				modeName = ctx.rules.getModeName();			if (modeName == null)				modeName = tokenMarker.getMainRuleSet().getModeName();			return ModeProvider.instance.getMode(modeName).getIndentRules();		}	
/**		 * Instantiate a TextArea.		 */		public JEditEmbeddedTextArea()		{			super(jEdit.getPropertyManager(), null);			initInputHandler();			EditPane.initPainter(getPainter());			JEditBuffer buffer = new JEditBuffer();			buffer.setMode(ModeProvider.instance.getMode("text"));			setBuffer(buffer);		}	
public Map<String, HistoryModel> load(Map<String, HistoryModel> models)		{			String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory == null)				return models;				history = new File(MiscUtilities.constructPath(				settingsDirectory,"history"));			if(!history.exists())				return models;				historyModTime = history.lastModified();				Log.log(Log.MESSAGE,HistoryModel.class,"Loading history");				if(models == null)				models = Collections.synchronizedMap(new HashMap<String, HistoryModel>());				BufferedReader in = null;			try			{				// Try loading with UTF-8 and fallback to the system				// default encoding to load a history which was made by				// an old version as well.				try				{					// Pass the decoder explicitly to report a decode error					// as an exception instead of replacing with \xFFFD.					in = new BufferedReader(new InputStreamReader(						new FileInputStream(history),						Charset.forName("UTF-8").newDecoder()));					models.putAll(loadFromReader(in));				}				catch(CharacterCodingException e)				{					// It seems to be made by an old version of jEdit.					in.close();					Log.log(Log.MESSAGE,HistoryModel.class,						"Failed to load history with UTF-8." +						" Fallbacking to the system default encoding.");						in = new BufferedReader(new FileReader(history));					models.putAll(loadFromReader(in));				}			}			catch(FileNotFoundException fnf)			{				//Log.log(Log.DEBUG,HistoryModel.class,fnf);			}			catch(IOException io)			{				Log.log(Log.ERROR,HistoryModel.class,io);			}			finally			{				IOUtilities.closeQuietly(in);			}			return models;		}	
public boolean save(Map<String, HistoryModel> models)		{			Log.log(Log.MESSAGE,HistoryModel.class,"Saving history");			File file1 = new File(MiscUtilities.constructPath(				jEdit.getSettingsDirectory(), "#history#save#"));			File file2 = new File(MiscUtilities.constructPath(				jEdit.getSettingsDirectory(), "history"));			if(file2.exists() && file2.lastModified() != historyModTime)			{				Log.log(Log.WARNING,HistoryModel.class,file2					+ " changed on disk; will not save history");				return false;			}				jEdit.backupSettingsFile(file2);				String lineSep = System.getProperty("line.separator");				BufferedWriter out = null;				try			{				out = new BufferedWriter(new OutputStreamWriter(					new FileOutputStream(file1), "UTF-8"));					if(models != null)				{					Collection<HistoryModel> values = models.values();					for (HistoryModel model : values)					{						if(model.getSize() == 0)							continue;							out.write('[');						out.write(StandardUtilities.charsToEscapes(							model.getName(),TO_ESCAPE));						out.write(']');						out.write(lineSep);							for(int i = 0; i < model.getSize(); i++)						{							out.write(StandardUtilities.charsToEscapes(								model.getItem(i),								TO_ESCAPE));							out.write(lineSep);						}					}				}					out.close();					/* to avoid data loss, only do this if the above				 * completed successfully */				file2.delete();				file1.renameTo(file2);			}			catch(IOException io)			{				Log.log(Log.ERROR,HistoryModel.class,io);			}			finally			{				IOUtilities.closeQuietly(out);			}				historyModTime = file2.lastModified();			return true;		}	
private static Map<String, HistoryModel> loadFromReader(BufferedReader in)			throws IOException		{			Map<String, HistoryModel> result = new HashMap<String, HistoryModel>();				HistoryModel currentModel = null;			String line;				while((line = in.readLine()) != null)			{				if(line.length() > 0 && line.charAt(0) == '[' && line.charAt(line.length() - 1) == ']')				{					if(currentModel != null)					{						result.put(currentModel.getName(),							currentModel);					}						String modelName = MiscUtilities						.escapesToChars(line.substring(						1,line.length() - 1));					currentModel = new HistoryModel(						modelName);				}				else if(currentModel == null)				{					throw new IOException("History data starts"						+ " before model name");				}				else				{					currentModel.addElement(MiscUtilities						.escapesToChars(line));				}			}				if(currentModel != null)			{				result.put(currentModel.getName(),currentModel);			}				return result;		}	
JEditKillRing()		{			String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory != null)			{				killringXML = new SettingsXML(settingsDirectory, "killring");			}		}	
@Override		public void load()		{			if(killringXML == null)				return;				if(!killringXML.fileExists())				return;				Log.log(Log.MESSAGE,KillRing.class,"Loading " + killringXML);				KillRingHandler handler = new KillRingHandler();			try			{				killringXML.load(handler);			}			catch (IOException ioe)			{				Log.log(Log.ERROR, this, ioe);			}			reset(handler.list);		}	
@Override		public void save()		{			if(killringXML == null)				return;				if(killringXML.hasChangedOnDisk())			{				Log.log(Log.WARNING,KillRing.class,killringXML					+ " changed on disk; will not save killring"					+ " files");				return;			}				Log.log(Log.MESSAGE,KillRing.class,"Saving " + killringXML);				String lineSep = System.getProperty("line.separator");				SettingsXML.Saver out = null;				try			{				out = killringXML.openSaver();				out.writeXMLDeclaration("1.1");					out.write("<!DOCTYPE KILLRING SYSTEM \"killring.dtd\">");				out.write(lineSep);				out.write("<KILLRING>");				out.write(lineSep);					int size = getSize();				for(int i = size - 1; i >=0; i--)				{					out.write("<ENTRY>");					out.write(XMLUtilities.charsToEntities(						getElementAt(i).toString(),true));					out.write("</ENTRY>");					out.write(lineSep);				}					out.write("</KILLRING>");				out.write(lineSep);					out.finish();			}			catch(Exception e)			{				Log.log(Log.ERROR,KillRing.class,e);			}			finally			{				IOUtilities.closeQuietly(out);			}		}	
@Override			public InputSource resolveEntity(String publicId, String systemId)			{				return XMLUtilities.findEntity(systemId, "killring.dtd", getClass());			}	
@Override			public void startElement(String uri, String localName,						 String qName, Attributes attrs)			{				inEntry = qName.equals("ENTRY");			}	
@Override			public void endElement(String uri, String localName, String name)			{				if(name.equals("ENTRY"))				{					list.add(charData.toString());					inEntry = false;					charData.setLength(0);				}			}	
@Override			public void characters(char[] ch, int start, int length)			{				if (inEntry)					charData.append(ch, start, length);			}	
@Override			public void processingInstruction(String target, String data)			{				if ("illegal-xml-character".equals(target))				{					char ch;					try					{						ch = (char)Integer.parseInt(data.trim());					}					catch (Exception e)					{						Log.log(Log.ERROR, this,							"Failed to get character from PI"								+ "\"" + target + "\""								+ " with \"" + data + "\""								+ ": " + e);						return;					}					characters(new char[] {ch}, 0, 1);				}			}	
JEditMode(String name)		{			super(name);		}	
/**		 * Returns a mode property.		 *		 * @param key The property name		 * @since jEdit 4.3pre10		 */		@Override		public Object getProperty(String key)		{			String prefix = "mode." + name + '.';				//if(jEdit.getBooleanProperty(prefix + "customSettings"))			//{				String property = jEdit.getProperty(prefix + key);				if(property != null)				{					Object value;					try					{						value = new Integer(property);					}					catch(NumberFormatException nf)					{						value = property;					}					return value;				}			//}				Object value = props.get(key);			if(value != null)				return value;				String global = jEdit.getProperty("buffer." + key);			if(global != null)			{				try				{					return new Integer(global);				}				catch(NumberFormatException nf)				{					return global;				}			}			else				return null;		}	
/**		 * Loads the mode from disk if it hasn't been loaded already.		 * @since jEdit 4.3pre10		 */		@Override		public void loadIfNecessary()		{			if(marker == null)			{				jEdit.loadMode(this);				if (marker == null)					Log.log(Log.ERROR, this, "Mode not correctly loaded, token marker is still null");			}		}	
JEditRegisterSaver()		{			String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory != null)			{				registersXML = new SettingsXML(settingsDirectory, "registers");			}		}	
public void loadRegisters()		{			if(registersXML == null)				return;				if(!registersXML.fileExists())				return;				Log.log(Log.MESSAGE,jEdit.class,"Loading " + registersXML);				RegistersHandler handler = new RegistersHandler();			try			{				Registers.setLoading(true);				registersXML.load(handler);			}			catch (IOException ioe)			{				Log.log(Log.ERROR, Registers.class, ioe);			}			finally			{				Registers.setLoading(false);			}		}	
public void saveRegisters()		{			if(registersXML == null)				return;				if(registersXML.hasChangedOnDisk())			{				Log.log(Log.WARNING,Registers.class,registersXML					+ " changed on disk; will not save registers");				return;			}				Log.log(Log.MESSAGE,Registers.class,"Saving " + registersXML);				String lineSep = System.getProperty("line.separator");				SettingsXML.Saver out = null;				try			{				out = registersXML.openSaver();				out.writeXMLDeclaration();					out.write("<!DOCTYPE REGISTERS SYSTEM \"registers.dtd\">");				out.write(lineSep);				out.write("<REGISTERS>");				out.write(lineSep);					Registers.Register[] registers = Registers.getRegisters();				for(int i = 0; i < registers.length; i++)				{					Registers.Register register = registers[i];					if(register == null ||					   i == '$' ||					   i == '%' ||					   register.toString().length() == 0)						continue;						out.write("<REGISTER NAME=\"");					if(i == '"')						out.write("&quot;");					else						out.write((char)i);					out.write("\">");						out.write(XMLUtilities.charsToEntities(						register.toString(), false));						out.write("</REGISTER>");					out.write(lineSep);				}					out.write("</REGISTERS>");				out.write(lineSep);					out.finish();			}			catch(Exception e)			{				Log.log(Log.ERROR,Registers.class,e);			}			finally			{				IOUtilities.closeQuietly(out);			}		}	
@Override			public InputSource resolveEntity(String publicId, String systemId)			{				return XMLUtilities.findEntity(systemId, "registers.dtd", getClass());			}	
@Override			public void startElement(String uri, String localName,						 String qName, Attributes attrs)			{				registerName = attrs.getValue("NAME");				inRegister = "REGISTER".equals(qName);			}	
@Override			public void endElement(String uri, String localName, String name)			{				if("REGISTER".equals(name))				{					if(registerName == null || registerName.length() != 1)						Log.log(Log.ERROR,this,"Malformed NAME: " + registerName);					else						Registers.setRegister(registerName.charAt(0),charData.toString());					inRegister = false;					charData.setLength(0);				}			}	
@Override			public void characters(char[] ch, int start, int length)			{				if (inRegister)					charData.append(ch, start, length);			}	
public void registerChanged(char name)		{			EditBus.send(new RegisterChanged(null, name));		}	
/**		 * Creates a new JEditTextArea.		 */		public JEditTextArea(View view)		{			super(jEdit.getPropertyManager(), view);			enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);			this.view = view;		}	
@Override		public FoldPainter getFoldPainter()		{			FoldPainter foldPainter = (FoldPainter) ServiceManager.getService(					FOLD_PAINTER_SERVICE, getFoldPainterName());			if (foldPainter == null)				foldPainter = (FoldPainter) ServiceManager.getService(					FOLD_PAINTER_SERVICE,					DEFAULT_FOLD_PAINTER_SERVICE);			return foldPainter;		}	
/**		 * On subsequent invocations, first moves the caret to the first		 * non-whitespace character of the line, then the beginning of the		 * line, then to the first visible line.		 * @since jEdit 2.7pre2		 */		@Override		public void smartHome(boolean select)		{			Macros.Recorder recorder = view.getMacroRecorder();				switch(view.getInputHandler().getLastActionCount())			{			case 1:				if(recorder != null)					recorder.record("textArea.goToStartOfWhiteSpace(" + select + ");");					goToStartOfWhiteSpace(select);				break;			case 2:				if(recorder != null)					recorder.record("textArea.goToStartOfLine(" + select + ");");					goToStartOfLine(select);				break;			default: //case 3:				if(recorder != null)					recorder.record("textArea.goToFirstVisibleLine(" + select + ");");					goToFirstVisibleLine(select);				break;			}		}	
/**		 * On subsequent invocations, first moves the caret to the last		 * non-whitespace character of the line, then the end of the		 * line, then to the last visible line.		 * @since jEdit 2.7pre2		 */		@Override		public void smartEnd(boolean select)		{			Macros.Recorder recorder = view.getMacroRecorder();				switch(view.getInputHandler().getLastActionCount())			{			case 1:				if(recorder != null)					recorder.record("textArea.goToEndOfWhiteSpace(" + select + ");");					goToEndOfWhiteSpace(select);				break;			case 2:				if(recorder != null)					recorder.record("textArea.goToEndOfLine(" + select + ");");					goToEndOfLine(select);				break;			default: //case 3:				if(recorder != null)					recorder.record("textArea.goToLastVisibleLine(" + select + ");");				goToLastVisibleLine(select);				break;			}		}	
public void goToBufferEnd(boolean select)		{			EditBus.send(new PositionChanging(this));			super.goToBufferEnd(select);		}	
/**		 * Moves the caret to the bracket matching the one before the caret.		 * Also sends PositionChanging if it goes somewhere.		 * @since jEdit 4.3pre18		 */		public void goToMatchingBracket()		{			if(getLineLength(caretLine) != 0)			{				int dot = caret - getLineStartOffset(caretLine);					int bracket = TextUtilities.findMatchingBracket(					buffer,caretLine,Math.max(0,dot - 1));				if(bracket != -1)				{					EditBus.send(new PositionChanging(this));					selectNone();					moveCaretPosition(bracket + 1,false);					return;				}			}			getToolkit().beep();		}	
public void goToBufferStart(boolean select)		{			EditBus.send(new PositionChanging(this));			super.goToBufferStart(select);		}	
@Override		public int replaceSelection(String selectedText)		{			EditBus.send(new PositionChanging(this));			return super.replaceSelection(selectedText);		}	
/**		 * Displays the 'go to line' dialog box, and moves the caret to the		 * specified line number.		 * @since jEdit 2.7pre2		 */		public void showGoToLineDialog()		{			String line = GUIUtilities.input(view,"goto-line",null);			if(line == null)				return;				try			{				int lineNumber = Integer.parseInt(line) - 1;				EditBus.send(new PositionChanging(this));				setCaretPosition(getLineStartOffset(lineNumber));			}			catch(Exception e)			{				getToolkit().beep();			}		}	
/**		 * Handles the insertion of the specified character. It performs the		 * following operations in addition to TextArea#userInput(char):		 * <ul>		 * <li>Inserting a space with automatic abbrev expansion enabled will		 * try to expand the abbrev		 * </ul>		 *		 * @param ch The character		 * @since jEdit 2.7pre3		 */		@Override		public void userInput(char ch)		{			if(ch == ' ' && Abbrevs.getExpandOnInput()				&& Abbrevs.expandAbbrev(view,false))				return;				super.userInput(ch);		}	
/**		 * Surrounds the selection with explicit fold markers.		 * @since jEdit 4.0pre3		 */		@Override		public void addExplicitFold()		{			try			{				super.addExplicitFold();			}			catch (TextAreaException e)			{				GUIUtilities.error(view,"folding-not-explicit",null);			}		}	
/**		 * Formats the paragraph containing the caret.		 * @since jEdit 2.7pre2		 */		@Override		public void formatParagraph()		{			try			{				super.formatParagraph();			}			catch (TextAreaException e)			{				GUIUtilities.error(view,"format-maxlinelen",null);			}		}	
protected static void doWordCount(View view, String text)		{			char[] chars = text.toCharArray();			int characters = chars.length;			int words = 0;			int lines = 1;				boolean word = true;			for(int i = 0; i < chars.length; i++)			{				switch(chars[i])				{				case '\r': case '\n':					lines++;				case ' ': case '\t':					word = true;					break;				default:					if(word)					{						words++;						word = false;					}					break;				}			}				Object[] args = { characters, words, lines };			GUIUtilities.message(view,"wordcount",args);		}	
/**		 * Displays the 'word count' dialog box.		 * @since jEdit 2.7pre2		 */		public void showWordCountDialog()		{			String selection = getSelectedText();			if(selection != null)			{				doWordCount(view,selection);				return;			}				doWordCount(view,buffer.getText(0,buffer.getLength()));		}	
/**		 * Returns this text area's view.		 * @since jEdit 4.2pre5		 */		public View getView()		{			return view;		}	
/**		 * @deprecated Instead, obtain a Selection instance using		 * any means, and call its <code>getStart()</code> method		 */		@Deprecated		public final int getSelectionStart()		{			if(getSelectionCount() != 1)				return caret;				return getSelection(0).getStart();		}	
/**		 * @deprecated Instead, obtain a Selection instance using		 * any means, and call its <code>getStart(int)</code> method		 */		@Deprecated		public int getSelectionStart(int line)		{			if(getSelectionCount() != 1)				return caret;				return getSelection(0).getStart(buffer,line);		}	
/**		 * @deprecated Instead, obtain a Selection instance using		 * any means, and call its <code>getStartLine()</code> method		 */		@Deprecated		public final int getSelectionStartLine()		{			if(getSelectionCount() != 1)				return caret;				return getSelection(0).getStartLine();		}	
/**		 * @deprecated Do not use.		 */		@Deprecated		public final void setSelectionStart(int selectionStart)		{			int selectionEnd = getSelectionCount() == 1 ? getSelection(0).getEnd() : caret;			setSelection(new Selection.Range(selectionStart, selectionEnd));			moveCaretPosition(selectionEnd,true);		}	
/**		 * @deprecated Instead, obtain a Selection instance using		 * any means, and call its <code>getEnd()</code> method		 */		@Deprecated		public final int getSelectionEnd()		{			return getSelectionCount() == 1 ? getSelection(0).getEnd() : caret;			}	
/**		 * @deprecated Instead, obtain a Selection instance using		 * any means, and call its <code>getEnd(int)</code> method		 */		@Deprecated		public int getSelectionEnd(int line)		{			if(getSelectionCount() != 1)				return caret;				return getSelection(0).getEnd(buffer,line);		}	
/**		 * @deprecated Instead, obtain a Selection instance using		 * any means, and call its <code>getEndLine()</code> method		 */		@Deprecated		public final int getSelectionEndLine()		{			if(getSelectionCount() != 1)				return caret;				return getSelection(0).getEndLine();		}	
/**		 * @deprecated Do not use.		 */		@Deprecated		public final void setSelectionEnd(int selectionEnd)		{			int selectionStart = getSelectionCount() == 1 ?	getSelection(0).getStart() : caret;			setSelection(new Selection.Range(selectionStart, selectionEnd));			moveCaretPosition(selectionEnd,true);		}	
/**		 * @deprecated Instead, call either <code>addToSelection()</code>,		 * or <code>setSelection()</code> with a new Selection instance.		 */		@Deprecated		public void select(int start, int end)		{			setSelection(new Selection.Range(start, end));			moveCaretPosition(end,true);		}	
/**		 * @deprecated Instead, call either <code>addToSelection()</code>,		 * or <code>setSelection()</code> with a new Selection instance.		 */		@Deprecated		public void select(int start, int end, boolean doElectricScroll)		{			selectNone();				int newStart, newEnd;			if(start < end)			{				newStart = start;				newEnd = end;			}			else			{				newStart = end;				newEnd = start;			}				setSelection(new Selection.Range(newStart,newEnd));			moveCaretPosition(end,doElectricScroll);		}	
/**		 * @deprecated Instead, check if the appropriate Selection		 * is an instance of the Selection.Rect class.		 */		@Deprecated		public boolean isSelectionRectangular()		{			Selection s = getSelectionAtOffset(caret);			return s != null && s instanceof Selection.Rect;		}	
public static String getFoldPainterName()		{			return jEdit.getProperty(FOLD_PAINTER_PROPERTY, DEFAULT_FOLD_PAINTER_SERVICE);		}	
/**		 * Do the same thing as right-clicking on the text area. The Gestures		 * plugin uses this API.		 * @since jEdit 4.2pre13		 */		@Override		public void handlePopupTrigger(MouseEvent evt)		{				if(popup.isVisible())				popup.setVisible(false);			else			{				// Rebuild popup menu every time the menu is requested.				createPopupMenu(evt);					int x = evt.getX();				int y = evt.getY();					int dragStart = xyToOffset(x,y,					!(painter.isBlockCaretEnabled()					|| isOverwriteEnabled()));					if(getSelectionCount() == 0 || multi)					moveCaretPosition(dragStart,false);				GUIUtilities.showPopupMenu(popup,painter,x,y);			}		}	
/**		 * Creates the popup menu.		 * @since 4.3pre15		 */		@Override		public void createPopupMenu(MouseEvent evt)		{			popup = GUIUtilities.loadPopupMenu("view.context", this, evt);			JMenuItem customize = new JMenuItem(jEdit.getProperty(				"view.context.customize"));			customize.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					new GlobalOptions(view,"context");				}			});			popup.addSeparator();			popup.add(customize);		}	
/**		 * Shows the popup menu below the current caret position.		 * @since 4.3pre10		 */		@Override		public void showPopupMenu()		{			if (!popup.isVisible() && hasFocus())			{				Point caretPos = offsetToXY(getCaretPosition());				if (caretPos != null)				{					// Open the context menu below the caret					int charHeight = getPainter().getFontMetrics().getHeight();					GUIUtilities.showPopupMenu(popup,						painter,caretPos.x,caretPos.y + charHeight,true);				}			}		}	
/**		 * Visit a view.		 * @param view the visited view		 */		public void visit(View view)		{		}	
/**		 * Visit an EditPane.		 * @param editPane the visited edit pane		 */		public void visit(EditPane editPane)		{		}	
/**		 * Visit a JEditTextArea.		 * @param textArea the visited textArea		 */		public void visit(JEditTextArea textArea)		{		}	
JJTParserState() {	    nodes = new java.util.Stack();	    marks = new java.util.Stack();	    sp = 0;	    mk = 0;	  }	
boolean nodeCreated() {	    return node_created;	  }	
void reset() {	    nodes.removeAllElements();	    marks.removeAllElements();	    sp = 0;	    mk = 0;	  }	
Node rootNode() {	    return (Node)nodes.elementAt(0);	  }	
void pushNode(Node n) {	    nodes.push(n);	    ++sp;	  }	
Node popNode() {	    if (--sp < mk) {	      mk = ((Integer)marks.pop()).intValue();	    }	    return (Node)nodes.pop();	  }	
Node peekNode() {	    return (Node)nodes.peek();	  }	
int nodeArity() {	    return sp - mk;	  }	
void clearNodeScope(Node n) {	    while (sp > mk) {	      popNode();	    }	    mk = ((Integer)marks.pop()).intValue();	  }	
void openNodeScope(Node n) {	    marks.push(new Integer(mk));	    mk = sp;	    n.jjtOpen();	  }	
void closeNodeScope(Node n, int num) {	    mk = ((Integer)marks.pop()).intValue();	    while (num-- > 0) {	      Node c = popNode();	      c.jjtSetParent(n);	      n.jjtAddChild(c, num);	    }	    n.jjtClose();	    pushNode(n);	    node_created = true;	  }	
void closeNodeScope(Node n, boolean condition) {	    if (condition) {	      int a = nodeArity();	      mk = ((Integer)marks.pop()).intValue();	      while (a-- > 0) {		Node c = popNode();		c.jjtSetParent(n);		n.jjtAddChild(c, a);	      }	      n.jjtClose();	      pushNode(n);	      node_created = true;	    } else {	      mk = ((Integer)marks.pop()).intValue();	      node_created = false;	    }	  }	
JThis( NameSpace namespace, Interpreter declaringInterp ) { 			super( namespace, declaringInterp );		}	
public String toString() {			return "'this' reference (JThis) to Bsh object: " + namespace.getName();		}	
void event(String name, Object event)		{			CallStack callstack = new CallStack( namespace );			BshMethod method = null;				// handleEvent gets all events			try {				method = namespace.getMethod( 					"handleEvent", new Class [] { null } );			} catch ( UtilEvalError e ) {/*squeltch*/  }				if (method != null)				try {					method.invoke( 						new Object[] { event }, declaringInterpreter, callstack, null );				} catch(EvalError e) {					declaringInterpreter.error(						"local event hander method invocation error:" + e );				}				// send to specific event handler			try {				method = namespace.getMethod( name, new Class [] { null } );			} catch ( UtilEvalError e ) { /*squeltch*/ }			if (method != null)				try {					method.invoke( 						new Object[] { event }, declaringInterpreter, callstack, null );				} catch(EvalError e) {					declaringInterpreter.error(						"local event hander method invocation error:" + e );				}		}	
public void ancestorAdded(AncestorEvent e) { event("ancestorAdded", e); }	
public void ancestorRemoved(AncestorEvent e) { event("ancestorRemoved", e); }	
public void ancestorMoved(AncestorEvent e) { event("ancestorMoved", e); }	
public void caretUpdate(CaretEvent e) { event("caretUpdate", e); }	
public void editingStopped(ChangeEvent e) { event("editingStopped", e); }	
public void editingCanceled(ChangeEvent e) { event("editingCanceled", e); }	
public void stateChanged(ChangeEvent e) { event("stateChanged", e); }	
public void insertUpdate(DocumentEvent e) { event("insertUpdate", e); }	
public void removeUpdate(DocumentEvent e) { event("removeUpdate", e); }	
public void changedUpdate(DocumentEvent e) { event("changedUpdate", e); }	
public void hyperlinkUpdate(HyperlinkEvent e) { event("internalFrameOpened", e); }	
public void internalFrameOpened(InternalFrameEvent e) { event("internalFrameOpened", e); }	
public void internalFrameClosing(InternalFrameEvent e) { event("internalFrameClosing", e); }	
public void internalFrameClosed(InternalFrameEvent e) { event("internalFrameClosed", e); }	
public void internalFrameIconified(InternalFrameEvent e) { event("internalFrameIconified", e); }	
public void internalFrameDeiconified(InternalFrameEvent e) { event("internalFrameDeiconified", e); }	
public void internalFrameActivated(InternalFrameEvent e) { event("internalFrameActivated", e); }	
public void internalFrameDeactivated(InternalFrameEvent e) { event("internalFrameDeactivated", e); }	
public void intervalAdded(ListDataEvent e) { event("intervalAdded", e); }	
public void intervalRemoved(ListDataEvent e) { event("intervalRemoved", e); }	
public void contentsChanged(ListDataEvent e) { event("contentsChanged", e); }	
public void valueChanged(ListSelectionEvent e) { event("valueChanged", e); }	
public void menuDragMouseEntered(MenuDragMouseEvent e) { event("menuDragMouseEntered", e); }	
public void menuDragMouseExited(MenuDragMouseEvent e) { event("menuDragMouseExited", e); }	
public void menuDragMouseDragged(MenuDragMouseEvent e) { event("menuDragMouseDragged", e); }	
public void menuDragMouseReleased(MenuDragMouseEvent e) { event("menuDragMouseReleased", e); }	
public void menuKeyTyped(MenuKeyEvent e) { event("menuKeyTyped", e); }	
public void menuKeyPressed(MenuKeyEvent e) { event("menuKeyPressed", e); }	
public void menuKeyReleased(MenuKeyEvent e) { event("menuKeyReleased", e); }	
public void menuSelected(MenuEvent e) { event("menuSelected", e); }	
public void menuDeselected(MenuEvent e) { event("menuDeselected", e); }	
public void menuCanceled(MenuEvent e) { event("menuCanceled", e); }	
public void popupMenuWillBecomeVisible(PopupMenuEvent e) { event("popupMenuWillBecomeVisible", e); }	
public void popupMenuWillBecomeInvisible(PopupMenuEvent e) { event("popupMenuWillBecomeInvisible", e); }	
public void popupMenuCanceled(PopupMenuEvent e) { event("popupMenuCanceled", e); }	
public void columnAdded(TableColumnModelEvent e) { event("columnAdded", e); }	
public void columnRemoved(TableColumnModelEvent e) { event("columnRemoved", e); }	
public void columnMoved(TableColumnModelEvent e) { event("columnMoved", e); }	
public void columnMarginChanged(ChangeEvent e) { event("columnMarginChanged", e); }	
public void columnSelectionChanged(ListSelectionEvent e) { event("columnSelectionChanged", e); }	
public void tableChanged(TableModelEvent e) { event("tableChanged", e); }	
public void treeExpanded(TreeExpansionEvent e) { event("treeExpanded", e); }	
public void treeCollapsed(TreeExpansionEvent e) { event("treeCollapsed", e); }	
public void treeNodesChanged(TreeModelEvent e) { event("treeNodesChanged", e); }	
public void treeNodesInserted(TreeModelEvent e) { event("treeNodesInserted", e); }	
public void treeNodesRemoved(TreeModelEvent e) { event("treeNodesRemoved", e); }	
public void treeStructureChanged(TreeModelEvent e) { event("treeStructureChanged", e); }	
public void valueChanged(TreeSelectionEvent e) { event("valueChanged", e); }	
public void treeWillExpand(TreeExpansionEvent e) { event("treeWillExpand", e); }	
public void treeWillCollapse(TreeExpansionEvent e) { event("treeWillCollapse", e); }	
public void undoableEditHappened(UndoableEditEvent e) { event("undoableEditHappened", e); }	
public void actionPerformed(ActionEvent e) { event("actionPerformed", e); }	
public void adjustmentValueChanged(AdjustmentEvent e) { event("adjustmentValueChanged", e); }	
public void componentResized(ComponentEvent e) { event("componentResized", e); }	
public void componentMoved(ComponentEvent e) { event("componentMoved", e); }	
public void componentShown(ComponentEvent e) { event("componentShown", e); }	
public void componentHidden(ComponentEvent e) { event("componentHidden", e); }	
public void componentAdded(ContainerEvent e) { event("componentAdded", e); }	
public void componentRemoved(ContainerEvent e) { event("componentRemoved", e); }	
public void focusGained(FocusEvent e) { event("focusGained", e); }	
public void focusLost(FocusEvent e) { event("focusLost", e); }	
public void itemStateChanged(ItemEvent e) { event("itemStateChanged", e); }	
public void keyTyped(KeyEvent e) { event("keyTyped", e); }	
public void keyPressed(KeyEvent e) { event("keyPressed", e); }	
public void keyReleased(KeyEvent e) { event("keyReleased", e); }	
public void mouseClicked(MouseEvent e) { event("mouseClicked", e); }	
public void mousePressed(MouseEvent e) { event("mousePressed", e); }	
public void mouseReleased(MouseEvent e) { event("mouseReleased", e); }	
public void mouseEntered(MouseEvent e) { event("mouseEntered", e); }	
public void mouseExited(MouseEvent e) { event("mouseExited", e); }	
public void mouseDragged(MouseEvent e) { event("mouseDragged", e); }	
public void mouseMoved(MouseEvent e) { event("mouseMoved", e); }	
public void textValueChanged(TextEvent e) { event("textValueChanged", e); }	
public void windowOpened(WindowEvent e) { event("windowOpened", e); }	
public void windowClosing(WindowEvent e) { event("windowClosing", e); }	
public void windowClosed(WindowEvent e) { event("windowClosed", e); }	
public void windowIconified(WindowEvent e) { event("windowIconified", e); }	
public void windowDeiconified(WindowEvent e) { event("windowDeiconified", e); }	
public void windowActivated(WindowEvent e) { event("windowActivated", e); }	
public void windowDeactivated(WindowEvent e) { event("windowDeactivated", e); }	
public void propertyChange(PropertyChangeEvent e) { 			event("propertyChange", e ); }	
public void vetoableChange(PropertyChangeEvent e) {			event("vetoableChange", e ); }	
public boolean imageUpdate(java.awt.Image img, int infoflags,	                               int x, int y, int width, int height) {				BshMethod method = null;			try {				method = namespace.getMethod( "imageUpdate",					new Class [] { null, null, null, null, null, null } );			} catch ( UtilEvalError e ) {/*squeltch*/ }				if(method != null)				try {					CallStack callstack = new CallStack( namespace );					method.invoke( 						new Object[] { 							img, new Primitive(infoflags), new Primitive(x), 							new Primitive(y), new Primitive(width), 							new Primitive(height) }, 						declaringInterpreter, callstack, null					);				} catch(EvalError e) {					declaringInterpreter.error(						"local event handler imageUpdate: method invocation error:" + e );				}			return true;		}	
/**		 * Adds a keyboard translation.		 * @param key1 Translate this key		 * @param key2 Into this key		 * @since jEdit 4.2pre3		 */		public static void addTranslation(Key key1, Key key2)		{			transMap.put(key1,key2);		}	
/**		 * Pass this an event from {@link		 * KeyEventWorkaround#processKeyEvent(java.awt.event.KeyEvent)}.		 * @param evt the KeyEvent to translate		 * @since jEdit 4.2pre3		 */		public static Key translateKeyEvent(KeyEvent evt)		{			Key key = translateKeyEvent2(evt);				if (key!=null)			{				if (key.isPhantom())				{					key = null;				}			}				return key;		}	
/**		 * Pass this an event from {@link		 * KeyEventWorkaround#processKeyEvent(java.awt.event.KeyEvent)}.		 * @param evt the KeyEvent to translate		 * @since jEdit 4.2pre3		 */		public static Key translateKeyEvent2(KeyEvent evt)		{			int modifiers = evt.getModifiers();			Key returnValue;				switch(evt.getID())			{			case KeyEvent.KEY_PRESSED:				int keyCode = evt.getKeyCode();				if((keyCode >= KeyEvent.VK_0					&& keyCode <= KeyEvent.VK_9)					|| (keyCode >= KeyEvent.VK_A					&& keyCode <= KeyEvent.VK_Z))				{					if(Debug.ALTERNATIVE_DISPATCHER)						return null;					else					{						returnValue = new Key(							modifiersToString(modifiers),							'\0',Character.toLowerCase(							(char)keyCode));					}				}				else				{					if(keyCode == KeyEvent.VK_TAB)					{						evt.consume();						returnValue = new Key(							modifiersToString(modifiers),							keyCode,'\0');					}					else if(keyCode == KeyEvent.VK_SPACE)					{						// for SPACE or S+SPACE we pass the						// key typed since international						// keyboards sometimes produce a						// KEY_PRESSED SPACE but not a						// KEY_TYPED SPACE, eg if you have to						// do a "<space> to insert ".						if((modifiers & ~InputEvent.SHIFT_MASK) == 0)							returnValue = null;						else						{							returnValue = new Key(								modifiersToString(modifiers),								0,' ');						}					}					else					{						returnValue = new Key(							modifiersToString(modifiers),							keyCode,'\0');					}				}				break;			case KeyEvent.KEY_TYPED:				char ch = evt.getKeyChar();					if(KeyEventWorkaround.isMacControl(evt))					ch |= 0x60;					switch(ch)				{				case '\n':				case '\t':				case '\b':					return null;				case ' ':					if((modifiers & ~InputEvent.SHIFT_MASK) != 0)						return null;				}					int ignoreMods;				if(Debug.ALT_KEY_PRESSED_DISABLED)				{					/* on MacOS, A+ can be user input */					ignoreMods = InputEvent.SHIFT_MASK						| InputEvent.ALT_GRAPH_MASK						| InputEvent.ALT_MASK;				}				else				{					/* on MacOS, A+ can be user input */					ignoreMods = InputEvent.SHIFT_MASK						| InputEvent.ALT_GRAPH_MASK;				}					if((modifiers & InputEvent.ALT_GRAPH_MASK) == 0					&& (modifiers & ~ignoreMods) != 0)				{					if(Debug.ALTERNATIVE_DISPATCHER)					{						returnValue = new Key(							modifiersToString(modifiers),							0,ch);					}					else						return null;				}				else				{					if(ch == ' ')					{						returnValue = new Key(							modifiersToString(modifiers),							0,ch);					}					else						returnValue = new Key(null,0,ch);				}				break;			default:				return null;			}				/* I guess translated events do not have the 'evt' field set			so consuming won't work. I don't think this is a problem as			nothing uses translation anyway */			Key trans = transMap.get(returnValue);			if(trans == null)				return returnValue;			else				return trans;		}	
/**		 * Converts a string to a keystroke. The string should be of the		 * form <i>modifiers</i>+<i>shortcut</i> where <i>modifiers</i>		 * is any combination of A for Alt, C for Control, S for Shift		 * or M for Meta, and <i>shortcut</i> is either a single character,		 * or a keycode name from the <code>KeyEvent</code> class, without		 * the <code>VK_</code> prefix.		 * @param keyStroke A string description of the key stroke		 * @since jEdit 4.2pre3		 */		public static Key parseKey(String keyStroke)		{			if(keyStroke == null)				return null;			int modifiers = 0;			String key;			int endOfModifiers = keyStroke.indexOf('+');			if(endOfModifiers <= 0)	// not found or found at first			{				key = keyStroke;			}			else			{				for(int i = 0; i < endOfModifiers; i++)				{					switch(Character.toUpperCase(keyStroke						.charAt(i)))					{					case 'A':						modifiers |= a;						break;					case 'C':						modifiers |= c;						break;					case 'M':						modifiers |= m;						break;					case 'S':						modifiers |= s;						break;					}				}				key = keyStroke.substring(endOfModifiers + 1);			}			if(key.length() == 1)			{				return new Key(modifiersToString(modifiers),0,key.charAt(0));			}			else if(key.length() == 0)			{				Log.log(Log.ERROR,KeyEventTranslator.class,					"Invalid key stroke: " + keyStroke);				return null;			}			else if(key.equals("SPACE"))			{				return new Key(modifiersToString(modifiers),0,' ');			}			else			{				int ch;					try				{					ch = KeyEvent.class.getField("VK_".concat(key))						.getInt(null);				}				catch(Exception e)				{					Log.log(Log.ERROR,KeyEventTranslator.class,						"Invalid key stroke: "						+ keyStroke);					return null;				}					return new Key(modifiersToString(modifiers),ch,'\0');			}		}	
/**		 * Changes the mapping between symbolic modifier key names		 * (<code>C</code>, <code>A</code>, <code>M</code>, <code>S</code>) and		 * Java modifier flags.		 *		 * You can map more than one Java modifier to a symobolic modifier, for		 * example :		 * <p><code><pre>		 *	setModifierMapping(		 *		InputEvent.CTRL_MASK,		 *		InputEvent.ALT_MASK | InputEvent.META_MASK,		 *		0,		 *		InputEvent.SHIFT_MASK);		 *<pre></code></p>		 *		 * You cannot map a Java modifer to more than one symbolic modifier.		 *		 * @param c The modifier(s) to map the <code>C</code> modifier to		 * @param a The modifier(s) to map the <code>A</code> modifier to		 * @param m The modifier(s) to map the <code>M</code> modifier to		 * @param s The modifier(s) to map the <code>S</code> modifier to		 *		 * @since jEdit 4.2pre3		 */		public static void setModifierMapping(int c, int a, int m, int s)		{				int duplicateMapping =				(c & a) | (c & m) | (c & s) | (a & m) | (a & s) | (m & s);				if((duplicateMapping & InputEvent.CTRL_MASK) != 0)			{				throw new IllegalArgumentException(					"CTRL is mapped to more than one modifier");			}			if((duplicateMapping & InputEvent.ALT_MASK) != 0)			{				throw new IllegalArgumentException(					"ALT is mapped to more than one modifier");			}			if((duplicateMapping & InputEvent.META_MASK) != 0)			{				throw new IllegalArgumentException(					"META is mapped to more than one modifier");			}			if((duplicateMapping & InputEvent.SHIFT_MASK) != 0)			{				throw new IllegalArgumentException(					"SHIFT is mapped to more than one modifier");			}				KeyEventTranslator.c = c;			KeyEventTranslator.a = a;			KeyEventTranslator.m = m;			KeyEventTranslator.s = s;		}	
/**		 * Returns a the symbolic modifier name for the specified Java modifier		 * flag.		 *		 * @param mod A modifier constant from <code>InputEvent</code>		 *		 * @since jEdit 4.2pre3		 */		public static char getSymbolicModifierName(int mod)		{			if((mod & c) != 0)				return 'C';			else if((mod & a) != 0)				return 'A';			else if((mod & m) != 0)				return 'M';			else if((mod & s) != 0)				return 'S';			else				return '\0';		}	
public static String modifiersToString(int mods)		{			StringBuilder buf = null;				for(int i = 0; i < MODS.length; i++)			{				if((mods & MODS[i]) != 0)					buf = lazyAppend(buf,getSymbolicModifierName(MODS[i]));			}				if(buf == null)				return null;			else				return buf.toString();		}	
/**		 * Returns a string containing symbolic modifier names set in the		 * specified event.		 *		 * @param evt The event		 *		 * @since jEdit 4.2pre3		 */		public static String getModifierString(InputEvent evt)		{			StringBuilder buf = new StringBuilder();			if(evt.isControlDown())				buf.append(getSymbolicModifierName(InputEvent.CTRL_MASK));			if(evt.isAltDown())				buf.append(getSymbolicModifierName(InputEvent.ALT_MASK));			if(evt.isMetaDown())				buf.append(getSymbolicModifierName(InputEvent.META_MASK));			if(evt.isShiftDown())				buf.append(getSymbolicModifierName(InputEvent.SHIFT_MASK));			return buf.length() == 0 ? null : buf.toString();		}	
private static StringBuilder lazyAppend(StringBuilder buf, char ch)		{			if(buf == null)				buf = new StringBuilder();			if(buf.indexOf(String.valueOf(ch)) == -1)				buf.append(ch);			return buf;		}	
public Key(String modifiers, int key, char input)			{				this.modifiers = modifiers;				this.key = key;				this.input = input;				hashCode = key + input;			}	
@Override			public int hashCode()			{				return hashCode;			}	
@Override			public boolean equals(Object o)			{				if(o instanceof Key)				{					Key k = (Key)o;					if(StandardUtilities.objectsEqual(modifiers,						k.modifiers) && key == k.key						&& input == k.input)					{						return true;					}				}					return false;			}	
@Override			public String toString()			{				return (modifiers == null ? "" : modifiers)					+ '<'					+ Integer.toString(key,16)					+ ','					+ Integer.toString(input,16)					+ '>';			}	
public void setIsFromGlobalContext(boolean to)			{				isFromGlobalContext = to;			}	
public boolean isFromGlobalContext()			{				return isFromGlobalContext;			}	
public void setIsPhantom(boolean to)			{				isPhantom = to;			}	
public boolean isPhantom()			{				return isPhantom;			}	
public static boolean isBindable(int keyCode)		{			switch(keyCode)			{			case KeyEvent.VK_ALT:			case KeyEvent.VK_ALT_GRAPH:			case KeyEvent.VK_CONTROL:			case KeyEvent.VK_SHIFT:			case KeyEvent.VK_META:			case KeyEvent.VK_DEAD_GRAVE:			case KeyEvent.VK_DEAD_ACUTE:			case KeyEvent.VK_DEAD_CIRCUMFLEX:			case KeyEvent.VK_DEAD_TILDE:			case KeyEvent.VK_DEAD_MACRON:			case KeyEvent.VK_DEAD_BREVE:			case KeyEvent.VK_DEAD_ABOVEDOT:			case KeyEvent.VK_DEAD_DIAERESIS:			case KeyEvent.VK_DEAD_ABOVERING:			case KeyEvent.VK_DEAD_DOUBLEACUTE:			case KeyEvent.VK_DEAD_CARON:			case KeyEvent.VK_DEAD_CEDILLA:			case KeyEvent.VK_DEAD_OGONEK:			case KeyEvent.VK_DEAD_IOTA:			case KeyEvent.VK_DEAD_VOICED_SOUND:			case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:				return false;			default:				return true;			}		}	
/**		 * We need to know if a keycode can potentially result in a		 * keytyped.		 * @since jEdit 4.3pre2		 */		public static boolean isPrintable(int keyCode)		{			switch(keyCode)			{			/* case KeyEvent.VK_ENTER:			case KeyEvent.VK_TAB: */			case KeyEvent.VK_SPACE:			case KeyEvent.VK_COMMA:			case KeyEvent.VK_MINUS:			case KeyEvent.VK_PERIOD:			case KeyEvent.VK_SLASH:			case KeyEvent.VK_0:			case KeyEvent.VK_1:			case KeyEvent.VK_2:			case KeyEvent.VK_3:			case KeyEvent.VK_4:			case KeyEvent.VK_5:			case KeyEvent.VK_6:			case KeyEvent.VK_7:			case KeyEvent.VK_8:			case KeyEvent.VK_9:			case KeyEvent.VK_SEMICOLON:			case KeyEvent.VK_EQUALS   :			case KeyEvent.VK_A:			case KeyEvent.VK_B:			case KeyEvent.VK_C:			case KeyEvent.VK_D:			case KeyEvent.VK_E:			case KeyEvent.VK_F:			case KeyEvent.VK_G:			case KeyEvent.VK_H:			case KeyEvent.VK_I:			case KeyEvent.VK_J:			case KeyEvent.VK_K:			case KeyEvent.VK_L:			case KeyEvent.VK_M:			case KeyEvent.VK_N:			case KeyEvent.VK_O:			case KeyEvent.VK_P:			case KeyEvent.VK_Q:			case KeyEvent.VK_R:			case KeyEvent.VK_S:			case KeyEvent.VK_T:			case KeyEvent.VK_U:			case KeyEvent.VK_V:			case KeyEvent.VK_W:			case KeyEvent.VK_X:			case KeyEvent.VK_Y:			case KeyEvent.VK_Z:			case KeyEvent.VK_OPEN_BRACKET :			case KeyEvent.VK_BACK_SLASH   :			case KeyEvent.VK_CLOSE_BRACKET:		/*	case KeyEvent.VK_NUMPAD0 :			case KeyEvent.VK_NUMPAD1 :			case KeyEvent.VK_NUMPAD2 :			case KeyEvent.VK_NUMPAD3 :			case KeyEvent.VK_NUMPAD4 :			case KeyEvent.VK_NUMPAD5 :			case KeyEvent.VK_NUMPAD6 :			case KeyEvent.VK_NUMPAD7 :			case KeyEvent.VK_NUMPAD8 :			case KeyEvent.VK_NUMPAD9 :			case KeyEvent.VK_MULTIPLY:			case KeyEvent.VK_ADD     :			case KeyEvent.VK_SEPARATOR:			case KeyEvent.VK_SUBTRACT   :			case KeyEvent.VK_DECIMAL    :			case KeyEvent.VK_DIVIDE     :*/			case KeyEvent.VK_BACK_QUOTE:			case KeyEvent.VK_QUOTE:			case KeyEvent.VK_DEAD_GRAVE:			case KeyEvent.VK_DEAD_ACUTE:			case KeyEvent.VK_DEAD_CIRCUMFLEX:			case KeyEvent.VK_DEAD_TILDE:			case KeyEvent.VK_DEAD_MACRON:			case KeyEvent.VK_DEAD_BREVE:			case KeyEvent.VK_DEAD_ABOVEDOT:			case KeyEvent.VK_DEAD_DIAERESIS:			case KeyEvent.VK_DEAD_ABOVERING:			case KeyEvent.VK_DEAD_DOUBLEACUTE:			case KeyEvent.VK_DEAD_CARON:			case KeyEvent.VK_DEAD_CEDILLA:			case KeyEvent.VK_DEAD_OGONEK:			case KeyEvent.VK_DEAD_IOTA:			case KeyEvent.VK_DEAD_VOICED_SOUND:			case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:			case KeyEvent.VK_AMPERSAND:			case KeyEvent.VK_ASTERISK:			case KeyEvent.VK_QUOTEDBL:			case KeyEvent.VK_LESS:			case KeyEvent.VK_GREATER:			case KeyEvent.VK_BRACELEFT:			case KeyEvent.VK_BRACERIGHT:			case KeyEvent.VK_AT:			case KeyEvent.VK_COLON:			case KeyEvent.VK_CIRCUMFLEX:			case KeyEvent.VK_DOLLAR:			case KeyEvent.VK_EURO_SIGN:			case KeyEvent.VK_EXCLAMATION_MARK:			case KeyEvent.VK_INVERTED_EXCLAMATION_MARK:			case KeyEvent.VK_LEFT_PARENTHESIS:			case KeyEvent.VK_NUMBER_SIGN:			case KeyEvent.VK_PLUS:			case KeyEvent.VK_RIGHT_PARENTHESIS:			case KeyEvent.VK_UNDERSCORE:				return true;			default:				return false;			}		}	
/**		 * Apple sucks.		 */		public static boolean isMacControl(KeyEvent evt)		{			return (OperatingSystem.isMacOS() &&				(evt.getModifiers() & InputEvent.CTRL_MASK) != 0				&& evt.getKeyChar() <= 0x2B);		}	
public static boolean isNumericKeypad(int keyCode)		{			switch(keyCode)			{			case KeyEvent.VK_NUMPAD0:			case KeyEvent.VK_NUMPAD1:			case KeyEvent.VK_NUMPAD2:			case KeyEvent.VK_NUMPAD3:			case KeyEvent.VK_NUMPAD4:			case KeyEvent.VK_NUMPAD5:			case KeyEvent.VK_NUMPAD6:			case KeyEvent.VK_NUMPAD7:			case KeyEvent.VK_NUMPAD8:			case KeyEvent.VK_NUMPAD9:			case KeyEvent.VK_MULTIPLY:			case KeyEvent.VK_ADD:			/* case KeyEvent.VK_SEPARATOR: */			case KeyEvent.VK_SUBTRACT:			case KeyEvent.VK_DECIMAL:			case KeyEvent.VK_DIVIDE:				return true;			default:				return false;			}		}	
public static KeyEvent processKeyEvent(KeyEvent evt)		{			int keyCode = evt.getKeyCode();			char ch = evt.getKeyChar();			int modifiers = evt.getModifiers();				switch(evt.getID())			{			//{{{ KEY_PRESSED...			case KeyEvent.KEY_PRESSED:				// get rid of keys we never need to handle				switch(keyCode)				{				case '\0':					return null;				case KeyEvent.VK_ALT:				case KeyEvent.VK_ALT_GRAPH:				case KeyEvent.VK_CONTROL:				case KeyEvent.VK_SHIFT:				case KeyEvent.VK_META:					break;				default:					if(!evt.isMetaDown())					{						if(!evt.isControlDown()							&& !evt.isAltDown())						{							if(isPrintable(keyCode))							{								return null;							}						}					}						if(Debug.ALT_KEY_PRESSED_DISABLED)					{						/* we don't handle key pressed A+ */						/* they're too troublesome */						if((modifiers & InputEvent.ALT_MASK) != 0)							return null;					}						if(isNumericKeypad(keyCode))						last = LAST_NUMKEYPAD;					else						last = LAST_NOTHING;						break;				}				break;			//}}}			//{{{ KEY_TYPED...			case KeyEvent.KEY_TYPED:				// need to let \b through so that backspace will work				// in HistoryTextFields				if(!isMacControl(evt)					&& (ch < 0x20 || ch == 0x7f || ch == 0xff)					&& ch != '\b' && ch != '\t' && ch != '\n')				{					return null;				}					if(Debug.DUMP_KEY_EVENTS)				{					Log.log(Log.DEBUG,"KEWa","Key event (working around): "						+ AbstractInputHandler.toString(evt)+": last="+last+".");				}					if(!Debug.ALTERNATIVE_DISPATCHER)				{					if(((modifiers & InputEvent.CTRL_MASK) != 0						^ (modifiers & InputEvent.ALT_MASK) != 0)						|| (modifiers & InputEvent.META_MASK) != 0)					{						return null;					}				}					// if the last key was a numeric keypad key				// and NumLock is off, filter it out				if(last == LAST_NUMKEYPAD)				{					last = LAST_NOTHING;					if((ch >= '0' && ch <= '9') || ch == '.'						|| ch == '/' || ch == '*'						|| ch == '-' || ch == '+')					{						return null;					}				}				// Windows JDK workaround				else if(last == LAST_ALT)				{					last = LAST_NOTHING;					switch(ch)					{					case 'B':					case 'M':					case 'X':					case 'c':					case '!':					case ',':					case '?':						return null;					}				}				break;			//}}}			//{{{ KEY_RELEASED...			case KeyEvent.KEY_RELEASED:				switch(keyCode)				{				case KeyEvent.VK_ALT:					// we consume this to work around the bug					// where A+TAB window switching activates					// the menu bar on Windows.					evt.consume();					break;				case KeyEvent.VK_ALT_GRAPH:				case KeyEvent.VK_CONTROL:				case KeyEvent.VK_SHIFT:				case KeyEvent.VK_META:					break;				case KeyEvent.VK_LEFT:				case KeyEvent.VK_RIGHT:				case KeyEvent.VK_UP:				case KeyEvent.VK_DOWN:				case KeyEvent.VK_PAGE_UP:				case KeyEvent.VK_PAGE_DOWN:				case KeyEvent.VK_END:				case KeyEvent.VK_HOME:					/* workaround for A+keys producing					 * garbage on Windows */					if(modifiers == InputEvent.ALT_MASK)						last = LAST_ALT;					break;				}				break;			//}}}			}			return evt;		}	
/**		 * A workaround for non-working NumLock status in some Java versions.		 * @since jEdit 4.0pre8		 */		public static void numericKeypadKey()		{			last = LAST_NOTHING;		}	
/**		 * Creates a new <code>KeywordMap</code>.		 * @param ignoreCase True if keys are case insensitive		 */		public KeywordMap(boolean ignoreCase)		{			this(ignoreCase, 52);			this.ignoreCase = ignoreCase;			noWordSep = new StringBuilder();		}	
/**		 * Creates a new <code>KeywordMap</code>.		 * @param ignoreCase True if the keys are case insensitive		 * @param mapLength The number of `buckets' to create.		 * A value of 52 will give good performance for most maps.		 */		public KeywordMap(boolean ignoreCase, int mapLength)		{			this.mapLength = mapLength;			this.ignoreCase = ignoreCase;			map = new Keyword[mapLength];		}	
/**		 * Looks up a key.		 * @param text The text segment		 * @param offset The offset of the substring within the text segment		 * @param length The length of the substring		 */		public byte lookup(Segment text, int offset, int length)		{			if(length == 0)				return Token.NULL;			Keyword k = map[getSegmentMapKey(text, offset, length)];			while(k != null)			{				if(length != k.keyword.length)				{					k = k.next;					continue;				}				if(SyntaxUtilities.regionMatches(ignoreCase,text,offset,					k.keyword))					return k.id;				k = k.next;			}			return Token.NULL;		}	
/**		 * Adds a key-value mapping.		 * @param keyword The key		 * @param id The value		 */		public void add(String keyword, byte id)		{			add(keyword.toCharArray(),id);		}	
/**		 * Adds a key-value mapping.		 * @param keyword The key		 * @param id The value		 * @since jEdit 4.2pre3		 */		public void add(char[] keyword, byte id)		{			int key = getStringMapKey(keyword);				// complete-word command needs a list of all non-alphanumeric			// characters used in a keyword map.	loop:		for(int i = 0; i < keyword.length; i++)			{				char ch = keyword[i];				if(!Character.isLetterOrDigit(ch))				{					for(int j = 0; j < noWordSep.length(); j++)					{						if(noWordSep.charAt(j) == ch)							continue loop;					}						noWordSep.append(ch);				}			}				map[key] = new Keyword(keyword,id,map[key]);		}	
/**		 * Returns all non-alphanumeric characters that appear in the		 * keywords of this keyword map.		 * @since jEdit 4.0pre3		 */		public String getNonAlphaNumericChars()		{			return noWordSep.toString();		}	
/**		 * Returns an array containing all keywords in this keyword map.		 * @since jEdit 4.0pre3		 */		public String[] getKeywords()		{			List<String> vector = new ArrayList<String>(100);			for(int i = 0; i < map.length; i++)			{				Keyword keyword = map[i];				while(keyword != null)				{					vector.add(new String(keyword.keyword));					keyword = keyword.next;				}			}			String[] retVal = new String[vector.size()];			vector.toArray(retVal);			return retVal;		}	
/**		 * Returns true if the keyword map is set to be case insensitive,		 * false otherwise.		 */		public boolean getIgnoreCase()		{			return ignoreCase;		}	
/**		 * Sets if the keyword map should be case insensitive.		 * @param ignoreCase True if the keyword map should be case		 * insensitive, false otherwise		 */		public void setIgnoreCase(boolean ignoreCase)		{			this.ignoreCase = ignoreCase;		}	
/**		 * Adds the content of another keyword map to this one.		 * @since jEdit 4.2pre3		 */		public void add(KeywordMap map)		{			for(int i = 0; i < map.map.length; i++)			{				Keyword k = map.map[i];				while(k != null)				{					add(k.keyword,k.id);					k = k.next;				}			}		}	
private int getStringMapKey(char[] s)		{			return (Character.toUpperCase(s[0]) +					Character.toUpperCase(s[s.length-1]))					% mapLength;		}	
protected int getSegmentMapKey(Segment s, int off, int len)		{			return (Character.toUpperCase(s.array[off]) +					Character.toUpperCase(s.array[off + len - 1]))					% mapLength;		}	
Keyword(char[] keyword, byte id, Keyword next)			{				this.keyword = keyword;				this.id = id;				this.next = next;			}	
public static KillRing getInstance()		{			return killRing;		}	
public static void setInstance(KillRing killRing)		{			KillRing.killRing = killRing;		}	
public void propertiesChanged(int historySize)		{			int newSize = Math.max(1, historySize);			if(ring == null)				ring = new UndoManager.RemovedContent[newSize];			else if(newSize != ring.length)			{				UndoManager.RemovedContent[] newRing = new UndoManager.RemovedContent[					newSize];				int newCount = Math.min(getSize(),newSize);				for(int i = 0; i < newCount; i++)				{					newRing[i] = (UndoManager.RemovedContent)getElementAt(i);				}				ring = newRing;				count = newCount;				wrap = false;			}				if(count == ring.length)			{				count = 0;				wrap = true;			}		}	
public void load() {}	
public void save() {}	
/**		 * This method is made to be used by implementation of load()		 * method to initialize (or reset) the killring by a loaded		 * sequence of objects.		 *		 * Each element is converted to an element of the killring as		 * followings:		 *   - If it is a String, it is converted as if it is a result of		 *     getElementAt(n).toString().		 *   - Otherwise, it is converted as if it is a Object which was		 *     obtained by getElementAt(n).		 *		 * @since jEdit 4.3pre12		 */		protected void reset(List source)		{			UndoManager.RemovedContent[] newRing				= new UndoManager.RemovedContent[source.size()];			int i = 0;			for(Object x: source)			{				UndoManager.RemovedContent element;				if(x instanceof String)				{					element = new UndoManager.RemovedContent(						(String)x);				}				else				{					element = (UndoManager.RemovedContent)x;				}				newRing[i++] = element;			}			ring = newRing;			count = 0;			wrap = true;		}	
public void addListDataListener(ListDataListener listener) {}	
public void removeListDataListener(ListDataListener listener) {}	
public Object getElementAt(int index)		{			return ring[virtualToPhysicalIndex(index)];		}	
public int getSize()		{			if(wrap)				return ring.length;			else				return count;		}	
public boolean removeElement(Object value)		{			for(int i = 0; i < getSize(); i++)			{				if(ring[i].equals(value))				{					remove(i);					return true;				}			}			return false;		}	
public void insertElementAt(Object value, int index)		{			/* This is not terribly efficient, but this method is only			called by the 'Paste Deleted' dialog where the performance			is not exactly vital */			remove(index);			add((UndoManager.RemovedContent)value);		}	
void changed(UndoManager.RemovedContent rem)		{			if(rem.inKillRing)			{				// compare existing entries' hashcode with this				int length = (wrap ? ring.length : count);				int kill = -1;					for(int i = 0; i < length; i++)				{					if(ring[i] != rem						&& ring[i].hashcode == rem.hashcode						&& ring[i].str.equals(rem.str))					{						// we don't want duplicate						// entries in the kill ring						kill = i;						break;					}				}					if(kill != -1)					remove(kill);			}			else				add(rem);		}	
void add(UndoManager.RemovedContent rem)		{			// compare existing entries' hashcode with this			int length = (wrap ? ring.length : count);			for(int i = 0; i < length; i++)			{				if(ring[i].hashcode == rem.hashcode)				{					// strings might be equal!					if(ring[i].str.equals(rem.str))					{						// we don't want duplicate entries						// in the kill ring						return;					}				}			}				// no duplicates, check for all-whitespace string			boolean allWhitespace = true;			for(int i = 0; i < rem.str.length(); i++)			{				if(!Character.isWhitespace(rem.str.charAt(i)))				{					allWhitespace = false;					break;				}			}				if(allWhitespace)				return;				rem.inKillRing = true;				if(ring[count] != null)				ring[count].inKillRing = false;				ring[count] = rem;			if(++count >= ring.length)			{				wrap = true;				count = 0;			}		}	
void remove(int i)		{			if(wrap)			{				UndoManager.RemovedContent[] newRing = new UndoManager.RemovedContent[					ring.length];				int newCount = 0;				for(int j = 0; j < ring.length; j++)				{					int index = virtualToPhysicalIndex(j);						if(i == index)					{						ring[index].inKillRing = false;						continue;					}						newRing[newCount++] = ring[index];				}				ring = newRing;				count = newCount;				wrap = false;			}			else			{				System.arraycopy(ring,i + 1,ring,i,count - i - 1);				count--;			}		}	
/**		 * Since the kill ring has a wrap-around representation, we need to		 * convert user-visible indices to actual indices in the array.		 */		private int virtualToPhysicalIndex(int index)		{			if(wrap)			{				if(index < count)					return count - index - 1;				else					return count + ring.length - index - 1;			}			else				return count - index - 1;		}	
/**	   * Constructs a new label.	   */		  public Label () {	  }	
/**	   * Puts a reference to this label in the bytecode of a method. If the position	   * of the label is known, the offset is computed and written directly.	   * Otherwise, a null offset is written and a new forward reference is declared	   * for this label.	   *	   * @param owner the code writer that calls this method.	   * @param out the bytecode of the method.	   * @param source the position of first byte of the bytecode instruction that	   *      contains this label.	   * @param wideOffset <tt>true</tt> if the reference must be stored in 4 bytes,	   *      or <tt>false</tt> if it must be stored with 2 bytes.	   * @throws IllegalArgumentException if this label has not been created by the	   *      given code writer.	   */		  void put (	    final CodeWriter owner,	    final ByteVector out,	    final int source,	    final boolean wideOffset)	  {	    if (CodeWriter.CHECK) {	      if (this.owner == null) {	        this.owner = owner;	      } else if (this.owner != owner) {	        throw new IllegalArgumentException();	      }	    }	    if (resolved) {	      if (wideOffset) {	        out.put4(position - source);	      } else {	        out.put2(position - source);	      }	    } else {	      if (wideOffset) {	        addReference(-1 - source, out.length);	        out.put4(-1);	      } else {	        addReference(source, out.length);	        out.put2(-1);	      }	    }	  }	
/**	   * Adds a forward reference to this label. This method must be called only for	   * a true forward reference, i.e. only if this label is not resolved yet. For	   * backward references, the offset of the reference can be, and must be,	   * computed and stored directly.	   *	   * @param sourcePosition the position of the referencing instruction. This	   *      position will be used to compute the offset of this forward reference.	   * @param referencePosition the position where the offset for this forward	   *      reference must be stored.	   */		  private void addReference (	    final int sourcePosition,	    final int referencePosition)	  {	    if (srcAndRefPositions == null) {	      srcAndRefPositions = new int[6];	    }	    if (referenceCount >= srcAndRefPositions.length) {	      int[] a = new int[srcAndRefPositions.length + 6];	      System.arraycopy(srcAndRefPositions, 0, a, 0, srcAndRefPositions.length);	      srcAndRefPositions = a;	    }	    srcAndRefPositions[referenceCount++] = sourcePosition;	    srcAndRefPositions[referenceCount++] = referencePosition;	  }	
/**	   * Resolves all forward references to this label. This method must be called	   * when this label is added to the bytecode of the method, i.e. when its	   * position becomes known. This method fills in the blanks that where left in	   * the bytecode by each forward reference previously added to this label.	   *	   * @param owner the code writer that calls this method.	   * @param position the position of this label in the bytecode.	   * @param data the bytecode of the method.	   * @return <tt>true</tt> if a blank that was left for this label was to small	   *      to store the offset. In such a case the corresponding jump instruction	   *      is replaced with a pseudo instruction (using unused opcodes) using an	   *      unsigned two bytes offset. These pseudo instructions will need to be	   *      replaced with true instructions with wider offsets (4 bytes instead of	   *      2). This is done in {@link CodeWriter#resizeInstructions}.	   * @throws IllegalArgumentException if this label has already been resolved,	   *      or if it has not been created by the given code writer.	   */		  boolean resolve (	    final CodeWriter owner,	    final int position,	    final byte[] data)	  {	    if (CodeWriter.CHECK) {	      if (this.owner == null) {	        this.owner = owner;	      }	      if (resolved || this.owner != owner) {	        throw new IllegalArgumentException();	      }	    }	    boolean needUpdate = false;	    this.resolved = true;	    this.position = position;	    int i = 0;	    while (i < referenceCount) {	      int source = srcAndRefPositions[i++];	      int reference = srcAndRefPositions[i++];	      int offset;	      if (source >= 0) {	        offset = position - source;	        if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {	          // changes the opcode of the jump instruction, in order to be able to	          // find it later (see resizeInstructions in CodeWriter). These	          // temporary opcodes are similar to jump instruction opcodes, except	          // that the 2 bytes offset is unsigned (and can therefore represent	          // values from 0 to 65535, which is sufficient since the size of a	          // method is limited to 65535 bytes).	          int opcode = data[reference - 1] & 0xFF;	          if (opcode <= Constants.JSR) {	            // changes IFEQ ... JSR to opcodes 202 to 217 (inclusive)	            data[reference - 1] = (byte)(opcode + 49);	          } else {	            // changes IFNULL and IFNONNULL to opcodes 218 and 219 (inclusive)	            data[reference - 1] = (byte)(opcode + 20);	          }	          needUpdate = true;	        }	        data[reference++] = (byte)(offset >>> 8);	        data[reference] = (byte)offset;	      } else {	        offset = position + source + 1;	        data[reference++] = (byte)(offset >>> 24);	        data[reference++] = (byte)(offset >>> 16);	        data[reference++] = (byte)(offset >>> 8);	        data[reference] = (byte)offset;	      }	    }	    return needUpdate;	  }	
/**			Variable LHS constructor.	*/		LHS( NameSpace nameSpace, String varName )		{	throw new Error("namespace lhs");	/*			type = VARIABLE;			this.varName = varName;			this.nameSpace = nameSpace;	*/		}	
/**			@param localVar if true the variable is set directly in the This			reference's local scope.  If false recursion to look for the variable			definition in parent's scope is allowed. (e.g. the default case for			undefined vars going to global).		*/		LHS( NameSpace nameSpace, String varName, boolean localVar )		{			type = VARIABLE;			this.localVar = localVar;			this.varName = varName;			this.nameSpace = nameSpace;		}	
/**			Static field LHS Constructor.			This simply calls Object field constructor with null object.		*/		LHS( Field field )		{			type = FIELD;			this.object = null;			this.field = field;		}	
/**			Object field LHS Constructor.		*/		LHS( Object object, Field field )		{			if ( object == null)				throw new NullPointerException("constructed empty LHS");				type = FIELD;			this.object = object;			this.field = field;		}	
/**			Object property LHS Constructor.		*/		LHS( Object object, String propName )		{			if(object == null)				throw new NullPointerException("constructed empty LHS");				type = PROPERTY;			this.object = object;			this.propName = propName;		}	
/**			Array index LHS Constructor.		*/		LHS( Object array, int index )		{			if(array == null)				throw new NullPointerException("constructed empty LHS");				type = INDEX;			this.object = array;			this.index = index;		}	
public Object getValue() throws UtilEvalError		{			if ( type == VARIABLE )				return nameSpace.getVariable( varName );				if (type == FIELD)				try {					Object o = field.get( object );					return Primitive.wrap( o, field.getType() );				} catch(IllegalAccessException e2) {					throw new UtilEvalError("Can't read field: " + field);				}				if ( type == PROPERTY )				try {					return Reflect.getObjectProperty(object, propName);				}				catch(ReflectError e) {					Interpreter.debug(e.getMessage());					throw new UtilEvalError("No such property: " + propName);				}				if ( type == INDEX )				try {					return Reflect.getIndex(object, index);				}				catch(Exception e) {					throw new UtilEvalError("Array access: " + e);				}				throw new InterpreterError("LHS type");		}	
/**			Assign a value to the LHS.		*/		public Object assign( Object val, boolean strictJava ) 			throws UtilEvalError		{			if ( type == VARIABLE )			{				// Set the variable in namespace according to localVar flag				if ( localVar )					nameSpace.setLocalVariable( varName, val, strictJava );				else					nameSpace.setVariable( varName, val, strictJava );			} else 			if ( type == FIELD )			{				try {					Object fieldVal = val instanceof Primitive ?  						((Primitive)val).getValue() : val;						// This should probably be in Reflect.java					ReflectManager.RMSetAccessible( field );					field.set( object, fieldVal );					return val;				}				catch( NullPointerException e) {   	    			throw new UtilEvalError(						"LHS ("+field.getName()+") not a static field.");				}     	   			catch( IllegalAccessException e2) {   					throw new UtilEvalError(						"LHS ("+field.getName()+") can't access field: "+e2);				}     				catch( IllegalArgumentException e3) 				{					String type = val instanceof Primitive ?						((Primitive)val).getType().getName()						: val.getClass().getName();					throw new UtilEvalError(						"Argument type mismatch. " + (val == null ? "null" : type )						+ " not assignable to field "+field.getName());				}			}			else 			if ( type == PROPERTY )			{				/*				if ( object instanceof Hashtable )					((Hashtable)object).put(propName, val);				*/				CollectionManager cm = CollectionManager.getCollectionManager();				if ( cm.isMap( object ) )					cm.putInMap( object/*map*/, propName, val );				else					try {						Reflect.setObjectProperty(object, propName, val);					}					catch(ReflectError e) {						Interpreter.debug("Assignment: " + e.getMessage());						throw new UtilEvalError("No such property: " + propName);					}			} else 			if ( type == INDEX )				try {					Reflect.setIndex(object, index, val);				} catch ( UtilTargetError e1 ) { // pass along target error					throw e1;				} catch ( Exception e ) {					throw new UtilEvalError("Assignment: " + e.getMessage());				}			else				throw new InterpreterError("unknown lhs");				return val;		}	
public String toString() { 			return "LHS: "				+((field!=null)? "field = "+field.toString():"")				+(varName!=null ? " varName = "+varName: "")				+(nameSpace!=null ? " nameSpace = "+nameSpace.toString(): "");		}	
public LineManager()		{			endOffsets = new int[1];			endOffsets[0] = 1;			foldLevels = new short[1];			lineContext = new TokenMarker.LineContext[1];			lineCount = 1;		}	
public final int getLineCount()		{			return lineCount;		}	
public int getLineOfOffset(int offset)		{			int start = 0;			int end = lineCount - 1;				for(;;)			{				switch(end - start)				{				case 0:					if(getLineEndOffset(start) <= offset)						return start + 1;					else						return start;				case 1:					if(getLineEndOffset(start) <= offset)					{						if(getLineEndOffset(end) <= offset)							return end + 1;						else							return end;					}					else						return start;				default:					int pivot = (end + start) / 2;					int value = getLineEndOffset(pivot);					if(value == offset)						return pivot + 1;					else if(value < offset)						start = pivot + 1;					else						end = pivot - 1;					break;				}			}		}	
public final int getLineEndOffset(int line)		{			if(gapLine != -1 && line >= gapLine)				return endOffsets[line] + gapWidth;			else				return endOffsets[line];		}	
public final int getFoldLevel(int line)		{			return foldLevels[line];		}	
public final void setFoldLevel(int line, int level)		{			if(level > 0xffff)			{				// limitations...				level = 0xffff;			}				foldLevels[line] = (short)level;		}	
public void setFirstInvalidFoldLevel(int firstInvalidFoldLevel)		{			this.firstInvalidFoldLevel = firstInvalidFoldLevel;		}	
public int getFirstInvalidFoldLevel()		{			return firstInvalidFoldLevel;		}	
public final TokenMarker.LineContext getLineContext(int line)		{			return lineContext[line];		}	
public final void setLineContext(int line, TokenMarker.LineContext context)		{			lineContext[line] = context;		}	
public void setFirstInvalidLineContext(int firstInvalidLineContext)		{			this.firstInvalidLineContext = firstInvalidLineContext;		}	
public int getFirstInvalidLineContext()		{			return firstInvalidLineContext;		}	
public void _contentInserted(IntegerArray endOffsets)		{			gapLine = -1;			gapWidth = 0;			firstInvalidLineContext = firstInvalidFoldLevel = 0;			lineCount = endOffsets.getSize();			this.endOffsets = endOffsets.getArray();			foldLevels = new short[lineCount];				lineContext = new TokenMarker.LineContext[lineCount];		}	
public void contentInserted(int startLine, int offset,			int numLines, int length, IntegerArray endOffsets)		{			int endLine = startLine + numLines;				//{{{ Update line info and line context arrays			if(numLines > 0)			{				//moveGap(-1,0,"contentInserted");					lineCount += numLines;					if(this.endOffsets.length <= lineCount)				{					int[] endOffsetsN = new int[(lineCount + 1) * 2];					System.arraycopy(this.endOffsets,0,endOffsetsN,0,							 this.endOffsets.length);					this.endOffsets = endOffsetsN;				}					if(foldLevels.length <= lineCount)				{					short[] foldLevelsN = new short[(lineCount + 1) * 2];					System.arraycopy(foldLevels,0,foldLevelsN,0,							 foldLevels.length);					foldLevels = foldLevelsN;				}					if(lineContext.length <= lineCount)				{					TokenMarker.LineContext[] lineContextN						= new TokenMarker.LineContext[(lineCount + 1) * 2];					System.arraycopy(lineContext,0,lineContextN,0,							 lineContext.length);					lineContext = lineContextN;				}					System.arraycopy(this.endOffsets,startLine,					this.endOffsets,endLine,lineCount - endLine);				System.arraycopy(foldLevels,startLine,foldLevels,					endLine,lineCount - endLine);				System.arraycopy(lineContext,startLine,lineContext,					endLine,lineCount - endLine);					if(startLine <= gapLine)					gapLine += numLines;				else if(gapLine != -1)					offset -= gapWidth;					if(startLine < firstInvalidLineContext)					firstInvalidLineContext += numLines;					for(int i = 0; i < numLines; i++)				{					this.endOffsets[startLine + i] = (offset + endOffsets.get(i));					foldLevels[startLine + i] = 0;				}			} //}}}				if(firstInvalidFoldLevel == -1 || firstInvalidFoldLevel > startLine)				firstInvalidFoldLevel = startLine;			moveGap(endLine,length,"contentInserted");		}	
public void contentRemoved(int startLine, int offset,			int numLines, int length)		{			int endLine = startLine + numLines;				//{{{ Update line info and line context arrays			if(numLines > 0)			{				//moveGap(-1,0,"contentRemoved");					if(startLine + numLines < gapLine)					gapLine -= numLines;				else if(startLine < gapLine)					gapLine = startLine;					if(startLine + numLines < firstInvalidLineContext)					firstInvalidLineContext -= numLines;				else if(startLine < firstInvalidLineContext)					firstInvalidLineContext = startLine - 1;					lineCount -= numLines;					System.arraycopy(endOffsets,endLine,endOffsets,					startLine,lineCount - startLine);				System.arraycopy(foldLevels,endLine,foldLevels,					startLine,lineCount - startLine);				System.arraycopy(lineContext,endLine,lineContext,					startLine,lineCount - startLine);			} //}}}				if(firstInvalidFoldLevel == -1 || firstInvalidFoldLevel > startLine)				firstInvalidFoldLevel = startLine;			moveGap(startLine,-length,"contentRemoved");		}	
private final void setLineEndOffset(int line, int end)		{			endOffsets[line] = end;		}	
private final void moveGap(int newGapLine, int newGapWidth, String method)		{			if(gapLine == -1)				gapWidth = newGapWidth;			else if(newGapLine == -1)			{				if(gapWidth != 0)				{					if(Debug.OFFSET_DEBUG && gapLine != lineCount)						Log.log(Log.DEBUG,this,method + ": update from " + gapLine + " to " + lineCount + " width " + gapWidth);					for(int i = gapLine; i < lineCount; i++)						setLineEndOffset(i,getLineEndOffset(i));				}					gapWidth = newGapWidth;			}			else if(newGapLine < gapLine)			{				if(gapWidth != 0)				{					if(Debug.OFFSET_DEBUG && newGapLine != gapLine)						Log.log(Log.DEBUG,this,method + ": update from " + newGapLine + " to " + gapLine + " width " + gapWidth);					for(int i = newGapLine; i < gapLine; i++)						setLineEndOffset(i,getLineEndOffset(i) - gapWidth);				}				gapWidth += newGapWidth;			}			else //if(newGapLine >= gapLine)			{				if(gapWidth != 0)				{					if(Debug.OFFSET_DEBUG && gapLine != newGapLine)						Log.log(Log.DEBUG,this,method + ": update from " + gapLine + " to " + newGapLine + " width " + gapWidth);					for(int i = gapLine; i < newGapLine; i++)						setLineEndOffset(i,getLineEndOffset(i));				}					gapWidth += newGapWidth;			}				if(newGapLine == lineCount)				gapLine = -1;			else				gapLine = newGapLine;		}	
public Widget getWidget(View view) 		{			Widget lineSep = new LineSepWidget(view);			return lineSep;		}	
LineSepWidget(final View view) 			{				lineSep = new ToolTipLabel();				lineSep.setHorizontalAlignment(SwingConstants.CENTER);				lineSep.setToolTipText(jEdit.getProperty("view.status.linesep-tooltip"));				this.view = view;				lineSep.addMouseListener(new MouseAdapter() 							 {								 @Override								 public void mouseClicked(MouseEvent evt)								 {									 view.getBuffer().toggleLineSeparator(view);								 }							 });			}	
public JComponent getComponent() 			{				return lineSep;			}	
public void update() 			{				Buffer buffer = view.getBuffer();				String lineSep = buffer.getStringProperty(JEditBuffer.LINESEP);				if("\n".equals(lineSep))					this.lineSep.setText("U");				else if("\r\n".equals(lineSep))					this.lineSep.setText("W");				else if("\r".equals(lineSep))					this.lineSep.setText("M");			}	
public void propertiesChanged()			{				// retarded GTK look and feel!				Font font = new JLabel().getFont();				//UIManager.getFont("Label.font");				FontMetrics fm = lineSep.getFontMetrics(font);				Dimension dim = new Dimension(Math.max(								       Math.max(fm.charWidth('U'),										fm.charWidth('W')),								       fm.charWidth('M')) + 1,					fm.getHeight());				lineSep.setPreferredSize(dim);				lineSep.setMaximumSize(dim);			}	
public void open(DefaultListModel listModel)		{			final DefaultTableModel tableModel = createTableModel(listModel);			final JTable table = new JTable(tableModel);			table			    .setToolTipText("Move: PgUp/PgDown; Edit: Double-Click or Insert/Delete");				table.addKeyListener(new KeyAdapter()			{				public void keyPressed(KeyEvent e)				{					int[] selRows = table.getSelectedRows();					if (selRows.length == 0)					{						return;					}					int firstSelectedRow = selRows[0];					int key = e.getKeyCode();					ListSelectionModel selectionModel = table.getSelectionModel();					switch (key)					{						case KeyEvent.VK_DELETE:							for (int i = selRows.length - 1; i >= 0; i--)							{								tableModel.removeRow(selRows[i]);							}							if (firstSelectedRow >= 0							    && firstSelectedRow < tableModel.getRowCount())							{								selectionModel.addSelectionInterval(firstSelectedRow,								    firstSelectedRow);							}							e.consume();// avoid beep							break;						case KeyEvent.VK_INSERT:							tableModel.insertRow(firstSelectedRow + 1, new String[] { "" });							e.consume(); // Dont edit cell							break;						case KeyEvent.VK_PAGE_UP:						case KeyEvent.VK_PAGE_DOWN:							boolean isUp = key == KeyEvent.VK_PAGE_UP;							int direction = isUp ? -1 : 1;							int min = selectionModel.getMinSelectionIndex() + direction;							int max = selectionModel.getMaxSelectionIndex() + direction;							if (min < 0 || max >= tableModel.getRowCount())							{								return; // avoid ArrayIndexOutOfBoundsException							}							for (int i = 0; i < selRows.length; i++)							{								int row = selRows[isUp ? i : (selRows.length - 1 - i)];								int to = row + direction;								selectionModel.removeSelectionInterval(row, row);								selectionModel.addSelectionInterval(to, to);								tableModel.moveRow(row, row, to);							}							break;					}				}			});			int result = JOptionPane.showConfirmDialog(null, table, "Change "			    + jEdit.getProperty("history.caption"), JOptionPane.OK_CANCEL_OPTION);			if (result == JOptionPane.OK_OPTION)			{				updatelistModel(listModel, tableModel);			}		}	
private DefaultTableModel createTableModel(DefaultListModel listModel)		{			Object[][] tableRowData = new String[listModel.size()][1];			for (int i = 0; i < listModel.size(); i++)			{				tableRowData[i][0] = listModel.get(i);			}			return new DefaultTableModel(tableRowData, new String[] { "" });		}	
private void updatelistModel(DefaultListModel listModel,		    DefaultTableModel tableModel)		{			listModel.removeAllElements();			for (int i = 0; i < tableModel.getRowCount(); i++)			{				Object cellText = tableModel.getValueAt(i, 0);				if (cellText != null && !cellText.equals(""))				{					listModel.addElement(cellText);				}			}		}	
/**		 * Initializes the log.		 * @param stdio If true, standard output and error will be		 * sent to the log		 * @param level Messages with this log level or higher will		 * be printed to the system console		 * @since jEdit 3.2pre4		 */		public static void init(boolean stdio, int level)		{			if(stdio)			{				if(System.out == realOut && System.err == realErr)				{					System.setOut(createPrintStream(NOTICE,null));					System.setErr(createPrintStream(ERROR,null));				}			}				Log.level = level;				// Log some stuff			log(MESSAGE,Log.class,"When reporting bugs, please"				+ " include the following information:");			String[] props = {				"java.version", "java.vm.version", "java.runtime.version",				"java.vendor", "java.compiler", "os.name", "os.version",				"os.arch", "user.home", "java.home",				"java.class.path",				};			for(int i = 0; i < props.length; i++)			{				log(MESSAGE,Log.class,					props[i] + '=' + System.getProperty(props[i]));			}		}	
/**		 * Writes all currently logged messages to this stream if there was no		 * stream set previously, and sets the stream to write future log		 * messages to.		 * @param stream The writer		 * @since jEdit 3.2pre4		 */		public static void setLogWriter(Writer stream)		{			if(Log.stream == null && stream != null)			{				try				{					if(wrap)					{						for(int i = logLineCount; i < log.length; i++)						{							stream.write(log[i]);							stream.write(lineSep);						}					}					for(int i = 0; i < logLineCount; i++)					{						stream.write(log[i]);						stream.write(lineSep);					}						stream.flush();				}				catch(Exception e)				{					// do nothing, who cares				}			}				Log.stream = stream;		}	
/**		 * Flushes the log stream.		 * @since jEdit 2.6pre5		 */		public static void flushStream()		{			if(stream != null)			{				try				{					stream.flush();				}				catch(IOException io)				{					io.printStackTrace(realErr);				}			}		}	
/**		 * Closes the log stream. Should be done before your program exits.		 * @since jEdit 2.6pre5		 */		public static void closeStream()		{			if(stream != null)			{				try				{					stream.close();					stream = null;				}				catch(IOException io)				{					io.printStackTrace(realErr);				}			}		}	
/**		 * Returns the list model for viewing the log contents.		 * @since jEdit 4.2pre1		 */		public static ListModel getLogListModel()		{			return listModel;		}	
/**		 * Logs an exception with a message.		 *		 * If an exception is the cause of a call to {@link #log}, then		 * the exception should be explicitly provided so that it can		 * be presented to the (debugging) user in a useful manner		 * (not just the exception message, but also the exception stack trace)		 *		 * @since jEdit 4.3pre5		 */		public static void log(int urgency, Object source, Object message,			Throwable exception)		{			// We can do nicer here, but this is a start...			log(urgency,source,message);			log(urgency,source,exception);		}	
/**		 * Logs a message. This method is thread-safe.<p>		 *		 * The following code sends a typical debugging message to the activity		 * log:		 * <pre>Log.log(Log.DEBUG,this,"counter = " + counter);</pre>		 * The corresponding activity log entry might read as follows:		 * <pre>[debug] JavaParser: counter = 15</pre>		 *		 * @param urgency The urgency; can be one of		 * <code>Log.DEBUG</code>, <code>Log.MESSAGE</code>,		 * <code>Log.NOTICE</code>, <code>Log.WARNING</code>, or		 * <code>Log.ERROR</code>.		 * @param source The source of the message, either an object or a		 * class instance. When writing log messages from macros, set		 * this parameter to <code>BeanShell.class</code> to make macro		 * errors easier to spot in the activity log.		 * @param message The message. This can either be a string or		 * an exception		 *		 * @since jEdit 2.2pre2		 */		public static void log(int urgency, Object source, Object message)		{			String _source;			if(source == null)			{				_source = Thread.currentThread().getName();				if(_source == null)				{					_source = Thread.currentThread().getClass().getName();				}			}			else if(source instanceof Class)				_source = ((Class)source).getName();			else				_source = source.getClass().getName();			int index = _source.lastIndexOf('.');			if(index != -1)				_source = _source.substring(index+1);				if(message instanceof Throwable)			{				_logException(urgency,source,(Throwable)message);			}			else			{				String _message = String.valueOf(message);				// If multiple threads log stuff, we don't want				// the output to get mixed up				synchronized(LOCK)				{					StringTokenizer st = new StringTokenizer(						_message,"\r\n");					int lineCount = 0;					boolean oldWrap = wrap;					while(st.hasMoreTokens())					{						lineCount++;						_log(urgency,_source,st.nextToken()							.replace('\t',' '));					}					listModel.update(lineCount,oldWrap);				}			}		}	
private static PrintStream createPrintStream(final int urgency,			final Object source)		{			return new LogPrintStream(urgency, source);		}	
private static void _logException(final int urgency,			final Object source,			final Throwable message)		{			PrintStream out = createPrintStream(urgency,source);			if (urgency >= level)			{				synchronized (throwables)				{					if (throwables.size() == MAX_THROWABLES)					{						throwables.remove(0);					}					throwables.add(message);				}			}			synchronized(LOCK)			{				message.printStackTrace(out);			}		}	
private static void _log(int urgency, String source, String message)		{			String fullMessage = timeFormat.format(new Date()) + " ["+Thread.currentThread().getName()+"] [" + urgencyToString(urgency) + "] " + source				+ ": " + message;				try			{				log[logLineCount] = fullMessage;				if(++logLineCount >= log.length)				{					wrap = true;					logLineCount = 0;				}					if(stream != null)				{					stream.write(fullMessage);					stream.write(lineSep);				}			}			catch(Exception e)			{				e.printStackTrace(realErr);			}				if(urgency >= level)			{				if(urgency == ERROR)					realErr.println(fullMessage);				else					realOut.println(fullMessage);			}		}	
private static String urgencyToString(int urgency)		{			switch(urgency)			{			case DEBUG:				return "debug";			case MESSAGE:				return "message";			case NOTICE:				return "notice";			case WARNING:				return "warning";			case ERROR:				return "error";			}				throw new IllegalArgumentException("Invalid urgency: " + urgency);		}	
private void fireIntervalAdded(int index1, int index2)			{				for(int i = 0; i < listeners.size(); i++)				{					ListDataListener listener = listeners.get(i);					listener.intervalAdded(new ListDataEvent(this,						ListDataEvent.INTERVAL_ADDED,						index1,index2));				}			}	
private void fireIntervalRemoved(int index1, int index2)			{				for(int i = 0; i < listeners.size(); i++)				{					ListDataListener listener = listeners.get(i);					listener.intervalRemoved(new ListDataEvent(this,						ListDataEvent.INTERVAL_REMOVED,						index1,index2));				}			}	
public void addListDataListener(ListDataListener listener)			{				listeners.add(listener);			}	
public void removeListDataListener(ListDataListener listener)			{				listeners.remove(listener);			}	
public Object getElementAt(int index)			{				if(wrap)				{					if(index < MAXLINES - logLineCount)						return log[index + logLineCount];					else						return log[index - MAXLINES + logLineCount];				}				else					return log[index];			}	
public int getSize()			{				if(wrap)					return MAXLINES;				else					return logLineCount;			}	
void update(final int lineCount, final boolean oldWrap)			{				if(lineCount == 0 || listeners.isEmpty())					return;					SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						if(wrap)						{							if(oldWrap)								fireIntervalRemoved(0,lineCount - 1);							else							{								fireIntervalRemoved(0,									logLineCount);							}							fireIntervalAdded(								MAXLINES - lineCount + 1,								MAXLINES);						}						else						{							fireIntervalAdded(								logLineCount - lineCount + 1,								logLineCount);						}					}				});			}	
LogPrintStream(int urgency, Object source)			{				super(new LogOutputStream(urgency, source));				buffer = new ByteArrayOutputStream();				orig = out;			}	
/**			 * This is a hack to allow "printf" to not print weird			 * stuff to the output. Since "printf" doesn't seem to			 * print the whole message in one shot, our output			 * stream above would break a line of log into several			 * lines; so we buffer the result of the printf call and			 * print the whole thing in one shot. A similar hack			 * would be needed for the "other" printf method, but			 * I'll settle for the common case only.			 */			public PrintStream printf(String format, Object... args)			{				synchronized (orig)				{					buffer.reset();					out = buffer;					super.printf(format, args);						try					{						byte[] data = buffer.toByteArray();						orig.write(data, 0, data.length);						out = orig;					}					catch (IOException ioe)					{						// don't do anything?					}					finally					{						buffer.reset();					}				}				return this;			}	
LogOutputStream(int urgency, Object source)			{				this.urgency 	= urgency;				this.source 	= source;			}	
public synchronized void write(int b)			{				byte[] barray = { (byte)b };				write(barray,0,1);			}	
public synchronized void write(byte[] b, int off, int len)			{				String str = new String(b,off,len);				log(urgency,source,str);			}	
public LogViewer()		{			super(new BorderLayout());				JPanel caption = new JPanel();			caption.setLayout(new BoxLayout(caption,BoxLayout.X_AXIS));			caption.setBorder(new EmptyBorder(6,6,6,6));				String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory != null)			{				String[] args = { MiscUtilities.constructPath(									      settingsDirectory, "activity.log") };				JLabel label = new JLabel(jEdit.getProperty(									    "log-viewer.caption",args));				caption.add(label);			}				caption.add(Box.createHorizontalGlue());				tailIsOn = jEdit.getBooleanProperty("log-viewer.tail", false);			tail = new JCheckBox(					     jEdit.getProperty("log-viewer.tail.label"),tailIsOn);			tail.addActionListener(new ActionHandler());					filter = new JTextField();			filter.getDocument().addDocumentListener(new DocumentListener()			{				public void changedUpdate(DocumentEvent e)				{					setFilter();				}					public void insertUpdate(DocumentEvent e)				{					setFilter();				}					public void removeUpdate(DocumentEvent e)				{					setFilter();				}			});			caption.add(filter);			caption.add(tail);				caption.add(Box.createHorizontalStrut(12));				copy = new JButton(jEdit.getProperty("log-viewer.copy"));			copy.addActionListener(new ActionHandler());			caption.add(copy);				ListModel model = Log.getLogListModel();			listModel = new MyFilteredListModel(model);			// without this, listModel is held permanently in model.			// See addNotify() and removeNotify(), and constructor of			// FilteredListModel.			model.removeListDataListener(listModel);				list = new LogList(listModel);			listModel.setList(list);			add(BorderLayout.NORTH,caption);			JScrollPane scroller = new JScrollPane(list);			Dimension dim = scroller.getPreferredSize();			dim.width = Math.min(600,dim.width);			scroller.setPreferredSize(dim);			add(BorderLayout.CENTER,scroller);				propertiesChanged();		}	
@Override		public void setBounds(int x, int y, int width, int height)		{			list.setCellRenderer( new ColorizerCellRenderer() );			super.setBounds(x, y, width, height);			scrollLaterIfRequired();		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof PropertiesChanged)				propertiesChanged();		}	
@Override		public void addNotify()		{			super.addNotify();			ListModel model = Log.getLogListModel();			model.addListDataListener(listModel);			model.addListDataListener(listHandler = new ListHandler());			if(tailIsOn)				scrollToTail();				EditBus.addToBus(this);		}	
@Override		public void removeNotify()		{			super.removeNotify();			ListModel model = Log.getLogListModel();			model.removeListDataListener(listModel);			model.removeListDataListener(listHandler);			listHandler = null;			EditBus.removeFromBus(this);		}	
public void focusOnDefaultComponent()		{			list.requestFocus();		}	
private void setFilter()		{			listModel.setFilter(filter.getText());			scrollLaterIfRequired();		}	
private void propertiesChanged()		{			list.setFont(jEdit.getFontProperty("view.font"));			list.setFixedCellHeight(list.getFontMetrics(list.getFont())						.getHeight());		}	
/** Scroll to the tail of the logs. */		private void scrollToTail()		{			int index = list.getModel().getSize();			if(index != 0)				list.ensureIndexIsVisible(index - 1);		}	
private void scrollLaterIfRequired()		{			if (tailIsOn)				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						scrollToTail();					}				});		}	
public void actionPerformed(ActionEvent e)			{				Object src = e.getSource();				if(src == tail)				{					tailIsOn = !tailIsOn;					jEdit.setBooleanProperty("log-viewer.tail",tailIsOn);					if(tailIsOn)					{						scrollToTail();					}				}				else if(src == copy)				{					StringBuilder buf = new StringBuilder();					Object[] selected = list.getSelectedValues();					if(selected != null && selected.length != 0)					{						for(int i = 0; i < selected.length; i++)						{							buf.append(selected[i]);							buf.append('\n');						}					}					else					{						ListModel model = list.getModel();						for(int i = 0; i < model.getSize(); i++)						{							buf.append(model.getElementAt(i));							buf.append('\n');						}					}					Registers.setRegister('$',buf.toString());				}			}	
public void intervalAdded(ListDataEvent e)			{				contentsChanged(e);			}	
public void intervalRemoved(ListDataEvent e)			{				contentsChanged(e);			}	
public void contentsChanged(ListDataEvent e)			{				scrollLaterIfRequired();			}	
LogList(ListModel model)			{				super(model);				setVisibleRowCount(24);				getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);				setAutoscrolls(true);			}	
@Override			public void processMouseEvent(MouseEvent evt)			{				if(evt.getID() == MouseEvent.MOUSE_PRESSED)				{					startIndex = list.locationToIndex(									  evt.getPoint());				}				super.processMouseEvent(evt);			}	
@Override			public void processMouseMotionEvent(MouseEvent evt)			{				if(evt.getID() == MouseEvent.MOUSE_DRAGGED)				{					int row = list.locationToIndex(evt.getPoint());					if(row != -1)					{						if(startIndex == -1)						{							list.setSelectionInterval(row,row);							startIndex = row;						}						else							list.setSelectionInterval(startIndex,row);						list.ensureIndexIsVisible(row);						evt.consume();					}				}				else					super.processMouseMotionEvent(evt);			}	
public Component getListCellRendererComponent(								      JList list,								      Object value,              // value to display								      int index,                 // cell index								      boolean isSelected,        // is the cell selected								      boolean cellHasFocus )     // the list and the cell have the focus			{				String s = value.toString();				setText(s);				if (isSelected)				{					setBackground(list.getSelectionBackground());					setForeground(list.getSelectionForeground());				}				else				{					setBackground(list.getBackground());					Color color = list.getForeground();					if (s.contains("[debug]"))					{						color = Color.BLUE;					}					else if (s.contains("[notice]"))					{						color = Color.GREEN;					}					else if (s.contains("[warning]"))					{						color = Color.ORANGE;					}					else if (s.contains("[error]"))					{						color = Color.RED;					}					setForeground( color );				}				setEnabled( list.isEnabled() );				setFont( list.getFont() );				setOpaque( true );				return this;			}	
MyFilteredListModel(ListModel model)			{				super(model);			}	
@Override			public String prepareFilter(String filter)			{				return filter.toLowerCase();			}	
@Override			public boolean passFilter(int row, String filter)			{				return delegated.getElementAt(row).toString().toLowerCase().contains(filter);			}	
/**		 * Prompts for one or more files to run as macros		 * @param view The view		 * @since jEdit 4.0pre7		 */		public static void showRunScriptDialog(View view)		{			String[] paths = GUIUtilities.showVFSFileDialog(view,				null,JFileChooser.OPEN_DIALOG,true);			if(paths != null)			{				Buffer buffer = view.getBuffer();				try				{					buffer.beginCompoundEdit();		file_loop:			for(int i = 0; i < paths.length; i++)						runScript(view,paths[i],false);				}				finally				{					buffer.endCompoundEdit();				}			}		}	
/**		 * Runs the specified script.		 * Unlike the {@link BeanShell#runScript(View,String,Reader,boolean)}		 * method, this method can run scripts supported		 * by any registered macro handler.		 * @param view The view		 * @param path The VFS path of the script		 * @param ignoreUnknown If true, then unknown file types will be		 * ignored; otherwise, a warning message will be printed and they will		 * be evaluated as BeanShell scripts.		 *		 * @since jEdit 4.1pre2		 */		public static void runScript(View view, String path, boolean ignoreUnknown)		{			Handler handler = getHandlerForPathName(path);			if(handler != null)			{				try				{					Macro newMacro = handler.createMacro(						MiscUtilities.getFileName(path), path);					newMacro.invoke(view);				}				catch (Exception e)				{					Log.log(Log.ERROR, Macros.class, e);					return;				}				return;			}				// only executed if above loop falls			// through, ie there is no handler for			// this file			if(ignoreUnknown)			{				Log.log(Log.NOTICE,Macros.class,path +					": Cannot find a suitable macro handler");			}			else			{				Log.log(Log.ERROR,Macros.class,path +					": Cannot find a suitable macro handler, "					+ "assuming BeanShell");				getHandler("beanshell").createMacro(					path,path).invoke(view);			}		}	
/**		 * Utility method that can be used to display a message dialog in a macro.		 * @param comp The component to show the dialog on behalf of, this		 * will usually be a view instance		 * @param message The message		 * @since jEdit 2.7pre2		 */		public static void message(Component comp, String message)		{			GUIUtilities.hideSplashScreen();				JOptionPane.showMessageDialog(comp,message,				jEdit.getProperty("macro-message.title"),				JOptionPane.INFORMATION_MESSAGE);		}	
/**		 * Utility method that can be used to display an error dialog in a macro.		 * @param comp The component to show the dialog on behalf of, this		 * will usually be a view instance		 * @param message The message		 * @since jEdit 2.7pre2		 */		public static void error(Component comp, String message)		{			GUIUtilities.hideSplashScreen();				JOptionPane.showMessageDialog(comp,message,				jEdit.getProperty("macro-message.title"),				JOptionPane.ERROR_MESSAGE);		}	
/**		 * Utility method that can be used to prompt for input in a macro.		 * @param comp The component to show the dialog on behalf of, this		 * will usually be a view instance		 * @param prompt The prompt string		 * @since jEdit 2.7pre2		 */		public static String input(Component comp, String prompt)		{			GUIUtilities.hideSplashScreen();				return input(comp,prompt,null);		}	
/**		 * Utility method that can be used to prompt for input in a macro.		 * @param comp The component to show the dialog on behalf of, this		 * will usually be a view instance		 * @param prompt The prompt string		 * @since jEdit 3.1final		 */		public static String input(Component comp, String prompt, String defaultValue)		{			GUIUtilities.hideSplashScreen();				return (String)JOptionPane.showInputDialog(comp,prompt,				jEdit.getProperty("macro-input.title"),				JOptionPane.QUESTION_MESSAGE,null,null,defaultValue);		}	
/**		 * Utility method that can be used to ask for confirmation in a macro.		 * @param comp The component to show the dialog on behalf of, this		 * will usually be a view instance		 * @param prompt The prompt string		 * @param buttons The buttons to display - for example,		 * JOptionPane.YES_NO_CANCEL_OPTION		 * @since jEdit 4.0pre2		 */		public static int confirm(Component comp, String prompt, int buttons)		{			GUIUtilities.hideSplashScreen();				return JOptionPane.showConfirmDialog(comp,prompt,				jEdit.getProperty("macro-confirm.title"),buttons,				JOptionPane.QUESTION_MESSAGE);		}	
/**		 * Utility method that can be used to ask for confirmation in a macro.		 * @param comp The component to show the dialog on behalf of, this		 * will usually be a view instance		 * @param prompt The prompt string		 * @param buttons The buttons to display - for example,		 * JOptionPane.YES_NO_CANCEL_OPTION		 * @param type The dialog type - for example,		 * JOptionPane.WARNING_MESSAGE		 */		public static int confirm(Component comp, String prompt, int buttons, int type)		{			GUIUtilities.hideSplashScreen();				return JOptionPane.showConfirmDialog(comp,prompt,				jEdit.getProperty("macro-confirm.title"),buttons,type);		}	
/**		 * Rebuilds the macros list, and sends a MacrosChanged message		 * (views update their Macros menu upon receiving it)		 * @since jEdit 2.2pre4		 */		public static void loadMacros()		{			macroActionSet.removeAllActions();			macroHierarchy.removeAllElements();			macroHash.clear();				// since subsequent macros with the same name are ignored,			// load user macros first so that they override the system			// macros.			String settings = jEdit.getSettingsDirectory();				if(settings != null)			{				userMacroPath = MiscUtilities.constructPath(					settings,"macros");				loadMacros(macroHierarchy,"",new File(userMacroPath));			}				if(jEdit.getJEditHome() != null)			{				systemMacroPath = MiscUtilities.constructPath(					jEdit.getJEditHome(),"macros");				loadMacros(macroHierarchy,"",new File(systemMacroPath));			}				EditBus.send(new DynamicMenuChanged("macros"));		}	
/**		 * Adds a macro handler to the handlers list		 * @since jEdit 4.0pre6		 */		public static void registerHandler(Handler handler)		{			if (getHandler(handler.getName()) != null)			{				Log.log(Log.ERROR, Macros.class, "Cannot register more than one macro handler with the same name");				return;			}				Log.log(Log.DEBUG,Macros.class,"Registered " + handler.getName()				+ " macro handler");			macroHandlers.add(handler);		}	
/**		 * Returns an array containing the list of registered macro handlers		 * @since jEdit 4.0pre6		 */		public static Handler[] getHandlers()		{			Handler[] handlers = new Handler[macroHandlers.size()];			return macroHandlers.toArray(handlers);		}	
/**		 * Returns the macro handler suitable for running the specified file		 * name, or null if there is no suitable handler.		 * @since jEdit 4.1pre3		 */		public static Handler getHandlerForPathName(String pathName)		{			for (int i = 0; i < macroHandlers.size(); i++)			{				Handler handler = macroHandlers.get(i);				if (handler.accept(pathName))					return handler;			}				return null;		}	
/**		 * Returns the macro handler with the specified name, or null if		 * there is no registered handler with that name.		 * @since jEdit 4.0pre6		 */		public static Handler getHandler(String name)		{			for (int i = 0; i < macroHandlers.size(); i++)			{				Handler handler = macroHandlers.get(i);				if (handler.getName().equals(name))					return handler;			}				return null;		}	
/**		 * Returns a vector hierarchy with all known macros in it.		 * Each element of this vector is either a macro name string,		 * or another vector. If it is a vector, the first element is a		 * string label, the rest are again, either macro name strings		 * or vectors.		 * @since jEdit 2.6pre1		 */		public static Vector getMacroHierarchy()		{			return macroHierarchy;		}	
/**		 * Returns an action set with all known macros in it.		 * @since jEdit 4.0pre1		 */		public static ActionSet getMacroActionSet()		{			return macroActionSet;		}	
/**		 * Returns the macro with the specified name.		 * @param macro The macro's name		 * @since jEdit 2.6pre1		 */		public static Macro getMacro(String macro)		{			return macroHash.get(macro);		}	
/**		 * @since jEdit 4.3pre1		 */		public static Macro getLastMacro()		{			return lastMacro;		}	
/**		 * @since jEdit 4.3pre1		 */		public static void setLastMacro(Macro macro)		{			lastMacro = macro;		}	
public Macro(Handler handler, String name, String label, String path)			{				super(name);				this.handler = handler;				this.label = label;				this.path = path;			}	
public Handler getHandler()			{				return handler;			}	
public String getPath()			{				return path;			}	
@Override			public void invoke(View view)			{				setLastMacro(this);					if(view == null)					handler.runMacro(null,this);				else				{					try					{						view.getBuffer().beginCompoundEdit();						handler.runMacro(view,this);					}					finally					{						view.getBuffer().endCompoundEdit();					}				}			}	
@Override			public String getCode()			{				return "Macros.getMacro(\"" + getName() + "\").invoke(view);";			}	
public static String macroNameToLabel(String macroName)			{				int index = macroName.lastIndexOf('/');				return macroName.substring(index + 1).replace('_', ' ');			}	
/**		 * Starts recording a temporary macro.		 * @param view The view		 * @since jEdit 2.7pre2		 */		public static void recordTemporaryMacro(View view)		{			String settings = jEdit.getSettingsDirectory();				if(settings == null)			{				GUIUtilities.error(view,"no-settings",new String[0]);				return;			}			if(view.getMacroRecorder() != null)			{				GUIUtilities.error(view,"already-recording",new String[0]);				return;			}				Buffer buffer = jEdit.openFile((View)null,settings + File.separator				+ "macros","Temporary_Macro.bsh",true,null);				if(buffer == null)				return;				buffer.remove(0,buffer.getLength());			buffer.insert(0,jEdit.getProperty("macro.temp.header"));				recordMacro(view,buffer,true);		}	
/**		 * Starts recording a macro.		 * @param view The view		 * @since jEdit 2.7pre2		 */		public static void recordMacro(View view)		{			String settings = jEdit.getSettingsDirectory();				if(settings == null)			{				GUIUtilities.error(view,"no-settings",new String[0]);				return;			}				if(view.getMacroRecorder() != null)			{				GUIUtilities.error(view,"already-recording",new String[0]);				return;			}				String name = GUIUtilities.input(view,"record",null);			if(name == null)				return;				name = name.replace(' ','_');				Buffer buffer = jEdit.openFile((View) null,null,				MiscUtilities.constructPath(settings,"macros",				name + ".bsh"),true,null);				if(buffer == null)				return;				buffer.remove(0,buffer.getLength());			buffer.insert(0,jEdit.getProperty("macro.header"));				recordMacro(view,buffer,false);		}	
/**		 * Stops a recording currently in progress.		 * @param view The view		 * @since jEdit 2.7pre2		 */		public static void stopRecording(View view)		{			Recorder recorder = view.getMacroRecorder();				if(recorder == null)				GUIUtilities.error(view,"macro-not-recording",null);			else			{				view.setMacroRecorder(null);				if(!recorder.temporary)					view.setBuffer(recorder.buffer);				recorder.dispose();			}		}	
/**		 * Runs the temporary macro.		 * @param view The view		 * @since jEdit 2.7pre2		 */		public static void runTemporaryMacro(View view)		{			String settings = jEdit.getSettingsDirectory();				if(settings == null)			{				GUIUtilities.error(view,"no-settings",null);				return;			}				String path = MiscUtilities.constructPath(				jEdit.getSettingsDirectory(),"macros",				"Temporary_Macro.bsh");				if(jEdit.getBuffer(path) == null)			{				GUIUtilities.error(view,"no-temp-macro",null);				return;			}				Handler handler = getHandler("beanshell");			Macro temp = handler.createMacro(path,path);				Buffer buffer = view.getBuffer();				try			{				buffer.beginCompoundEdit();				temp.invoke(view);			}			finally			{				/* I already wrote a comment expaining this in				 * Macro.invoke(). */				if(buffer.insideCompoundEdit())					buffer.endCompoundEdit();			}		}	
private static void loadMacros(List vector, String path, File directory)		{			lastMacro = null;				File[] macroFiles = directory.listFiles();			if(macroFiles == null || macroFiles.length == 0)				return;				for(int i = 0; i < macroFiles.length; i++)			{				File file = macroFiles[i];				String fileName = file.getName();				if(file.isHidden())				{					/* do nothing! */				}				else if(file.isDirectory())				{					String submenuName = fileName.replace('_',' ');					List submenu = null;					//{{{ try to merge with an existing menu first					for(int j = 0; j < vector.size(); j++)					{						Object obj = vector.get(j);						if(obj instanceof List)						{							List vec = (List)obj;							if(submenuName.equals(vec.get(0)))							{								submenu = vec;								break;							}						}					} //}}}					if(submenu == null)					{						submenu = new Vector();						submenu.add(submenuName);						vector.add(submenu);					}						loadMacros(submenu,path + fileName + '/',file);				}				else				{					addMacro(file,path,vector);				}			}		}	
private static void addMacro(File file, String path, List vector)		{			String fileName = file.getName();			Handler handler = getHandlerForPathName(file.getPath());				if(handler == null)				return;				try			{				// in case macro file name has a space in it.				// spaces break the view.toolBar property, for instance,				// since it uses spaces to delimit action names.				String macroName = (path + fileName).replace(' ','_');				Macro newMacro = handler.createMacro(macroName,					file.getPath());				// ignore if already added.				// see comment in loadMacros().				if(macroHash.get(newMacro.getName()) != null)					return;					vector.add(newMacro.getName());				jEdit.setTemporaryProperty(newMacro.getName()					+ ".label",					newMacro.label);				jEdit.setTemporaryProperty(newMacro.getName()					+ ".mouse-over",					handler.getLabel() + " - " + file.getPath());				macroActionSet.addAction(newMacro);				macroHash.put(newMacro.getName(),newMacro);			}			catch (Exception e)			{				Log.log(Log.ERROR, Macros.class, e);				macroHandlers.remove(handler);			}		}	
/**		 * Starts recording a macro.		 * @param view The view		 * @param buffer The buffer to record to		 * @param temporary True if this is a temporary macro		 * @since jEdit 3.0pre5		 */		private static void recordMacro(View view, Buffer buffer, boolean temporary)		{			view.setMacroRecorder(new Recorder(view,buffer,temporary));				// setting the message to 'null' causes the status bar to check			// if a recording is in progress			view.getStatus().setMessage(null);		}	
public Recorder(View view, Buffer buffer, boolean temporary)			{				this.view = view;				this.buffer = buffer;				this.temporary = temporary;				EditBus.addToBus(this);			}	
public void record(String code)			{				if (BeanShell.isScriptRunning())					return;				flushInput();					append("\n");				append(code);			}	
public void record(int repeat, String code)			{				if(repeat == 1)					record(code);				else				{					record("for(int i = 1; i <= " + repeat + "; i++)\n"						+ "{\n"						+ code + '\n'						+ '}');				}			}	
/**			 * @since jEdit 4.2pre5			 */			public void recordInput(int repeat, char ch, boolean overwrite)			{				// record \n and \t on lines specially so that auto indent				// can take place				if(ch == '\n')					record(repeat,"textArea.userInput(\'\\n\');");				else if(ch == '\t')					record(repeat,"textArea.userInput(\'\\t\');");				else				{					StringBuilder buf = new StringBuilder(repeat);					for(int i = 0; i < repeat; i++)						buf.append(ch);					recordInput(buf.toString(),overwrite);				}			}	
/**			 * @since jEdit 4.2pre5			 */			public void recordInput(String str, boolean overwrite)			{				String charStr = StandardUtilities.charsToEscapes(str);					if(overwrite)				{					if(lastWasOverwrite)					{						overwriteCount++;						append(charStr);					}					else					{						flushInput();						overwriteCount = 1;						lastWasOverwrite = true;						append("\ntextArea.setSelectedText(\"" + charStr);					}				}				else				{					if(lastWasInput)						append(charStr);					else					{						flushInput();						lastWasInput = true;						append("\ntextArea.setSelectedText(\"" + charStr);					}				}			}	
public void handleMessage(EBMessage msg)			{				if(msg instanceof BufferUpdate)				{					BufferUpdate bmsg = (BufferUpdate)msg;					if(bmsg.getWhat() == BufferUpdate.CLOSED)					{						if(bmsg.getBuffer() == buffer)							stopRecording(view);					}				}			}	
private void append(String str)			{				buffer.insert(buffer.getLength(),str);			}	
private void dispose()			{				flushInput();					for(int i = 0; i < buffer.getLineCount(); i++)				{					buffer.indentLine(i,true);				}					EditBus.removeFromBus(this);					// setting the message to 'null' causes the status bar to				// check if a recording is in progress				view.getStatus().setMessage(null);			}	
/**			 * We try to merge consecutive inputs. This helper method is			 * called when something other than input is to be recorded.			 */			private void flushInput()			{				if(lastWasInput)				{					lastWasInput = false;					append("\");");				}					if(lastWasOverwrite)				{					lastWasOverwrite = false;					append("\");\n");					append("offset = buffer.getLineEndOffset("						+ "textArea.getCaretLine()) - 1;\n");					append("buffer.remove(textArea.getCaretPosition(),"						+ "Math.min(" + overwriteCount						+ ",offset - "						+ "textArea.getCaretPosition()));");				}			}	
public String getName()			{				return name;			}	
public String getLabel()			{				return label;			}	
public boolean accept(String path)			{				return filter.matcher(MiscUtilities.getFileName(path)).matches();			}	
/**			 * Runs the specified macro. This method is optional; it is			 * called if the specified macro is a startup script. The			 * default behavior is to simply call {@link #runMacro(View,Macros.Macro)}.			 *			 * @param view The view - may be null.			 * @param macro The macro.			 * @param ownNamespace  A hint indicating whenever functions and			 * variables defined in the script are to be self-contained, or			 * made available to other scripts. The macro handler may ignore			 * this parameter.			 * @since jEdit 4.1pre3			 */			public void runMacro(View view, Macro macro, boolean ownNamespace)			{				runMacro(view,macro);			}	
protected Handler(String name)			{				this.name = name;				label = jEdit.getProperty("macro-handler."					+ name + ".label", name);				try				{					filter = Pattern.compile(StandardUtilities.globToRE(						jEdit.getProperty(						"macro-handler." + name + ".glob")));				}				catch (Exception e)				{					throw new InternalError("Missing or invalid glob for handler " + name);				}			}	
BeanShellHandler()			{				super("beanshell");			}	
@Override			public Macro createMacro(String macroName, String path)			{				// Remove '.bsh'				macroName = macroName.substring(0, macroName.length() - 4);					return new Macro(this, macroName,					Macro.macroNameToLabel(macroName), path);			}	
@Override			public void runMacro(View view, Macro macro)			{				BeanShell.runScript(view,macro.getPath(),null,true);			}	
@Override			public void runMacro(View view, Macro macro, boolean ownNamespace)			{				BeanShell.runScript(view,macro.getPath(),null,ownNamespace);			}	
public boolean updateEveryTime()		{			return false;		}	
public void update(JMenu menu)		{			Vector macroVector = Macros.getMacroHierarchy();				int count = menu.getMenuComponentCount();				createMacrosMenu(menu,macroVector,0);				if(count == menu.getMenuComponentCount())			{				JMenuItem mi = new JMenuItem(jEdit.getProperty(					"no-macros.label"));				mi.setEnabled(false);				menu.add(mi);			}		}	
private void createMacrosMenu(JMenu menu, Vector vector, int start)		{			Vector<JMenuItem> menuItems = new Vector<JMenuItem>();				for(int i = start; i < vector.size(); i++)			{				Object obj = vector.elementAt(i);				if(obj instanceof String)				{					menuItems.add(new EnhancedMenuItem(						jEdit.getProperty(obj + ".label"),						(String)obj,jEdit.getActionContext()));				}				else if(obj instanceof Vector)				{					Vector subvector = (Vector)obj;					String name = (String)subvector.elementAt(0);					JMenu submenu = new JMenu(name);					createMacrosMenu(submenu,subvector,1);					if(submenu.getMenuComponentCount() != 0)						menuItems.add(submenu);				}			}				Collections.sort(menuItems, new MenuItemTextComparator());			for(int i = 0; i < menuItems.size(); i++)			{				menu.add(menuItems.get(i));			}		}	
public ManagePanel(PluginManager window)		{			super(new BorderLayout(12,12));				this.window = window;				setBorder(new EmptyBorder(12,12,12,12));				Box topBox = new Box(BoxLayout.X_AXIS);			topBox.add(hideLibraries = new HideLibrariesButton());			add(BorderLayout.NORTH,topBox);				/* Create the plugin table */			table = new JTable(pluginModel = new PluginTableModel());			table.setShowGrid(false);			table.setIntercellSpacing(new Dimension(0,0));			table.setRowHeight(table.getRowHeight() + 2);			table.setPreferredScrollableViewportSize(new Dimension(500,300));			table.setDefaultRenderer(Object.class, new TextRenderer(				(DefaultTableCellRenderer)table.getDefaultRenderer(Object.class)));			table.addFocusListener(new TableFocusHandler());			table.getSelectionModel().addListSelectionListener(new TableSelectionListener());			InputMap tableInputMap = table.getInputMap(JComponent.WHEN_FOCUSED);			ActionMap tableActionMap = table.getActionMap();			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,0),"tabOutForward");			tableActionMap.put("tabOutForward",new KeyboardAction(KeyboardCommand.TAB_OUT_FORWARD));			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,InputEvent.SHIFT_MASK),"tabOutBack");			tableActionMap.put("tabOutBack",new KeyboardAction(KeyboardCommand.TAB_OUT_BACK));			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,0),"editPlugin");			tableActionMap.put("editPlugin",new KeyboardAction(KeyboardCommand.EDIT_PLUGIN));			tableInputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),"closePluginManager");			tableActionMap.put("closePluginManager",new KeyboardAction(KeyboardCommand.CLOSE_PLUGIN_MANAGER));				TableColumn col1 = table.getColumnModel().getColumn(0);			TableColumn col2 = table.getColumnModel().getColumn(1);			TableColumn col3 = table.getColumnModel().getColumn(2);			TableColumn col4 = table.getColumnModel().getColumn(3);				col1.setPreferredWidth(30);			col1.setMinWidth(30);			col1.setMaxWidth(30);			col1.setResizable(false);				col2.setPreferredWidth(300);			col3.setPreferredWidth(100);			col4.setPreferredWidth(100);				JTableHeader header = table.getTableHeader();			header.setReorderingAllowed(false);			HeaderMouseHandler mouseHandler = new HeaderMouseHandler();			header.addMouseListener(mouseHandler);			table.addMouseListener(mouseHandler);			scrollpane = new JScrollPane(table);			scrollpane.getViewport().setBackground(table.getBackground());			pluginDetailPanel = new PluginDetailPanel();			scrollpane.setPreferredSize(new Dimension(400,400));			JSplitPane split = new JSplitPane(JSplitPane.VERTICAL_SPLIT,				true, scrollpane, pluginDetailPanel);			add(BorderLayout.CENTER, split);			split.setResizeWeight(0.75);			/* Create button panel */			Box buttons = new Box(BoxLayout.X_AXIS);				buttons.add(new RemoveButton());			buttons.add(new SaveButton());			buttons.add(new RestoreButton());			buttons.add(new FindOrphan());			buttons.add(Box.createGlue());			buttons.add(new HelpButton());				add(BorderLayout.SOUTH,buttons);				pluginModel.update();		}	
public void update()		{			pluginModel.update();		}	
ManagePanelRestoreHandler()			{				selectedPlugins = new HashSet<String>();				jarNames = new HashSet<String>();			}	
@Override			public void startElement(String uri, String localName,								String qName, Attributes attrs) throws SAXException			{				if (localName.equals("plugin"))				{					String jarName = attrs.getValue("jar");					String name = attrs.getValue("name");					Entry e = new Entry(jarName);					e.name=name;					selectedPlugins.add(name);					jarNames.add(jarName);				}			}	
boolean loadPluginSet(String path)		{			VFS vfs = VFSManager.getVFSForPath(path);			Object session = vfs.createVFSSession(path, this);			try			{				InputStream is = vfs._createInputStream(session, path, false, this);				XMLUtilities.parseXML(is, new ManagePanelRestoreHandler());				is.close();				int rowCount = pluginModel.getRowCount();				for (int i=0 ; i<rowCount ; i++)				{					Entry ent = pluginModel.getEntry(i);					String name = ent.name;					if (name != null)					{						pluginModel.setValueAt(selectedPlugins.contains(name), i, 0);					}					else					{						String jarPath = ent.jar;						String jarName = jarPath.substring(1 + jarPath.lastIndexOf(File.separatorChar));						try						{							pluginModel.setValueAt(jarNames.contains(jarName), i, 0);						}						catch (Exception e)						{							Log.log(Log.WARNING, this, "Exception thrown loading: " + jarName);						}					}				}			}			catch (Exception e)			{				Log.log(Log.ERROR, this, "Loading Pluginset Error", e);				return false;			}			pluginModel.update();			return true;		}	
/**		 * Returns a collection of declared jars in the plugin.		 * If the plugin is loaded use {@link org.gjt.sp.jedit.PluginJAR#getRequiredJars()}		 * instead		 *		 * @param jarName the jar name of the plugin		 * @return a collection containing jars path		 * @throws IOException if jEdit cannot generate cache		 * @since jEdit 4.3pre12		 */		private static Collection<String> getDeclaredJars(String jarName) throws IOException		{			Collection<String> jarList = new ArrayList<String>();			PluginJAR pluginJAR = new PluginJAR(new File(jarName));			PluginJAR.PluginCacheEntry pluginCacheEntry = PluginJAR.getPluginCache(pluginJAR);			if (pluginCacheEntry == null)			{				pluginCacheEntry = pluginJAR.generateCache();			}			Properties cachedProperties = pluginCacheEntry.cachedProperties;				String jars = cachedProperties.getProperty("plugin." + pluginCacheEntry.pluginClass + ".jars");				if (jars != null)			{				String dir = MiscUtilities.getParentOfPath(pluginJAR.getPath());				StringTokenizer st = new StringTokenizer(jars);				while (st.hasMoreTokens())				{					String _jarPath = MiscUtilities.constructPath(dir, st.nextToken());					if (new File(_jarPath).exists())						jarList.add(_jarPath);				}			}			jarList.add(jarName);			return jarList;		}	
/**			 * Constructor used for jars that aren't loaded.			 *			 * @param jar jar file name			 */			Entry(String jar)			{				jars = new LinkedList<String>();				this.jar = jar;				jars.add(this.jar);				status = NOT_LOADED;			}	
/**			 * Constructor used for loaded jars.			 *			 * @param jar the pluginJar			 */			Entry(PluginJAR jar)			{				jars = new LinkedList<String>();				this.jar = jar.getPath();				jars.add(this.jar);					plugin = jar.getPlugin();				if(plugin != null)				{					status = plugin instanceof EditPlugin.Broken						? ERROR : LOADED;					clazz = plugin.getClassName();					name = jEdit.getProperty("plugin."+clazz+".name");					version = jEdit.getProperty("plugin."+clazz+".version");					author = jEdit.getProperty("plugin."+clazz+".author");					docs = jEdit.getProperty("plugin."+clazz+".docs");					description = jEdit.getProperty("plugin."+clazz+".description");					String jarsProp = jEdit.getProperty("plugin."+clazz+".jars");						if(jarsProp != null)					{						String directory = MiscUtilities.getParentOfPath(this.jar);							StringTokenizer st = new StringTokenizer(jarsProp);						while(st.hasMoreElements())						{							jars.add(MiscUtilities.constructPath(								directory,st.nextToken()));						}					}						String filesProp = jEdit.getProperty("plugin."+clazz+".files");						if(filesProp != null)					{						String directory = MiscUtilities.getParentOfPath(this.jar);							StringTokenizer st = new StringTokenizer(filesProp);						while(st.hasMoreElements())						{							jars.add(MiscUtilities.constructPath(								directory,st.nextToken()));						}					}				}				else				{					status = LOADED;				}			}	
PluginTableModel()			{				entries = new ArrayList<Entry>();			}	
public int getColumnCount()			{				return 5;			}	
@Override			public Class getColumnClass(int columnIndex)			{				switch (columnIndex)				{					case 0: return Boolean.class;					default: return Object.class;				}			}	
@Override			public String getColumnName(int column)			{				switch (column)				{					case 0:						return " ";					case 1:						return jEdit.getProperty("manage-plugins.info.name");					case 2:						return jEdit.getProperty("manage-plugins.info.version");					case 3:						return jEdit.getProperty("manage-plugins.info.status");					case 4:						return jEdit.getProperty("manage-plugins.info.data");					default:						throw new Error("Column out of range");				}			}	
public Entry getEntry(int rowIndex)			{				return entries.get(rowIndex);			}	
public int getRowCount()			{				return entries.size();			}	
public Object getValueAt(int rowIndex,int columnIndex)			{				Entry entry = entries.get(rowIndex);				switch (columnIndex)				{					case 0:						return Boolean.valueOf(!entry.status.equals(Entry.NOT_LOADED));					case 1:						if(entry.name == null)						{							return MiscUtilities.getFileName(entry.jar);						}						else						{							return entry.name;						}					case 2:						return entry.version;					case 3:						return jEdit.getProperty("plugin-manager.status." + entry.status);					case 4:						if (entry.dataSize == null && entry.plugin != null)						{							File pluginDirectory = entry.plugin.getPluginHome();							if (null == pluginDirectory)							{								return null;							}							if (pluginDirectory.exists())							{								entry.dataSize = MiscUtilities.formatFileSize(IOUtilities.fileLength(pluginDirectory));							}							else							{								if (jEdit.getBooleanProperty("plugin." + entry.clazz + ".usePluginHome"))								{									entry.dataSize = MiscUtilities.formatFileSize(0);								}								else								{									entry.dataSize = jEdit.getProperty("manage-plugins.data-size.unknown");								}								}						}						return entry.dataSize;					default:						throw new Error("Column out of range");				}			}	
@Override			public boolean isCellEditable(int rowIndex, int columnIndex)			{				return columnIndex == 0;			}	
@Override			public void setValueAt(Object value, int rowIndex,				int columnIndex)			{				Entry entry = entries.get(rowIndex);				if(columnIndex == 0)				{					PluginJAR jar = jEdit.getPluginJAR(entry.jar);					if(jar == null)					{						if(value.equals(Boolean.FALSE))							return;							PluginJAR.load(entry.jar, true);					}					else					{						if(value.equals(Boolean.TRUE))							return;							unloadPluginJARWithDialog(jar);					}				}					update();			}	
public void setSortType(int type)			{				sortType = type;				sort(type);			}	
public void sort(int type)			{				List<String> savedSelection = new ArrayList<String>();				saveSelection(savedSelection);				Collections.sort(entries,new EntryCompare(type));				fireTableChanged(new TableModelEvent(this));				restoreSelection(savedSelection);			}	
public void update()			{				List<String> savedSelection = new ArrayList<String>();				saveSelection(savedSelection);				entries.clear();					String systemJarDir = MiscUtilities.constructPath(					jEdit.getJEditHome(),"jars");				String userJarDir;				String settingsDirectory = jEdit.getSettingsDirectory();				if(settingsDirectory == null)					userJarDir = null;				else				{					userJarDir = MiscUtilities.constructPath(						settingsDirectory,"jars");				}					PluginJAR[] plugins = jEdit.getPluginJARs();				for(int i = 0; i < plugins.length; i++)				{					String path = plugins[i].getPath();					if(path.startsWith(systemJarDir)						|| (userJarDir != null						&& path.startsWith(userJarDir)))					{						Entry e = new Entry(plugins[i]);						if(!hideLibraries.isSelected()							|| e.clazz != null)						{							entries.add(e);						}					}				}					String[] newPlugins = jEdit.getNotLoadedPluginJARs();				for(int i = 0; i < newPlugins.length; i++)				{					Entry e = new Entry(newPlugins[i]);					entries.add(e);				}					sort(sortType);				restoreSelection(savedSelection);			}	
private void unloadPluginJARWithDialog(PluginJAR jar)			{				// unloaded = new HashSet<String>();				unloaded = new ConcurrentHashMap<String, Object>();				String[] dependents = jar.getDependentPlugins();				if(dependents.length == 0)					unloadPluginJAR(jar);				else				{					List<String> closureSet = new LinkedList<String>();					PluginJAR.transitiveClosure(dependents, closureSet);					List<String> listModel = new ArrayList<String>();					listModel.addAll(closureSet);					Collections.sort(listModel, new StandardUtilities.StringCompare<String>(true));						int button = GUIUtilities.listConfirm(window,"plugin-manager.dependency",						new String[] { jar.getFile().getName() }, listModel.toArray());					if(button == JOptionPane.YES_OPTION)						unloadPluginJAR(jar);				}			}	
private void unloadPluginJAR(PluginJAR jar)			{				String[] dependents = jar.getDependentPlugins();				for (String dependent : dependents)				{					if (!unloaded.containsKey(dependent))					{						unloaded.put(dependent, Boolean.TRUE);						PluginJAR _jar = jEdit.getPluginJAR(dependent);						if(_jar != null)							unloadPluginJAR(_jar);					}				}				jEdit.removePluginJAR(jar,false);				jEdit.setBooleanProperty("plugin-blacklist."+MiscUtilities.getFileName(jar.getPath()),true);			}	
/**			 * Save the selection in the given list.			 * The list will be filled with the jar names of the selected entries			 *			 * @param savedSelection the list where to save the selection			 */			public void saveSelection(List<String> savedSelection)			{				if (table != null)				{					int[] rows = table.getSelectedRows();					for (int i=0 ; i<rows.length ; i++)					{						savedSelection.add(entries.get(rows[i]).jar);					}				}			}	
/**			 * Restore the selection.			 *			 * @param savedSelection the selection list that contains the jar names of the selected items			 */			public void restoreSelection(List<String> savedSelection)			{				if (null != table)				{					table.setColumnSelectionInterval(0,0);					if (!savedSelection.isEmpty())					{						int i = 0;						int rowCount = getRowCount();						for ( ; i<rowCount ; i++)						{							if (savedSelection.contains(entries.get(i).jar))							{								table.setRowSelectionInterval(i,i);								break;							}						}						ListSelectionModel lsm = table.getSelectionModel();						for ( ; i<rowCount ; i++)						{							if (savedSelection.contains(entries.get(i).jar))							{								lsm.addSelectionInterval(i,i);							}						}					}					else					{						if (table.getRowCount() != 0)							table.setRowSelectionInterval(0,0);						JScrollBar scrollbar = scrollpane.getVerticalScrollBar();						scrollbar.setValue(scrollbar.getMinimum());					}				}			}	
TextRenderer(DefaultTableCellRenderer tcr)			{				this.tcr = tcr;			}	
@Override			public Component getTableCellRendererComponent(JTable table, Object value,				boolean isSelected, boolean hasFocus, int row, int column)			{				Entry entry = pluginModel.getEntry(row);				if (entry.status.equals(Entry.ERROR))					tcr.setForeground(Color.red);				else					tcr.setForeground(UIManager.getColor("Table.foreground"));				return tcr.getTableCellRendererComponent(table,value,isSelected,false,row,column);			}	
HideLibrariesButton()			{				super(jEdit.getProperty("plugin-manager.hide-libraries"));				setSelected(jEdit.getBooleanProperty(					"plugin-manager.hide-libraries.toggle"));				addActionListener(this);			}	
public void actionPerformed(ActionEvent evt)			{				jEdit.setBooleanProperty(					"plugin-manager.hide-libraries.toggle",					isSelected());				ManagePanel.this.update();			}	
RestoreButton()			{				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("manage-plugins.restore.icon")));				addActionListener(this);				setToolTipText("Choose a PluginSet, select/deselect plugins based on set.");			}	
public void actionPerformed(ActionEvent e)			{				String path = jEdit.getProperty(PluginManager.PROPERTY_PLUGINSET,					jEdit.getSettingsDirectory() + File.separator);				String[] selectedFiles = GUIUtilities.showVFSFileDialog(ManagePanel.this.window,					jEdit.getActiveView(), path, VFSBrowser.OPEN_DIALOG, false);				if (selectedFiles == null || selectedFiles.length != 1) return;				path = selectedFiles[0];				boolean success = loadPluginSet(path);				if (success)				{					jEdit.setProperty(PluginManager.PROPERTY_PLUGINSET, path);					EditBus.send(new PropertiesChanged(PluginManager.getInstance()));				}				}	
SaveButton()			{				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("manage-plugins.save.icon")));				setToolTipText("Save Currently Checked Plugins Set");				addActionListener(this);				setEnabled(true);			}	
void saveState(String vfsURL, List<Entry> pluginList)			{				StringBuilder sb = new StringBuilder("<pluginset>\n ");					for (Entry entry: pluginList)				{					String jarName = entry.jar.substring(1+entry.jar.lastIndexOf(File.separatorChar));					sb.append("   <plugin name=\"").append(entry.name).append("\" jar=\"");					sb.append(jarName).append("\" />\n ");				}				sb.append("</pluginset>\n");					VFS vfs = VFSManager.getVFSForPath(vfsURL);				Object session = vfs.createVFSSession(vfsURL, ManagePanel.this);				Writer writer = null;				try				{					OutputStream os = vfs._createOutputStream(session, vfsURL, ManagePanel.this);					writer = new BufferedWriter(new OutputStreamWriter(os));					writer.write(sb.toString());				}				catch (Exception e)				{					Log.log(Log.ERROR, this, "Saving State Error", e);				}				finally				{					IOUtilities.closeQuietly(writer);				}				}	
public void actionPerformed(ActionEvent e)			{				String path = jEdit.getProperty("plugin-manager.pluginset.path", jEdit.getSettingsDirectory() + File.separator);				VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(					ManagePanel.this.window, jEdit.getActiveView(),					path, VFSBrowser.SAVE_DIALOG, false , true);				String[] fileselections = fileChooser.getSelectedFiles();				List<Entry> pluginSelections = new ArrayList<Entry>();				if (fileselections == null || fileselections.length != 1) return;					PluginJAR[] jars = jEdit.getPluginJARs();				for (PluginJAR jar : jars)				{					if (jar.getPlugin() != null)					{						Entry entry = new Entry (jar);						pluginSelections.add(entry);					}				}				saveState(fileselections[0], pluginSelections);				jEdit.setProperty("plugin-manager.pluginset.path", fileselections[0]);				EditBus.send(new PropertiesChanged(PluginManager.getInstance()));			}	
RemoveButton()			{				super(jEdit.getProperty("manage-plugins.remove"));				table.getSelectionModel().addListSelectionListener(this);				addActionListener(this);				setEnabled(false);			}	
public void actionPerformed(ActionEvent evt)			{				int[] selected = table.getSelectedRows();					List<String> listModel = new LinkedList<String>();				Roster roster = new Roster();				Set<String> jarsToRemove = new HashSet<String>();				// this one will contains the loaded jars to remove. They				// are the only one we need to check to unload plugins				// that depends on them				Set<String> loadedJarsToRemove = new HashSet<String>();				for(int i = 0; i < selected.length; i++)				{					Entry entry = pluginModel.getEntry(selected[i]);					if (entry.status.equals(Entry.NOT_LOADED))					{						if (entry.jar != null)						{							try							{								Collection<String> jarList = getDeclaredJars(entry.jar);								jarsToRemove.addAll(jarList);							}							catch (IOException e)							{								Log.log(Log.ERROR, this, e);							}						}					}					else					{						jarsToRemove.addAll(entry.jars);						loadedJarsToRemove.addAll(entry.jars);					}					table.getSelectionModel().removeSelectionInterval(selected[i], selected[i]);				}					for (String jar : jarsToRemove)				{					listModel.add(jar);					roster.addRemove(jar);				}					int button = GUIUtilities.listConfirm(window,					"plugin-manager.remove-confirm",					null,listModel.toArray());				if(button == JOptionPane.YES_OPTION)				{						List<String> closureSet = new ArrayList<String>();					PluginJAR.transitiveClosure(loadedJarsToRemove.toArray(new String[loadedJarsToRemove.size()]), closureSet);					closureSet.removeAll(listModel);					if (closureSet.isEmpty())					{						button = JOptionPane.YES_OPTION;					}					else					{						button = GUIUtilities.listConfirm(window,"plugin-manager.remove-dependencies",							null, closureSet.toArray());						Collections.sort(closureSet, new StandardUtilities.StringCompare<String>(true));					}					if(button == JOptionPane.YES_OPTION)					{						for (String jarName:closureSet)						{							PluginJAR pluginJAR = jEdit.getPluginJAR(jarName);							jEdit.removePluginJAR(pluginJAR, false);						}						roster.performOperationsInAWTThread(window);						pluginModel.update();						if (table.getRowCount() != 0)						{							table.setRowSelectionInterval(0,0);						}						table.setColumnSelectionInterval(0,0);						JScrollBar scrollbar = scrollpane.getVerticalScrollBar();						scrollbar.setValue(scrollbar.getMinimum());					}				}			}	
public void valueChanged(ListSelectionEvent e)			{				if (table.getSelectedRowCount() == 0)					setEnabled(false);				else					setEnabled(true);			}	
private FindOrphan()			{				super(jEdit.getProperty("plugin-manager.findOrphan.label"));				addActionListener(this);			}	
public void actionPerformed(ActionEvent e)			{				PluginJAR[] pluginJARs = jEdit.getPluginJARs();				Set<String> neededJars = new HashSet<String>();					Map<String, String> jarlibs = new HashMap<String, String>();				for (PluginJAR pluginJAR : pluginJARs)				{					EditPlugin plugin = pluginJAR.getPlugin();					if (plugin == null)					{						jarlibs.put(new File(pluginJAR.getPath()).getName(), pluginJAR.getPath());					}					else					{						Set<String> strings = plugin.getPluginJAR().getRequiredJars();						for (String string : strings)						{							neededJars.add(new File(string).getName());						}					}				}					String[] notLoadedJars = jEdit.getNotLoadedPluginJARs();				for (int i = 0; i < notLoadedJars.length; i++)				{					PluginJAR pluginJAR = new PluginJAR(new File(notLoadedJars[i]));					PluginJAR.PluginCacheEntry pluginCacheEntry = PluginJAR.getPluginCache(pluginJAR);					try					{						if (pluginCacheEntry == null)						{							pluginCacheEntry = pluginJAR.generateCache();						}						if (pluginCacheEntry.pluginClass == null)						{							// Not a plugin							jarlibs.put(new File(notLoadedJars[i]).getName(), notLoadedJars[i]);							continue;						}								Properties cachedProperties = pluginCacheEntry.cachedProperties;							String jars = cachedProperties.getProperty("plugin." + pluginCacheEntry.pluginClass + ".jars");							if (jars != null)						{							StringTokenizer st = new StringTokenizer(jars);							while (st.hasMoreTokens())							{								neededJars.add(st.nextToken());							}						}					}					catch (IOException e1)					{						Log.log(Log.ERROR, this, e);					}				}					List<String> removingJars = new ArrayList<String>();				Set<String> jarlibsKeys = jarlibs.keySet();				for (String jar : jarlibsKeys)				{					if (!neededJars.contains(jar))					{						removingJars.add(jar);						Log.log(Log.MESSAGE, this, "It seems that this jar do not belong to any plugin " +jar);					}				}				if(removingJars.isEmpty())				{					GUIUtilities.message(ManagePanel.this, "plugin-manager.noOrphan", null);					return;				}					String[] strings = removingJars.toArray(new String[removingJars.size()]);				List<String> mustRemove = new ArrayList<String>();				int ret = GUIUtilities.listConfirm(ManagePanel.this,								   "plugin-manager.findOrphan",								   null,								   strings,								   mustRemove);				if (ret != JOptionPane.OK_OPTION || mustRemove.isEmpty())					return;					Roster roster = new Roster();				for (int i = 0; i < mustRemove.size(); i++)				{					String entry = mustRemove.get(i);					roster.addRemove(jarlibs.get(entry));				}					roster.performOperationsInAWTThread(window);				pluginModel.update();				if (table.getRowCount() != 0)				{					table.setRowSelectionInterval(0,0);				}				table.setColumnSelectionInterval(0,0);				JScrollBar scrollbar = scrollpane.getVerticalScrollBar();				scrollbar.setValue(scrollbar.getMinimum());				table.repaint();			}	
HelpButton()			{				super(jEdit.getProperty("manage-plugins.help"));				table.getSelectionModel().addListSelectionListener(this);				addActionListener(this);				setEnabled(false);			}	
public void actionPerformed(ActionEvent evt)			{				new HelpViewer(docURL);			}	
public void valueChanged(ListSelectionEvent e)			{				if (table.getSelectedRowCount() == 1)				{					try					{						Entry entry = pluginModel.getEntry(table.getSelectedRow());						String label = entry.clazz;						String docs = entry.docs;						if (label != null)						{							EditPlugin plug = jEdit.getPlugin(label, false);							PluginJAR jar = null;							if (plug != null) jar = plug.getPluginJAR();							if(jar != null && docs != null)							{								URL url = jar.getClassLoader().getResource(docs);								if(url != null)								{									docURL = url;									setEnabled(true);									return;								}							}						}					}					catch (Exception ex)					{						Log.log(Log.ERROR, this, "ManagePanel HelpButton Update", ex);					}				}				setEnabled(false);			}	
EntryCompare(int type)			{				this.type = type;			}	
public int compare(Entry e1, Entry e2)			{				if (type == NAME)					return compareNames(e1,e2);				else				{					int result;					if ((result = e1.status.compareToIgnoreCase(e2.status)) == 0)						return compareNames(e1,e2);					return result;				}			}	
private static int compareNames(Entry e1, Entry e2)			{				String s1;				if(e1.name == null)					s1 = MiscUtilities.getFileName(e1.jar);				else					s1 = e1.name;				String s2;				if(e2.name == null)					s2 = MiscUtilities.getFileName(e2.jar);				else					s2 = e2.name;					return s1.compareToIgnoreCase(s2);			}	
@Override			public void mouseClicked(MouseEvent evt)			{				if (evt.getSource() == table.getTableHeader())				{					switch(table.getTableHeader().columnAtPoint(evt.getPoint()))					{						case 1:							pluginModel.setSortType(EntryCompare.NAME);							break;						case 3:							pluginModel.setSortType(EntryCompare.STATUS);							break;						default:							break;					}				}				else				{					if (GUIUtilities.isPopupTrigger(evt))					{						int row = table.rowAtPoint(evt.getPoint());						if (row != -1 &&						    !table.isRowSelected(row))						{							table.setRowSelectionInterval(row,row);						}						if (popup == null)						{							popup = new JPopupMenu();							JMenuItem item = GUIUtilities.loadMenuItem("plugin-manager.cleanup");							item.addActionListener(new CleanupActionListener());							popup.add(item);						}						GUIUtilities.showPopupMenu(popup, table, evt.getX(), evt.getY());					}				}			}	
public void actionPerformed(ActionEvent e)				{						int[] ints = table.getSelectedRows();					List<String> list = new ArrayList<String>(ints.length);					List<Entry> entries = new ArrayList<Entry>(ints.length);					for (int i = 0; i < ints.length; i++)					{						Entry entry = pluginModel.getEntry(ints[i]);						if (entry.plugin != null)						{							list.add(entry.name);							entries.add(entry);						}					}						String[] strings = list.toArray(new String[list.size()]);					int ret = GUIUtilities.listConfirm(ManagePanel.this,									   "plugin-manager.cleanup",									   null,									   strings);					if (ret != JOptionPane.OK_OPTION)						return;						for (int i = 0; i < entries.size(); i++)					{						Entry entry = entries.get(i);						File path = entry.plugin.getPluginHome();						Log.log(Log.NOTICE, this, "Removing data of plugin " + entry.name + " home="+path);						FileVFS.recursiveDelete(path);						entry.dataSize = null;					}					table.repaint();				}	
KeyboardAction(KeyboardCommand command)			{				this.command = command;			}	
public void actionPerformed(ActionEvent evt)			{				switch (command)				{				case TAB_OUT_FORWARD:					KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent();					break;				case TAB_OUT_BACK:					KeyboardFocusManager.getCurrentKeyboardFocusManager().focusPreviousComponent();					break;				case EDIT_PLUGIN:					int[] rows = table.getSelectedRows();					for (int i = 0; i < rows.length; i++)					{						Object st = pluginModel.getValueAt(rows[i], 0);						pluginModel.setValueAt(st.equals(Boolean.FALSE), rows[i], 0);					}					break;				case CLOSE_PLUGIN_MANAGER:					window.ok();					break;				default:					throw new InternalError();				}			}	
@Override			public void focusGained(FocusEvent fe)			{				if (table.getSelectedRow() == -1)				{					table.setRowSelectionInterval(0,0);					JScrollBar scrollbar = scrollpane.getVerticalScrollBar();					scrollbar.setValue(scrollbar.getMinimum());				}				if (table.getSelectedColumn() == -1)				{					table.setColumnSelectionInterval(0,0);				}			}	
public void valueChanged(ListSelectionEvent e)			{				int row = table.getSelectedRow();				if (row != -1)				{					Entry entry = pluginModel.getEntry(row);					pluginDetailPanel.setPlugin(entry);				}			}	
/**		 * Returns the marker's shortcut character.		 * @since jEdit 3.2pre1		 */		public char getShortcut()		{			return shortcut;		}	
/**		 * Returns the position of this marker.		 * @since jEdit 3.2pre1		 */		public int getPosition()		{			return (position == null ? pos : position.getOffset());		}	
Marker(Buffer buffer, char shortcut, int position)		{			this.buffer = buffer;			this.shortcut = shortcut;			this.pos = position;		}	
/**		 * Sets the marker's shortcut.		 * @param shortcut The new shortcut		 * @since jEdit 3.2pre1		 */		void setShortcut(char shortcut)		{			this.shortcut = shortcut;		}	
void createPosition()		{			position = buffer.createPosition(pos);		}	
void removePosition()		{			// forget the cached Position instance			if(position != null)			{				pos = position.getOffset();				position = null;			}		}	
/**		 * Sets the position of this marker.		 * @since jEdit 4.0pre5		 */		void setPosition(int pos)		{			this.pos = pos;		}	
public boolean updateEveryTime()		{			return true;		}	
public void update(JMenu menu)		{			final View view = GUIUtilities.getView(menu);			Buffer buffer = view.getBuffer();				List<Marker> markers = buffer.getMarkers();				if(markers.isEmpty())			{				JMenuItem mi = new JMenuItem(jEdit.getProperty(					"no-markers.label"));				mi.setEnabled(false);				menu.add(mi);				return;			}				int maxItems = jEdit.getIntegerProperty("menu.spillover",20);				JMenu current = menu;				for(int i = 0; i < markers.size(); i++)			{				final Marker marker = markers.get(i);				int lineNo = buffer.getLineOfOffset(marker.getPosition());					if(current.getItemCount() >= maxItems && i != markers.size() - 1)				{					//current.addSeparator();					JMenu newCurrent = new JMenu(						jEdit.getProperty(						"common.more"));					current.add(newCurrent);					current = newCurrent;				}					JMenuItem mi = new MarkersMenuItem(buffer,					lineNo,marker.getShortcut());				mi.addActionListener(new ActionListener()				{					public void actionPerformed(ActionEvent evt)					{						view.getTextArea().setCaretPosition(							marker.getPosition());					}				});				current.add(mi);			}		}	
MarkersMenuItem(Buffer buffer, int lineNo, char shortcut)			{				String text = buffer.getLineText(lineNo).trim();				if(text.length() == 0)					text = jEdit.getProperty("markers.blank-line");				setText((lineNo + 1) + ": " + text);					shortcutProp = "goto-marker.shortcut";				MarkersMenuItem.this.shortcut = shortcut;			}	
public Dimension getPreferredSize()			{				Dimension d = super.getPreferredSize();					String shortcut = getShortcut();					if(shortcut != null)				{					d.width += (getFontMetrics(acceleratorFont)						.stringWidth(shortcut) + 15);				}				return d;			}	
public void paint(Graphics g)			{				super.paint(g);					String shortcut = getShortcut();					if(shortcut != null)				{					g.setFont(acceleratorFont);					g.setColor(getModel().isArmed() ?						acceleratorSelectionForeground :						acceleratorForeground);					FontMetrics fm = g.getFontMetrics();					Insets insets = getInsets();					g.drawString(shortcut,getWidth() - (fm.stringWidth(						shortcut) + insets.right + insets.left + 5),						getFont().getSize() + (insets.top - 1)						/* XXX magic number */);				}			}	
private String getShortcut()			{				if(shortcut == '\0')					return null;				else				{					String shortcutPrefix = jEdit.getProperty(shortcutProp);						if(shortcutPrefix == null)						return null;					else					{						return shortcutPrefix + ' ' + shortcut;					}				}			}	
/**		 * Creates a new I/O request for markers.		 * @param view The view		 * @param buffer The buffer		 * @param session The VFS session		 * @param vfs The VFS		 * @param path The path		 */		public MarkersSaveRequest(View view, Buffer buffer,			Object session, VFS vfs, String path)		{			this.view = view;			this.buffer = buffer;			this.session = session;			this.vfs = vfs;			this.path = path;			this.markersPath = Buffer.getMarkersPath(vfs, path);			}	
public void run()		{			OutputStream out = null;				try			{				// the entire save operation can be aborted...				setAbortable(true);				try				{					// We only save markers to VFS's that support deletion.					// Otherwise, we will accumilate stale marks files.					if((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)					{						if(buffer.getMarkers().isEmpty())							vfs._delete(session,markersPath,view);						else						{							String[] args = { vfs.getFileName(path) };							setStatus(jEdit.getProperty("vfs.status.save-markers",args));							setValue(0);							out = vfs._createOutputStream(session,markersPath,view);							if(out != null)								writeMarkers(out);							}					}				}				catch(IOException io)				{					Log.log(Log.ERROR,this,io);					buffer.setBooleanProperty(ERROR_OCCURRED,true);				}			}			catch(WorkThread.Abort a)			{				IOUtilities.closeQuietly(out);				buffer.setBooleanProperty(ERROR_OCCURRED,true);			}		}	
private void writeMarkers(OutputStream out)			throws IOException		{			Writer o = new BufferedWriter(new OutputStreamWriter(out));			try			{				List<Marker> markers = buffer.getMarkers();				for(int i = 0; i < markers.size(); i++)				{					Marker marker = markers.get(i);					o.write('!');					o.write(marker.getShortcut());					o.write(';');						String pos = String.valueOf(marker.getPosition());					o.write(pos);					o.write(';');					o.write(pos);					o.write('\n');				}			}			finally			{				o.close();			}		}	
public MarkerViewer(View view)		{			super(new BorderLayout());			this.view = view;			Box toolBar = new Box(BoxLayout.X_AXIS);				toolBar.add(new JLabel(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("markers.label"))));				toolBar.add(Box.createGlue());				RolloverButton addMarker = new RolloverButton(				GUIUtilities.loadIcon("Plus.png"));			addMarker.setToolTipText(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("add-marker.label")));			addMarker.addActionListener(this);			addMarker.setActionCommand("add-marker");			toolBar.add(addMarker);				previous = new RolloverButton(GUIUtilities.loadIcon("ArrowL.png"));			previous.setToolTipText(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("prev-marker.label")));			previous.addActionListener(this);			previous.setActionCommand("prev-marker");			toolBar.add(previous);				next = new RolloverButton(GUIUtilities.loadIcon("ArrowR.png"));			next.setToolTipText(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("next-marker.label")));			next.addActionListener(this);			next.setActionCommand("next-marker");			toolBar.add(next);				clear = new RolloverButton(GUIUtilities.loadIcon("Clear.png"));			clear.setToolTipText(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("remove-all-markers.label")));			clear.addActionListener(this);			clear.setActionCommand("clear");			toolBar.add(clear);					add(BorderLayout.NORTH, toolBar);				markerList = new JList();			markerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			markerList.setCellRenderer(new Renderer());			markerList.addMouseListener(new MouseHandler());				add(BorderLayout.CENTER,new JScrollPane(markerList));				refreshList();		}	
public boolean requestDefaultFocus()		{			markerList.requestFocus();			return true;		}	
public void actionPerformed(ActionEvent evt)		{			String cmd = evt.getActionCommand();			if (cmd.equals("clear"))				view.getBuffer().removeAllMarkers();			else if (cmd.equals("add-marker"))				view.getEditPane().addMarker();			else if (cmd.equals("next-marker"))			{				view.getEditPane().goToNextMarker(false);				updateSelection();			}			else if (cmd.equals("prev-marker"))			{				view.getEditPane().goToPrevMarker(false);				updateSelection();			}		}	
public void handleMessage(EBMessage msg)		{			if (msg instanceof EditPaneUpdate)			{				EditPaneUpdate epu = (EditPaneUpdate)msg;				if (epu.getEditPane().getView().equals(view) &&					epu.getWhat().equals(EditPaneUpdate.BUFFER_CHANGED))					refreshList();			}			if (msg instanceof ViewUpdate)			{				ViewUpdate vu = (ViewUpdate)msg;				if (vu.getView().equals(view) &&					vu.getWhat().equals(ViewUpdate.EDIT_PANE_CHANGED))					refreshList();			}			if (msg instanceof BufferUpdate)			{				BufferUpdate bu = (BufferUpdate)msg;				if (view.getBuffer().equals(bu.getBuffer())					&&					(bu.getWhat().equals(BufferUpdate.MARKERS_CHANGED) || bu.getWhat().equals(BufferUpdate.LOADED)))					refreshList();			}		}	
public void addNotify()		{			super.addNotify();			EditBus.addToBus(this);		}	
public void removeNotify()		{			super.removeNotify();			EditBus.removeFromBus(this);		}	
private void refreshList()		{			java.util.Vector markers = view.getBuffer().getMarkers();			if (markers.size() > 0)			{				markerList.setListData(markers);				markerList.setEnabled(true);				next.setEnabled(true);				previous.setEnabled(true);				clear.setEnabled(true);			}			else			{				markerList.setListData(new Object[] {					jEdit.getProperty("no-markers.label") });				markerList.setEnabled(false);				next.setEnabled(false);				previous.setEnabled(false);				clear.setEnabled(false);			}			}	
private void goToSelectedMarker()		{			Object value = markerList.getSelectedValue();			if(!(value instanceof Marker))				return;				Marker mark = (Marker)value;			view.getTextArea().setCaretPosition(mark.getPosition());			view.toFront();			view.requestFocus();			view.getTextArea().requestFocus();		}	
private void updateSelection()		{			ListModel model = markerList.getModel();			int currentLine = view.getTextArea().getCaretLine();			Buffer buffer = view.getBuffer();			for (int i = 0; i < model.getSize(); i++)			{				Object o = model.getElementAt(i);				if (o instanceof Marker)				{					Marker mark = (Marker)model.getElementAt(i);					if (buffer.getLineOfOffset(mark.getPosition()) == currentLine)					{						markerList.setSelectedIndex(i);						break;					}				}			}			}	
public Component getListCellRendererComponent(				JList list, Object value, int index,				boolean isSelected, boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,				index,isSelected,cellHasFocus);					if(value instanceof Marker)				{					Marker mark = (Marker)value;					JEditTextArea textArea = view.getTextArea();					int pos = textArea.getLineOfOffset(mark.getPosition());					String txt = view.getTextArea().getLineText(pos);					if (txt.equals(""))						txt = jEdit.getProperty("markers.blank-line");					char shortcut_char = mark.getShortcut();					String shortcut = "";					if (shortcut_char > 0)						shortcut = "["+shortcut_char+"]";					setText((pos+1)+" "+shortcut+": "+txt);				}				return this;			}	
public void mousePressed(MouseEvent evt)			{				if(evt.isConsumed())					return;					int index = markerList.locationToIndex(evt.getPoint());				markerList.setSelectedIndex(index);					goToSelectedMarker();			}	
public Widget getWidget(View view) 		{			Widget memory = new MemoryStatusWidget(view);			return memory;		}	
public MemoryStatusWidget(View view) 			{				memoryStatus = new MemoryStatus(view);			}	
public JComponent getComponent() 			{				return memoryStatus;			}	
public void update() 			{			}	
public void propertiesChanged()			{			}	
MemoryStatus(View view)			{				this.view = view;				// fucking GTK look and feel				Font font = new JLabel().getFont();				//Font font = UIManager.getFont("Label.font");				MemoryStatus.this.setFont(font);					FontRenderContext frc = new FontRenderContext(					null,false,false);				Rectangle2D bounds = font.getStringBounds(					memoryTestStr,frc);				Dimension dim = new Dimension((int)bounds.getWidth(),					(int)bounds.getHeight());				setPreferredSize(dim);				setMaximumSize(dim);				lm = font.getLineMetrics(memoryTestStr,frc);					setForeground(jEdit.getColorProperty("view.status.foreground"));				setBackground(jEdit.getColorProperty("view.status.background"));					progressForeground = jEdit.getColorProperty(					"view.status.memory.foreground");				progressBackground = jEdit.getColorProperty(					"view.status.memory.background");					addMouseListener(new MouseHandler());			}	
@Override			public void addNotify()			{				super.addNotify();				timer = new Timer(2000,this);				timer.start();				ToolTipManager.sharedInstance().registerComponent(this);			}	
@Override			public void removeNotify()			{				timer.stop();				ToolTipManager.sharedInstance().unregisterComponent(this);				super.removeNotify();			}	
@Override			public String getToolTipText()			{				Runtime runtime = Runtime.getRuntime();				long free = runtime.freeMemory();				long total = runtime.totalMemory();				long used = total - free;				args[0] = (int) (used / 1024);				args[1] = (int) (total / 1024);				return jEdit.getProperty("view.status.memory-tooltip",args);			}	
@Override			public Point getToolTipLocation(MouseEvent event)			{				return new Point(event.getX(),-20);			}	
public void actionPerformed(ActionEvent evt)			{				MemoryStatus.this.repaint();			}	
@Override			public void paintComponent(Graphics g)			{				Insets insets = new Insets(0,0,0,0);//MemoryStatus.this.getBorder().getBorderInsets(this);					Runtime runtime = Runtime.getRuntime();				long free = runtime.freeMemory();				long total = runtime.totalMemory();				long used = total - free;					int width = MemoryStatus.this.getWidth()					- insets.left - insets.right;				int height = MemoryStatus.this.getHeight()					- insets.top - insets.bottom - 1;					float fraction = ((float)used) / total;					g.setColor(progressBackground);					g.fillRect(insets.left,insets.top,					(int)(width * fraction),					height);					String str = (used / 1024 / 1024) + "/"					+ (total / 1024 / 1024) + "Mb";					FontRenderContext frc = new FontRenderContext(null,false,false);					Rectangle2D bounds = g.getFont().getStringBounds(str,frc);					Graphics g2 = g.create();				g2.setClip(insets.left,insets.top,					(int)(width * fraction),					height);					g2.setColor(progressForeground);					g2.drawString(str,					insets.left + ((int) (width - bounds.getWidth()) / 2),					(int)(insets.top + lm.getAscent()));					g2.dispose();					g2 = g.create();					g2.setClip(insets.left + (int)(width * fraction),					insets.top,MemoryStatus.this.getWidth()					- insets.left - (int)(width * fraction),					height);					g2.setColor(MemoryStatus.this.getForeground());					g2.drawString(str,					insets.left + ((int) (width - bounds.getWidth()) >> 1),					(int)(insets.top + lm.getAscent()));					g2.dispose();			}	
@Override				public void mousePressed(MouseEvent evt)				{					if(evt.getClickCount() == 2)					{						jEdit.showMemoryDialog(view);						repaint();					}				}	
public int compare(JMenuItem obj1, JMenuItem obj2)		{			int compareValue = 0;			boolean obj1E = obj1 instanceof EnhancedMenuItem;			boolean obj2E = obj2 instanceof EnhancedMenuItem;			if (obj1E && !obj2E)			{				compareValue = 1;			}			else if (obj2E && !obj1E)			{				compareValue = -1;			}			else			{				compareValue = StandardUtilities.compareStrings(obj1.getText(), obj2.getText(), true);			}			return compareValue;		}	
public MirrorList(boolean download, ProgressObserver observer) throws Exception		{			mirrors = new ArrayList<Mirror>();				Mirror none = new Mirror();			none.id = Mirror.NONE;			none.description = none.location = none.country = none.continent = "";			mirrors.add(none);				String path = jEdit.getProperty("plugin-manager.mirror-url");			MirrorListHandler handler = new MirrorListHandler(this,path);			if (download)			{				Log.log(Log.NOTICE, this, "Loading mirror list from internet");				downloadXml(path);			}			else			{				Log.log(Log.NOTICE, this, "Loading mirror list from cache");				readXml();			}			observer.setValue(1);			Reader in = new BufferedReader(new StringReader(xml));				InputSource isrc = new InputSource(in);			isrc.setSystemId("jedit.jar");			XMLReader parser = XMLReaderFactory.createXMLReader();			parser.setContentHandler(handler);			parser.setDTDHandler(handler);			parser.setEntityResolver(handler);			parser.setErrorHandler(handler);			parser.parse(isrc);			observer.setValue(2);		}	
/**		 * Read and store the mirror list xml.		 * @throws IOException exception if it was not possible to read the		 * xml or if the url was invalid		 */		private void readXml() throws IOException		{			String settingsDirectory = jEdit.getSettingsDirectory();			if(settingsDirectory == null)				return;				File mirrorList = new File(MiscUtilities.constructPath(				settingsDirectory,"mirrorList.xml"));			if(!mirrorList.exists())				return;			InputStream inputStream = null;			try			{				inputStream = new BufferedInputStream(new FileInputStream(mirrorList));					ByteArrayOutputStream out = new ByteArrayOutputStream();				IOUtilities.copyStream(null,inputStream,out, false);				xml = out.toString();			}			finally			{				IOUtilities.closeQuietly(inputStream);			}		}	
/**		 * Read and store the mirror list xml.		 *		 * @param path the url		 * @throws IOException exception if it was not possible to read the		 * xml or if the url was invalid		 */		private void downloadXml(String path) throws IOException		{			InputStream inputStream = null;			try			{				inputStream = new URL(path).openStream();					ByteArrayOutputStream out = new ByteArrayOutputStream();				IOUtilities.copyStream(null,inputStream,out, false);				xml = out.toString();			}			finally			{				IOUtilities.closeQuietly(inputStream);			}		}	
void add(Mirror mirror)		{			mirrors.add(mirror);		}	
void finished()		{			Collections.sort(mirrors,new MirrorCompare());		}	
public int compare(Mirror m1,Mirror m2)			{				int result;				if ((result = m1.continent.compareToIgnoreCase(m2.continent)) == 0)					if ((result = m1.country.compareToIgnoreCase(m2.country)) == 0)						if ((result = m1.location.compareToIgnoreCase(m2.location)) == 0)							return m1.description.compareToIgnoreCase(m2.description);				return result;			}	
public boolean equals(Object obj)			{				return obj instanceof MirrorCompare;			}	
MirrorListHandler(MirrorList mirrors, String path)		{			this.mirrors = mirrors;			this.path = path;		}	
public InputSource resolveEntity(String publicId, String systemId)		{			return XMLUtilities.findEntity(systemId, "mirrors.dtd",						PluginOptions.class);		}	
public void characters(char[] c, int off, int len)		{			String tag = peekElement();				if(tag == "DESCRIPTION")				description.append(c, off, len);			else if(tag == "LOCATION")				location.append(c, off, len);			else if(tag == "COUNTRY")				country.append(c, off, len);			else if(tag == "CONTINENT")				continent.append(c, off, len);		}	
public void startElement(String uri, String localName,					 String tag, Attributes attrs)		{			tag = pushElement(tag);				if (tag.equals("MIRROR"))			{				mirror = new MirrorList.Mirror();				id = attrs.getValue("ID");			}		}	
public void endElement(String uri, String localName, String tag)		{			popElement();				if(tag.equals("MIRROR"))			{				mirror.id = id;				mirror.description = description.toString();				mirror.location = location.toString();				mirror.country = country.toString();				mirror.continent = continent.toString();				mirrors.add(mirror);				description.setLength(0);				location.setLength(0);				country.setLength(0);				continent.setLength(0);			}		}	
public void startDocument()		{			try			{				pushElement(null);			}			catch (Exception e)			{				Log.log(Log.ERROR, this, e);			}		}	
public void endDocument()		{			mirrors.finished();		}	
private String pushElement(String name)		{			name = name == null ? null : name.intern();			stateStack.push(name);			return name;		}	
private String peekElement()		{			return stateStack.peek();		}	
private void popElement()		{			stateStack.pop();		}	
/**		 * @return the canonical form of the specified path name. Currently		 * only expands a leading <code>~</code>. <b>For local path names		 * only.</b>		 * @param path The path name		 * @since jEdit 4.0pre2		 */		public static String canonPath(String path)		{			if(path.length() == 0)				return path;				if(path.startsWith("file://"))				path = path.substring("file://".length());			else if(path.startsWith("file:"))				path = path.substring("file:".length());			else if(isURL(path))				return path;				if(File.separatorChar == '\\')			{					// get rid of mixed paths on Windows					path = path.replace('/','\\');					// also get rid of trailing spaces on Windows					int trim = path.length();					while(path.charAt(trim - 1) == ' ')						trim--;						if (path.charAt(trim - 1) == '\\')						while (trim > 1 && path.charAt(trim - 2) == '\\')						{							trim--;						}					path = path.substring(0,trim);			}			else if(OperatingSystem.isMacOS())			{				// do the same on OS X				path = path.replace(':','/');			}				if(path.startsWith('~' + File.separator))			{				path = path.substring(2);				String home = System.getProperty("user.home");					if(home.endsWith(File.separator))					return home + path;				else					return home + File.separator + path;			}			else if("~".equals(path))				return System.getProperty("user.home");			else if ("-".equals(path))				return getParentOfPath(jEdit.getActiveView().getBuffer().getPath());			else				return path;		}	
/** Accepts a string from the user which may contain variables of various syntaxes.		 *  The goal is to support the following:		 *     $varname		 *     ${varname}		 *     And expand each of these by looking at the system environment variables for possible		 *     expansions.		 *     @return a string which is either the unchanged input string, or one with expanded variables.		 *     @since 4.3pre7		 *     @author ezust		 */		public static String expandVariables(String arg)		{			Pattern p = varPattern;			Matcher m = p.matcher(arg);			if (!m.find())			{				p = varPattern2;				m = p.matcher(arg);				if (!m.find()) // no variables to substitute					return arg;			}			String varName = m.group(2);			String expansion = System.getenv(varName);			if (expansion == null)			{ // try everything uppercase?				varName = varName.toUpperCase();				String uparg = arg.toUpperCase();				m = p.matcher(uparg);				expansion = System.getenv(varName);			}			if (expansion != null)			{				expansion = expansion.replace("\\", "\\\\");				return m.replaceFirst(expansion);			}			return arg;		}	
/** returns an abbreviated path, replacing		 *  values with variables, if a prefix exists.		 *  @since jEdit 4.3pre16		 */		public static String abbreviate(String path)		{			if (svc == null)				svc = new VarCompressor();			return svc.compress(path);		}	
/**		 * Resolves any symbolic links in the path name specified		 * using <code>File.getCanonicalPath()</code>. <b>For local path		 * names only.</b>		 * @since jEdit 4.2pre1		 */		public static String resolveSymlinks(String path)		{			if(isURL(path))				return path;				// 2 aug 2003: OS/2 Java has a broken getCanonicalPath()			if(OperatingSystem.isOS2())				return path;			// 18 nov 2003: calling this on a drive letter on Windows causes			// drive access			if(OperatingSystem.isDOSDerived())			{				if(path.length() == 2 || path.length() == 3)				{					if(path.charAt(1) == ':')						return path;				}			}			try			{				return new File(path).getCanonicalPath();			}			catch(IOException io)			{				return path;			}		}	
/**		 * Returns if the specified path name is an absolute path or URL.		 * @since jEdit 4.1pre11		 */		public static boolean isAbsolutePath(String path)		{			if(isURL(path))				return true;			else if(path.startsWith("~/") || path.startsWith('~' + File.separator) || "~".equals(path))				return true;			else if ("-".equals(path))				return true;			else if(OperatingSystem.isDOSDerived())			{				if(path.length() == 2 && path.charAt(1) == ':')					return true;				if(path.length() > 2 && path.charAt(1) == ':'					&& (path.charAt(2) == '\\'						|| path.charAt(2) == '/'))					return true;				if(path.startsWith("\\\\")					|| path.startsWith("//"))					return true;			}			// not sure if this is correct for OpenVMS.			else if(OperatingSystem.isUnix()					|| OperatingSystem.isVMS())			{				// nice and simple				if(path.length() > 0 && path.charAt(0) == '/')					return true;			}				return false;		}	
/**		 * Constructs an absolute path name from a directory and another		 * path name. This method is VFS-aware.		 * @param parent The directory		 * @param path The path name		 */		public static String constructPath(String parent, String path)		{			if(isAbsolutePath(path))				return canonPath(path);				if (parent == null)				parent = System.getProperty("user.dir");				if (path == null || path.length() == 0)				return parent;				// have to handle this case specially on windows.			// insert \ between, eg A: and myfile.txt.			if(OperatingSystem.isDOSDerived())			{				if(path.length() == 2 && path.charAt(1) == ':')					return path;				else if(path.length() > 2 && path.charAt(1) == ':'						&& path.charAt(2) != '\\')				{					path = path.substring(0,2) + '\\'						+ path.substring(2);					return canonPath(path);				}			}				String dd = ".." + File.separator;			String d = '.' + File.separator;				for(;;)			{				if(".".equals(path))					return parent;				else if("..".equals(path))					return getParentOfPath(parent);				else if(path.startsWith(dd) || path.startsWith("../"))				{					parent = getParentOfPath(parent);					path = path.substring(3);				}				else if(path.startsWith(d) || path.startsWith("./"))					path = path.substring(2);				else					break;			}			if(path.length() == 0)				return parent;				if(OperatingSystem.isDOSDerived()				&& !isURL(parent)			&& path.charAt(0) == '\\')				parent = parent.substring(0,2);				VFS vfs = VFSManager.getVFSForPath(parent);				return canonPath(vfs.constructPath(parent,path));		}	
/**		 * Constructs an absolute path name from three path components.		 * This method is VFS-aware.		 * @param parent The parent directory		 * @param path1 The first path		 * @param path2 The second path		 */		public static String constructPath(String parent,					    String path1, String path2)		{			return constructPath(constructPath(parent,path1),path2);		}	
/**		 * Like {@link #constructPath}, except <code>path</code> will be		 * appended to <code>parent</code> even if it is absolute.		 * <b>For local path names only.</b>.		 *		 * @param parent the parent path		 * @param path the path to append to the parent		 */		public static String concatPath(String parent, String path)		{			parent = canonPath(parent);			path = canonPath(path);				// Make all child paths relative.			if (path.startsWith(File.separator))				path = path.substring(1);			else if (path.length() >= 3 && path.charAt(1) == ':')				path = path.replace(':', File.separatorChar);				if (parent == null)				parent = System.getProperty("user.dir");				if (parent.endsWith(File.separator))				return parent + path;			else				return parent + File.separator + path;		}	
/**		 * Return the first index of either / or the OS-specific file		 * separator.		 * @param path The path		 * @since jEdit 4.3pre3		 */		public static int getFirstSeparatorIndex(String path)		{			int start = getPathStart(path);			int index = path.indexOf('/',start);			if(index == -1)				index = path.indexOf(File.separatorChar,start);			return index;		}	
/**		 * Return the last index of either / or the OS-specific file		 * separator.		 * @param path The path		 * @since jEdit 4.3pre3		 */		public static int getLastSeparatorIndex(String path)		{			int start = getPathStart(path);			if(start != 0)				path = path.substring(start);			int index = Math.max(				path.lastIndexOf('/'), path.lastIndexOf(File.separatorChar));			if(index == -1)				return index;			else				return index + start;		}	
/**		 * Returns the extension of the specified filename, or an empty		 * string if there is none.		 * @param path The path		 */		public static String getFileExtension(String path)		{			int fsIndex = getLastSeparatorIndex(path);			int index = path.lastIndexOf('.');			// there could be a dot in the path and no file extension			if(index == -1 || index < fsIndex )				return "";			else				return path.substring(index);		}	
/**		 * Returns the last component of the specified path.		 * This method is VFS-aware.		 * @param path The path name		 */		public static String getFileName(String path)		{			return VFSManager.getVFSForPath(path).getFileName(path);		}	
/**		 * Returns the last component of the specified path name without the		 * trailing extension (if there is one).		 * @param path The path name		 * @since jEdit 4.0pre8		 */		public static String getFileNameNoExtension(String path)		{			String name = getFileName(path);			int index = name.indexOf('.');			if(index == -1)				return name;			else				return name.substring(0,index);		}	
/**		 * @deprecated Call getParentOfPath() instead		 */		@Deprecated		public static String getFileParent(String path)		{			return getParentOfPath(path);		}	
/**		 * Returns the parent of the specified path. This method is VFS-aware.		 * @param path The path name		 * @since jEdit 2.6pre5		 */		public static String getParentOfPath(String path)		{			return VFSManager.getVFSForPath(path).getParentOfPath(path);		}	
/**		 * @deprecated Call getProtocolOfURL() instead		 */		@Deprecated		public static String getFileProtocol(String url)		{			return getProtocolOfURL(url);		}	
/**		 * Returns the protocol specified by a URL.		 * @param url The URL		 * @since jEdit 2.6pre5		 */		public static String getProtocolOfURL(String url)		{			return url.substring(0,url.indexOf(':'));		}	
/**		 * Checks if the specified string is a URL.		 * @param str The string to check		 * @return True if the string is a URL, false otherwise		 */		public static boolean isURL(String str)		{			int fsIndex = getLastSeparatorIndex(str);			if(fsIndex == 0) // /etc/passwd				return false;			else if(fsIndex == 2) // C:\AUTOEXEC.BAT				return false;				int cIndex = str.indexOf(':');			if(cIndex <= 1) // D:\WINDOWS, or doesn't contain : at all				return false;				String protocol = str.substring(0,cIndex);			VFS vfs = VFSManager.getVFSForProtocol(protocol);			if(vfs != null && !(vfs instanceof UrlVFS))				return true;				try			{				new URL(str);				return true;			}			catch(MalformedURLException mf)			{				return false;			}		}	
/**		 * Saves a backup (optionally numbered) of a file.		 * @param file A local file		 * @param backups The number of backups. Must be >= 1. If > 1, backup		 * files will be numbered.		 * @param backupPrefix The backup file name prefix		 * @param backupSuffix The backup file name suffix		 * @param backupDirectory The directory where to save backups; if null,		 * they will be saved in the same directory as the file itself.		 * @since jEdit 4.0pre1		 */		 public static void saveBackup(File file, int backups,			 String backupPrefix, String backupSuffix,			 String backupDirectory)		{			saveBackup(file,backups,backupPrefix,backupSuffix,backupDirectory,0);		}	
/**		 * Saves a backup (optionally numbered) of a file.		 * @param file A local file		 * @param backups The number of backups. Must be >= 1. If > 1, backup		 * files will be numbered.		 * @param backupPrefix The backup file name prefix		 * @param backupSuffix The backup file name suffix		 * @param backupDirectory The directory where to save backups; if null,		 * they will be saved in the same directory as the file itself.		 * @param backupTimeDistance The minimum time in minutes when a backup		 * version 1 shall be moved into version 2; if 0, backups are always		 * moved.		 * @since jEdit 4.2pre5		 */		public static void saveBackup(File file, int backups,				       String backupPrefix, String backupSuffix,				       String backupDirectory, int backupTimeDistance)		{			if(backupPrefix == null)				backupPrefix = "";			if(backupSuffix == null)				backupSuffix = "";				String name = file.getName();				// If backups is 1, create ~ file			if(backups == 1)			{				File backupFile = new File(backupDirectory,					backupPrefix + name + backupSuffix);				long modTime = backupFile.lastModified();				/* if backup file was created less than				 * 'backupTimeDistance' ago, we do not				 * create the backup */				if(System.currentTimeMillis() - modTime				   >= backupTimeDistance)				{					Log.log(Log.DEBUG,MiscUtilities.class,						"Saving backup of file \"" +						file.getAbsolutePath() + "\" to \"" +						backupFile.getAbsolutePath() + '"');					backupFile.delete();					if (!file.renameTo(backupFile))						IOUtilities.moveFile(file, backupFile);				}			}			// If backups > 1, move old ~n~ files, create ~1~ file			else			{				/* delete a backup created using above method */				new File(backupDirectory,					backupPrefix + name + backupSuffix					+ backups + backupSuffix).delete();					File firstBackup = new File(backupDirectory,					backupPrefix + name + backupSuffix					+ '1' + backupSuffix);				long modTime = firstBackup.lastModified();				/* if backup file was created less than				 * 'backupTimeDistance' ago, we do not				 * create the backup */				if(System.currentTimeMillis() - modTime				   >= backupTimeDistance)				{					for(int i = backups - 1; i > 0; i--)					{						File backup = new File(backupDirectory,							backupPrefix + name							+ backupSuffix + i							+ backupSuffix);							backup.renameTo(new File(backupDirectory,							backupPrefix + name							+ backupSuffix + (i + 1)							+ backupSuffix));					}						File backupFile = new File(backupDirectory,						backupPrefix + name + backupSuffix						+ '1' + backupSuffix);					Log.log(Log.DEBUG,MiscUtilities.class,						"Saving backup of file \"" +						file.getAbsolutePath() + "\" to \"" +						backupFile.getAbsolutePath() + '"');					if (!file.renameTo(backupFile))						IOUtilities.moveFile(file, backupFile);				}			}		}	
/**		 * Moves the source file to the destination.		 *		 * If the destination cannot be created or is a read-only file, the		 * method returns <code>false</code>. Otherwise, the contents of the		 * source are copied to the destination, the source is deleted,		 * and <code>true</code> is returned.		 *		 * @param source The source file to move.		 * @param dest   The destination where to move the file.		 * @return true on success, false otherwise.		 *		 * @since jEdit 4.3pre1		 * @deprecated use {@link org.gjt.sp.util.IOUtilities#moveFile(java.io.File, java.io.File)}		 */		@Deprecated		public static boolean moveFile(File source, File dest)		{			return IOUtilities.moveFile(source, dest);		}	
/**		 * Copy an input stream to an output stream.		 *		 * @param bufferSize the size of the buffer		 * @param progress the progress observer it could be null		 * @param in the input stream		 * @param out the output stream		 * @param canStop if true, the copy can be stopped by interrupting the thread		 * @return <code>true</code> if the copy was done, <code>false</code> if it was interrupted		 * @throws IOException  IOException If an I/O error occurs		 * @since jEdit 4.3pre3		 * @deprecated use {@link IOUtilities#copyStream(int, org.gjt.sp.util.ProgressObserver, java.io.InputStream, java.io.OutputStream, boolean)}		 */		@Deprecated		public static boolean copyStream(int bufferSize, ProgressObserver progress,			InputStream in, OutputStream out, boolean canStop)			throws IOException		{			return IOUtilities.copyStream(bufferSize, progress, in, out, canStop);		}	
/**		 * Copy an input stream to an output stream with a buffer of 4096 bytes.		 *		 * @param progress the progress observer it could be null		 * @param in the input stream		 * @param out the output stream		 * @param canStop if true, the copy can be stopped by interrupting the thread		 * @return <code>true</code> if the copy was done, <code>false</code> if it was interrupted		 * @throws IOException  IOException If an I/O error occurs		 * @since jEdit 4.3pre3		 * @deprecated use {@link IOUtilities#copyStream(org.gjt.sp.util.ProgressObserver, java.io.InputStream, java.io.OutputStream, boolean)}		 */		@Deprecated		public static boolean copyStream(ProgressObserver progress, InputStream in, OutputStream out, boolean canStop)			throws IOException		{			return IOUtilities.copyStream(4096,progress, in, out, canStop);		}	
/**		 * Check if a Reader is binary.		 * @deprecated		 *   Use isBinary(InputStream) instead.		 */		@Deprecated		public static boolean isBinary(Reader reader) throws IOException		{			return containsNullCharacter(reader);		}	
/**		 * Check if an InputStream is binary.		 * First this tries encoding auto detection. If an encoding is		 * detected, the stream should be a text stream. Otherwise, this		 * will check the first characters 100		 * (jEdit property vfs.binaryCheck.length) in the system default		 * encoding. If more than 1 (jEdit property vfs.binaryCheck.count)		 * NUL(\u0000) was found, the stream is declared binary.		 *		 * This is not 100% because sometimes the autodetection could fail.		 *		 * This method will not close the stream. You have to do it yourself		 *		 * @param in the stream		 * @return <code>true</code> if the stream was detected as binary		 * @throws IOException IOException If an I/O error occurs		 * @since jEdit 4.3pre10		 */		public static boolean isBinary(InputStream in) throws IOException		{			AutoDetection.Result detection = new AutoDetection.Result(in);			// If an encoding is detected, this is a text stream			if (detection.getDetectedEncoding() != null)			{				return false;			}			// Read the stream in system default encoding. The encoding			// might be wrong. But enough for binary detection.			try			{				return containsNullCharacter(					new InputStreamReader(detection.getRewindedStream()));			}			catch (MalformedInputException mie)			{				// This error probably means the input is binary.				return true;			}		}	
/**		 * Check if the filename is a backup file.		 * @param filename the filename to check		 * @return true if this is a backup file.		 * @since jEdit 4.3pre5		 */		public static boolean isBackup(String filename)		{			if (filename.startsWith("#")) return true;			if (filename.endsWith("~")) return true;			if (filename.endsWith(".bak")) return true;			return false;		}	
/**		 * Tries to detect if the stream is gzipped, and if it has an encoding		 * specified with an XML PI.		 *		 * @param in the input stream reader that must be autodetected		 * @param buffer a buffer. It can be null if you only want to autodetect the encoding of a file		 * @return a Reader using the detected encoding		 * @throws IOException io exception during read		 * @since jEdit 4.3pre5		 */		public static Reader autodetect(InputStream in, Buffer buffer) throws IOException		{			String encoding;			if (buffer == null)				encoding = System.getProperty("file.encoding");			else				encoding = buffer.getStringProperty(JEditBuffer.ENCODING);			boolean gzipped = false;				if (buffer == null || buffer.getBooleanProperty(Buffer.ENCODING_AUTODETECT))			{				AutoDetection.Result detection = new AutoDetection.Result(in);				gzipped = detection.streamIsGzipped();				if (gzipped)				{					Log.log(Log.DEBUG, MiscUtilities.class						, "Stream is Gzipped");				}				String detected = detection.getDetectedEncoding();				if (detected != null)				{					encoding = detected;					Log.log(Log.DEBUG, MiscUtilities.class						, "Stream encoding detected is " + detected);				}				in = detection.getRewindedStream();			}			else			{				// Make the stream buffered in the same way.				in = AutoDetection.getMarkedStream(in);			}				Reader result = EncodingServer.getTextReader(in, encoding);			if (buffer != null)			{				// Store the successful properties.				if (gzipped)				{					buffer.setBooleanProperty(Buffer.GZIPPED,true);				}				buffer.setProperty(JEditBuffer.ENCODING, encoding);			}			return result;		}	
/**		 * Method that will close an {@link InputStream} ignoring it if it is null and ignoring exceptions.		 *		 * @param in the InputStream to close.		 * @since jEdit 4.3pre3		 * @deprecated use {@link IOUtilities#closeQuietly(java.io.InputStream)}		 */		@Deprecated		public static void closeQuietly(InputStream in)		{			IOUtilities.closeQuietly(in);		}	
/**		 * Method that will close an {@link OutputStream} ignoring it if it is null and ignoring exceptions.		 *		 * @param out the OutputStream to close.		 * @since jEdit 4.3pre3		 * @deprecated use {@link IOUtilities#closeQuietly(java.io.OutputStream)}		 */		@Deprecated		public static void closeQuietly(OutputStream out)		{			IOUtilities.closeQuietly(out);		}	
/**		 * Converts a file name to a class name. All slash characters are		 * replaced with periods and the trailing '.class' is removed.		 * @param name The file name		 */		public static String fileToClass(String name)		{			char[] clsName = name.toCharArray();			for(int i = clsName.length - 6; i >= 0; i--)				if(clsName[i] == '/')					clsName[i] = '.';			return new String(clsName,0,clsName.length - 6);		}	
/**		 * Converts a class name to a file name. All periods are replaced		 * with slashes and the '.class' extension is added.		 * @param name The class name		 */		public static String classToFile(String name)		{			return name.replace('.','/').concat(".class");		}	
/**		 * @param p1 A path name		 * @param p2 A path name		 * @return True if both paths are equal, ignoring trailing slashes, as		 * well as case insensitivity on Windows.		 * @since jEdit 4.3pre2		 */		public static boolean pathsEqual(String p1, String p2)		{			VFS v1 = VFSManager.getVFSForPath(p1);			VFS v2 = VFSManager.getVFSForPath(p2);				if(v1 != v2)				return false;				if(p1.endsWith("/") || p1.endsWith(File.separator))				p1 = p1.substring(0,p1.length() - 1);				if(p2.endsWith("/") || p2.endsWith(File.separator))				p2 = p2.substring(0,p2.length() - 1);				if((v1.getCapabilities() & VFS.CASE_INSENSITIVE_CAP) != 0)				return p1.equalsIgnoreCase(p2);			else				return p1.equals(p2);		}	
/**		 * Returns the number of leading white space characters in the		 * specified string.		 * @param str The string		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#getLeadingWhiteSpace(String)}		 */		@Deprecated		public static int getLeadingWhiteSpace(String str)		{			return StandardUtilities.getLeadingWhiteSpace(str);		}	
/**		 * Returns the number of trailing whitespace characters in the		 * specified string.		 * @param str The string		 * @since jEdit 2.5pre5		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#getTrailingWhiteSpace(String)}		 */		@Deprecated		public static int getTrailingWhiteSpace(String str)		{			return StandardUtilities.getTrailingWhiteSpace(str);		}	
/**		 * Returns the width of the leading white space in the specified		 * string.		 * @param str The string		 * @param tabSize The tab size		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#getLeadingWhiteSpace(String)}		 */		@Deprecated		public static int getLeadingWhiteSpaceWidth(String str, int tabSize)		{			return StandardUtilities.getLeadingWhiteSpaceWidth(str, tabSize);		}	
/**		 * Returns the virtual column number (taking tabs into account) of the		 * specified offset in the segment.		 *		 * @param seg The segment		 * @param tabSize The tab size		 * @since jEdit 4.1pre1		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#getVirtualWidth(javax.swing.text.Segment, int)}		 */		@Deprecated		public static int getVirtualWidth(Segment seg, int tabSize)		{			return StandardUtilities.getVirtualWidth(seg, tabSize);		}	
/**		 * Returns the array offset of a virtual column number (taking tabs		 * into account) in the segment.		 *		 * @param seg The segment		 * @param tabSize The tab size		 * @param column The virtual column number		 * @param totalVirtualWidth If this array is non-null, the total		 * virtual width will be stored in its first location if this method		 * returns -1.		 *		 * @return -1 if the column is out of bounds		 *		 * @since jEdit 4.1pre1		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#getVirtualWidth(javax.swing.text.Segment, int)}		 */		@Deprecated		public static int getOffsetOfVirtualColumn(Segment seg, int tabSize,						    int column, int[] totalVirtualWidth)		{			return StandardUtilities.getOffsetOfVirtualColumn(seg, tabSize, column, totalVirtualWidth);		}	
/**		 * Creates a string of white space with the specified length.<p>		 *		 * To get a whitespace string tuned to the current buffer's		 * settings, call this method as follows:		 *		 * <pre>myWhitespace = MiscUtilities.createWhiteSpace(myLength,		 *     (buffer.getBooleanProperty("noTabs") ? 0		 *     : buffer.getTabSize()));</pre>		 *		 * @param len The length		 * @param tabSize The tab size, or 0 if tabs are not to be used		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#createWhiteSpace(int, int)}		 */		@Deprecated		public static String createWhiteSpace(int len, int tabSize)		{			return StandardUtilities.createWhiteSpace(len,tabSize,0);		}	
/**		 * Creates a string of white space with the specified length.<p>		 *		 * To get a whitespace string tuned to the current buffer's		 * settings, call this method as follows:		 *		 * <pre>myWhitespace = MiscUtilities.createWhiteSpace(myLength,		 *     (buffer.getBooleanProperty("noTabs") ? 0		 *     : buffer.getTabSize()));</pre>		 *		 * @param len The length		 * @param tabSize The tab size, or 0 if tabs are not to be used		 * @param start The start offset, for tab alignment		 * @since jEdit 4.2pre1		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#createWhiteSpace(int, int, int)}		 */		@Deprecated		public static String createWhiteSpace(int len, int tabSize, int start)		{			return StandardUtilities.createWhiteSpace(len, tabSize, start);		}	
/**		 * Converts a Unix-style glob to a regular expression.<p>		 *		 * ? becomes ., * becomes .*, {aa,bb} becomes (aa|bb).		 * @param glob The glob pattern		 * @deprecated Use {@link org.gjt.sp.util.StandardUtilities#globToRE(String)}.		 */		@Deprecated		public static String globToRE(String glob)		{			return StandardUtilities.globToRE(glob);		}	
/**		 * Converts "\n" and "\t" escapes in the specified string to		 * newlines and tabs.		 * @param str The string		 * @since jEdit 2.3pre1		 */		public static String escapesToChars(String str)		{			StringBuilder buf = new StringBuilder();			for(int i = 0; i < str.length(); i++)			{				char c = str.charAt(i);				switch(c)				{				case '\\':					if(i == str.length() - 1)					{						buf.append('\\');						break;					}					c = str.charAt(++i);					switch(c)					{					case 'n':						buf.append('\n');						break;					case 't':						buf.append('\t');						break;					default:						buf.append(c);						break;					}					break;				default:					buf.append(c);				}			}			return buf.toString();		}	
/**		 * Escapes newlines, tabs, backslashes, and quotes in the specified		 * string.		 * @param str The string		 * @since jEdit 2.3pre1		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#charsToEscapes(String)}		 */		@Deprecated		public static String charsToEscapes(String str)		{			return StandardUtilities.charsToEscapes(str);		}	
/**		 * Escapes the specified characters in the specified string.		 * @param str The string		 * @param toEscape Any characters that require escaping		 * @since jEdit 4.1pre3		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#charsToEscapes(String)}		 */		@Deprecated		public static String charsToEscapes(String str, String toEscape)		{			return StandardUtilities.charsToEscapes(str, toEscape);		}	
/**		 * @deprecated Call {@link StandardUtilities#compareStrings(String, String, boolean)} instead		 */		@Deprecated		public static int compareVersions(String v1, String v2)		{			return StandardUtilities.compareStrings(v1,v2,false);		}	
/**		 * Compares two strings.<p>		 *		 * Unlike <function>String.compareTo()</function>,		 * this method correctly recognizes and handles embedded numbers.		 * For example, it places "My file 2" before "My file 10".<p>		 *		 * @param str1 The first string		 * @param str2 The second string		 * @param ignoreCase If true, case will be ignored		 * @return negative If str1 &lt; str2, 0 if both are the same,		 * positive if str1 &gt; str2		 * @since jEdit 4.0pre1		 * @deprecated use {@link org.gjt.sp.util.StandardUtilities#compareStrings(String, String, boolean)}		 */		@Deprecated		public static int compareStrings(String str1, String str2, boolean ignoreCase)		{			return StandardUtilities.compareStrings(str1, str2, ignoreCase);		}	
/**		 * @deprecated Call {@link StandardUtilities#objectsEqual(Object, Object)} instead.		 */		@Deprecated		public static boolean stringsEqual(String s1, String s2)		{			return StandardUtilities.objectsEqual(s1,s2);		}	
/**		 * Returns if two strings are equal. This correctly handles null pointers,		 * as opposed to calling <code>o1.equals(o2)</code>.		 * @since jEdit 4.2pre1		 * @deprecated use {@link StandardUtilities#objectsEqual(Object, Object)}		 */		@Deprecated		public static boolean objectsEqual(Object o1, Object o2)		{			return StandardUtilities.objectsEqual(o1, o2);		}	
/**		 * Converts &lt;, &gt;, &amp; in the string to their HTML entity		 * equivalents.		 * @param str The string		 * @since jEdit 4.2pre1		 * @deprecated	Use {@link org.gjt.sp.util.XMLUtilities#charsToEntities(String, boolean)}.		 */		@Deprecated		public static String charsToEntities(String str)		{			return XMLUtilities.charsToEntities(str,false);		}	
/**		 * Formats the given file size into a nice string (123 Bytes, 10.6 kB,		 * 1.2 MB).		 * @param length The size		 * @since jEdit 4.2pre1		 */		public static String formatFileSize(long length)		{			if(length < 1024)			{				return length + " Bytes";			}			else if(length < 1024 << 10)			{				return KB_FORMAT.format((double)length / 1024);			}			else			{				return MB_FORMAT.format((double)length / 1024 / 1024);			}		}	
/**		 * Returns the longest common prefix in the given set of strings.		 * @param str The strings		 * @param ignoreCase If true, case insensitive		 * @since jEdit 4.2pre2		 */		public static String getLongestPrefix(List<String> str, boolean ignoreCase)		{			if(str.isEmpty())				return "";				int prefixLength = 0;		loop:		for(;;)			{				String s = str.get(0);				if(prefixLength >= s.length())					break loop;				char ch = s.charAt(prefixLength);				for(int i = 1; i < str.size(); i++)				{					s = str.get(i);					if(prefixLength >= s.length())						break loop;					if(!compareChars(s.charAt(prefixLength),ch,ignoreCase))						break loop;				}				prefixLength++;			}				return str.get(0).substring(0,prefixLength);		}	
/**		 * Returns the longest common prefix in the given set of strings.		 * @param str The strings		 * @param ignoreCase If true, case insensitive		 * @since jEdit 4.2pre2		 */		public static String getLongestPrefix(String[] str, boolean ignoreCase)		{			return getLongestPrefix((Object[])str,ignoreCase);		}	
/**		 * Returns the longest common prefix in the given set of strings.		 * @param str The strings (calls <code>toString()</code> on each object)		 * @param ignoreCase If true, case insensitive		 * @since jEdit 4.2pre6		 */		public static String getLongestPrefix(Object[] str, boolean ignoreCase)		{			if(str.length == 0)				return "";				int prefixLength = 0;				String first = str[0].toString();		loop:		for(;;)			{				if(prefixLength >= first.length())					break loop;				char ch = first.charAt(prefixLength);				for(int i = 1; i < str.length; i++)				{					String s = str[i].toString();					if(prefixLength >= s.length())						break loop;					if(!compareChars(s.charAt(prefixLength),ch,ignoreCase))						break loop;				}				prefixLength++;			}				return first.substring(0,prefixLength);		}	
/**		 * Sorts the specified array. Equivalent to calling		 * <code>Arrays.sort()</code>.		 * @param obj The array		 * @param compare Compares the objects		 * @since jEdit 4.0pre4		 * @deprecated use <code>Arrays.sort()</code>		 */		@Deprecated		public static void quicksort(Object[] obj, Comparator compare)		{			Arrays.sort(obj,compare);		}	
/**		 * Sorts the specified vector.		 * @param vector The vector		 * @param compare Compares the objects		 * @since jEdit 4.0pre4		 * @deprecated <code>Collections.sort()</code>		 */		@Deprecated		public static void quicksort(Vector vector, Comparator compare)		{			Collections.sort(vector,compare);		}	
/**		 * Sorts the specified list.		 * @param list The list		 * @param compare Compares the objects		 * @since jEdit 4.0pre4		 * @deprecated <code>Collections.sort()</code>		 */		@Deprecated		public static void quicksort(List list, Comparator compare)		{			Collections.sort(list,compare);		}	
/**		 * Sorts the specified array. Equivalent to calling		 * <code>Arrays.sort()</code>.		 * @param obj The array		 * @param compare Compares the objects		 * @deprecated use <code>Arrays.sort()</code>		 */		@Deprecated		public static void quicksort(Object[] obj, Compare compare)		{			Arrays.sort(obj,compare);		}	
/**		 * Sorts the specified vector.		 * @param vector The vector		 * @param compare Compares the objects		 * @deprecated <code>Collections.sort()</code>		 */		@Deprecated		public static void quicksort(Vector vector, Compare compare)		{			Collections.sort(vector,compare);		}	
public int compare(Object obj1, Object obj2)			{				return StandardUtilities.compareStrings(obj1.toString(),					obj2.toString(),false);			}	
public int compare(Object obj1, Object obj2)			{				return StandardUtilities.compareStrings(obj1.toString(), obj2.toString(), true);			}	
public int compare(Object obj1, Object obj2)			{				return comparator.compare((JMenuItem)obj1, (JMenuItem)obj2);			}	
/**		 * Converts an internal version number (build) into a		 * `human-readable' form.		 * @param build The build		 */		public static String buildToVersion(String build)		{			if(build.length() != 11)				return "<unknown version: " + build + '>';			// First 2 chars are the major version number			int major = Integer.parseInt(build.substring(0,2));			// Second 2 are the minor number			int minor = Integer.parseInt(build.substring(3,5));			// Then the pre-release status			int beta = Integer.parseInt(build.substring(6,8));			// Finally the bug fix release			int bugfix = Integer.parseInt(build.substring(9,11));				return major + "." + minor				+ (beta != 99 ? "rc" + beta :				(bugfix != 0 ? "." + bugfix : ""));		}	
/**		 * If on JDK 1.2 or higher, make sure that tools.jar is available.		 * This method should be called by plugins requiring the classes		 * in this library.		 * <p>		 * tools.jar is searched for in the following places:		 * <ol>		 *   <li>the classpath that was used when jEdit was started,		 *   <li>jEdit's jars folder in the user's home,		 *   <li>jEdit's system jars folder,		 *   <li><i>java.home</i>/lib/. In this case, tools.jar is added to		 *       jEdit's list of known jars using jEdit.addPluginJAR(),		 *       so that it gets loaded through JARClassLoader.		 * </ol><p>		 *		 * On older JDK's this method does not perform any checks, and returns		 * <code>true</code> (even though there is no tools.jar).		 *		 * @return <code>false</code> if and only if on JDK 1.2 and tools.jar		 *    could not be found. In this case it prints some warnings on Log,		 *    too, about the places where it was searched for.		 * @since jEdit 3.2.2		 */		public static boolean isToolsJarAvailable()		{			Log.log(Log.DEBUG, MiscUtilities.class,"Searching for tools.jar...");				Collection<String> paths = new LinkedList<String>();				//{{{ 1. Check whether tools.jar is in the system classpath:			paths.add("System classpath: "				+ System.getProperty("java.class.path"));				try			{				// Either class sun.tools.javac.Main or				// com.sun.tools.javac.Main must be there:				try				{					Class.forName("sun.tools.javac.Main");				}				catch(ClassNotFoundException e1)				{					Class.forName("com.sun.tools.javac.Main");				}				Log.log(Log.DEBUG, MiscUtilities.class,					"- is in classpath. Fine.");				return true;			}			catch(ClassNotFoundException e)			{				//Log.log(Log.DEBUG, MiscUtilities.class,				//	"- is not in system classpath.");			} //}}}				//{{{ 2. Check whether it is in the jEdit user settings jars folder:			String settingsDir = jEdit.getSettingsDirectory();			if(settingsDir != null)			{				String toolsPath = constructPath(settingsDir, "jars",					"tools.jar");				paths.add(toolsPath);				if(new File(toolsPath).exists())				{					Log.log(Log.DEBUG, MiscUtilities.class,						"- is in the user's jars folder. Fine.");					// jEdit will load it automatically					return true;				}			} //}}}				//{{{ 3. Check whether it is in jEdit's system jars folder:			String jEditDir = jEdit.getJEditHome();			if(jEditDir != null)			{				String toolsPath = constructPath(jEditDir, "jars", "tools.jar");				paths.add(toolsPath);				if(new File(toolsPath).exists())				{					Log.log(Log.DEBUG, MiscUtilities.class,						"- is in jEdit's system jars folder. Fine.");					// jEdit will load it automatically					return true;				}			} //}}}				//{{{ 4. Check whether it is in <java.home>/lib:			String toolsPath = System.getProperty("java.home");			if(toolsPath.toLowerCase().endsWith(File.separator + "jre"))				toolsPath = toolsPath.substring(0, toolsPath.length() - 4);			toolsPath = constructPath(toolsPath, "lib", "tools.jar");			paths.add(toolsPath);				if(!new File(toolsPath).exists())			{				Log.log(Log.WARNING, MiscUtilities.class,					"Could not find tools.jar.\n"					+ "I checked the following locations:\n"					+ paths.toString());				return false;			} //}}}				//{{{ Load it, if not yet done:			PluginJAR jar = jEdit.getPluginJAR(toolsPath);			if(jar == null)			{				Log.log(Log.DEBUG, MiscUtilities.class,					"- adding " + toolsPath + " to jEdit plugins.");				jEdit.addPluginJAR(toolsPath);			}			else				Log.log(Log.DEBUG, MiscUtilities.class,					"- has been loaded before.");			//}}}				return true;		}	
/**		 * Parse a Unix-style permission string (rwxrwxrwx).		 * @param s The string (must be 9 characters long).		 * @since jEdit 4.1pre8		 */		public static int parsePermissions(String s)		{			int permissions = 0;				if(s.length() == 9)			{				if(s.charAt(0) == 'r')					permissions += 0400;				if(s.charAt(1) == 'w')					permissions += 0200;				if(s.charAt(2) == 'x')					permissions += 0100;				else if(s.charAt(2) == 's')					permissions += 04100;				else if(s.charAt(2) == 'S')					permissions += 04000;				if(s.charAt(3) == 'r')					permissions += 040;				if(s.charAt(4) == 'w')					permissions += 020;				if(s.charAt(5) == 'x')					permissions += 010;				else if(s.charAt(5) == 's')					permissions += 02010;				else if(s.charAt(5) == 'S')					permissions += 02000;				if(s.charAt(6) == 'r')					permissions += 04;				if(s.charAt(7) == 'w')					permissions += 02;				if(s.charAt(8) == 'x')					permissions += 01;				else if(s.charAt(8) == 't')					permissions += 01001;				else if(s.charAt(8) == 'T')					permissions += 01000;			}				return permissions;		}	
/**		 * Returns a list of supported character encodings.		 * @since jEdit 4.2pre5		 * @deprecated See #getEncodings(boolean)		 */		@Deprecated		public static String[] getEncodings()		{			return getEncodings(false);		}	
/**		 * Returns a list of supported character encodings.		 * @since jEdit 4.3pre5		 * @param getSelected Whether to return just the selected encodings or all.		 */		public static String[] getEncodings(boolean getSelected)		{			Set<String> set;			if (getSelected)			{				set = EncodingServer.getSelectedNames();			}			else			{				set = EncodingServer.getAvailableNames();			}			return set.toArray(new String[set.size()]);		}	
/**		 * Returns a string containing the stack trace of the given throwable.		 * @since jEdit 4.2pre6		 */		public static String throwableToString(Throwable t)		{			StringWriter s = new StringWriter();			t.printStackTrace(new PrintWriter(s));			return s.toString();		}	
/**		 * Convenience method for parsing an XML file.		 *		 * @return Whether any error occured during parsing.		 * @since jEdit 4.3pre5		 * @deprecated Use {@link XMLUtilities#parseXML(InputStream,DefaultHandler)}.		 */		@Deprecated		public static boolean parseXML(InputStream in, DefaultHandler handler)			throws IOException		{			return XMLUtilities.parseXML(in, handler);		}	
/**		 * Tries to find the given systemId in the context of the given		 * class.		 *		 * @deprecated Use {@link XMLUtilities#findEntity(String,String,Class)}.		 */		@Deprecated		public static InputSource findEntity(String systemId, String test, Class where)		{			return XMLUtilities.findEntity(systemId, test, where);		}	
private MiscUtilities() {}	
/**		 * Compares two chars.		 * should this be public?		 * @param ch1 the first char		 * @param ch2 the second char		 * @param ignoreCase true if you want to ignore case		 */		private static boolean compareChars(char ch1, char ch2, boolean ignoreCase)		{			if(ignoreCase)				return Character.toUpperCase(ch1) == Character.toUpperCase(ch2);			else				return ch1 == ch2;		}	
private static int getPathStart(String path)		{			if(path.startsWith("/"))				return 0;			else if(OperatingSystem.isDOSDerived()				&& path.length() >= 3				&& path.charAt(1) == ':'				&& (path.charAt(2) == '/'				|| path.charAt(2) == '\\'))				return 3;			else				return 0;		}	
private static boolean containsNullCharacter(Reader reader)			throws IOException		{			int nbChars = jEdit.getIntegerProperty("vfs.binaryCheck.length",100);			int authorized = jEdit.getIntegerProperty("vfs.binaryCheck.count",1);			for (long i = 0L;i < nbChars;i++)			{				int c = reader.read();				if (c == -1)					return false;				if (c == 0)				{					authorized--;					if (authorized == 0)						return true;				}			}			return false;		}	
VarCompressor()			{				ProcessBuilder pb = new ProcessBuilder();				Map<String, String> env = pb.environment();				if (OperatingSystem.isUnix())					prefixMap.put(System.getProperty("user.home"), "~");				for (String k: env.keySet())				{					if (k.equalsIgnoreCase("pwd") || k.equalsIgnoreCase("oldpwd")) continue;					if (!Character.isLetter(k.charAt(0))) continue;					String v = env.get(k);					// only add possible candidates to the prefix map					if (!canBePathPrefix(v)) continue;					// no need for trailing file separator					if (v.endsWith(File.separator))						v = v.substring(0, v.length()-1);					// check if it is actually shorter					if (OperatingSystem.isWindows())						if (k.length()+2 > v.length()) continue; // gets replaced by %FOO%					else						if (k.length()+1 > v.length()) continue; // gets replaced by $FOO					if (OperatingSystem.isWindows())					{						// no case sensitivity, might as well convert to lower case						v = v.toLowerCase();						k = k.toLowerCase();					}					if (prefixMap.containsKey(v))					{						String otherKey = prefixMap.get(v);						if (otherKey.length() < k.length()) continue;					}					prefixMap.put(v, k);				}			}	
String compress(String path)			{				String original = path;				if (previous.containsKey(path))				{					return previous.get(path);				}				String bestPrefix = "/";				String verifiedPrefix = bestPrefix;				for (String tryPrefix : prefixMap.keySet())				{					if (tryPrefix.length() < bestPrefix.length()) continue;					if (OperatingSystem.isWindows() &&					    path.toLowerCase().startsWith(tryPrefix))						bestPrefix = tryPrefix;					else if (path.startsWith(tryPrefix))					{						bestPrefix = tryPrefix;					}					// Only use prefix if it is a directory-prefix of the path					if (!bestPrefix.equals(verifiedPrefix))					{						String remainder = original.substring(bestPrefix.length());						if (remainder.length() < 1 || remainder.startsWith(File.separator))							verifiedPrefix = bestPrefix;						else bestPrefix = verifiedPrefix;					}				}				if (bestPrefix.length() > 1)				{					String remainder = original.substring(bestPrefix.length());					String envvar = prefixMap.get(bestPrefix);					if (envvar.equals("~"))						path = envvar + remainder;					else if (OperatingSystem.isWindows())						path = '%' + envvar.toUpperCase() + '%' + remainder;					else						path = '$' + envvar + remainder;				}				previous.put(original, path);				return path;			}	
private boolean canBePathPrefix(String s)			{				// Do not use File#isDirectory() since it causes				// access to file system or network to check if				// the directory is actually exists.				return !s.contains(File.pathSeparator)					&& new File(s).isAbsolute();			}	
/**		 * Creates a new edit mode.		 *		 * @param name The name used in mode listings and to query mode		 * properties		 * @see #getProperty(String)		 */		public Mode(String name)		{			this.name = name;			this.ignoreWhitespace = true;			props = new Hashtable<String, Object>();		}	
/**		 * Initializes the edit mode. Should be called after all properties		 * are loaded and set.		 */		public void init()		{			try			{				String filenameGlob = (String)getProperty("filenameGlob");				if(filenameGlob != null && filenameGlob.length() != 0)				{					filenameRE = Pattern.compile(StandardUtilities.globToRE(filenameGlob),								     Pattern.CASE_INSENSITIVE);				}					String firstlineGlob = (String)getProperty("firstlineGlob");				if(firstlineGlob != null && firstlineGlob.length() != 0)				{					firstlineRE = Pattern.compile(StandardUtilities.globToRE(firstlineGlob),								      Pattern.CASE_INSENSITIVE);				}			}			catch(PatternSyntaxException re)			{				Log.log(Log.ERROR,this,"Invalid filename/firstline"					+ " globs in mode " + name);				Log.log(Log.ERROR,this,re);			}				// Fix for this bug:			// -- Put a mode into the user dir with the same name as one			//    on the system dir.			// -- Reload edit modes.			// -- Old mode from system dir still used for highlighting			//    until jEdit restart.			marker = null;		}	
/**		 * Returns the token marker for this mode.		 */		public TokenMarker getTokenMarker()		{			loadIfNecessary();			return marker;		}	
/**		 * Sets the token marker for this mode.		 * @param marker The new token marker		 */		public void setTokenMarker(TokenMarker marker)		{			this.marker = marker;		}	
/**		 * Loads the mode from disk if it hasn't been loaded already.		 * @since jEdit 2.5pre3		 */		public void loadIfNecessary()		{			if(marker == null)			{				ModeProvider.instance.loadMode(this);				if (marker == null)					Log.log(Log.ERROR, this, "Mode not correctly loaded, token marker is still null");			}		}	
/**		 * Returns a mode property.		 * @param key The property name		 *		 * @since jEdit 2.2pre1		 */		public Object getProperty(String key)		{			Object value = props.get(key);			if(value != null)				return value;			return null;		}	
/**		 * Returns the value of a boolean property.		 * @param key The property name		 *		 * @since jEdit 2.5pre3		 */		public boolean getBooleanProperty(String key)		{			Object value = getProperty(key);			return StandardUtilities.getBoolean(value, false);		}	
/**		 * Sets a mode property.		 * @param key The property name		 * @param value The property value		 */		public void setProperty(String key, Object value)		{			props.put(key,value);		}	
/**		 * Unsets a mode property.		 * @param key The property name		 * @since jEdit 3.2pre3		 */		public void unsetProperty(String key)		{			props.remove(key);		}	
/**		 * Should only be called by <code>XModeHandler</code>.		 * @since jEdit 4.0pre3		 */		public void setProperties(Map props)		{			if(props == null)				props = new Hashtable<String, Object>();				ignoreWhitespace = !"false".equalsIgnoreCase(						(String)props.get("ignoreWhitespace"));				// need to carry over file name and first line globs because they are			// not given to us by the XMode handler, but instead are filled in by			// the catalog loader.			String filenameGlob = (String)this.props.get("filenameGlob");			String firstlineGlob = (String)this.props.get("firstlineGlob");			String filename = (String)this.props.get("file");			this.props = props;			if(filenameGlob != null)				props.put("filenameGlob",filenameGlob);			if(firstlineGlob != null)				props.put("firstlineGlob",firstlineGlob);			if(filename != null)				props.put("file",filename);		}	
/**		 * Returns true if the edit mode is suitable for editing the specified		 * file. The buffer name and first line is checked against the		 * file name and first line globs, respectively.		 * @param fileName The buffer's name		 * @param firstLine The first line of the buffer		 *		 * @since jEdit 3.2pre3		 */		public boolean accept(String fileName, String firstLine)		{			return acceptFilename(fileName) || acceptFirstLine(firstLine);		}	
/**		 * Returns true if the buffer name matches the file name glob.		 * @param fileName The buffer's name		 * @return true if the file name matches the file name glob.		 * @since jEdit 4.3pre18		 */		public boolean acceptFilename(String fileName)		{			return filenameRE != null && filenameRE.matcher(fileName).matches();		}	
/**		 * Returns true if the first line matches the first line glob.		 * @param firstLine The first line of the buffer		 * @return true if the first line matches the first line glob.		 * @since jEdit 4.3pre18		 */		public boolean acceptFirstLine(String firstLine)		{			return firstlineRE != null && firstlineRE.matcher(firstLine).matches();		}	
/**		 * Returns the internal name of this edit mode.		 */		public String getName()		{			return name;		}	
/**		 * Returns a string representation of this edit mode.		 */		public String toString()		{			return name;		}	
public boolean getIgnoreWhitespace()		{			return ignoreWhitespace;		}	
public synchronized List<IndentRule> getIndentRules()		{			if (indentRules == null)			{				initIndentRules();			}			return indentRules;		}	
public synchronized boolean isElectricKey(char ch)		{			if (electricKeys == null)			{				String[] props = {					"indentOpenBrackets",					"indentCloseBrackets",					"electricKeys"				};					StringBuilder buf = new StringBuilder();				for(int i = 0; i < props.length; i++)				{					String prop = (String) getProperty(props[i]);					if (prop != null)						buf.append(prop);				}					electricKeys = buf.toString();			}				return (electricKeys.indexOf(ch) >= 0);		}	
private void initIndentRules()		{			List<IndentRule> rules = new LinkedList<IndentRule>();				String[] regexpProps = {				"indentNextLine",				"indentNextLines"			};				for(int i = 0; i < regexpProps.length; i++)			{				IndentRule rule = createRegexpIndentRule(regexpProps[i]);				if(rule != null)					rules.add(rule);			}				String[] bracketProps = {				"indentOpenBracket",				"indentCloseBracket",				"unalignedOpenBracket",				"unalignedCloseBracket",			};				for(int i = 0; i < bracketProps.length; i++)			{				createBracketIndentRules(bracketProps[i], rules);			}				String[] finalProps = {				"unindentThisLine",				"unindentNextLines"			};				for(int i = 0; i < finalProps.length; i++)			{				IndentRule rule = createRegexpIndentRule(finalProps[i]);				if(rule != null)					rules.add(rule);			}				if (getBooleanProperty("deepIndent"))			{				String unalignedOpenBrackets = (String) getProperty("unalignedOpenBrackets");				if (unalignedOpenBrackets != null)				{					for (int i = 0 ; i < unalignedOpenBrackets.length();i++)					{						char openChar = unalignedOpenBrackets.charAt(i);						char closeChar = TextUtilities.getComplementaryBracket(openChar, null);						if (closeChar != '\0')							rules.add(new DeepIndentRule(openChar, closeChar));					}				}			}				if (!getIgnoreWhitespace())				rules.add(new WhitespaceRule());				indentRules = Collections.unmodifiableList(rules);		}	
private IndentRule createRegexpIndentRule(String prop)		{			String value = (String) getProperty(prop);				try			{				if(value != null)				{					Method m = IndentRuleFactory.class.getMethod(						prop,new Class[] { String.class });					return (IndentRule)m.invoke(null, value);				}			}			catch(Exception e)			{				Log.log(Log.ERROR,this,"Bad indent rule " + prop					+ '=' + value + ':');				Log.log(Log.ERROR,this,e);			}				return null;		}	
private void createBracketIndentRules(String prop,							List<IndentRule> rules)		{			String value = (String) getProperty(prop + 's');				try			{				if(value != null)				{					for(int i = 0; i < value.length(); i++)					{						char ch = value.charAt(i);							Method m = IndentRuleFactory.class.getMethod(							prop,new Class[] { char.class });						rules.add((IndentRule) m.invoke(null, ch));					}				}			}			catch(Exception e)			{				Log.log(Log.ERROR,this,"Bad indent rule " + prop					+ '=' + value + ':');				Log.log(Log.ERROR,this,e);			}		}	
ModeCatalogHandler(String directory, boolean resource)		{			this.directory = directory;			this.resource = resource;		}	
public InputSource resolveEntity(String publicId, String systemId)		{			return XMLUtilities.findEntity(systemId, "catalog.dtd", getClass());		}	
public void startElement(String uri, String localName,								 String qName, Attributes attrs)		{			if (qName.equals("MODE"))			{				String modeName = attrs.getValue("NAME");					String file = attrs.getValue("FILE");				if(file == null)				{					Log.log(Log.ERROR,this,directory + "catalog:"						+ " mode " + modeName + " doesn't have"						+ " a FILE attribute");				}					String filenameGlob = attrs.getValue("FILE_NAME_GLOB");				String firstlineGlob = attrs.getValue("FIRST_LINE_GLOB");						Mode mode = ModeProvider.instance.getMode(modeName);				if(mode == null)				{					mode = instantiateMode(modeName);					ModeProvider.instance.addMode(mode);				}					Object path;				if(resource)					path = jEdit.class.getResource(directory + file);				else					path = MiscUtilities.constructPath(directory,file);				mode.setProperty("file",path);					if(filenameGlob != null)					mode.setProperty("filenameGlob",filenameGlob);				else					mode.unsetProperty("filenameGlob");					if(firstlineGlob != null)					mode.setProperty("firstlineGlob",firstlineGlob);				else					mode.unsetProperty("firstlineGlob");					mode.init();			}		}	
protected Mode instantiateMode(String modeName)		{			return new Mode(modeName);		}	
public void removeAll()		{			modes = new ArrayList<Mode>(180);		}	
/**		 * Returns the edit mode with the specified name.		 * @param name The edit mode		 * @since jEdit 4.3pre10		 */		public Mode getMode(String name)		{			for(int i = 0; i < modes.size(); i++)			{				Mode mode = modes.get(i);				if(mode.getName().equals(name))					return mode;			}			return null;		}	
/**		 * Get the appropriate mode that must be used for the file		 * @param filename the filename		 * @param firstLine the first line of the file		 * @return the edit mode, or null if no mode match the file		 * @since jEdit 4.3pre12		 */		public Mode getModeForFile(String filename, String firstLine)		{			String nogzName = filename.substring(0,filename.length() -				(filename.endsWith(".gz") ? 3 : 0));			Mode[] modes = getModes();				// this must be in reverse order so that modes from the user			// catalog get checked first!			for(int i = modes.length - 1; i >= 0; i--)			{				if(modes[i].accept(nogzName,firstLine))				{					return modes[i];				}			}			return null;		}	
/**		 * Returns an array of installed edit modes.		 * @since jEdit 4.3pre10		 */		public Mode[] getModes()		{			Mode[] array = new Mode[modes.size()];			modes.toArray(array);			return array;		}	
/**		 * Do not call this method. It is only public so that classes		 * in the org.gjt.sp.jedit.syntax package can access it.		 * @since jEdit 4.3pre10		 * @param mode The edit mode		 */		public void addMode(Mode mode)		{			modes.add(mode);		}	
public void loadMode(Mode mode, XModeHandler xmh)		{			String fileName = (String)mode.getProperty("file");				Log.log(Log.NOTICE,this,"Loading edit mode " + fileName);				XMLReader parser;			try			{				parser = XMLReaderFactory.createXMLReader();			} catch (SAXException saxe)			{				Log.log(Log.ERROR, this, saxe);				return;			}			mode.setTokenMarker(xmh.getTokenMarker());				InputStream grammar;				try			{				grammar = new BufferedInputStream(						new FileInputStream(fileName));			}			catch (FileNotFoundException e1)			{				InputStream resource = ModeProvider.class.getResourceAsStream(fileName);				if (resource == null)					error(fileName, e1);				grammar = new BufferedInputStream(resource);			}				try			{				InputSource isrc = new InputSource(grammar);				isrc.setSystemId("jedit.jar");				parser.setContentHandler(xmh);				parser.setDTDHandler(xmh);				parser.setEntityResolver(xmh);				parser.setErrorHandler(xmh);				parser.parse(isrc);					mode.setProperties(xmh.getModeProperties());			}			catch (Throwable e)			{				error(fileName, e);			}			finally			{				IOUtilities.closeQuietly(grammar);			}		}	
public void loadMode(Mode mode)		{			XModeHandler xmh = new XModeHandler(mode.getName())			{				@Override				public void error(String what, Object subst)				{					Log.log(Log.ERROR, this, subst);				}					@Override				public TokenMarker getTokenMarker(String modeName)				{					Mode mode = getMode(modeName);					if(mode == null)						return null;					else						return mode.getTokenMarker();				}			};			loadMode(mode, xmh);		}	
protected void error(String file, Throwable e)		{			Log.log(Log.ERROR, this, e);		}	
public Widget getWidget(View view) 	    {		ModeWidget mode = new ModeWidget(view);		return mode;	    }	
public ModeWidget(final View view) 		    {			    mode = new ToolTipLabel();			    this.view = view;			    mode.setToolTipText(jEdit.getProperty("view.status.mode-tooltip"));			    mode.addMouseListener(new MouseAdapter() 						  {							  @Override							  public void mouseClicked(MouseEvent evt)							  {								  if(evt.getClickCount() == 2)									  new BufferOptions(view,view.getBuffer());							  }						  });		    }	
public JComponent getComponent() 		    {			    return mode;		    }	
public void update() 		    {			    Buffer buffer = view.getBuffer();			    if (buffer.isLoaded())				    mode.setText(buffer.getMode().toString());		    }	
public void propertiesChanged()		    {		    }	
/**			@param context is METHOD or FIELD		*/		public void addModifier( int context, String name ) 		{			if ( modifiers == null )				modifiers = new Hashtable();				Object existing = modifiers.put( name, Void.TYPE/*arbitrary flag*/ );			if ( existing != null )				throw new IllegalStateException("Duplicate modifier: "+ name );				int count = 0;			if ( hasModifier("private") ) ++count;			if ( hasModifier("protected") ) ++count;			if ( hasModifier("public") ) ++count;			if ( count > 1 )				throw new IllegalStateException(					"public/private/protected cannot be used in combination." );				switch( context ) 			{			case CLASS:				validateForClass();				break;			case METHOD:				validateForMethod();				break;			case FIELD:				validateForField();				break;			}		}	
public boolean hasModifier( String name ) 		{			if ( modifiers == null )				modifiers = new Hashtable();			return modifiers.get(name) != null;		}	
private void validateForMethod() 		{ 			insureNo("volatile", "Method");			insureNo("transient", "Method");		}	
private void validateForField() 		{ 			insureNo("synchronized", "Variable");			insureNo("native", "Variable");			insureNo("abstract", "Variable");		}	
private void validateForClass() 		{ 			validateForMethod(); // volatile, transient			insureNo("native", "Class");			insureNo("synchronized", "Class");		}	
private void insureNo( String modifier, String context )		{			if ( hasModifier( modifier ) )				throw new IllegalStateException(					context + " cannot be declared '"+modifier+"'");		}	
public String toString()		{			return "Modifiers: "+modifiers;		}	
MouseActions(IPropertyManager propertyManager, String name)		{			this.propertyManager = propertyManager;			this.name = name;		}	
public String getActionForEvent(MouseEvent evt, String variant)		{			String modStr = KeyEventTranslator.getModifierString(evt);			if(modStr == null)			{				return propertyManager.getProperty("view." + name + '.'					+ variant + "Click");			}			else			{				return propertyManager.getProperty("view." + name + '.'					+ KeyEventTranslator.getModifierString(evt)					+ variant + "Click");			}		}	
public MouseHandler(JEditTextArea textArea)		{			super(textArea);			this.textArea = textArea;		}	
@Override		public void mousePressed(MouseEvent evt)		{			showCursor();				control = (OperatingSystem.isMacOS() && evt.isMetaDown())				|| (!OperatingSystem.isMacOS() && evt.isControlDown());				ctrlForRectangularSelection = textArea.isCtrlForRectangularSelection();				// so that Home <mouse click> Home is not the same			// as pressing Home twice in a row			textArea.getInputHandler().resetLastActionCount();				quickCopyDrag = (textArea.isQuickCopyEnabled() &&				isMiddleButton(evt.getModifiers()));				if(!quickCopyDrag)			{				textArea.requestFocus();				TextArea.focusedComponent = textArea;			}				if(textArea.getBuffer().isLoading())				return;			EditBus.send(new PositionChanging(textArea));			int x = evt.getX();			int y = evt.getY();				dragStart = textArea.xyToOffset(x,y,				!(textArea.getPainter().isBlockCaretEnabled()				|| textArea.isOverwriteEnabled()));			dragStartLine = textArea.getLineOfOffset(dragStart);			dragStartOffset = dragStart - textArea.getLineStartOffset(				dragStartLine);				if(isPopupTrigger(evt)				&& textArea.getRightClickPopup() != null)			{				if(textArea.isRightClickPopupEnabled())					textArea.handlePopupTrigger(evt);				return;			}				dragged = false;				textArea.blink = true;			textArea.invalidateLine(textArea.getCaretLine());				clickCount = evt.getClickCount();				if(textArea.isDragEnabled()				&& textArea.selectionManager.insideSelection(x,y)				&& clickCount == 1 && !evt.isShiftDown())			{				maybeDragAndDrop = true;					textArea.moveCaretPosition(dragStart,false);				return;			}				maybeDragAndDrop = false;				if(quickCopyDrag)			{				// ignore double clicks of middle button				doSingleClick(evt);			}			else			{				switch(clickCount)				{				case 1:					doSingleClick(evt);					break;				case 2:					doDoubleClick();					break;				default: //case 3:					doTripleClick();					break;				}			}		}	
@Override		public void mouseReleased(MouseEvent evt)		{			// middle mouse button drag inserts selection			// at caret position			Selection sel = textArea.getSelectionAtOffset(dragStart);			if(dragged && sel != null)			{				Registers.setRegister('%',textArea.getSelectedText(sel));				if(quickCopyDrag)				{					textArea.removeFromSelection(sel);					Registers.paste(TextArea.focusedComponent,						'%',sel instanceof Selection.Rect);						TextArea.focusedComponent.requestFocus();				}			}			else if(!dragged && textArea.isQuickCopyEnabled() &&				isMiddleButton(evt.getModifiers()))			{				textArea.requestFocus();				TextArea.focusedComponent = textArea;					textArea.setCaretPosition(dragStart,false);				if(!textArea.isEditable())					textArea.getToolkit().beep();				else					Registers.paste(textArea,'%',control);			}			else if(maybeDragAndDrop				&& !textArea.isMultipleSelectionEnabled())			{				textArea.selectNone();			}				maybeDragAndDrop = false;			dragged = false;		}	
public MouseOptionPane()		{			super("mouse");		}	
protected void _init()		{			/* Text drag and drop */			dragAndDrop = new JCheckBox(jEdit.getProperty(				"options.mouse.dragAndDrop"));			dragAndDrop.setSelected(jEdit.getBooleanProperty(				"view.dragAndDrop"));			addComponent(dragAndDrop);				/* Non word character selection behavior */			joinNonWordChars = new JCheckBox(jEdit.getProperty(				"options.mouse.joinNonWordChars"));			joinNonWordChars.setSelected(jEdit.getBooleanProperty(				"view.joinNonWordChars"));			addComponent(joinNonWordChars);				/* Middle mouse button click pastes % register */			middleMousePaste = new JCheckBox(jEdit.getProperty("options.mouse"				+ ".middleMousePaste"));			middleMousePaste.setSelected(jEdit.getBooleanProperty(				"view.middleMousePaste"));			addComponent(middleMousePaste);				/*			 * Pressing Ctrl while mouse actions makes them as if			 * selection mode were rectangular mode			 */			ctrlForRectangularSelection = new JCheckBox(jEdit.getProperty(				"options.mouse.ctrlForRectangularSelection"));			ctrlForRectangularSelection.setSelected(jEdit.getBooleanProperty(				"view.ctrlForRectangularSelection"));			addComponent(ctrlForRectangularSelection);				/* Gutter mouse actions */			int c = clickActionKeys.length;			String[] clickActionNames = new String[c];			for(int i = 0; i < c; i++)			{				clickActionNames[i] = jEdit.getProperty(					"options.mouse.gutter."+clickActionKeys[i]);			}				c = clickModifierKeys.length;			String[] clickModifierNames = new String[c];			for(int i = 0; i < c; i++)			{				clickModifierNames[i] = jEdit.getProperty(					"options.mouse.gutter."+clickModifierKeys[i]);			}				gutterClickActions = new JComboBox[c];				for(int i = 0; i < c; i++)			{				JComboBox cb = new JComboBox(clickActionNames);				gutterClickActions[i] = cb;					String val = jEdit.getProperty("view.gutter."+clickModifierKeys[i]);				for(int j = 0; j < clickActionKeys.length; j++)				{					if(val.equals(clickActionKeys[j]))					{						cb.setSelectedIndex(j);					}				}					addComponent(clickModifierNames[i],cb);			}		}	
public void _save()		{			jEdit.setBooleanProperty("view.dragAndDrop",						 dragAndDrop.isSelected());			jEdit.setBooleanProperty("view.joinNonWordChars",						 joinNonWordChars.isSelected());			jEdit.setBooleanProperty("view.middleMousePaste",						 middleMousePaste.isSelected());			jEdit.setBooleanProperty("view.ctrlForRectangularSelection",						 ctrlForRectangularSelection.isSelected());				int c = clickModifierKeys.length;			for(int i = 0; i < c; i++)			{				int idx = gutterClickActions[i].getSelectedIndex();				jEdit.setProperty("view.gutter."+clickModifierKeys[i],					clickActionKeys[idx]);			}		}	
public Widget getWidget(View view)		{			Widget multiSelect = new MultiSelectWidget(view);			return multiSelect;		}	
MultiSelectWidget(final View view)			{				multiSelect = new ToolTipLabel();				multiSelect.setHorizontalAlignment(SwingConstants.CENTER);				multiSelect.setToolTipText(jEdit.getProperty("view.status.multi-tooltip"));				this.view = view;				multiSelect.addMouseListener(new MouseAdapter()							     {								     @Override								     public void mouseClicked(MouseEvent e)								     {									     JEditTextArea textArea = view.getTextArea();									     if (textArea != null)										     textArea.toggleMultipleSelectionEnabled();								     }							     });			}	
public JComponent getComponent()			{				return multiSelect;			}	
public void update()			{				JEditTextArea textArea = view.getTextArea();				if (textArea != null)				{					multiSelect.setText(textArea.isMultipleSelectionEnabled()							    ? "M" : "-");				}			}	
public void propertiesChanged()			{				// retarded GTK look and feel!				Font font = new JLabel().getFont();				//UIManager.getFont("Label.font");				FontMetrics fm = multiSelect.getFontMetrics(font);				Dimension dim = new Dimension(							      Math.max(fm.charWidth('-'),fm.charWidth('M')) + 1,							      fm.getHeight());				multiSelect.setPreferredSize(dim);				multiSelect.setMaximumSize(dim);			}	
private void reset() {			evalName = value;			evalBaseObject = null;			callstackDepth = 0;		}	
/**			This constructor should *not* be used in general. 			Use NameSpace getNameResolver() which supports caching.			@see NameSpace getNameResolver().		*/		// I wish I could make this "friendly" to only NameSpace		Name( NameSpace namespace, String s )		{			this.namespace = namespace;			value = s;		}	
/**			Resolve possibly complex name to an object value.				Throws EvalError on various failures.			A null object value is indicated by a Primitive.NULL.			A return type of Primitive.VOID comes from attempting to access			an undefined variable.				Some cases:				myVariable				myVariable.foo				myVariable.foo.bar				java.awt.GridBagConstraints.BOTH				my.package.stuff.MyClass.someField.someField...				Interpreter reference is necessary to allow resolution of 			"this.interpreter" magic field.			CallStack reference is necessary to allow resolution of 			"this.caller" magic field.			"this.callstack" magic field.		*/		public Object toObject( CallStack callstack, Interpreter interpreter ) 			throws UtilEvalError		{			return toObject( callstack, interpreter, false );		}	
/**			@see toObject()			@param forceClass if true then resolution will only produce a class.			This is necessary to disambiguate in cases where the grammar knows			that we want a class; where in general the var path may be taken.		*/		synchronized public Object toObject( 			CallStack callstack, Interpreter interpreter, boolean forceClass ) 			throws UtilEvalError		{			reset();				Object obj = null;			while( evalName != null )				obj = consumeNextObjectField( 					callstack, interpreter, forceClass, false/*autoalloc*/  );				if ( obj == null )				throw new InterpreterError("null value in toObject()");				return obj;		}	
private Object completeRound( 			String lastEvalName, String nextEvalName, Object returnObject )		{			if ( returnObject == null )				throw new InterpreterError("lastEvalName = "+lastEvalName);			this.lastEvalName = lastEvalName;			this.evalName = nextEvalName;			this.evalBaseObject = returnObject;			return returnObject;		}	
/**			Get the next object by consuming one or more components of evalName.  			Often this consumes just one component, but if the name is a classname 			it will consume all of the components necessary to make the class 			identifier.		*/		private Object consumeNextObjectField( 				CallStack callstack, Interpreter interpreter, 			boolean forceClass, boolean autoAllocateThis ) 			throws UtilEvalError		{			/*				Is it a simple variable name?				Doing this first gives the correct Java precedence for vars 				vs. imported class names (at least in the simple case - see				tests/precedence1.bsh).  It should also speed things up a bit.			*/			if ( (evalBaseObject == null && !isCompound(evalName) )				&& !forceClass ) 			{				Object obj = resolveThisFieldReference( 					callstack, namespace, interpreter, evalName, false );					if ( obj != Primitive.VOID )					return completeRound( evalName, FINISHED, obj );			}				/*				Is it a bsh script variable reference?				If we're just starting the eval of name (no base object)				or we're evaluating relative to a This type reference check.			*/			String varName = prefix(evalName, 1);			if ( ( evalBaseObject == null || evalBaseObject instanceof This  )				&& !forceClass ) 			{				if ( Interpreter.DEBUG ) 					Interpreter.debug("trying to resolve variable: " + varName);					Object obj;				// switch namespace and special var visibility				if ( evalBaseObject == null ) {					obj = resolveThisFieldReference( 						callstack, namespace, interpreter, varName, false );				} else {					obj = resolveThisFieldReference( 						callstack, ((This)evalBaseObject).namespace, 						interpreter, varName, true );				}					if ( obj != Primitive.VOID ) 				{					// Resolved the variable					if ( Interpreter.DEBUG ) 						Interpreter.debug( "resolved variable: " + varName + 						" in namespace: "+namespace);						return completeRound( varName, suffix(evalName), obj );				}			}				/*				Is it a class name?				If we're just starting eval of name try to make it, else fail.			*/			if ( evalBaseObject == null ) 			{				if ( Interpreter.DEBUG ) 					Interpreter.debug( "trying class: " + evalName);								/*					Keep adding parts until we have a class 				*/				Class clas = null;				int i = 1;				String className = null;				for(; i <= countParts(evalName); i++)				{					className = prefix(evalName, i);					if ( (clas = namespace.getClass(className)) != null )						break;				}							if ( clas != null )  {					return completeRound(						className,						suffix( evalName, countParts(evalName)-i ),						new ClassIdentifier(clas) 					);				}				// not a class (or variable per above)				if ( Interpreter.DEBUG ) 					Interpreter.debug( "not a class, trying var prefix "+evalName );			}				// No variable or class found in 'this' type ref.			// if autoAllocateThis then create one; a child 'this'.			if ( ( evalBaseObject == null || evalBaseObject instanceof This  )				&& !forceClass && autoAllocateThis )			{				NameSpace targetNameSpace = 					( evalBaseObject == null ) ?  						namespace : ((This)evalBaseObject).namespace;				Object obj = new NameSpace( 					targetNameSpace, "auto: "+varName ).getThis( interpreter );				targetNameSpace.setVariable( varName, obj, false );				return completeRound( varName, suffix(evalName), obj );			}				/*				If we didn't find a class or variable name (or prefix) above				there are two possibilities:					- If we are a simple name then we can pass as a void variable 				reference.				- If we are compound then we must fail at this point.			*/			if ( evalBaseObject == null ) {				if ( !isCompound(evalName) ) {					return completeRound( evalName, FINISHED, Primitive.VOID );				} else					throw new UtilEvalError(						"Class or variable not found: " + evalName);			}				/*				--------------------------------------------------------				After this point we're definitely evaluating relative to				a base object.				--------------------------------------------------------			*/				/*				Do some basic validity checks.			*/				if ( evalBaseObject == Primitive.NULL) // previous round produced null				throw new UtilTargetError( new NullPointerException( 					"Null Pointer while evaluating: " +value ) );				if ( evalBaseObject == Primitive.VOID) // previous round produced void				throw new UtilEvalError(					"Undefined variable or class name while evaluating: "+value);				if ( evalBaseObject instanceof Primitive)				throw new UtilEvalError("Can't treat primitive like an object. "+				"Error while evaluating: "+value);				/* 				Resolve relative to a class type				static field, inner class, ?			*/			if ( evalBaseObject instanceof ClassIdentifier ) 			{				Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();				String field = prefix(evalName, 1);					// Class qualified 'this' reference from inner class.				// e.g. 'MyOuterClass.this'				if ( field.equals("this") )				{					// find the enclosing class instance space of the class name					NameSpace ns = namespace;					while ( ns != null )					{						// getClassInstance() throws exception if not there						if ( ns.classInstance != null 							&& ns.classInstance.getClass() == clas 						)							return completeRound( 								field, suffix(evalName), ns.classInstance );						ns=ns.getParent();					}					throw new UtilEvalError(						"Can't find enclosing 'this' instance of class: "+clas);				}					Object obj = null;				// static field?				try {					if ( Interpreter.DEBUG ) 						Interpreter.debug("Name call to getStaticFieldValue, class: "							+clas+", field:"+field);					obj = Reflect.getStaticFieldValue(clas, field);				} catch( ReflectError e ) { 					if ( Interpreter.DEBUG ) 						Interpreter.debug("field reflect error: "+e);				}					// inner class?				if ( obj == null ) {					String iclass = clas.getName()+"$"+field;					Class c = namespace.getClass( iclass );					if ( c != null )						obj = new ClassIdentifier(c);				}					if ( obj == null )					throw new UtilEvalError(						"No static field or inner class: " 						+ field + " of " + clas );					return completeRound( field, suffix(evalName), obj );			}				/*				If we've fallen through here we are no longer resolving to				a class type.			*/			if ( forceClass )				throw new UtilEvalError( 					value +" does not resolve to a class name." );				/* 				Some kind of field access?			*/				String field = prefix(evalName, 1);				// length access on array? 			if ( field.equals("length") && evalBaseObject.getClass().isArray() )			{				Object obj = new Primitive(Array.getLength(evalBaseObject));				return completeRound( field, suffix(evalName), obj );			}				// Check for field on object 			// Note: could eliminate throwing the exception somehow			try {				Object obj = Reflect.getObjectFieldValue(evalBaseObject, field);				return completeRound( field, suffix(evalName), obj );			} catch(ReflectError e) { /* not a field */ }					// if we get here we have failed			throw new UtilEvalError(				"Cannot access field: " + field + ", on object: " + evalBaseObject);		}	
/**			Resolve a variable relative to a This reference.				This is the general variable resolution method, accomodating special			fields from the This context.  Together the namespace and interpreter			comprise the This context.  The callstack, if available allows for the			this.caller construct.  			Optionally interpret special "magic" field names: e.g. interpreter.			<p/>				@param callstack may be null, but this is only legitimate in special			cases where we are sure resolution will not involve this.caller.				@param namespace the namespace of the this reference (should be the			same as the top of the stack?		*/		Object resolveThisFieldReference( 			CallStack callstack, NameSpace thisNameSpace, Interpreter interpreter, 			String varName, boolean specialFieldsVisible ) 			throws UtilEvalError		{			if ( varName.equals("this") ) 			{				/*					Somewhat of a hack.  If the special fields are visible (we're					operating relative to a 'this' type already) dissallow further					.this references to prevent user from skipping to things like					super.this.caller				*/				if ( specialFieldsVisible )					throw new UtilEvalError("Redundant to call .this on This type");					// Allow getThis() to work through BlockNameSpace to the method				// namespace		// XXX re-eval this... do we need it?				This ths = thisNameSpace.getThis( interpreter );				thisNameSpace= ths.getNameSpace();				Object result = ths;					NameSpace classNameSpace = getClassNameSpace( thisNameSpace );				if ( classNameSpace != null )				{					if ( isCompound( evalName ) )						result = classNameSpace.getThis( interpreter );					else						result = classNameSpace.getClassInstance();				}					return result;			}				/*				Some duplication for "super".  See notes for "this" above				If we're in an enclsing class instance and have a superclass				instance our super is the superclass instance.			*/			if ( varName.equals("super") ) 			{				//if ( specialFieldsVisible )				//throw new UtilEvalError("Redundant to call .this on This type");					// Allow getSuper() to through BlockNameSpace to the method's super				This ths = thisNameSpace.getSuper( interpreter );				thisNameSpace = ths.getNameSpace();				// super is now the closure's super or class instance			// XXXX re-evaluate this		// can getSuper work by itself now?				// If we're a class instance and the parent is also a class instance				// then super means our parent.				if ( 					thisNameSpace.getParent() != null 					&& thisNameSpace.getParent().isClass				)					ths = thisNameSpace.getParent().getThis( interpreter );					return ths;			}				Object obj = null;				if ( varName.equals("global") )				obj = thisNameSpace.getGlobal( interpreter );				if ( obj == null && specialFieldsVisible ) 			{				if (varName.equals("namespace"))					obj = thisNameSpace;				else if (varName.equals("variables"))					obj = thisNameSpace.getVariableNames();				else if (varName.equals("methods"))					obj = thisNameSpace.getMethodNames();				else if ( varName.equals("interpreter") )					if ( lastEvalName.equals("this") )						obj = interpreter;					else						throw new UtilEvalError(							"Can only call .interpreter on literal 'this'");			}				if ( obj == null && specialFieldsVisible && varName.equals("caller") )			{				if ( lastEvalName.equals("this") || lastEvalName.equals("caller") ) 				{					// get the previous context (see notes for this class)					if ( callstack == null )						throw new InterpreterError("no callstack");					obj = callstack.get( ++callstackDepth ).getThis( 						interpreter ); 				}				else					throw new UtilEvalError(					"Can only call .caller on literal 'this' or literal '.caller'");					// early return				return obj;			}				if ( obj == null && specialFieldsVisible 				&& varName.equals("callstack") )			{				if ( lastEvalName.equals("this") ) 				{					// get the previous context (see notes for this class)					if ( callstack == null )						throw new InterpreterError("no callstack");					obj = callstack;				}				else					throw new UtilEvalError(					"Can only call .callstack on literal 'this'");			}					if ( obj == null )				obj = thisNameSpace.getVariable(varName);				if ( obj == null )				throw new InterpreterError("null this field ref:"+varName);				return obj;		}	
/**			@return the enclosing class body namespace or null if not in a class.		*/		static NameSpace getClassNameSpace( NameSpace thisNameSpace ) 		{			// is a class instance			//if ( thisNameSpace.classInstance != null )			if ( thisNameSpace.isClass )				return thisNameSpace;				if ( thisNameSpace.isMethod 				&& thisNameSpace.getParent() != null 				//&& thisNameSpace.getParent().classInstance != null				&& thisNameSpace.getParent().isClass			)				return thisNameSpace.getParent();				return null;		}	
/**			Check the cache, else use toObject() to try to resolve to a class			identifier.  				@throws ClassNotFoundException on class not found.			@throws ClassPathException (type of EvalError) on special case of 			ambiguous unqualified name after super import. 		*/		synchronized public Class toClass() 			throws ClassNotFoundException, UtilEvalError		{			if ( asClass != null )				return asClass;				reset();				// "var" means untyped, return null class			if ( evalName.equals("var") )				return asClass = null;				/* Try straightforward class name first */			Class clas = namespace.getClass( evalName );				if ( clas == null ) 			{				/* 					Try toObject() which knows how to work through inner classes					and see what we end up with 				*/				Object obj = null;				try {					// Null interpreter and callstack references.					// class only resolution should not require them.					obj = toObject( null, null, true );  				} catch ( UtilEvalError  e ) { }; // couldn't resolve it							if ( obj instanceof ClassIdentifier )					clas = ((ClassIdentifier)obj).getTargetClass();			}				if ( clas == null )				throw new ClassNotFoundException(					"Class: " + value+ " not found in namespace");				asClass = clas;			return asClass;		}	
synchronized public LHS toLHS( 			CallStack callstack, Interpreter interpreter )			throws UtilEvalError		{			// Should clean this up to a single return statement			reset();			LHS lhs;				// Simple (non-compound) variable assignment e.g. x=5;			if ( !isCompound(evalName) ) 			{				if ( evalName.equals("this") )					throw new UtilEvalError("Can't assign to 'this'." );					// Interpreter.debug("Simple var LHS...");				lhs = new LHS( namespace, evalName, false/*bubble up if allowed*/);				return lhs;			}				// Field e.g. foo.bar=5;			Object obj = null;			try {				while( evalName != null && isCompound( evalName ) )				{					obj = consumeNextObjectField( callstack, interpreter, 						false/*forcclass*/, true/*autoallocthis*/ );				}			} 			catch( UtilEvalError e ) {				throw new UtilEvalError( "LHS evaluation: " + e.getMessage() );			}				// Finished eval and its a class.			if ( evalName == null && obj instanceof ClassIdentifier )				throw new UtilEvalError("Can't assign to class: " + value );				if ( obj == null )				throw new UtilEvalError("Error in LHS: " + value );				// e.g. this.x=5;  or someThisType.x=5;			if ( obj instanceof This )			{				// dissallow assignment to magic fields				if ( 					evalName.equals("namespace")					|| evalName.equals("variables")					|| evalName.equals("methods")					|| evalName.equals("caller")				)					throw new UtilEvalError(						"Can't assign to special variable: "+evalName );					Interpreter.debug("found This reference evaluating LHS");				/*					If this was a literal "super" reference then we allow recursion					in setting the variable to get the normal effect of finding the					nearest definition starting at the super scope.  On any other					resolution qualified by a 'this' type reference we want to set					the variable directly in that scope. e.g. this.x=5;  or 					someThisType.x=5;										In the old scoping rules super didn't do this.				*/				boolean localVar = !lastEvalName.equals("super");				return new LHS( ((This)obj).namespace, evalName, localVar );			}				if ( evalName != null )			{				try {					if ( obj instanceof ClassIdentifier ) 					{						Class clas = ((ClassIdentifier)obj).getTargetClass();						lhs = Reflect.getLHSStaticField(clas, evalName);						return lhs;					} else {						lhs = Reflect.getLHSObjectField(obj, evalName);						return lhs;					}				} catch(ReflectError e) {					throw new UtilEvalError("Field access: "+e);				}			}				throw new InterpreterError("Internal error in lhs...");		}	
/**			Invoke the method identified by this name.			Performs caching of method resolution using SignatureKey.			<p>		        Name contains a wholely unqualfied messy name; resolve it to 			( object | static prefix ) + method name and invoke.			<p>		        The interpreter is necessary to support 'this.interpreter' references			in the called code. (e.g. debug());			<p>				<pre>	        Some cases:		            // dynamic	            local();	            myVariable.foo();	            myVariable.bar.blah.foo();	            // static	            java.lang.Integer.getInteger("foo");			</pre>	    */	    public Object invokeMethod(			Interpreter interpreter, Object[] args, CallStack callstack,			SimpleNode callerInfo		)	        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException	    {	        String methodName = Name.suffix(value, 1);			BshClassManager bcm = interpreter.getClassManager();			NameSpace namespace = callstack.top();				// Optimization - If classOfStaticMethod is set then we have already 			// been here and determined that this is a static method invocation.			// Note: maybe factor this out with path below... clean up.	        if ( classOfStaticMethod != null )			{				return Reflect.invokeStaticMethod( 					bcm, classOfStaticMethod, methodName, args );			}				if ( !Name.isCompound(value) )				return invokeLocalMethod( 					interpreter, args, callstack, callerInfo );				// Note: if we want methods declared inside blocks to be accessible via			// this.methodname() inside the block we could handle it here as a			// special case.  See also resolveThisFieldReference() special handling			// for BlockNameSpace case.  They currently work via the direct name			// e.g. methodName().		        String prefix = Name.prefix(value);				// Superclass method invocation? (e.g. super.foo())			if ( prefix.equals("super") && Name.countParts(value) == 2 )			{				// Allow getThis() to work through block namespaces first				This ths = namespace.getThis( interpreter );				NameSpace thisNameSpace = ths.getNameSpace();				NameSpace classNameSpace = getClassNameSpace( thisNameSpace );				if ( classNameSpace != null )				{					Object instance = classNameSpace.getClassInstance();					return ClassGenerator.getClassGenerator()						.invokeSuperclassMethod( bcm, instance, methodName, args );				}			}		        // Find target object or class identifier	        Name targetName = namespace.getNameResolver( prefix );	        Object obj = targetName.toObject( callstack, interpreter );				if ( obj == Primitive.VOID ) 				throw new UtilEvalError( "Attempt to resolve method: "+methodName						+"() on undefined variable or class name: "+targetName);		        // if we've got an object, resolve the method	        if ( !(obj instanceof ClassIdentifier) ) {		            if (obj instanceof Primitive) {		                if (obj == Primitive.NULL)	                    throw new UtilTargetError( new NullPointerException( 							"Null Pointer in Method Invocation" ) );		                // some other primitive	                // should avoid calling methods on primitive, as we do	                // in Name (can't treat primitive like an object message)	                // but the hole is useful right now.					if ( Interpreter.DEBUG )	                	interpreter.debug(						"Attempt to access method on primitive..." 						+ " allowing bsh.Primitive to peek through for debugging");	            }		            // found an object and it's not an undefined variable	            return Reflect.invokeObjectMethod(					obj, methodName, args, interpreter, callstack, callerInfo );	        }				// It's a class		        // try static method	        if ( Interpreter.DEBUG ) 	        	Interpreter.debug("invokeMethod: trying static - " + targetName);		        Class clas = ((ClassIdentifier)obj).getTargetClass();				// cache the fact that this is a static method invocation on this class			classOfStaticMethod = clas;				        if ( clas != null )				return Reflect.invokeStaticMethod( bcm, clas, methodName, args );		        // return null; ???			throw new UtilEvalError("invokeMethod: unknown target: " + targetName);	    }	
/**			Invoke a locally declared method or a bsh command.			If the method is not already declared in the namespace then try			to load it as a resource from the imported command path (e.g.			/bsh/commands)		*/		/*			Note: the bsh command code should probably not be here...  we need to			scope it by the namespace that imported the command... so it probably			needs to be integrated into NameSpace.		*/	    private Object invokeLocalMethod( 			Interpreter interpreter, Object[] args, CallStack callstack,			SimpleNode callerInfo		)	        throws EvalError/*, ReflectError, InvocationTargetException*/	    {	        if ( Interpreter.DEBUG ) 	        	Interpreter.debug( "invokeLocalMethod: " + value );			if ( interpreter == null )				throw new InterpreterError(					"invokeLocalMethod: interpreter = null");				String commandName = value;			Class [] argTypes = Types.getTypes( args );		        // Check for existing method	        BshMethod meth = null;			try {				meth = namespace.getMethod( commandName, argTypes );			} catch ( UtilEvalError e ) {				throw e.toEvalError(					"Local method invocation", callerInfo, callstack );			}				// If defined, invoke it	        if ( meth != null )				return meth.invoke( args, interpreter, callstack, callerInfo );				BshClassManager bcm = interpreter.getClassManager();				// Look for a BeanShell command				Object commandObject;			try {				commandObject = namespace.getCommand( 					commandName, argTypes, interpreter );			} catch ( UtilEvalError e ) {				throw e.toEvalError("Error loading command: ", 					callerInfo, callstack );			}				// should try to print usage here if nothing found			if ( commandObject == null )			{				// Look for a default invoke() handler method in the namespace				// Note: this code duplicates that in This.java... should it?				// Call on 'This' can never be a command				BshMethod invokeMethod = null;				try {					invokeMethod = namespace.getMethod( 						"invoke", new Class [] { null, null } );				} catch ( UtilEvalError e ) {					throw e.toEvalError(						"Local method invocation", callerInfo, callstack );				}					if ( invokeMethod != null )					return invokeMethod.invoke( 						new Object [] { commandName, args }, 						interpreter, callstack, callerInfo );		            throw new EvalError( "Command not found: " 					+StringUtil.methodString( commandName, argTypes ), 					callerInfo, callstack );			}				if ( commandObject instanceof BshMethod )				return ((BshMethod)commandObject).invoke( 					args, interpreter, callstack, callerInfo );				if ( commandObject instanceof Class )				try {					return Reflect.invokeCompiledCommand( 						((Class)commandObject), args, interpreter, callstack );				} catch ( UtilEvalError e ) {					throw e.toEvalError("Error invoking compiled command: ",					callerInfo, callstack );				}				throw new InterpreterError("invalid command type");	    }	
public static boolean isCompound(String value)		{			return value.indexOf('.') != -1 ;			//return countParts(value) > 1;		}	
static int countParts(String value)		{			if(value == null)				return 0;				int count = 0;			int index = -1;			while((index = value.indexOf('.', index + 1)) != -1)				count++;			return count + 1;		}	
static String prefix(String value)		{			if(!isCompound(value))				return null;				return prefix(value, countParts(value) - 1);		}	
static String prefix(String value, int parts)		{			if (parts < 1 )				return null;				int count = 0;			int index = -1;				while( ((index = value.indexOf('.', index + 1)) != -1) 				&& (++count < parts) )			{ ; }				return (index == -1) ? value : value.substring(0, index);		}	
static String suffix(String name)		{			if(!isCompound(name))				return null;				return suffix(name, countParts(name) - 1);		}	
public static String suffix(String value, int parts)		{			if (parts < 1)				return null;				int count = 0;			int index = value.length() + 1;				while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 				&& (++count < parts) );				return (index == -1) ? value : value.substring(index + 1);		}	
public String toString() { return value; }	
void setClassStatic( Class clas ) {	        this.classStatic = clas;	        importStatic( clas );	    }	
void setClassInstance( Object instance ) {	        this.classInstance = instance;	        importObject( instance );	    }	
Object getClassInstance()	        throws UtilEvalError	    {	        if ( classInstance != null )	            return classInstance;		        if ( classStatic != null	            //|| ( getParent()!=null && getParent().classStatic != null )	        )	            throw new UtilEvalError(	                "Can't refer to class instance from static context.");	        else	            throw new InterpreterError(	                "Can't resolve class instance 'this' in: "+this);	    }	
/**	        @param parent the parent namespace of this namespace.  Child namespaces	        inherit all variables and methods of their parent and can (of course)	        override / shadow them.	        @param name a name	    */	    public NameSpace( NameSpace parent, String name )	    {	        // Note: in this case parent must have a class manager.	        this( parent, null, name );	    }	
public NameSpace( BshClassManager classManager, String name )	    {	        this( null, classManager, name );	    }	
public NameSpace(	        NameSpace parent, BshClassManager classManager, String name )	    {	        // We might want to do this here rather than explicitly in Interpreter	        // for global (see also prune())	        //if ( classManager == null && (parent == null ) )	            // create our own class manager?		        setName(name);	        setParent(parent);	        setClassManager( classManager );		        // Register for notification of classloader change	        if ( classManager != null )	            classManager.addListener(this);	    }	
public void setName( String name ) {	        this.nsName = name;	    }	
/**	        The name of this namespace.  If the namespace is a method body	        namespace then this is the name of the method.  If it's a class or	        class instance then it's the name of the class.	    */	    public String getName() {	        return this.nsName;	    }	
/**	        Set the node associated with the creation of this namespace.	        This is used in debugging and to support the getInvocationLine()	        and getInvocationText() methods.	    */	    void setNode( SimpleNode node ) {	        callerInfoNode = node;	    }	
/**	    */	    SimpleNode getNode()	    {	        if ( callerInfoNode != null )	            return callerInfoNode;	        if ( parent != null )	            return parent.getNode();	        else	            return null;	    }	
/**	        Resolve name to an object through this namespace.	    */	    public Object get( String name, Interpreter interpreter )	        throws UtilEvalError	    {	        CallStack callstack = new CallStack( this );	        return getNameResolver( name ).toObject( callstack, interpreter );	    }	
/**	        Set the variable through this namespace.	        This method obeys the LOCALSCOPING property to determine how variables	        are set.	        <p>	        Note: this method is primarily intended for use internally.  If you use	        this method outside of the bsh package and wish to set variables with	        primitive values you will have to wrap them using bsh.Primitive.	        @see org.gjt.sp.jedit.bsh.Primitive	        <p>	        Setting a new variable (which didn't exist before) or removing	        a variable causes a namespace change.		        @param strictJava specifies whether strict java rules are applied.	    */	    public void	setVariable( String name, Object value, boolean strictJava )	        throws UtilEvalError	    {	        // if localscoping switch follow strictJava, else recurse	        boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;	        setVariable( name, value, strictJava, recurse );	    }	
/**	        Set a variable explicitly in the local scope.	    */	    void setLocalVariable(	        String name, Object value, boolean strictJava )	        throws UtilEvalError	    {	        setVariable( name, value, strictJava, false/*recurse*/ );	    }	
/**	        Set the value of a the variable 'name' through this namespace.	        The variable may be an existing or non-existing variable.	        It may live in this namespace or in a parent namespace if recurse is	        true.	        <p>	        Note: This method is not public and does *not* know about LOCALSCOPING.	        Its caller methods must set recurse intelligently in all situations	        (perhaps based on LOCALSCOPING).		        <p>	        Note: this method is primarily intended for use internally.  If you use	        this method outside of the bsh package and wish to set variables with	        primitive values you will have to wrap them using bsh.Primitive.	        @see org.gjt.sp.jedit.bsh.Primitive	        <p>	        Setting a new variable (which didn't exist before) or removing	        a variable causes a namespace change.		        @param strictJava specifies whether strict java rules are applied.	        @param recurse determines whether we will search for the variable in	          our parent's scope before assigning locally.	    */	    void setVariable(	        String name, Object value, boolean strictJava, boolean recurse )	        throws UtilEvalError	    {	        if ( variables == null )	            variables =	new Hashtable();		        // primitives should have been wrapped	        // {{{ jEdit change	        //if ( value == null )	        //	throw new InterpreterError("null variable value");		        if ( value == null ) {	            // don't break jEdit core and plugins!	            unsetVariable(name);	            return;	        }		        // }}}	        // Locate the variable definition if it exists.	        Variable existing = getVariableImpl( name, recurse );		        // Found an existing variable here (or above if recurse allowed)	        if ( existing != null )	        {	            try {	                existing.setValue( value, Variable.ASSIGNMENT );	            } catch ( UtilEvalError e ) {	                throw new UtilEvalError(	                    "Variable assignment: " + name + ": " + e.getMessage());	            }	        } else	        // No previous variable definition found here (or above if recurse)	        {	            if ( strictJava )	                throw new UtilEvalError(	                    "(Strict Java mode) Assignment to undeclared variable: "	                    +name );		            // If recurse, set global untyped var, else set it here.	            //NameSpace varScope = recurse ? getGlobal() : this;	            // This modification makes default allocation local	            NameSpace varScope = this;		            varScope.variables.put(	                name, new Variable( name, value, null/*modifiers*/ ) );		            // nameSpaceChanged() on new variable addition	            nameSpaceChanged();	        }	    }	
/**	        Remove the variable from the namespace.	    */	    public void unsetVariable( String name )	    {	        if ( variables != null )	        {	            variables.remove( name );	            nameSpaceChanged();	        }	    }	
/**	        Get the names of variables defined in this namespace.	        (This does not show variables in parent namespaces).	    */	    public String [] getVariableNames() {	        if ( variables == null )	            return new String [0];	        else	            return enumerationToStringArray( variables.keys() );	    }	
/**	        Get the names of methods declared in this namespace.	        (This does not include methods in parent namespaces).	    */	    public String [] getMethodNames()	    {	        if ( methods == null )	            return new String [0];	        else	            return enumerationToStringArray( methods.keys() );	    }	
/**	        Get the methods defined in this namespace.	        (This does not show methods in parent namespaces).	        Note: This will probably be renamed getDeclaredMethods()	    */	    public BshMethod [] getMethods()	    {	        if ( methods == null )	            return new BshMethod [0];	        else	            return flattenMethodCollection( methods.elements() );	    }	
private String [] enumerationToStringArray( Enumeration e ) {	        Vector v = new Vector();	        while ( e.hasMoreElements() )	            v.addElement( e.nextElement() );	        String [] sa = new String [ v.size() ];	        v.copyInto( sa );	        return sa;	    }	
/**	        Flatten the vectors of overloaded methods to a single array.	        @see #getMethods()	    */	    private BshMethod [] flattenMethodCollection( Enumeration e ) {	        Vector v = new Vector();	        while ( e.hasMoreElements() ) {	            Object o = e.nextElement();	            if ( o instanceof BshMethod )	                v.addElement( o );	            else {	                Vector ov = (Vector)o;	                for(int i=0; i<ov.size(); i++)	                    v.addElement( ov.elementAt( i ) );	            }	        }	        BshMethod [] bma = new BshMethod [ v.size() ];	        v.copyInto( bma );	        return bma;	    }	
/**	        Get the parent namespace.	        Note: this isn't quite the same as getSuper().	        getSuper() returns 'this' if we are at the root namespace.	    */	    public NameSpace getParent() {	        return parent;	    }	
/**	        Get the parent namespace' This reference or this namespace' This	        reference if we are the top.	    */	    public This getSuper( Interpreter declaringInterpreter )	    {	        if ( parent != null )	            return parent.getThis( declaringInterpreter );	        else	            return getThis( declaringInterpreter );	    }	
/**	        Get the top level namespace or this namespace if we are the top.	        Note: this method should probably return type bsh.This to be consistent	        with getThis();	    */	    public This getGlobal( Interpreter declaringInterpreter )	    {	        if ( parent != null )	            return parent.getGlobal( declaringInterpreter );	        else	            return getThis( declaringInterpreter );	    }	
/**	        A This object is a thin layer over a namespace, comprising a bsh object	        context.  It handles things like the interface types the bsh object	        supports and aspects of method invocation on it.	        <p>		        The declaringInterpreter is here to support callbacks from Java through	        generated proxies.  The scripted object "remembers" who created it for	        things like printing messages and other per-interpreter phenomenon	        when called externally from Java.	    */	    /*	        Note: we need a singleton here so that things like 'this == this' work	        (and probably a good idea for speed).		        Caching a single instance here seems technically incorrect,	        considering the declaringInterpreter could be different under some	        circumstances.  (Case: a child interpreter running a source() / eval()	        command ).  However the effect is just that the main interpreter that	        executes your script should be the one involved in call-backs from Java.		        I do not know if there are corner cases where a child interpreter would	        be the first to use a This reference in a namespace or if that would	        even cause any problems if it did...  We could do some experiments	        to find out... and if necessary we could cache on a per interpreter	        basis if we had weak references...  We might also look at skipping	        over child interpreters and going to the parent for the declaring	        interpreter, so we'd be sure to get the top interpreter.	    */	    This getThis( Interpreter declaringInterpreter )	    {	        if ( thisReference == null )	            thisReference = This.getThis( this, declaringInterpreter );		        return thisReference;	    }	
public BshClassManager getClassManager()	    {	        if ( classManager != null )	            return classManager;	        if ( parent != null && parent != JAVACODE )	            return parent.getClassManager();		System.out.println("experiment: creating class manager");	        classManager = BshClassManager.createClassManager( null/*interp*/ );		        //Interpreter.debug("No class manager namespace:" +this);	        return classManager;	    }	
void setClassManager( BshClassManager classManager ) {	        this.classManager = classManager;	    }	
/**	        Used for serialization	    */	    public void prune()	    {	        // Cut off from parent, we must have our own class manager.	        // Can't do this in the run() command (needs to resolve stuff)	        // Should we do it by default when we create a namespace will no	        // parent of class manager?		        if ( this.classManager == null )	// XXX if we keep the createClassManager in getClassManager then we can axe	// this?	            setClassManager(	                BshClassManager.createClassManager( null/*interp*/ ) );		        setParent( null );	    }	
public void setParent( NameSpace parent )	    {	        this.parent = parent;		        // If we are disconnected from root we need to handle the def imports	        if ( parent == null )	            loadDefaultImports();	    }	
/**	        Get the specified variable in this namespace or a parent namespace.	        <p>	        Note: this method is primarily intended for use internally.  If you use	        this method outside of the bsh package you will have to use	        Primitive.unwrap() to get primitive values.	        @see Primitive#unwrap( Object )		        @return The variable value or Primitive.VOID if it is not defined.	    */	    public Object getVariable( String name )	        throws UtilEvalError	    {	        return getVariable( name, true );	    }	
/**	        Get the specified variable in this namespace.	        @param recurse If recurse is true then we recursively search through	        parent namespaces for the variable.	        <p>	        Note: this method is primarily intended for use internally.  If you use	        this method outside of the bsh package you will have to use	        Primitive.unwrap() to get primitive values.	        @see Primitive#unwrap( Object )		        @return The variable value or Primitive.VOID if it is not defined.	    */	    public Object getVariable( String name, boolean recurse )	        throws UtilEvalError	    {	        Variable var = getVariableImpl( name, recurse );	        return unwrapVariable( var );	    }	
/**	        Locate a variable and return the Variable object with optional	        recursion through parent name spaces.	        <p/>	        If this namespace is static, return only static variables.		        @return the Variable value or null if it is not defined	    */	    protected Variable getVariableImpl( String name, boolean recurse )	        throws UtilEvalError	    {	        Variable var = null;		        // Change import precedence if we are a class body/instance	        // Get imported first.	        if ( var == null && isClass )	            var = getImportedVar( name );		        if ( var == null && variables != null )	            var	= (Variable)variables.get(name);		        // Change import precedence if we are a class body/instance	        if ( var == null && !isClass )	            var = getImportedVar( name );		        // try parent	        if ( recurse && (var == null) && (parent != null) )	            var	= parent.getVariableImpl( name, recurse );		        return var;	    }	
public Variable [] getDeclaredVariables()	    {	        if ( variables == null )	            return new Variable[0];	        Variable [] vars = new Variable [ variables.size() ];	        int i=0;	        for( Enumeration e = variables.elements(); e.hasMoreElements(); )	            vars[i++] = (Variable)e.nextElement();	        return vars;	    }	
/**	        Unwrap a variable to its value.	        @return return the variable value.  A null var is mapped to	            Primitive.VOID	    */	    protected Object unwrapVariable( Variable var )	        throws UtilEvalError	    {	        return (var == null) ? Primitive.VOID :	var.getValue();	    }	
/**	        @deprecated See #setTypedVariable( String, Class, Object, Modifiers )	    */	    public void	setTypedVariable(	        String	name, Class type, Object value,	boolean	isFinal )	        throws UtilEvalError	    {	        Modifiers modifiers = new Modifiers();	        if ( isFinal )	            modifiers.addModifier( Modifiers.FIELD, "final" );	        setTypedVariable( name, type, value, modifiers );	    }	
/**	        Declare a variable in the local scope and set its initial value.	        Value may be null to indicate that we would like the default value	        for the variable type. (e.g.  0 for integer types, null for object	        types).  An existing typed variable may only be set to the same type.	        If an untyped variable of the same name exists it will be overridden	        with the new typed var.	        The set will perform a Types.getAssignableForm() on the value if	        necessary.		        <p>	        Note: this method is primarily intended for use internally.  If you use	        this method outside of the bsh package and wish to set variables with	        primitive values you will have to wrap them using bsh.Primitive.	        @see org.gjt.sp.jedit.bsh.Primitive		        @param value If value is null, you'll get the default value for the type	        @param modifiers may be null	    */	    public void	setTypedVariable(	        String	name, Class type, Object value,	Modifiers modifiers )	        throws UtilEvalError	    {	        //checkVariableModifiers( name, modifiers );		        if ( variables == null )	            variables =	new Hashtable();		        // Setting a typed variable is always a local operation.	        Variable existing = getVariableImpl( name, false/*recurse*/ );			        // Null value is just a declaration	        // Note: we might want to keep any existing value here instead of reset	    /*	    // Moved to Variable	        if ( value == null )	            value = Primitive.getDefaultValue( type );	    */		        // does the variable already exist?	        if ( existing != null )	        {	            // Is it typed?	            if ( existing.getType() != null )	            {	                // If it had a different type throw error.	                // This allows declaring the same var again, but not with	                // a different (even if assignable) type.	                if ( existing.getType() != type )	                {	                    throw new UtilEvalError( "Typed variable: "+name	                        +" was previously declared with type: "	                        + existing.getType() );	                } else	                {	                    // else set it and return	                    existing.setValue( value, Variable.DECLARATION );	                    return;	                }	            }	            // Careful here:	            // else fall through to override and install the new typed version	        }		        // Add the new typed var	        variables.put( name, new Variable( name, type, value, modifiers ) );	    }	
/**	        Note: this is primarily for internal use.	        @see Interpreter#source( String )	        @see Interpreter#eval( String )	    */	    public void	setMethod( String name, BshMethod method )	        throws UtilEvalError	    {	        //checkMethodModifiers( method );		        if ( methods == null )	            methods = new Hashtable();		        Object m = methods.get(name);		        //{{{ jEdit version: properly handle methods with same signature.	        if (m == null)	            methods.put(name, method);	        else if (m instanceof BshMethod)	        {	            // is the new method overriding the old method?	            if (Arrays.equals(((BshMethod)m).getParameterTypes(),	                              method.getParameterTypes()))	            {	                methods.put(name, method);	            }	            else	            {	                Vector v = new Vector();	                v.addElement( m );	                v.addElement( method );	                methods.put( name, v );	            }	        }	        else	        {	            Vector _methods = (Vector) m;	            for (int i = 0; i < _methods.size(); i++)	            {	                // Check whether the new method overrides some old	                // method in the list.	                BshMethod _old_m = (BshMethod) _methods.get(i);	                if (Arrays.equals(_old_m.getParameterTypes(),	                                  method.getParameterTypes()))	                {	                    _methods.remove(i);	                    break;	                }	            }	            _methods.addElement( method );	        }	        //}}}		        //{{{ Original BeanShell code	        // if ( m == null )	        // 	methods.put(name, method);	        // else	        // if ( m instanceof BshMethod ) {	        // 	Vector v = new Vector();	        // 	v.addElement( m );	        // 	v.addElement( method );	        // 	methods.put( name, v );	        // } else // Vector	        // 	((Vector)m).addElement( method );	        //}}}	    }	
/**	        @see #getMethod( String, Class [], boolean )	        @see #getMethod( String, Class [] )	    */	    public BshMethod getMethod( String name, Class [] sig )	        throws UtilEvalError	    {	        return getMethod( name, sig, false/*declaredOnly*/ );	    }	
/**	        Get the bsh method matching the specified signature declared in	        this name space or a parent.	        <p>	        Note: this method is primarily intended for use internally.  If you use	        this method outside of the bsh package you will have to be familiar	        with BeanShell's use of the Primitive wrapper class.	        @see org.gjt.sp.jedit.bsh.Primitive	        @return the BshMethod or null if not found	        @param declaredOnly if true then only methods declared directly in this	            namespace will be found and no inherited or imported methods will	            be visible.	    */	    public BshMethod getMethod(	        String name, Class [] sig, boolean declaredOnly )	        throws UtilEvalError	    {	        BshMethod method = null;		        // Change import precedence if we are a class body/instance	        // Get import first.	        if ( method == null && isClass && !declaredOnly )	            method = getImportedMethod( name, sig );		        Object m = null;	        if ( method == null && methods != null )	        {	            m = methods.get(name);		            // m contains either BshMethod or Vector of BshMethod	            if ( m != null )	            {	                // unwrap	                BshMethod [] ma;	                if ( m instanceof Vector )	                {	                    Vector vm = (Vector)m;	                    ma = new BshMethod[ vm.size() ];	                    vm.copyInto( ma );	                } else	                    ma = new BshMethod[] { (BshMethod)m };		                // Apply most specific signature matching	                Class [][] candidates = new Class[ ma.length ][];	                for( int i=0; i< ma.length; i++ )	                    candidates[i] = ma[i].getParameterTypes();		                int match =	                    Reflect.findMostSpecificSignature( sig, candidates );	                if ( match != -1 )	                    method = ma[match];	            }	        }		        if ( method == null && !isClass && !declaredOnly )	            method = getImportedMethod( name, sig );		        // try parent	        if ( !declaredOnly && (method == null) && (parent != null) )	            return parent.getMethod( name, sig );		        return method;	    }	
/**	        Import a class name.	        Subsequent imports override earlier ones	    */	    public void	importClass(String name)	    {	        if ( importedClasses == null )	            importedClasses = new Hashtable();		        importedClasses.put( Name.suffix(name, 1), name );	        nameSpaceChanged();	    }	
/**	        subsequent imports override earlier ones	    */	    public void	importPackage(String name)	    {	        if(importedPackages == null)	            importedPackages = new Vector();		        // If it exists, remove it and add it at the end (avoid memory leak)	        if ( importedPackages.contains( name ) )	            importedPackages.remove( name );		        importedPackages.addElement(name);	        nameSpaceChanged();	    }	
/**	        Import scripted or compiled BeanShell commands in the following package	        in the classpath.  You may use either "/" path or "." package notation.	        e.g. importCommands("/bsh/commands") or importCommands("bsh.commands")	        are equivalent.  If a relative path style specifier is used then it is	        made into an absolute path by prepending "/".	    */	    public void	importCommands( String name )	    {	        if ( importedCommands == null )	            importedCommands = new Vector();		        // dots to slashes	        name = name.replace('.','/');	        // absolute	        if ( !name.startsWith("/") )	            name = "/"+name;	        // remove trailing (but preserve case of simple "/")	        if ( name.length() > 1 && name.endsWith("/") )	            name = name.substring( 0, name.length()-1 );		        // If it exists, remove it and add it at the end (avoid memory leak)	        if ( importedCommands.contains( name ) )	            importedCommands.remove( name );		        importedCommands.addElement(name);	        nameSpaceChanged();	    }	
/**	        A command is a scripted method or compiled command class implementing a	        specified method signature.  Commands are loaded from the classpath	        and may be imported using the importCommands() method.	        <p/>		        This method searches the imported commands packages for a script or	        command object corresponding to the name of the method.  If it is a	        script the script is sourced into this namespace and the BshMethod for	        the requested signature is returned.  If it is a compiled class the	        class is returned.  (Compiled command classes implement static invoke()	        methods).	        <p/>		        The imported packages are searched in reverse order, so that later	        imports take priority.	        Currently only the first object (script or class) with the appropriate	        name is checked.  If another, overloaded form, is located in another	        package it will not currently be found.  This could be fixed.	        <p/>		        @return a BshMethod, Class, or null if no such command is found.	        @param name is the name of the desired command method	        @param argTypes is the signature of the desired command method.	        @throws UtilEvalError if loadScriptedCommand throws UtilEvalError	            i.e. on errors loading a script that was found	    */	    // {{{ jEdit's getCommand	    public Object getCommand(	        String name, Class [] argTypes, Interpreter interpreter )	        throws UtilEvalError	    {	        if (Interpreter.DEBUG) Interpreter.debug("getCommand: "+name);	        BshClassManager bcm = interpreter.getClassManager();		        InputStream in = getCommand( name );		        if ( in != null )	            return loadScriptedCommand(	                in, name, argTypes, name, interpreter );		        /* // Chop leading "/" and change "/" to "."	        String className;	        if ( path.equals("/") )	            className = name;	        else	            className = path.substring(1).replace('/','.') +"."+name;		        Class clas = bcm.classForName( className );	        if ( clas != null )	            return clas; */		        if ( parent != null )	            return parent.getCommand( name, argTypes, interpreter );	        else	            return null;	    }	
protected BshMethod getImportedMethod( String name, Class [] sig )	        throws UtilEvalError	    {	        // Try object imports	        if ( importedObjects != null )	        for(int i=0; i<importedObjects.size(); i++)	        {	            Object object = importedObjects.elementAt(i);	            Class clas = object.getClass();	            Method method = Reflect.resolveJavaMethod(	                getClassManager(), clas, name, sig, false/*onlyStatic*/ );	            if ( method != null )	                return new BshMethod( method, object );	        }		        // Try static imports	        if ( importedStatic!= null )	        for(int i=0; i<importedStatic.size(); i++)	        {	            Class clas = (Class)importedStatic.elementAt(i);	            Method method = Reflect.resolveJavaMethod(	                getClassManager(), clas, name, sig, true/*onlyStatic*/ );	            if ( method != null )	                return new BshMethod( method, null/*object*/ );	        }		        return null;	    }	
protected Variable getImportedVar( String name )	        throws UtilEvalError	    {	        // Try object imports	        if ( importedObjects != null )	        for(int i=0; i<importedObjects.size(); i++)	        {	            Object object = importedObjects.elementAt(i);	            Class clas = object.getClass();	            Field field = Reflect.resolveJavaField(	                clas, name, false/*onlyStatic*/ );	            if ( field != null )	                return new Variable(	                    name, field.getType(), new LHS( object, field ) );	        }		        // Try static imports	        if ( importedStatic!= null )	        for(int i=0; i<importedStatic.size(); i++)	        {	            Class clas = (Class)importedStatic.elementAt(i);	            Field field = Reflect.resolveJavaField(	                clas, name, true/*onlyStatic*/ );	            if ( field != null )	                return new Variable( name, field.getType(), new LHS( field ) );	        }		        return null;	    }	
/**	        Load a command script from the input stream and find the BshMethod in	        the target namespace.	        @throws UtilEvalError on error in parsing the script or if the the	            method is not found after parsing the script.	    */	    /*	        If we want to support multiple commands in the command path we need to	        change this to not throw the exception.	    */	    private BshMethod loadScriptedCommand(	        InputStream in, String name, Class [] argTypes, String resourcePath,	        Interpreter interpreter )	        throws UtilEvalError	    {	        try {	            interpreter.eval(	                new InputStreamReader(in), this, resourcePath );	        } catch ( EvalError e ) {	        /*	            Here we catch any EvalError from the interpreter because we are	            using it as a tool to load the command, not as part of the	            execution path.	        */	            Interpreter.debug( e.toString() );	            throw new UtilEvalError(	                "Error loading script: "+ e.getMessage());	        }		        // Look for the loaded command	        BshMethod meth = getMethod( name, argTypes );	        /*	        if ( meth == null )	            throw new UtilEvalError("Loaded resource: " + resourcePath +	                "had an error or did not contain the correct method" );	        */		        return meth;	    }	
/**	        Helper that caches class.	    */	    void cacheClass( String name, Class c ) {	        if ( classCache == null ) {	            classCache = new Hashtable();	            //cacheCount++; // debug	        }		        classCache.put(name, c);	    }	
/**	        Load a class through this namespace taking into account imports.	        The class search will proceed through the parent namespaces if	        necessary.		        @return null if not found.	    */	    public Class getClass( String name )	        throws UtilEvalError	    {	        Class c = getClassImpl(name);	        if ( c != null )	            return c;	        else	            // implement the recursion for getClassImpl()	            if ( parent != null )	                return parent.getClass( name );	            else	                return null;	    }	
/**	        Implementation of getClass()		        Load a class through this namespace taking into account imports.	        <p>		        Check the cache first.  If an unqualified name look for imported	        class or package.  Else try to load absolute name.	        <p>		        This method implements caching of unqualified names (normally imports).	        Qualified names are cached by the BshClassManager.	        Unqualified absolute class names (e.g. unpackaged Foo) are cached too	        so that we don't go searching through the imports for them each time.		        @return null if not found.	    */	    private Class getClassImpl( String name )	        throws UtilEvalError	    {	        Class c = null;		        // Check the cache	        if (classCache != null) {	            c =	(Class)classCache.get(name);		            if ( c != null )	                return c;	        }		        // Unqualified (simple, non-compound) name	        boolean unqualifiedName = !Name.isCompound(name);		        // Unqualified name check imported	        if ( unqualifiedName )	        {	            // Try imported class	            if ( c == null )	                c = getImportedClassImpl( name );		            // if found as imported also cache it	            if ( c != null ) {	                cacheClass( name, c );	                return c;	            }	        }		        // Try absolute	        c = classForName( name );	        if ( c != null ) {	            // Cache unqualified names to prevent import check again	            if ( unqualifiedName )	                cacheClass( name, c );	            return c;	        }		        // Not found	        if ( Interpreter.DEBUG )	            Interpreter.debug("getClass(): " + name	+ " not	found in "+this);	        return null;	    }	
/**	        Try to make the name into an imported class.	        This method takes into account only imports (class or package)	        found directly in this NameSpace (no parent chain).	    */	    private Class getImportedClassImpl( String name )	        throws UtilEvalError	    {	        // Try explicitly imported class, e.g. import foo.Bar;	        String fullname = null;	        if ( importedClasses != null )	            fullname = (String)importedClasses.get(name);		        // not sure if we should really recurse here for explicitly imported	        // class in parent...		        if ( fullname != null )	        {	            /*	                Found the full name in imported classes.	            */	            // Try to make the full imported name	            Class clas=classForName(fullname);		            // Handle imported inner class case	            if ( clas == null )	            {	                // Imported full name wasn't found as an absolute class	                // If it is compound, try to resolve to an inner class.	                // (maybe this should happen in the BshClassManager?)		                if ( Name.isCompound( fullname ) )	                    try {	                        clas = getNameResolver( fullname ).toClass();	                    } catch ( ClassNotFoundException e ) { /* not a class */ }	                else	                    if ( Interpreter.DEBUG ) Interpreter.debug(	                        "imported unpackaged name not found:" +fullname);		                // If found cache the full name in the BshClassManager	                if ( clas != null ) {	                    // (should we cache info in not a class case too?)	                    getClassManager().cacheClassInfo( fullname, clas );	                    return clas;	                }	            } else	                return clas;		            // It was explicitly imported, but we don't know what it is.	            // should we throw an error here??	            return null;	        }		        /*	            Try imported packages, e.g. "import foo.bar.*;"	            in reverse order of import...	            (give later imports precedence...)	        */	        if ( importedPackages != null )	            for(int i=importedPackages.size()-1; i>=0; i--)	            {	                String s = ((String)importedPackages.elementAt(i)) + "." + name;	                Class c=classForName(s);	                if ( c != null )	                    return c;	            }		        BshClassManager bcm = getClassManager();	        /*	            Try super import if available	            Note: we do this last to allow explicitly imported classes	            and packages to take priority.  This method will also throw an	            error indicating ambiguity if it exists...	        */	        if ( bcm.hasSuperImport() )	        {	            String s = bcm.getClassNameByUnqName( name );	            if ( s != null )	                return classForName( s );	        }		        return null;	    }	
private Class classForName( String name )	    {	        return getClassManager().classForName( name );	    }	
/**	        Implements NameSource	        @return all variable and method names in this and all parent	        namespaces	    */	    public String [] getAllNames()	    {	        Vector vec = new Vector();	        getAllNamesAux( vec );	        String [] names = new String [ vec.size() ];	        vec.copyInto( names );	        return names;	    }	
/**	        Helper for implementing NameSource	    */	    protected void getAllNamesAux( Vector vec )	    {	        Enumeration varNames = variables.keys();	        while( varNames.hasMoreElements() )	            vec.addElement( varNames.nextElement() );		        Enumeration methodNames = methods.keys();	        while( methodNames.hasMoreElements() )	            vec.addElement( methodNames.nextElement() );		        if ( parent != null )	            parent.getAllNamesAux( vec );	    }	
/**	        Implements NameSource	        Add a listener who is notified upon changes to names in this space.	    */	    public void addNameSourceListener( NameSource.Listener listener ) {	        if ( nameSourceListeners == null )	            nameSourceListeners = new Vector();	        nameSourceListeners.addElement( listener );	    }	
/**	        Perform "import *;" causing the entire classpath to be mapped.	        This can take a while.	    */	    public void doSuperImport()	        throws UtilEvalError	    {	        getClassManager().doSuperImport();	    }	
public String toString() {	        return "NameSpace: "	            + ( nsName==null	                ? super.toString()	                : nsName + " (" + super.toString() +")" )	            + ( isClass ? " (isClass) " : "" )	            + ( isMethod ? " (method) " : "" )	            + ( classStatic != null ? " (class static) " : "" )	            + ( classInstance != null ? " (class instance) " : "" );	    }	
private synchronized void writeObject(java.io.ObjectOutputStream s)	        throws IOException	    {	        // clear name resolvers... don't know if this is necessary.	        names = null;		        s.defaultWriteObject();	    }	
/**	        Invoke a method in this namespace with the specified args and	        interpreter reference.  No caller information or call stack is	        required.  The method will appear as if called externally from Java.	        <p>		        @see org.gjt.sp.jedit.bsh.This#invokeMethod(String methodName, Object [] args, Interpreter interpreter,	CallStack callstack, SimpleNode callerInfo, boolean ) invokeMethod	    */	    public Object invokeMethod(	        String methodName, Object [] args, Interpreter interpreter )	        throws EvalError	    {	        return invokeMethod(	            methodName, args, interpreter, null, null );	    }	
/**	        This method simply delegates to This.invokeMethod();	        <p>	        @see org.gjt.sp.jedit.bsh.This#invokeMethod(String methodName, Object [] args, Interpreter interpreter, CallStack callstack, SimpleNode callerInfo, boolean declaredOnly ) invokeMethod	    */	    public Object invokeMethod(	        String methodName, Object [] args, Interpreter interpreter,	        CallStack callstack, SimpleNode callerInfo )	        throws EvalError	    {	        return getThis( interpreter ).invokeMethod(	            methodName, args, interpreter, callstack, callerInfo,	            false/*declaredOnly*/ );	    }	
/**	        Clear all cached classes and names	    */	    public void classLoaderChanged() {	        nameSpaceChanged();	    }	
/**	        Clear all cached classes and names	    */	    public void nameSpaceChanged() {	        classCache = null;	        names = null;	    }	
/**	        Import standard packages.  Currently:	        <pre>	            importClass("org.gjt.sp.jedit.bsh.EvalError");	            importClass("org.gjt.sp.jedit.bsh.Interpreter");	            importPackage("javax.swing.event");	            importPackage("javax.swing");	            importPackage("java.awt.event");	            importPackage("java.awt");	            importPackage("java.net");	            importPackage("java.util");	            importPackage("java.io");	            importPackage("java.lang");	            addCommandPath("/org/gjt/sp/jedit/bsh/commands",getClass());	        </pre>	    */	    public void loadDefaultImports()	    {	        /**	            Note: the resolver looks through these in reverse order, per	            precedence rules...  so for max efficiency put the most common	            ones later.	        */	        importClass("org.gjt.sp.jedit.bsh.EvalError");	        importClass("org.gjt.sp.jedit.bsh.Interpreter");	        importPackage("javax.swing.event");	        importPackage("javax.swing");	        importPackage("java.awt.event");	        importPackage("java.awt");	        importPackage("java.net");	        importPackage("java.util");	        importPackage("java.io");	        importPackage("java.lang");	        addCommandPath("/org/gjt/sp/jedit/bsh/commands",getClass());	    }	
/**	        This is the factory for Name objects which resolve names within	        this namespace (e.g. toObject(), toClass(), toLHS()).	        <p>		        This was intended to support name resolver caching, allowing	        Name objects to cache info about the resolution of names for	        performance reasons.  However this not proven useful yet.	        <p>		        We'll leave the caching as it will at least minimize Name object	        creation.	        <p>		        (This method would be called getName() if it weren't already used for	        the simple name of the NameSpace)	        <p>		        This method was public for a time, which was a mistake.	        Use get() instead.	    */	    Name getNameResolver( String ambigname )	    {	        if ( names == null )	            names = new Hashtable();		        Name name = (Name)names.get( ambigname );		        if ( name == null ) {	            name = new Name( this, ambigname );	            names.put( ambigname, name );	        }		        return name;	    }	
public int getInvocationLine() {	        SimpleNode node = getNode();	        if ( node != null )	            return node.getLineNumber();	        else	            return -1;	    }	
public String getInvocationText() {	        SimpleNode node = getNode();	        if ( node != null )	            return node.getText();	        else	            return "<invoked from Java code>";	    }	
/**	        This is a helper method for working inside of bsh scripts and commands.	        In that context it is impossible to see a ClassIdentifier object	        for what it is.  Attempting to access a method on a ClassIdentifier	        will look like a static method invocation.		        This method is in NameSpace for convenience (you don't have to import	        bsh.ClassIdentifier to use it );	    */	    public static Class identifierToClass( ClassIdentifier ci )	    {	        return ci.getTargetClass();	    }	
/**	        Clear all variables, methods, and imports from this namespace.	        If this namespace is the root, it will be reset to the default	        imports.	        @see #loadDefaultImports()	    */	    public void clear()	    {	        variables = null;	        methods = null;	        importedClasses = null;	        importedPackages = null;	        importedCommands = null;	        importedObjects = null;	        if ( parent == null )	            loadDefaultImports();	        classCache = null;	        names = null;	    }	
/**	        Import a compiled Java object's methods and variables into this	        namespace.  When no scripted method / command or variable is found	        locally in this namespace method / fields of the object will be	        checked.  Objects are checked in the order of import with later imports	        taking precedence.	        <p/>	    */	    /*	        Note: this impor pattern is becoming common... could factor it out into	        an importedObject Vector class.	    */	    public void importObject( Object obj )	    {	        if ( importedObjects == null )	            importedObjects = new Vector();		        // If it exists, remove it and add it at the end (avoid memory leak)	        if ( importedObjects.contains( obj ) )	            importedObjects.remove( obj );		        importedObjects.addElement( obj );	        nameSpaceChanged();		    }	
/**	    */	    public void importStatic( Class clas )	    {	        if ( importedStatic == null )	            importedStatic = new Vector();		        // If it exists, remove it and add it at the end (avoid memory leak)	        if ( importedStatic.contains( clas ) )	            importedStatic.remove( clas );		        importedStatic.addElement( clas );	        nameSpaceChanged();	    }	
/**	        Set the package name for classes defined in this namespace.	        Subsequent sets override the package.	    */	    void setPackage( String packageName )	    {	        this.packageName = packageName;	    }	
String getPackage()	    {	        if ( packageName != null )	            return packageName;		        if ( parent != null )	            return parent.getPackage();		        return null;	    }	
public void setVariable(String name, Object value) throws UtilEvalError	        {	                setVariable(name,value,false);	        }	
/**	        Adds a URL to the command path.	    */	    public void addCommandPath(String path, Class clas)	    {	        if(importedCommands == null)	            importedCommands = new Vector();		        if(!path.endsWith("/"))	            path += '/';	        importedCommands.addElement(new CommandPathEntry(path,clas));	    }	
/**	        Remove a URLfrom the command path.	    */	    public void removeCommandPath(String path, Class clas)	    {	        if(importedCommands == null)	            return;		        for(int i = 0; i < importedCommands.size(); i++)	        {	            CommandPathEntry entry = (CommandPathEntry)importedCommands	                .elementAt(i);	            if(entry.path.equals(path) && entry.clas == clas)	            {	                importedCommands.removeElementAt(i);	                return;	            }	        }	    }	
/**	        Looks up a command.	    */	    public InputStream getCommand(String name)	    {	        if(importedCommands != null)	        {	            String extName = name + ".bsh";	            for(int i = importedCommands.size() - 1; i >= 0; i--)	            {	                CommandPathEntry entry = (CommandPathEntry)importedCommands	                    .elementAt(i);	                InputStream in = entry.clas.getResourceAsStream(entry.path + extName);	                if(in != null)	                    return in;	            }	        }		        if(parent == null)	            return null;	        else	            return parent.getCommand(name);	    }	
CommandPathEntry(String path, Class clas)	        {	            this.path = path;	            this.clas = clas;	        }	
public NumericTextField(String text)		{			this(text, false);		}	
public NumericTextField(String text, boolean positiveOnly)		{			super(text);			this.positiveOnly = positiveOnly;		}	
@Override		protected void processKeyEvent(KeyEvent e)		{			if (e.getID() == KeyEvent.KEY_TYPED)			{				if (!Character.isDigit(e.getKeyChar()) && !(!positiveOnly && e.getKeyChar() == '-'))				{					e.consume();				}			}			super.processKeyEvent(e);		}	
public OpenBracketIndentRule(char openBracket, boolean aligned)		{			super(openBracket,				TextUtilities.getComplementaryBracket(openBracket,null));			this.aligned = aligned;		}	
public void apply(JEditBuffer buffer, int thisLineIndex,			int prevLineIndex, int prevPrevLineIndex,			List<IndentAction> indentActions)		{			int prevOpenBracketCount = getOpenBracketCount(buffer,prevLineIndex);			if(prevOpenBracketCount != 0)			{				handleCollapse(indentActions, true);				boolean multiple = buffer.getBooleanProperty(					"multipleBracketIndent");				IndentAction increase = new IndentAction.Increase(					multiple ? prevOpenBracketCount : 1);				indentActions.add(increase);			}			else if(getOpenBracketCount(buffer,thisLineIndex) != 0)			{				handleCollapse(indentActions, false);			}		}	
private int getOpenBracketCount(JEditBuffer buffer, int line)		{			if(line == -1)				return 0;			else				return getBrackets(buffer, line).openCount;		}	
private static void handleCollapse(List<IndentAction> indentActions,						   boolean delPrevPrevCollapse)		{			if (indentActions.contains(IndentAction.PrevCollapse))			{				indentActions.clear();				return;			}				if (delPrevPrevCollapse && indentActions.contains(IndentAction.PrevPrevCollapse))			{				indentActions.clear();				return;			}		}	
/**		 * Returns the bounds of the default screen.		 */		public static Rectangle getScreenBounds()		{			int screenX = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();			int screenY = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();			int x, y, w, h;						if (isMacOS())			{				x = 0;				y = 22;				w = screenX;				h = screenY - y - 4;//shadow size			}			else if (isWindows())			{				x = -4;				y = -4;				w = screenX - 2*x;				h = screenY - 2*y;			}			else			{				x = 0;				y = 0;				w = screenX;				h = screenY;			}						return new Rectangle(x,y,w,h);		}	
/**		 * Returns the bounds of the (virtual) screen that the window should be in		 * @param window The bounds of the window to get the screen for		 */		public static Rectangle getScreenBounds(Rectangle window)		{			GraphicsDevice[] gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();			Set<GraphicsConfiguration> intersects = new HashSet<GraphicsConfiguration>();				// Get available screens			// O(n^3), this is nasty, but since we aren't dealling with			// many items it should be fine			for (int i=0; i < gd.length; i++)			{				GraphicsConfiguration gc = gd[i]					.getDefaultConfiguration();				// Don't add duplicates				if (window.intersects(gc.getBounds()))				{					if (!intersects.contains(gc))						intersects.add(gc);				}			}						GraphicsConfiguration choice = null;			if (!intersects.isEmpty())			{				// Pick screen with largest intersection				for (GraphicsConfiguration gcc : intersects)				{					if (choice == null)						choice = gcc;					else					{						Rectangle int1 = choice.getBounds().intersection(window);						Rectangle int2 = gcc.getBounds().intersection(window);						int area1 = int1.width * int1.height;						int area2 = int2.width * int2.height;						if (area2 > area1)							choice = gcc;					}				}			}			else				choice = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();						// Make adjustments for some OS's			int screenX = choice.getBounds().x;			int screenY = choice.getBounds().y;			int screenW = choice.getBounds().width;			int screenH = choice.getBounds().height;			int x, y, w, h;						if (isMacOS())			{				x = screenX;				y = screenY + 22;				w = screenW;				h = screenH - y - 4;//shadow size			}			else			{				x = screenX;				y = screenY;				w = screenW;				h = screenH;			}						// Yay, we're finally there			return new Rectangle(x,y,w,h);		}	
/**		 * Returns if we're running Windows 95/98/ME/NT/2000/XP, or OS/2.		 */		public static boolean isDOSDerived()		{			return isWindows() || isOS2();		}	
/**		 * Returns if we're running Windows 95/98/ME/NT/2000/XP.		 */		public static boolean isWindows()		{			return os == WINDOWS_9x || os == WINDOWS_NT;		}	
/**		 * Returns if we're running Windows 95/98/ME.		 */		public static boolean isWindows9x()		{			return os == WINDOWS_9x;		}	
/**		 * Returns if we're running Windows NT/2000/XP.		 */		public static boolean isWindowsNT()		{			return os == WINDOWS_NT;		}	
/**		 * Returns if we're running OS/2.		 */		public static boolean isOS2()		{			return os == OS2;		}	
/**		 * Returns if we're running Unix (this includes MacOS X).		 */		public static boolean isUnix()		{			return os == UNIX || os == MAC_OS_X;		}	
/**		 * Returns if we're running MacOS X.		 */		public static boolean isMacOS()		{			return os == MAC_OS_X;		}	
/**		 * Returns if this OS is likely to be using X11 as the graphics		 * system.		 * @since jEdit 4.2pre3		 */		public static boolean isX11()		{			return os == UNIX;		}	
/**		 * Returns if we're running VMS.		 */		public static boolean isVMS()		{			return os == VMS;		}	
/**		* Returns if we're running MacOS X and using the native look and feel.		*/		public static boolean isMacOSLF()		{			return isMacOS() && UIManager.getLookAndFeel().isNativeLookAndFeel();		}	
/**		 * Returns whether the screen menu bar on Mac OS X is in use.		 * @since jEdit 4.2pre1		*/		public static boolean hasScreenMenuBar()		{			if(!isMacOS())				return false;			else if(hasScreenMenuBar == -1)			{				String result = System.getProperty("apple.laf.useScreenMenuBar");				if (result == null)					result = System.getProperty("com.apple.macos.useScreenMenuBar");				hasScreenMenuBar = "true".equals(result) ? 1 : 0;			}				return hasScreenMenuBar == 1;		}	
/**		 * Returns if Java 2 version 1.4, or Java 2 version 1.5 is in use.		 */		@Deprecated		public static boolean hasJava14()		{			// jEdit 4.3 requires Java 1.4 or later. However, this method exists			// for two reasons. Compatibility with plugins for jEdit 4.2, and			// in case somebody wants to borrow this class for their app.			return java14;		}	
/**		 * Returns if Java 2 version 1.5 is in use.		 */		@Deprecated		public static boolean hasJava15()		{			return java15;		}	
/**		 * Returns if Java 2 version 1.6 is in use.		 * @since jEdit 4.3pre17		 */		public static boolean hasJava16()		{			return java16;		}	
/**		 * @since jEdit 4.3pre2		 */		public static boolean isCaseInsensitiveFS()		{			return isDOSDerived() || isMacOS();		}	
/**		 * Creates an option group.		 * @param name The internal name of the option group, used to key a		 * property <code>options.<i>name</i>.label</code> which is the		 * label displayed in the options dialog.		 * @see jEdit#getProperty(String)		 */		public OptionGroup(String name)		{			this.name = name;			label = jEdit.getProperty("options." + name + ".label");			members = new Vector<Object>();		}	
/**		 * Creates an option group.		 * @param label The label		 * @param options A whitespace-separated list of option pane names		 * @since jEdit 4.2pre2		 */		public OptionGroup(String name, String label, String options)		{			this.name = name;			this.label = label;			members = new Vector<Object>();				StringTokenizer st = new StringTokenizer(options);			while(st.hasMoreTokens())			{				String pane = st.nextToken();				addOptionPane(pane);			}		}	
public String getName()		{			return name;		}	
/**		 * Returns the option group's human-readable label.		 * @since jEdit 4.2pre1		 */		public String getLabel()		{			return label;		}	
public void addOptionGroup(OptionGroup group)		{			insertionSort(group.getLabel(),group);		}	
public void addOptionPane(OptionPane pane)		{			String label = jEdit.getProperty("options."				+ pane.getName() + ".label","NO LABEL PROPERTY: "				+ pane.getName());				insertionSort(label,pane);		}	
public void addOptionPane(String pane)		{			String label = jEdit.getProperty("options."				+ pane + ".label","NO LABEL PROPERTY: "				+ pane);				insertionSort(label,pane);		}	
public Enumeration<Object> getMembers()		{			return members.elements();		}	
public Object getMember(int index)		{			return (index >= 0 && index < members.size())				? members.elementAt(index) : null;		}	
public int getMemberIndex(Object member)		{			return members.indexOf(member);		}	
public int getMemberCount()		{			return members.size();		}	
/**		 * Sets if the members of this group should be sorted.		 * @since jEdit 4.2pre3		 */		public void setSort(boolean sort)		{			this.sort = sort;		}	
private void insertionSort(String newLabel, Object newObj)		{			if(sort)			{				for(int i = 0; i < members.size(); i++)				{					Object obj = members.elementAt(i);					String label;					if(obj instanceof OptionPane)					{						String name = ((OptionPane)obj).getName();						label = jEdit.getProperty("options."							+ name + ".label","NO LABEL PROPERTY: "							+ name);					}					else if(obj instanceof String)					{						label = jEdit.getProperty("options."							+ obj + ".label","NO LABEL PROPERTY: "							+ obj);					}					else if(obj instanceof OptionGroup)						label = ((OptionGroup)obj).getLabel();					else						throw new InternalError();						if(newLabel.compareToIgnoreCase(label) < 0)					{						members.insertElementAt(newObj,i);						return;					}				}			}				members.addElement(newObj);		}	
/**		 * @param frame - the parent frame for dialogs created		 * @param name the name of an option pane - it must have a .title and .code		 *  		property defined in order to instantiate.		 * @param pane the initial pane to show when this is created.		 */		protected OptionsDialog(Frame frame, String name, String pane)		{			super(frame, jEdit.getProperty(name + ".title"), true);			init(name,pane);		}	
protected OptionsDialog(Dialog dialog, String name, String pane)		{			super(dialog, jEdit.getProperty(name + ".title"), true);			init(name,pane);		}	
public void addOptionGroup(OptionGroup group)		{			getDefaultGroup().addOptionGroup(group);		}	
public void addOptionPane(OptionPane pane)		{			getDefaultGroup().addOptionPane(pane);		}	
public void ok()		{			if(currentPane != null)				jEdit.setProperty(name + ".last",currentPane.getName());			ok(true);		}	
public void cancel()		{			if(currentPane != null)				jEdit.setProperty(name + ".last",currentPane.getName());			dispose();		}	
public void ok(boolean dispose)		{			OptionTreeModel m = (OptionTreeModel) paneTree				.getModel();			save(m.getRoot());				/* This will fire the PROPERTIES_CHANGED event */			jEdit.propertiesChanged();				// Save settings to disk			jEdit.saveSettings();				// get rid of this dialog if necessary			if(dispose)				dispose();		}	
public void dispose()		{			GUIUtilities.saveGeometry(this,name);			jEdit.setIntegerProperty(name + ".splitter",splitter.getDividerLocation());			super.dispose();		}	
public void actionPerformed(ActionEvent evt)		{			Object source = evt.getSource();				if(source == ok)			{				ok();			}			else if(source == cancel)			{				cancel();			}			else if(source == apply)			{				ok(false);			}		}	
public void valueChanged(TreeSelectionEvent evt)		{			TreePath path = evt.getPath();				if(path == null)				return;				Object lastPathComponent = path.getLastPathComponent();			if(!(lastPathComponent instanceof String				|| lastPathComponent instanceof OptionPane))			{				return;			}				Object[] nodes = path.getPath();				StringBuilder buf = new StringBuilder();				OptionPane optionPane = null;				int lastIdx = nodes.length - 1;				for (int i = paneTree.isRootVisible() ? 0 : 1;				i <= lastIdx; i++)			{				String label;				Object node = nodes[i];				if (node instanceof OptionPane)				{					optionPane = (OptionPane)node;					label = jEdit.getProperty("options."						+ optionPane.getName()						+ ".label");				}				else if (node instanceof OptionGroup)				{					label = ((OptionGroup)node).getLabel();				}				else if (node instanceof String)				{					label = jEdit.getProperty("options."						+ node + ".label");					optionPane = deferredOptionPanes.get(node);					if(optionPane == null)					{						String propName = "options." + node + ".code";						String code = jEdit.getProperty(propName);						if(code != null)						{							optionPane = (OptionPane)								BeanShell.eval(								jEdit.getActiveView(),								BeanShell.getNameSpace(),								code							);								if(optionPane != null)							{								deferredOptionPanes.put(									node,optionPane);							}							else								continue;						}						else						{							Log.log(Log.ERROR,this,propName								+ " not defined");							continue;						}					}				}				else				{					continue;				}					buf.append(label);					if (i != lastIdx)					buf.append(": ");			}				if(optionPane == null)				return;				setTitle(jEdit.getProperty("options.title-template",				new Object[] { jEdit.getProperty(name + ".title"),				buf.toString() }));				try			{				optionPane.init();			}			catch(Throwable t)			{				Log.log(Log.ERROR,this,"Error initializing options:");				Log.log(Log.ERROR,this,t);			}				currentPane = optionPane;			stage.setViewportView(currentPane.getComponent());			stage.revalidate();			stage.repaint();				if(!isShowing())				addNotify();				updateSize();				currentPane = optionPane;		}	
/**		 * @param name the name of this pane		 * @param pane - a sub-pane name to select (?)		 * Could someone please write better docs for this function?		 * Creates buttons, adds listeners, and makes the pane visible.		 * This method is called automatically from the constructor,		 *		 * and also calls init on each of the optionPanes?		 *		 * @since jEdit 4.3pre9 (was private before)		 */		protected void init(String name, String pane)		{			this.name = name;				deferredOptionPanes = new HashMap<Object, OptionPane>();				JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);			stage = new JScrollPane();				paneTree = new JTree(createOptionTreeModel());			paneTree.setVisibleRowCount(1);			paneTree.setCellRenderer(new PaneNameRenderer());				// looks bad with the OS X L&F, apparently...			if(!OperatingSystem.isMacOSLF())				paneTree.putClientProperty("JTree.lineStyle", "Angled");				paneTree.setShowsRootHandles(true);			paneTree.setRootVisible(false);				JScrollPane scroller = new JScrollPane(paneTree,							       ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,							       ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);			scroller.setMinimumSize(new Dimension(100, 0));			splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,						  jEdit.getBooleanProperty("appearance.continuousLayout"),						  scroller,						  stage);			content.add(splitter, BorderLayout.CENTER);				Box buttons = new Box(BoxLayout.X_AXIS);			buttons.add(Box.createGlue());				ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(this);			buttons.add(ok);			buttons.add(Box.createHorizontalStrut(6));			getRootPane().setDefaultButton(ok);			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(this);			buttons.add(cancel);			buttons.add(Box.createHorizontalStrut(6));			apply = new JButton(jEdit.getProperty("common.apply"));			apply.addActionListener(this);			buttons.add(apply);				buttons.add(Box.createGlue());				content.add(buttons, BorderLayout.SOUTH);				// register the Options dialog as a TreeSelectionListener.			// this is done before the initial selection to ensure that the			// first selected OptionPane is displayed on startup.			paneTree.getSelectionModel().addTreeSelectionListener(this);				OptionGroup rootNode = (OptionGroup)paneTree.getModel().getRoot();			for(int i = 0; i < rootNode.getMemberCount(); i++)			{				paneTree.expandPath(new TreePath(				new Object[] { rootNode, rootNode.getMember(i) }));			}				// returns false if no such pane exists; calling with null			// param selects first option pane found			if(!selectPane(rootNode, pane))				selectPane(rootNode,null);				splitter.setDividerLocation(paneTree.getPreferredSize().width				+ scroller.getVerticalScrollBar().getPreferredSize()				.width);				GUIUtilities.loadGeometry(this,name);			int dividerLocation = jEdit.getIntegerProperty(name + ".splitter",-1);			if(dividerLocation != -1)				splitter.setDividerLocation(dividerLocation);				// in case saved geometry is too small			updateSize();				setVisible(true);		}	
private boolean selectPane(OptionGroup node, String name)		{			return selectPane(node,name,new ArrayList<Object>());		}	
private boolean selectPane(OptionGroup node, String name, List<Object> path)		{			path.add(node);				Enumeration<Object> e = node.getMembers();			while(e.hasMoreElements())			{				Object obj = e.nextElement();				if(obj instanceof OptionGroup)				{					OptionGroup grp = (OptionGroup)obj;					if(grp.getName().equals(name))					{						path.add(grp);						path.add(grp.getMember(0));						TreePath treePath = new TreePath(							path.toArray());						paneTree.scrollPathToVisible(treePath);						paneTree.setSelectionPath(treePath);						return true;					}					else if(selectPane((OptionGroup)obj,name,path))						return true;				}				else if(obj instanceof OptionPane)				{					OptionPane pane = (OptionPane)obj;					if(pane.getName().equals(name)						|| name == null)					{						path.add(pane);						TreePath treePath = new TreePath(							path.toArray());						paneTree.scrollPathToVisible(treePath);						paneTree.setSelectionPath(treePath);						return true;					}				}				else if(obj instanceof String)				{					String pane = (String)obj;					if(pane.equals(name)						|| name == null)					{						path.add(pane);						TreePath treePath = new TreePath(							path.toArray());						paneTree.scrollPathToVisible(treePath);						paneTree.setSelectionPath(treePath);						return true;					}				}			}				path.remove(node);				return false;		}	
private void save(Object obj)		{			if(obj instanceof OptionGroup)			{				OptionGroup grp = (OptionGroup)obj;				Enumeration<Object> members = grp.getMembers();				while(members.hasMoreElements())				{					save(members.nextElement());				}			}			else if(obj instanceof OptionPane)			{				try				{					((OptionPane)obj).save();				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Error saving options:");					Log.log(Log.ERROR,this,t);				}			}			else if(obj instanceof String)			{				save(deferredOptionPanes.get(obj));			}		}	
private void updateSize()		{			Dimension currentSize = getSize();			Dimension requestedSize = getPreferredSize();			Dimension newSize = new Dimension(				Math.max(currentSize.width,requestedSize.width),				Math.max(currentSize.height,requestedSize.height)			);			if(newSize.width < 300)				newSize.width = 300;			if(newSize.height < 200)				newSize.height = 200;			setSize(newSize);			validate();		}	
public PaneNameRenderer()			{				paneFont = UIManager.getFont("Tree.font");				if(paneFont == null)					paneFont = jEdit.getFontProperty("metal.secondary.font");				groupFont = paneFont.deriveFont(Font.BOLD);			}	
public Component getTreeCellRendererComponent(JTree tree,				Object value, boolean selected, boolean expanded,				boolean leaf, int row, boolean hasFocus)			{				super.getTreeCellRendererComponent(tree,value,					selected,expanded,leaf,row,hasFocus);					String name = null;					if (value instanceof OptionGroup)				{					setText(((OptionGroup)value).getLabel());					setFont(groupFont);				}				else if (value instanceof OptionPane)				{					name = ((OptionPane)value).getName();					setFont(paneFont);				}				else if (value instanceof String)				{					name = (String) value;					setFont(paneFont);				}					if (name != null)				{					String label = jEdit.getProperty("options." +						name + ".label");						if (label == null)					{						setText("NO LABEL PROPERTY: " + name);					}					else					{						setText(label);					}				}					setIcon(null);					return this;			}	
public OptionTreeModel()			{				this(new OptionGroup(null));			}	
public OptionTreeModel(OptionGroup root)			{				this.root = root;			}	
public void addTreeModelListener(TreeModelListener l)			{				listenerList.add(TreeModelListener.class, l);			}	
public void removeTreeModelListener(TreeModelListener l)			{				listenerList.remove(TreeModelListener.class, l);			}	
public Object getChild(Object parent, int index)			{				if (parent instanceof OptionGroup)				{					return ((OptionGroup)parent).getMember(index);				}				else				{					return null;				}			}	
public int getChildCount(Object parent)			{				if (parent instanceof OptionGroup)				{					return ((OptionGroup)parent).getMemberCount();				}				else				{					return 0;				}			}	
public int getIndexOfChild(Object parent, Object child)			{				if (parent instanceof OptionGroup)				{					return ((OptionGroup)parent)						.getMemberIndex(child);				}				else				{					return -1;				}			}	
public Object getRoot()			{				return root;			}	
public boolean isLeaf(Object node)			{				return !(node instanceof OptionGroup);			}	
public void valueForPathChanged(TreePath path, Object newValue)			{				// this model may not be changed by the TableCellEditor			}	
protected void fireNodesChanged(Object source, Object[] path,				int[] childIndices, Object[] children)			{				Object[] listeners = listenerList.getListenerList();					TreeModelEvent modelEvent = null;				for (int i = listeners.length - 2; i >= 0; i -= 2)				{					if (listeners[i] != TreeModelListener.class)						continue;						if (modelEvent == null)					{						modelEvent = new TreeModelEvent(source,							path, childIndices, children);					}						((TreeModelListener)listeners[i + 1])						.treeNodesChanged(modelEvent);				}			}	
protected void fireNodesInserted(Object source, Object[] path,				int[] childIndices, Object[] children)			{				Object[] listeners = listenerList.getListenerList();					TreeModelEvent modelEvent = null;				for (int i = listeners.length - 2; i >= 0; i -= 2)				{					if (listeners[i] != TreeModelListener.class)						continue;						if (modelEvent == null)					{						modelEvent = new TreeModelEvent(source,							path, childIndices, children);					}						((TreeModelListener)listeners[i + 1])						.treeNodesInserted(modelEvent);				}			}	
protected void fireNodesRemoved(Object source, Object[] path,				int[] childIndices, Object[] children)			{				Object[] listeners = listenerList.getListenerList();					TreeModelEvent modelEvent = null;				for (int i = listeners.length - 2; i >= 0; i -= 2)				{					if (listeners[i] != TreeModelListener.class)						continue;						if (modelEvent == null)					{						modelEvent = new TreeModelEvent(source,							path, childIndices, children);					}						((TreeModelListener)listeners[i + 1])						.treeNodesRemoved(modelEvent);				}			}	
protected void fireTreeStructureChanged(Object source,				Object[] path, int[] childIndices, Object[] children)			{				Object[] listeners = listenerList.getListenerList();					TreeModelEvent modelEvent = null;				for (int i = listeners.length - 2; i >= 0; i -= 2)				{					if (listeners[i] != TreeModelListener.class)						continue;						if (modelEvent == null)					{						modelEvent = new TreeModelEvent(source,							path, childIndices, children);					}						((TreeModelListener)listeners[i + 1])						.treeStructureChanged(modelEvent);				}			}	
public Widget getWidget(View view)		{			Widget overwrite = new OverwriteWidget(view);			return overwrite;		}	
OverwriteWidget(final View view)			{				overwrite = new ToolTipLabel();				overwrite.setHorizontalAlignment(SwingConstants.CENTER);				overwrite.setToolTipText(jEdit.getProperty("view.status.overwrite-tooltip"));				this.view = view;				overwrite.addMouseListener(new MouseAdapter()				{					@Override					public void mouseClicked(MouseEvent evt)					{						JEditTextArea textArea = view.getTextArea();						if (textArea != null)							textArea.toggleOverwriteEnabled();					}				});			}	
public JComponent getComponent()			{				return overwrite;			}	
public void update()			{				JEditTextArea textArea = view.getTextArea();				if (textArea != null)					overwrite.setText(textArea.isOverwriteEnabled()							  ? "O" : "-");			}	
public void propertiesChanged()			{				// retarded GTK look and feel!				Font font = new JLabel().getFont();				//UIManager.getFont("Label.font");				FontMetrics fm = overwrite.getFontMetrics(font);				Dimension dim = new Dimension(							      Math.max(fm.charWidth('-'),fm.charWidth('O')) + 1,							      fm.getHeight());				overwrite.setPreferredSize(dim);				overwrite.setMaximumSize(dim);			}	
public PanelWindowContainer(DockableWindowManagerImpl wm, String position,			int dimension)		{			this.wm = wm;			this.position = position;				//{{{ Button box setup			buttonPanel = new JPanel(new ButtonLayout());			buttonPanel.setBorder(new EmptyBorder(1,1,1,1));				closeBox = new JButton(GUIUtilities.loadIcon("closebox.gif"));			closeBox.setRequestFocusEnabled(false);			closeBox.setToolTipText(jEdit.getProperty("view.docking.close-tooltip"));			if(OperatingSystem.isMacOSLF())				closeBox.putClientProperty("JButton.buttonType","toolbar");				closeBox.setMargin(new Insets(0,0,0,0));				closeBox.addActionListener(new ActionHandler());				menuBtn = new JButton(GUIUtilities.loadIcon(jEdit.getProperty("dropdown-arrow.icon")));			menuBtn.setRequestFocusEnabled(false);			menuBtn.setToolTipText(jEdit.getProperty("view.docking.menu-tooltip"));			if(OperatingSystem.isMacOSLF())				menuBtn.putClientProperty("JButton.buttonType","toolbar");				menuBtn.setMargin(new Insets(0,0,0,0));				menuBtn.addMouseListener(new MenuMouseHandler());				buttonGroup = new ButtonGroup();			// JDK 1.4 workaround			buttonGroup.add(nullButton = new JToggleButton());			//}}}				dockables = new ArrayList<DockableWindowManagerImpl.Entry>();			buttons = new ArrayList<AbstractButton>();			dockablePanel = new DockablePanel(this);				this.dimension = dimension;		}	
/**		 * @since jEdit 4.3pre2		 */		public DockableWindowManagerImpl getDockableWindowManager()		{			return wm;		}	
public void register(DockableWindowManagerImpl.Entry entry)		{			dockables.add(entry);				//{{{ Create button			int rotation;			if(position.equals(DockableWindowManagerImpl.TOP)				|| position.equals(DockableWindowManagerImpl.BOTTOM))				rotation = RotatedTextIcon.NONE;			else if(position.equals(DockableWindowManagerImpl.LEFT))				rotation = RotatedTextIcon.CCW;			else if(position.equals(DockableWindowManagerImpl.RIGHT))				rotation = RotatedTextIcon.CW;			else				throw new InternalError("Invalid position: " + position);				JToggleButton button = new JToggleButton();			button.setMargin(new Insets(1,1,1,1));			button.setRequestFocusEnabled(false);			button.setIcon(new RotatedTextIcon(rotation,button.getFont(),				entry.shortTitle()));			button.setActionCommand(entry.factory.name);			button.addActionListener(new ActionHandler());			button.addMouseListener(new MenuMouseHandler());			if(OperatingSystem.isMacOSLF())				button.putClientProperty("JButton.buttonType","toolbar");			//}}}				buttonGroup.add(button);			buttons.add(button);			entry.btn = button;				wm.revalidate();		}	
public void unregister(DockableWindowManagerImpl.Entry entry)		{			if(entry.factory.name.equals(mostRecent))				mostRecent = null;				if(entry.btn != null)			{				buttonPanel.remove(entry.btn);				buttons.remove(entry.btn);				entry.btn = null;			}				dockables.remove(entry);			if(entry.win != null)				dockablePanel.remove(entry.win);				if(current == entry)			{				current = null;				show(current);			}			else			{				wm.revalidate();				dockablePanel.repaint();				buttonPanel.repaint();			}		}	
public void remove(DockableWindowManagerImpl.Entry entry)		{			if(entry.factory.name.equals(mostRecent))				mostRecent = null;				if(entry.win != null)			{				dockablePanel.remove(entry.win);				entry.win = null;			}				if(current == entry)			{				current = null;				show(current);			}			else			{				wm.revalidate();				dockablePanel.repaint();			}		}	
public void showMostRecent()		{			if(dockables.isEmpty())			{				Toolkit.getDefaultToolkit().beep();				return;			}				if(mostRecent == null)			{				mostRecent = dockables.get(0).factory.name;			}				wm.showDockableWindow(mostRecent);		}	
public void show(DockableWindowManagerImpl.Entry entry)		{			if(current == entry)			{				if(entry != null)				{					if(entry.win instanceof DefaultFocusComponent)					{						((DefaultFocusComponent)entry.win)							.focusOnDefaultComponent();					}					else					{						entry.win.requestDefaultFocus();					}				}				return;			}				if(entry != null)			{				if(current == null)				{					// we didn't have a component previously, so					// create a border					dockablePanel.setBorder(new DockBorder(position));				}					mostRecent = entry.factory.name;				this.current = entry;					if(entry.win.getParent() != dockablePanel)					dockablePanel.add(entry.factory.name,entry.win);					dockablePanel.showDockable(entry.factory.name);					entry.btn.setSelected(true);					if(entry.win instanceof DefaultFocusComponent)				{					((DefaultFocusComponent)entry.win)						.focusOnDefaultComponent();				}				else				{					entry.win.requestDefaultFocus();				}			}			else			{				if (current != null)				{										Object reason = DockableWindowUpdate.DEACTIVATED;					EditBus.send(new DockableWindowUpdate(wm, reason, current.factory.name));				}				current = null;				nullButton.setSelected(true);				// removing last component, so remove border				dockablePanel.setBorder(null);					wm.getView().getTextArea().requestFocus();			}				wm.revalidate();			dockablePanel.repaint();		}	
public boolean isVisible(DockableWindowManagerImpl.Entry entry)		{			return current == entry;		}	
/**		 * Returns the name of the dockable in this container.		 * @since jEdit 4.2pre1		 */		public String getCurrent()		{			if(current == null)				return null;			else				return current.factory.name;		}	
/**		 * Returns the width or height (depending on position) of the dockable		 * window container.		 * @since jEdit 4.2pre1		 */		public int getDimension()		{			return dimension;		}	
/**		 * @since jEdit 4.3pre2		 */		public String getPosition()		{			return position;		}	
public String[] getDockables()		{			String[] retVal = new String[dockables.size()];			for(int i = 0; i < dockables.size(); i++)			{				DockableWindowManagerImpl.Entry entry = dockables.get(i);				retVal[i] = entry.factory.name;			}			return retVal;		}	
void save()		{			jEdit.setIntegerProperty("view.dock." + position + ".dimension",				dimension);			if(current == null)				jEdit.unsetProperty("view.dock." + position + ".last");			else			{				jEdit.setProperty("view.dock." + position + ".last",					current.factory.name);			}		}	
void setDimension(int dimension)		{			if(dimension > SPLITTER_WIDTH)				this.dimension = dimension - SPLITTER_WIDTH;		}	
void sortDockables()		{			buttonPanel.removeAll();			buttonPanel.add(closeBox);			buttonPanel.add(menuBtn);			Collections.sort(buttons,new DockableWindowCompare());			for(int i = 0; i < buttons.size(); i++)			{				buttonPanel.add(buttons.get(i));			}		}	
/**		 * Returns the width or height of wrapped rows or columns.		 */		int getWrappedDimension(int dimension)		{			return ((ButtonLayout)buttonPanel.getLayout())				.getWrappedDimension(buttonPanel,dimension);		}	
public int compare(AbstractButton o1, AbstractButton o2)			{				String name1 = o1.getActionCommand();				String name2 = o2.getActionCommand();				return StandardUtilities.compareStrings(					jEdit.getProperty(name1 + ".title",""),					jEdit.getProperty(name2 + ".title",""),					true);			}	
public void actionPerformed(ActionEvent evt)			{				if(popup != null && popup.isVisible())					popup.setVisible(false);					if(evt.getSource() == closeBox)					show((DockableWindowManagerImpl.Entry)null);				else				{					if(wm.isDockableWindowVisible(evt.getActionCommand()))						show((DockableWindowManagerImpl.Entry)null);					else						wm.showDockableWindow(evt.getActionCommand());				}			}	
public void mousePressed(MouseEvent evt)			{				if(popup != null && popup.isVisible())				{					popup.setVisible(false);					return;				}					Component comp = (Component)evt.getSource();				String dockable;				if(comp instanceof JToggleButton)					dockable = ((JToggleButton)comp).getActionCommand();				else					dockable = getCurrent();					if(comp == menuBtn || GUIUtilities.isPopupTrigger(evt))				{					if(dockable == null)					{						popup = wm.createPopupMenu(PanelWindowContainer.this,null,false);					}					else					{						popup = wm.createPopupMenu(PanelWindowContainer.this,dockable,false);					}						int x, y;					boolean point;					if(comp == menuBtn)					{						x = 0;						y = menuBtn.getHeight();						point = false;					}					else					{						x = evt.getX();						y = evt.getY();						point = true;					}					GUIUtilities.showPopupMenu(popup,						comp,x,y,point);				}			}	
DockBorder(String position)			{				this.position = position;				insets = new Insets(					position.equals(DockableWindowManagerImpl.BOTTOM)						? SPLITTER_WIDTH : 0,					position.equals(DockableWindowManagerImpl.RIGHT)						? SPLITTER_WIDTH : 0,					position.equals(DockableWindowManagerImpl.TOP)						? SPLITTER_WIDTH : 0,					position.equals(DockableWindowManagerImpl.LEFT)						? SPLITTER_WIDTH : 0);			}	
public void paintBorder(Component c, Graphics g,				int x, int y, int width, int height)			{				updateColors();					if(color1 == null || color2 == null || color3 == null)					return;					if(position.equals(DockableWindowManagerImpl.BOTTOM))					paintHorizBorder(g,x,y,width);				else if(position.equals(DockableWindowManagerImpl.RIGHT))					paintVertBorder(g,x,y,height);				else if(position.equals(DockableWindowManagerImpl.TOP))				{					paintHorizBorder(g,x,y + height						- SPLITTER_WIDTH,width);				}				else if(position.equals(DockableWindowManagerImpl.LEFT))				{					paintVertBorder(g,x + width						- SPLITTER_WIDTH,y,height);				}			}	
public Insets getBorderInsets(Component c)			{				return insets;			}	
public boolean isBorderOpaque()			{				return false;			}	
private void paintHorizBorder(Graphics g, int x, int y, int width)			{				g.setColor(color3);				g.fillRect(x,y,width,SPLITTER_WIDTH);					for(int i = 0; i < width / 4 - 1; i++)				{					g.setColor(color1);					g.drawLine(x + (i << 2) + 2,y + 3,						x + (i << 2) + 2,y + 3);					g.setColor(color2);					g.drawLine(x + (i << 2) + 3,y + 4,						x + (i << 2) + 3,y + 4);					g.setColor(color1);					g.drawLine(x + (i << 2) + 4,y + 5,						x + (i << 2) + 4,y + 5);					g.setColor(color2);					g.drawLine(x + (i << 2) + 5,y + 6,						x + (i << 2) + 5,y + 6);				}			}	
private void paintVertBorder(Graphics g, int x, int y, int height)			{				g.setColor(color3);				g.fillRect(x,y,SPLITTER_WIDTH,height);					for(int i = 0; i < height / 4 - 1; i++)				{					g.setColor(color1);					g.drawLine(x + 3,y + (i << 2) + 2,						x + 3,y + (i << 2) + 2);					g.setColor(color2);					g.drawLine(x + 4,y + (i << 2) + 3,						x + 4,y + (i << 2) + 3);					g.setColor(color1);					g.drawLine(x + 5,y + (i << 2) + 4,						x + 5,y + (i << 2) + 4);					g.setColor(color2);					g.drawLine(x + 6,y + (i << 2) + 5,						x + 6,y + (i << 2) + 5);				}			}	
private void updateColors()			{				if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)				{					color1 = MetalLookAndFeel.getControlHighlight();					color2 = MetalLookAndFeel.getControlDarkShadow();					color3 = MetalLookAndFeel.getControl();				}				else				{					color1 = color2 = color3 = null;				}			}	
public RotatedTextIcon(int rotate, Font font, String text)			{				this.rotate = rotate;				this.font = font;					FontRenderContext fontRenderContext					= new FontRenderContext(null,true,true);				glyphs = font.createGlyphVector(fontRenderContext,text);				width = (int)glyphs.getLogicalBounds().getWidth() + 4;				//height = (int)glyphs.getLogicalBounds().getHeight();					LineMetrics lineMetrics = font.getLineMetrics(text,fontRenderContext);				ascent = lineMetrics.getAscent();				height = (int)lineMetrics.getHeight();					renderHints = new RenderingHints(					RenderingHints.KEY_ANTIALIASING,					RenderingHints.VALUE_ANTIALIAS_ON);				renderHints.put(RenderingHints.KEY_FRACTIONALMETRICS,					RenderingHints.VALUE_FRACTIONALMETRICS_ON);				renderHints.put(RenderingHints.KEY_RENDERING,					RenderingHints.VALUE_RENDER_QUALITY);			}	
public int getIconWidth()			{				return (int)(rotate == RotatedTextIcon.CW					|| rotate == RotatedTextIcon.CCW					? height : width);			}	
public int getIconHeight()			{				return (int)(rotate == RotatedTextIcon.CW					|| rotate == RotatedTextIcon.CCW					? width : height);			}	
public void paintIcon(Component c, Graphics g, int x, int y)			{				Graphics2D g2d = (Graphics2D)g;				g2d.setFont(font);				AffineTransform oldTransform = g2d.getTransform();				RenderingHints oldHints = g2d.getRenderingHints();					g2d.setRenderingHints(renderHints);				g2d.setColor(c.getForeground());					//{{{ No rotation				if(rotate == RotatedTextIcon.NONE)				{					g2d.drawGlyphVector(glyphs,x + 2,y + ascent);				} //}}}				//{{{ Clockwise rotation				else if(rotate == RotatedTextIcon.CW)				{					AffineTransform trans = new AffineTransform();					trans.concatenate(oldTransform);					trans.translate(x,y + 2);					trans.rotate(Math.PI / 2,						height / 2, width / 2);					g2d.setTransform(trans);					g2d.drawGlyphVector(glyphs,(height - width) / 2,						(width - height) / 2						+ ascent);				} //}}}				//{{{ Counterclockwise rotation				else if(rotate == RotatedTextIcon.CCW)				{					AffineTransform trans = new AffineTransform();					trans.concatenate(oldTransform);					trans.translate(x,y - 2);					trans.rotate(Math.PI * 3 / 2,						height / 2, width / 2);					g2d.setTransform(trans);					g2d.drawGlyphVector(glyphs,(height - width) / 2,						(width - height) / 2						+ ascent);				} //}}}					g2d.setTransform(oldTransform);				g2d.setRenderingHints(oldHints);			}	
public void addLayoutComponent(String name, Component comp) {}	
public void removeLayoutComponent(Component comp) {}	
/**			 * Returns the width or height of wrapped rows or columns.			 */			int getWrappedDimension(JComponent parent, int dimension)			{				Insets insets = parent.getBorder()					.getBorderInsets(parent);					Component[] comp = parent.getComponents();				if(comp.length <= 2)					return 0;					Dimension dim = comp[2].getPreferredSize();					if(position.equals(DockableWindowManagerImpl.TOP)					|| position.equals(DockableWindowManagerImpl.BOTTOM))				{					int width = dimension - insets.right;					Dimension returnValue = preferredLayoutSizeLR(insets, comp, dim, width);					return returnValue.height;				}				else				{					Dimension returnValue = preferredLayoutSizeTB(dimension, insets, comp, dim);					return returnValue.width;				}			}	
public Dimension preferredLayoutSize(Container parent)			{				Insets insets = ((JComponent)parent).getBorder()					.getBorderInsets(parent);					Component[] comp = parent.getComponents();				if(comp.length <= 2)				{					// nothing 'cept close box					return new Dimension(0,0);				}					Dimension dim = comp[2].getPreferredSize();					if(position.equals(DockableWindowManagerImpl.TOP)					|| position.equals(DockableWindowManagerImpl.BOTTOM))				{					int width = parent.getWidth() - insets.right;					Dimension returnValue = preferredLayoutSizeLR(insets, comp, dim, width);					return returnValue;				}				else				{					Dimension returnValue = preferredLayoutSizeTB(parent.getHeight(), insets, comp, dim);					return returnValue;				}			}	
public Dimension minimumLayoutSize(Container parent)			{				return preferredLayoutSize(parent);			}	
public void layoutContainer(Container parent)			{				Insets insets = ((JComponent)parent).getBorder()					.getBorderInsets(parent);					Component[] comp = parent.getComponents();				if(comp.length <= 2)				{					for(int i = 0; i < comp.length; i++)					{						comp[i].setVisible(false);					}					return;				}					comp[0].setVisible(true);				comp[1].setVisible(true);					Dimension dim = comp[2].getPreferredSize();					if(position.equals(DockableWindowManagerImpl.TOP)					|| position.equals(DockableWindowManagerImpl.BOTTOM))				{					int width = parent.getWidth() - insets.right;					int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);					int x = (rowHeight << 1) + insets.left;					int y = insets.top;					closeBox.setBounds(insets.left,insets.top,rowHeight,rowHeight);					menuBtn.setBounds(insets.left + rowHeight,insets.top,rowHeight,rowHeight);						for(int i = 2; i < comp.length; i++)					{						int btnWidth = comp[i].getPreferredSize().width;						if(btnWidth + x > width)						{							x = insets.left;							y += rowHeight;						}						comp[i].setBounds(x,y,btnWidth,rowHeight);						x += btnWidth;					}						/* if(y + rowHeight != parent.getHeight())					{						parent.setSize(							parent.getWidth(),							y + rowHeight);						((JComponent)parent).revalidate();					} */				}				else				{					int height = parent.getHeight() - insets.bottom;					int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);					int x = insets.left;					int y = (colWidth << 1) + insets.top;					closeBox.setBounds(insets.left,insets.top,colWidth,colWidth);					menuBtn.setBounds(insets.left,insets.top + colWidth,colWidth,colWidth);						for(int i = 2; i < comp.length; i++)					{						int btnHeight = comp[i].getPreferredSize().height;						if(btnHeight + y > height)						{							x += colWidth;							y = insets.top;						}						comp[i].setBounds(x,y,colWidth,btnHeight);						y += btnHeight;					}						/* if(x + colWidth != parent.getWidth())					{						parent.setSize(x + colWidth,							parent.getHeight());						((JComponent)parent).revalidate();					} */				}			}	
private Dimension preferredLayoutSizeLR(Insets insets, Component[] comp, Dimension dim, int width)			{				int rowHeight = Math.max(dim.height,closeBox.getPreferredSize().width);				int x = (rowHeight << 1) + insets.left;				Dimension returnValue = new Dimension(0,rowHeight					+ insets.top + insets.bottom);					for(int i = 2; i < comp.length; i++)				{					int btnWidth = comp[i].getPreferredSize().width;					if(btnWidth + x > width)					{						returnValue.height += rowHeight;						x = insets.left;					}						x += btnWidth;				}				return returnValue;			}	
private Dimension preferredLayoutSizeTB(int dimension, Insets insets, Component[] comp, Dimension dim)			{				int height = dimension - insets.bottom;				int colWidth = Math.max(dim.width,closeBox.getPreferredSize().height);				int y = (colWidth << 1) + insets.top;				Dimension returnValue = new Dimension(colWidth					+ insets.left + insets.right,0);					for(int i = 2; i < comp.length; i++)				{					int btnHeight = comp[i].getPreferredSize().height;					if(btnHeight + y > height)					{						returnValue.width += colWidth;						y = insets.top;					}						y += btnHeight;				}				return returnValue;			}	
public void show(String name)		{			DockableWindowManagerImpl.Entry entry = null;			if (name != null)			{				wm.showDockableWindow(name);				wm.hideDockableWindow(name);			}			show(entry);		}	
/**			Used to add source file info to exception		*/		public void setErrorSourceFile( String file ) {			this.sourceFile = file;		}	
public String getErrorSourceFile() { 			return sourceFile; 		}	
/**	   * This constructor is used by the method "generateParseException"	   * in the generated parser.  Calling this constructor generates	   * a new object of this type with the fields "currentToken",	   * "expectedTokenSequences", and "tokenImage" set.  The boolean	   * flag "specialConstructor" is also set to true to indicate that	   * this constructor was used to create this object.	   * This constructor calls its super class with the empty string	   * to force the "toString" method of parent class "Throwable" to	   * print the error message in the form:	   *     ParseException: <result of getMessage>	   */	  public ParseException(Token currentTokenVal,	                        int[][] expectedTokenSequencesVal,	                        String[] tokenImageVal	                       )	  {		// Begin BeanShell Modification - constructor		this();		// End BeanShell Modification - constructor	    specialConstructor = true;	    currentToken = currentTokenVal;	    expectedTokenSequences = expectedTokenSequencesVal;	    tokenImage = tokenImageVal;	  }	
/**	   * The following constructors are for use by you for whatever	   * purpose you can think of.  Constructing the exception in this	   * manner makes the exception behave in the normal way - i.e., as	   * documented in the class "Throwable".  The fields "errorToken",	   * "expectedTokenSequences", and "tokenImage" do not contain	   * relevant information.  The JavaCC generated code does not use	   * these constructors.	   */		  public ParseException() {		// Begin BeanShell Modification - constructor		this("");		// End BeanShell Modification - constructor	    specialConstructor = false;	  }	
public ParseException(String message) {		// Begin BeanShell Modification - super constructor args		// null node, null callstack, ParseException knows where the error is.		super( message, null, null );		// End BeanShell Modification - super constructor args	    specialConstructor = false;	  }	
public String	getMessage() {		return getMessage( false );	  }	
/**	   * This method has the standard behavior when this object has been	   * created using the standard constructors.  Otherwise, it uses	   * "currentToken" and "expectedTokenSequences" to generate a parse	   * error message and returns it.  If this object has been created	   * due to a parse error, and you do not catch it (it gets thrown	   * from the parser), then this method is called during the printing	   * of the final stack trace, and hence the correct error message	   * gets displayed.	   */	  // Begin BeanShell Modification - added debug param	  public String getMessage( boolean debug ) {	  // End BeanShell Modification - added debug param	    if (!specialConstructor) {	      return super.getMessage();	    }	    String expected = "";	    int maxSize = 0;	    for (int i = 0; i < expectedTokenSequences.length; i++) {	      if (maxSize < expectedTokenSequences[i].length) {	        maxSize = expectedTokenSequences[i].length;	      }	      for (int j = 0; j < expectedTokenSequences[i].length; j++) {	        expected += tokenImage[expectedTokenSequences[i][j]] + " ";	      }	      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {	        expected += "...";	      }	      expected += eol + "    ";	    }		// Begin BeanShell Modification - added sourceFile info	    String retval = "In file: "+ sourceFile +" Encountered \"";		// End BeanShell Modification - added sourceFile info	    Token tok = currentToken.next;	    for (int i = 0; i < maxSize; i++) {	      if (i != 0) retval += " ";	      if (tok.kind == 0) {	        retval += tokenImage[0];	        break;	      }	      retval += add_escapes(tok.image);	      tok = tok.next; 	    }	    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn + "." + eol;			// Begin BeanShell Modification - made conditional on debug		if ( debug )		{			if (expectedTokenSequences.length == 1) {			  retval += "Was expecting:" + eol + "    ";			} else {			  retval += "Was expecting one of:" + eol + "    ";			}				retval += expected;		}		// End BeanShell Modification - made conditional on debug		    return retval;	  }	
/**	   * Used to convert raw characters to their escaped version	   * when these raw version cannot be used as part of an ASCII	   * string literal.	   */	  protected String add_escapes(String str) {	      StringBuilder retval = new StringBuilder();	      char ch;	      for (int i = 0; i < str.length(); i++) {	        switch (str.charAt(i))	        {	           case 0 :	              continue;	           case '\b':	              retval.append("\\b");	              continue;	           case '\t':	              retval.append("\\t");	              continue;	           case '\n':	              retval.append("\\n");	              continue;	           case '\f':	              retval.append("\\f");	              continue;	           case '\r':	              retval.append("\\r");	              continue;	           case '\"':	              retval.append("\\\"");	              continue;	           case '\'':	              retval.append("\\\'");	              continue;	           case '\\':	              retval.append("\\\\");	              continue;	           default:	              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {	                 String s = "0000" + Integer.toString(ch, 16);	                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));	              } else {	                 retval.append(ch);	              }	              continue;	        }	      }	      return retval.toString();	   }	
public int getErrorLineNumber() 		{			return currentToken.next.beginLine;		}	
public String getErrorText() { 			// copied from generated getMessage()			int	maxSize	= 0;			for	(int i = 0; i <	expectedTokenSequences.length; i++) {			  if (maxSize < expectedTokenSequences[i].length)				maxSize	= expectedTokenSequences[i].length;			}				String retval = "";			Token tok =	currentToken.next;			for	(int i = 0; i <	maxSize; i++) 			{			  if (i != 0) retval += " ";			  if (tok.kind == 0) {				retval += tokenImage[0];				break;			  }			  retval +=	add_escapes(tok.image);			  tok = tok.next;			}						return retval;		}	
public String toString() {			return getMessage();		}	
public void setRetainComments( boolean b ) {	                retainComments = b;	        }	
void jjtreeOpenNodeScope(Node n) {	                ((SimpleNode)n).firstToken = getToken(1);	        }	
void jjtreeCloseNodeScope(Node n) {	                ((SimpleNode)n).lastToken = getToken(0);	        }	
/**			Re-initialize the input stream and token source.		*/	        void reInitInput( Reader in ) {	                ReInit(in);	        }	
public SimpleNode popNode()	        {	                if ( jjtree.nodeArity() > 0)  // number of child nodes 	                        return (SimpleNode)jjtree.popNode();	                else	                        return null;	        }	
/**			Explicitly re-initialize just the token reader.			This seems to be necessary to avoid certain looping errors when			reading bogus input.  See Interpreter.		*/	        void reInitTokenInput( Reader in ) {	                jj_input_stream.ReInit( in,	                        jj_input_stream.getEndLine(),	                        jj_input_stream.getEndColumn() );	        }	
public static void main( String [] args )	                throws IOException, ParseException	        {	                boolean print = false;	                int i=0;	                if ( args[0].equals("-p") ) {	                        i++;	                        print=true;	                }	                for(; i< args.length; i++) {	                        Reader in = new FileReader(args[i]);	                        Parser parser = new Parser(in);	                        parser.setRetainComments(true);	                        while( !parser.Line()/*eof*/ )	                                if ( print )	                                        System.out.println( parser.popNode() );	                }	        }	
/**			Lookahead for the enhanced for statement.  			Expect "for" "(" and then see whether we hit ":" or a ";" first.		*/	        boolean isRegularForStatement()	        {	                int curTok = 1;	                Token tok;	                tok = getToken(curTok++);	                if ( tok.kind != FOR ) return false;	                tok = getToken(curTok++);	                if ( tok.kind != LPAREN ) return false;	                while (true)	                {	                        tok = getToken(curTok++);	                        switch (tok.kind) {	                                case COLON:	                                        return false;	                                case SEMICOLON:	                                        return true;	                                case EOF:	                                        return false;	                        }	                }	        }	
/**			Generate a ParseException with the specified message, pointing to the			current token.			The auto-generated Parser.generateParseException() method does not			provide line number info, therefore we do this.		*/	        ParseException createParseException( String message )	        {	                Token errortok = token;	                int line = errortok.beginLine, column = errortok.beginColumn;	                String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;	                return new ParseException( "Parse error at line " + line	                        + ", column " + column + " : " + message );	        }	
final public boolean Line() throws ParseException {	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case 0:	      jj_consume_token(0);	        Interpreter.debug("End of File!");	        {if (true) return true;}	      break;	    default:	      if (jj_2_1(1)) {	        BlockStatement();	        {if (true) return false;}	      } else {	        jj_consume_token(-1);	        throw new ParseException();	      }	    }	    throw new Error("Missing return statement in function");	  }	
/*****************************************	 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *	 *****************************************/		/*		Gather modifiers for a class, method, or field.		I lookahead is true then we are being called as part of a lookahead and we		should not enforce any rules.  Otherwise we validate based on context		(field, method, class)	*/	  final public Modifiers Modifiers(int context, boolean lookahead) throws ParseException {	        Modifiers mods = null;	    label_1:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case ABSTRACT:	      case FINAL:	      case NATIVE:	      case PRIVATE:	      case PROTECTED:	      case PUBLIC:	      case STATIC:	      case STRICTFP:	      case SYNCHRONIZED:	      case TRANSIENT:	      case VOLATILE:	        ;	        break;	      default:	        break label_1;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case PRIVATE:	        jj_consume_token(PRIVATE);	        break;	      case PROTECTED:	        jj_consume_token(PROTECTED);	        break;	      case PUBLIC:	        jj_consume_token(PUBLIC);	        break;	      case SYNCHRONIZED:	        jj_consume_token(SYNCHRONIZED);	        break;	      case FINAL:	        jj_consume_token(FINAL);	        break;	      case NATIVE:	        jj_consume_token(NATIVE);	        break;	      case TRANSIENT:	        jj_consume_token(TRANSIENT);	        break;	      case VOLATILE:	        jj_consume_token(VOLATILE);	        break;	      case ABSTRACT:	        jj_consume_token(ABSTRACT);	        break;	      case STATIC:	        jj_consume_token(STATIC);	        break;	      case STRICTFP:	        jj_consume_token(STRICTFP);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	                if ( !lookahead )	                        try {	                                if ( mods == null ) mods = new Modifiers();	                                mods.addModifier( context, getToken(0).image );	                        } catch ( IllegalStateException e ) {	                                {if (true) throw createParseException( e.getMessage() );}	                        }	    }	        {if (true) return mods;}	    throw new Error("Missing return statement in function");	  }	
/**	*/	  final public void ClassDeclaration() throws ParseException {	 /*@bgen(jjtree) ClassDeclaration */	        BSHClassDeclaration jjtn000 = new BSHClassDeclaration(JJTCLASSDECLARATION);	        boolean jjtc000 = true;	        jjtree.openNodeScope(jjtn000);	        jjtreeOpenNodeScope(jjtn000);Modifiers mods;	        Token name;	        int numInterfaces;	    try {	      mods = Modifiers(Modifiers.CLASS, false);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case CLASS:	        jj_consume_token(CLASS);	        break;	      case INTERFACE:	        jj_consume_token(INTERFACE);	                                  jjtn000.isInterface=true;	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      name = jj_consume_token(IDENTIFIER);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case EXTENDS:	        jj_consume_token(EXTENDS);	        AmbiguousName();	                                      jjtn000.extend = true;	        break;	      default:	        ;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case IMPLEMENTS:	        jj_consume_token(IMPLEMENTS);	        numInterfaces = NameList();	                  jjtn000.numInterfaces=numInterfaces;	        break;	      default:	        ;	      }	      Block();	          jjtree.closeNodeScope(jjtn000, true);	          jjtc000 = false;	          jjtreeCloseNodeScope(jjtn000);	                jjtn000.modifiers = mods;	                jjtn000.name = name.image;	    } catch (Throwable jjte000) {	          if (jjtc000) {	            jjtree.clearNodeScope(jjtn000);	            jjtc000 = false;	          } else {	            jjtree.popNode();	          }	          if (jjte000 instanceof RuntimeException) {	            {if (true) throw (RuntimeException)jjte000;}	          }	          if (jjte000 instanceof ParseException) {	            {if (true) throw (ParseException)jjte000;}	          }	          {if (true) throw (Error)jjte000;}	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000, true);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final public void MethodDeclaration() throws ParseException {	 /*@bgen(jjtree) MethodDeclaration */	        BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);	        boolean jjtc000 = true;	        jjtree.openNodeScope(jjtn000);	        jjtreeOpenNodeScope(jjtn000);Token t = null;	        Modifiers mods;	        int count;	    try {	      mods = Modifiers(Modifiers.METHOD, false);	                                                      jjtn000.modifiers = mods;	      if (jj_2_2(2147483647)) {	        t = jj_consume_token(IDENTIFIER);	                           jjtn000.name = t.image;	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case BOOLEAN:	        case BYTE:	        case CHAR:	        case DOUBLE:	        case FLOAT:	        case INT:	        case LONG:	        case SHORT:	        case VOID:	        case IDENTIFIER:	          ReturnType();	          t = jj_consume_token(IDENTIFIER);	                           jjtn000.name = t.image;	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	      FormalParameters();	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case THROWS:	        jj_consume_token(THROWS);	        count = NameList();	                                      jjtn000.numThrows=count;	        break;	      default:	        ;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case LBRACE:	        Block();	        break;	      case SEMICOLON:	        jj_consume_token(SEMICOLON);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    } catch (Throwable jjte000) {	          if (jjtc000) {	            jjtree.clearNodeScope(jjtn000);	            jjtc000 = false;	          } else {	            jjtree.popNode();	          }	          if (jjte000 instanceof RuntimeException) {	            {if (true) throw (RuntimeException)jjte000;}	          }	          if (jjte000 instanceof ParseException) {	            {if (true) throw (ParseException)jjte000;}	          }	          {if (true) throw (Error)jjte000;}	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000, true);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final public void PackageDeclaration() throws ParseException {	 /*@bgen(jjtree) PackageDeclaration */	  BSHPackageDeclaration jjtn000 = new BSHPackageDeclaration(JJTPACKAGEDECLARATION);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(PACKAGE);	      AmbiguousName();	    } catch (Throwable jjte000) {	          if (jjtc000) {	            jjtree.clearNodeScope(jjtn000);	            jjtc000 = false;	          } else {	            jjtree.popNode();	          }	          if (jjte000 instanceof RuntimeException) {	            {if (true) throw (RuntimeException)jjte000;}	          }	          if (jjte000 instanceof ParseException) {	            {if (true) throw (ParseException)jjte000;}	          }	          {if (true) throw (Error)jjte000;}	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000, true);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final public void ImportDeclaration() throws ParseException {	 /*@bgen(jjtree) ImportDeclaration */	    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);	    boolean jjtc000 = true;	    jjtree.openNodeScope(jjtn000);	    jjtreeOpenNodeScope(jjtn000);Token s = null;	        Token t = null;	    try {	      if (jj_2_3(3)) {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case STATIC:	          s = jj_consume_token(STATIC);	          break;	        default:	          ;	        }	        jj_consume_token(IMPORT);	        AmbiguousName();	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case DOT:	          t = jj_consume_token(DOT);	          jj_consume_token(STAR);	          break;	        default:	          ;	        }	        jj_consume_token(SEMICOLON);	    jjtree.closeNodeScope(jjtn000, true);	    jjtc000 = false;	    jjtreeCloseNodeScope(jjtn000);	                if ( s != null ) jjtn000.staticImport = true;	                if ( t != null ) jjtn000.importPackage = true;	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case IMPORT:	          jj_consume_token(IMPORT);	          jj_consume_token(STAR);	          jj_consume_token(SEMICOLON);	                     jjtree.closeNodeScope(jjtn000, true);	                     jjtc000 = false;	                     jjtreeCloseNodeScope(jjtn000);	                jjtn000.superImport = true;	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void VariableDeclarator() throws ParseException {	 /*@bgen(jjtree) VariableDeclarator */	        BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);	        boolean jjtc000 = true;	        jjtree.openNodeScope(jjtn000);	        jjtreeOpenNodeScope(jjtn000);Token t;	    try {	      t = jj_consume_token(IDENTIFIER);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case ASSIGN:	        jj_consume_token(ASSIGN);	        VariableInitializer();	        break;	      default:	        ;	      }	          jjtree.closeNodeScope(jjtn000, true);	          jjtc000 = false;	          jjtreeCloseNodeScope(jjtn000);	                jjtn000.name = t.image;	    } catch (Throwable jjte000) {	          if (jjtc000) {	            jjtree.clearNodeScope(jjtn000);	            jjtc000 = false;	          } else {	            jjtree.popNode();	          }	          if (jjte000 instanceof RuntimeException) {	            {if (true) throw (RuntimeException)jjte000;}	          }	          if (jjte000 instanceof ParseException) {	            {if (true) throw (ParseException)jjte000;}	          }	          {if (true) throw (Error)jjte000;}	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000, true);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final public void VariableInitializer() throws ParseException {	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case LBRACE:	      ArrayInitializer();	      break;	    case BOOLEAN:	    case BYTE:	    case CHAR:	    case DOUBLE:	    case FALSE:	    case FLOAT:	    case INT:	    case LONG:	    case NEW:	    case NULL:	    case SHORT:	    case TRUE:	    case VOID:	    case INTEGER_LITERAL:	    case FLOATING_POINT_LITERAL:	    case CHARACTER_LITERAL:	    case STRING_LITERAL:	    case IDENTIFIER:	    case LPAREN:	    case BANG:	    case TILDE:	    case INCR:	    case DECR:	    case PLUS:	    case MINUS:	      Expression();	      break;	    default:	      jj_consume_token(-1);	      throw new ParseException();	    }	  }	
final public void ArrayInitializer() throws ParseException {	 /*@bgen(jjtree) ArrayInitializer */	  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(LBRACE);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case LBRACE:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        VariableInitializer();	        label_2:	        while (true) {	          if (jj_2_4(2)) {	            ;	          } else {	            break label_2;	          }	          jj_consume_token(COMMA);	          VariableInitializer();	        }	        break;	      default:	        ;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case COMMA:	        jj_consume_token(COMMA);	        break;	      default:	        ;	      }	      jj_consume_token(RBRACE);	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void FormalParameters() throws ParseException {	 /*@bgen(jjtree) FormalParameters */	  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(LPAREN);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FLOAT:	      case INT:	      case LONG:	      case SHORT:	      case IDENTIFIER:	        FormalParameter();	        label_3:	        while (true) {	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	          case COMMA:	            ;	            break;	          default:	            break label_3;	          }	          jj_consume_token(COMMA);	          FormalParameter();	        }	        break;	      default:	        ;	      }	      jj_consume_token(RPAREN);	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void FormalParameter() throws ParseException {	 /*@bgen(jjtree) FormalParameter */	  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);Token t;	    try {	      if (jj_2_5(2)) {	        Type();	        t = jj_consume_token(IDENTIFIER);	                                       jjtree.closeNodeScope(jjtn000, true);	                                       jjtc000 = false;	                                       jjtreeCloseNodeScope(jjtn000);	                                       jjtn000.name = t.image;	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case IDENTIFIER:	          t = jj_consume_token(IDENTIFIER);	                   jjtree.closeNodeScope(jjtn000, true);	                   jjtc000 = false;	                   jjtreeCloseNodeScope(jjtn000);	                   jjtn000.name = t.image;	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void Type() throws ParseException {	 /*@bgen(jjtree) Type */	  BSHType jjtn000 = new BSHType(JJTTYPE);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FLOAT:	      case INT:	      case LONG:	      case SHORT:	        PrimitiveType();	        break;	      case IDENTIFIER:	        AmbiguousName();	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      label_4:	      while (true) {	        if (jj_2_6(2)) {	          ;	        } else {	          break label_4;	        }	        jj_consume_token(LBRACKET);	        jj_consume_token(RBRACKET);	                                 jjtn000.addArrayDimension();	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ReturnType() throws ParseException {	 /*@bgen(jjtree) ReturnType */	  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case VOID:	        jj_consume_token(VOID);	           jjtree.closeNodeScope(jjtn000, true);	           jjtc000 = false;	           jjtreeCloseNodeScope(jjtn000);	           jjtn000.isVoid = true;	        break;	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FLOAT:	      case INT:	      case LONG:	      case SHORT:	      case IDENTIFIER:	        Type();	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void PrimitiveType() throws ParseException {	 /*@bgen(jjtree) PrimitiveType */	  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	        jj_consume_token(BOOLEAN);	              jjtree.closeNodeScope(jjtn000, true);	              jjtc000 = false;	              jjtreeCloseNodeScope(jjtn000);	              jjtn000.type = Boolean.TYPE;	        break;	      case CHAR:	        jj_consume_token(CHAR);	           jjtree.closeNodeScope(jjtn000, true);	           jjtc000 = false;	           jjtreeCloseNodeScope(jjtn000);	           jjtn000.type =  Character.TYPE;	        break;	      case BYTE:	        jj_consume_token(BYTE);	           jjtree.closeNodeScope(jjtn000, true);	           jjtc000 = false;	           jjtreeCloseNodeScope(jjtn000);	           jjtn000.type =  Byte.TYPE;	        break;	      case SHORT:	        jj_consume_token(SHORT);	            jjtree.closeNodeScope(jjtn000, true);	            jjtc000 = false;	            jjtreeCloseNodeScope(jjtn000);	            jjtn000.type =  Short.TYPE;	        break;	      case INT:	        jj_consume_token(INT);	          jjtree.closeNodeScope(jjtn000, true);	          jjtc000 = false;	          jjtreeCloseNodeScope(jjtn000);	          jjtn000.type =  Integer.TYPE;	        break;	      case LONG:	        jj_consume_token(LONG);	           jjtree.closeNodeScope(jjtn000, true);	           jjtc000 = false;	           jjtreeCloseNodeScope(jjtn000);	           jjtn000.type =  Long.TYPE;	        break;	      case FLOAT:	        jj_consume_token(FLOAT);	            jjtree.closeNodeScope(jjtn000, true);	            jjtc000 = false;	            jjtreeCloseNodeScope(jjtn000);	            jjtn000.type =  Float.TYPE;	        break;	      case DOUBLE:	        jj_consume_token(DOUBLE);	             jjtree.closeNodeScope(jjtn000, true);	             jjtc000 = false;	             jjtreeCloseNodeScope(jjtn000);	             jjtn000.type =  Double.TYPE;	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void AmbiguousName() throws ParseException {	 /*@bgen(jjtree) AmbiguousName */	    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);	    boolean jjtc000 = true;	    jjtree.openNodeScope(jjtn000);	    jjtreeOpenNodeScope(jjtn000);Token t;	    StringBuilder s;	    try {	      t = jj_consume_token(IDENTIFIER);	        s = new StringBuilder(t.image);	      label_5:	      while (true) {	        if (jj_2_7(2)) {	          ;	        } else {	          break label_5;	        }	        jj_consume_token(DOT);	        t = jj_consume_token(IDENTIFIER);	                                        s.append("."+t.image);	      }	                                                                      jjtree.closeNodeScope(jjtn000, true);	                                                                      jjtc000 = false;	                                                                      jjtreeCloseNodeScope(jjtn000);	        jjtn000.text = s.toString();	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public int NameList() throws ParseException {	  int count = 0;	    AmbiguousName();	                    ++count;	    label_6:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case COMMA:	        ;	        break;	      default:	        break label_6;	      }	      jj_consume_token(COMMA);	      AmbiguousName();	                                                       ++count;	    }	    {if (true) return count;}	    throw new Error("Missing return statement in function");	  }	
final public void Expression() throws ParseException {	    if (jj_2_8(2147483647)) {	      Assignment();	    } else {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        ConditionalExpression();	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    }	  }	
final public void Assignment() throws ParseException {	 /*@bgen(jjtree) Assignment */	  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);int op ;	    try {	      PrimaryExpression();	      op = AssignmentOperator();	                                    jjtn000.operator = op;	      Expression();	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public int AssignmentOperator() throws ParseException {	  Token t;	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case ASSIGN:	      jj_consume_token(ASSIGN);	      break;	    case STARASSIGN:	      jj_consume_token(STARASSIGN);	      break;	    case SLASHASSIGN:	      jj_consume_token(SLASHASSIGN);	      break;	    case MODASSIGN:	      jj_consume_token(MODASSIGN);	      break;	    case PLUSASSIGN:	      jj_consume_token(PLUSASSIGN);	      break;	    case MINUSASSIGN:	      jj_consume_token(MINUSASSIGN);	      break;	    case ANDASSIGN:	      jj_consume_token(ANDASSIGN);	      break;	    case XORASSIGN:	      jj_consume_token(XORASSIGN);	      break;	    case ORASSIGN:	      jj_consume_token(ORASSIGN);	      break;	    case LSHIFTASSIGN:	      jj_consume_token(LSHIFTASSIGN);	      break;	    case LSHIFTASSIGNX:	      jj_consume_token(LSHIFTASSIGNX);	      break;	    case RSIGNEDSHIFTASSIGN:	      jj_consume_token(RSIGNEDSHIFTASSIGN);	      break;	    case RSIGNEDSHIFTASSIGNX:	      jj_consume_token(RSIGNEDSHIFTASSIGNX);	      break;	    case RUNSIGNEDSHIFTASSIGN:	      jj_consume_token(RUNSIGNEDSHIFTASSIGN);	      break;	    case RUNSIGNEDSHIFTASSIGNX:	      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);	      break;	    default:	      jj_consume_token(-1);	      throw new ParseException();	    }	        t = getToken(0);	        {if (true) return t.kind;}	    throw new Error("Missing return statement in function");	  }	
final public void ConditionalExpression() throws ParseException {	    ConditionalOrExpression();	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case HOOK:	      jj_consume_token(HOOK);	      Expression();	      jj_consume_token(COLON);	                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);	                                                     boolean jjtc001 = true;	                                                     jjtree.openNodeScope(jjtn001);	                                                     jjtreeOpenNodeScope(jjtn001);	      try {	        ConditionalExpression();	      } catch (Throwable jjte001) {	                                                     if (jjtc001) {	                                                       jjtree.clearNodeScope(jjtn001);	                                                       jjtc001 = false;	                                                     } else {	                                                       jjtree.popNode();	                                                     }	                                                     if (jjte001 instanceof RuntimeException) {	                                                       {if (true) throw (RuntimeException)jjte001;}	                                                     }	                                                     if (jjte001 instanceof ParseException) {	                                                       {if (true) throw (ParseException)jjte001;}	                                                     }	                                                     {if (true) throw (Error)jjte001;}	      } finally {	                                                     if (jjtc001) {	                                                       jjtree.closeNodeScope(jjtn001,  3);	                                                       jjtreeCloseNodeScope(jjtn001);	                                                     }	      }	      break;	    default:	      ;	    }	  }	
final public void ConditionalOrExpression() throws ParseException {	  Token t=null;	    ConditionalAndExpression();	    label_7:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOL_OR:	      case BOOL_ORX:	        ;	        break;	      default:	        break label_7;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOL_OR:	        t = jj_consume_token(BOOL_OR);	        break;	      case BOOL_ORX:	        t = jj_consume_token(BOOL_ORX);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      ConditionalAndExpression();	      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  2);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	    }	  }	
final public void ConditionalAndExpression() throws ParseException {	  Token t=null;	    InclusiveOrExpression();	    label_8:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOL_AND:	      case BOOL_ANDX:	        ;	        break;	      default:	        break label_8;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOL_AND:	        t = jj_consume_token(BOOL_AND);	        break;	      case BOOL_ANDX:	        t = jj_consume_token(BOOL_ANDX);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      InclusiveOrExpression();	      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  2);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	    }	  }	
final public void InclusiveOrExpression() throws ParseException {	  Token t=null;	    ExclusiveOrExpression();	    label_9:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BIT_OR:	      case BIT_ORX:	        ;	        break;	      default:	        break label_9;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BIT_OR:	        t = jj_consume_token(BIT_OR);	        break;	      case BIT_ORX:	        t = jj_consume_token(BIT_ORX);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      ExclusiveOrExpression();	      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  2);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	    }	  }	
final public void ExclusiveOrExpression() throws ParseException {	  Token t=null;	    AndExpression();	    label_10:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case XOR:	        ;	        break;	      default:	        break label_10;	      }	      t = jj_consume_token(XOR);	      AndExpression();	      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  2);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	    }	  }	
final public void AndExpression() throws ParseException {	  Token t=null;	    EqualityExpression();	    label_11:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BIT_AND:	      case BIT_ANDX:	        ;	        break;	      default:	        break label_11;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BIT_AND:	        t = jj_consume_token(BIT_AND);	        break;	      case BIT_ANDX:	        t = jj_consume_token(BIT_ANDX);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      EqualityExpression();	      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  2);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	    }	  }	
final public void EqualityExpression() throws ParseException {	  Token t = null;	    InstanceOfExpression();	    label_12:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case EQ:	      case NE:	        ;	        break;	      default:	        break label_12;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case EQ:	        t = jj_consume_token(EQ);	        break;	      case NE:	        t = jj_consume_token(NE);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      InstanceOfExpression();	      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  2);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	    }	  }	
final public void InstanceOfExpression() throws ParseException {	  Token t = null;	    RelationalExpression();	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case INSTANCEOF:	      t = jj_consume_token(INSTANCEOF);	      Type();	                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	                              boolean jjtc001 = true;	                              jjtree.openNodeScope(jjtn001);	                              jjtreeOpenNodeScope(jjtn001);	      try {	                              jjtree.closeNodeScope(jjtn001,  2);	                              jjtc001 = false;	                              jjtreeCloseNodeScope(jjtn001);	                              jjtn001.kind = t.kind;	      } finally {	                              if (jjtc001) {	                                jjtree.closeNodeScope(jjtn001,  2);	                                jjtreeCloseNodeScope(jjtn001);	                              }	      }	      break;	    default:	      ;	    }	  }	
final public void RelationalExpression() throws ParseException {	  Token t = null;	    ShiftExpression();	    label_13:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case GT:	      case GTX:	      case LT:	      case LTX:	      case LE:	      case LEX:	      case GE:	      case GEX:	        ;	        break;	      default:	        break label_13;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case LT:	        t = jj_consume_token(LT);	        break;	      case LTX:	        t = jj_consume_token(LTX);	        break;	      case GT:	        t = jj_consume_token(GT);	        break;	      case GTX:	        t = jj_consume_token(GTX);	        break;	      case LE:	        t = jj_consume_token(LE);	        break;	      case LEX:	        t = jj_consume_token(LEX);	        break;	      case GE:	        t = jj_consume_token(GE);	        break;	      case GEX:	        t = jj_consume_token(GEX);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      ShiftExpression();	    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	    boolean jjtc001 = true;	    jjtree.openNodeScope(jjtn001);	    jjtreeOpenNodeScope(jjtn001);	      try {	    jjtree.closeNodeScope(jjtn001,  2);	    jjtc001 = false;	    jjtreeCloseNodeScope(jjtn001);	    jjtn001.kind = t.kind;	      } finally {	    if (jjtc001) {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtreeCloseNodeScope(jjtn001);	    }	      }	    }	  }	
final public void ShiftExpression() throws ParseException {	  Token t = null;	    AdditiveExpression();	    label_14:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case LSHIFT:	      case LSHIFTX:	      case RSIGNEDSHIFT:	      case RSIGNEDSHIFTX:	      case RUNSIGNEDSHIFT:	      case RUNSIGNEDSHIFTX:	        ;	        break;	      default:	        break label_14;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case LSHIFT:	        t = jj_consume_token(LSHIFT);	        break;	      case LSHIFTX:	        t = jj_consume_token(LSHIFTX);	        break;	      case RSIGNEDSHIFT:	        t = jj_consume_token(RSIGNEDSHIFT);	        break;	      case RSIGNEDSHIFTX:	        t = jj_consume_token(RSIGNEDSHIFTX);	        break;	      case RUNSIGNEDSHIFT:	        t = jj_consume_token(RUNSIGNEDSHIFT);	        break;	      case RUNSIGNEDSHIFTX:	        t = jj_consume_token(RUNSIGNEDSHIFTX);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      AdditiveExpression();	    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	    boolean jjtc001 = true;	    jjtree.openNodeScope(jjtn001);	    jjtreeOpenNodeScope(jjtn001);	      try {	    jjtree.closeNodeScope(jjtn001,  2);	    jjtc001 = false;	    jjtreeCloseNodeScope(jjtn001);	    jjtn001.kind = t.kind;	      } finally {	    if (jjtc001) {	      jjtree.closeNodeScope(jjtn001,  2);	      jjtreeCloseNodeScope(jjtn001);	    }	      }	    }	  }	
final public void AdditiveExpression() throws ParseException {	  Token t = null;	    MultiplicativeExpression();	    label_15:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case PLUS:	      case MINUS:	        ;	        break;	      default:	        break label_15;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case PLUS:	        t = jj_consume_token(PLUS);	        break;	      case MINUS:	        t = jj_consume_token(MINUS);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      MultiplicativeExpression();	                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	                                                     boolean jjtc001 = true;	                                                     jjtree.openNodeScope(jjtn001);	                                                     jjtreeOpenNodeScope(jjtn001);	      try {	                                                     jjtree.closeNodeScope(jjtn001,  2);	                                                     jjtc001 = false;	                                                     jjtreeCloseNodeScope(jjtn001);	                                                     jjtn001.kind = t.kind;	      } finally {	                                                     if (jjtc001) {	                                                       jjtree.closeNodeScope(jjtn001,  2);	                                                       jjtreeCloseNodeScope(jjtn001);	                                                     }	      }	    }	  }	
final public void MultiplicativeExpression() throws ParseException {	  Token t = null;	    UnaryExpression();	    label_16:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case STAR:	      case SLASH:	      case MOD:	        ;	        break;	      default:	        break label_16;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case STAR:	        t = jj_consume_token(STAR);	        break;	      case SLASH:	        t = jj_consume_token(SLASH);	        break;	      case MOD:	        t = jj_consume_token(MOD);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      UnaryExpression();	                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);	                      boolean jjtc001 = true;	                      jjtree.openNodeScope(jjtn001);	                      jjtreeOpenNodeScope(jjtn001);	      try {	                      jjtree.closeNodeScope(jjtn001,  2);	                      jjtc001 = false;	                      jjtreeCloseNodeScope(jjtn001);	                      jjtn001.kind = t.kind;	      } finally {	                      if (jjtc001) {	                        jjtree.closeNodeScope(jjtn001,  2);	                        jjtreeCloseNodeScope(jjtn001);	                      }	      }	    }	  }	
final public void UnaryExpression() throws ParseException {	  Token t = null;	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case PLUS:	    case MINUS:	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case PLUS:	        t = jj_consume_token(PLUS);	        break;	      case MINUS:	        t = jj_consume_token(MINUS);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      UnaryExpression();	      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  1);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  1);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	      break;	    case INCR:	      PreIncrementExpression();	      break;	    case DECR:	      PreDecrementExpression();	      break;	    case BOOLEAN:	    case BYTE:	    case CHAR:	    case DOUBLE:	    case FALSE:	    case FLOAT:	    case INT:	    case LONG:	    case NEW:	    case NULL:	    case SHORT:	    case TRUE:	    case VOID:	    case INTEGER_LITERAL:	    case FLOATING_POINT_LITERAL:	    case CHARACTER_LITERAL:	    case STRING_LITERAL:	    case IDENTIFIER:	    case LPAREN:	    case BANG:	    case TILDE:	      UnaryExpressionNotPlusMinus();	      break;	    default:	      jj_consume_token(-1);	      throw new ParseException();	    }	  }	
final public void PreIncrementExpression() throws ParseException {	  Token t = null;	    t = jj_consume_token(INCR);	    PrimaryExpression();	      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	    try {	      jjtree.closeNodeScope(jjtn001,  1);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	    } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  1);	        jjtreeCloseNodeScope(jjtn001);	      }	    }	  }	
final public void PreDecrementExpression() throws ParseException {	  Token t = null;	    t = jj_consume_token(DECR);	    PrimaryExpression();	      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	    try {	      jjtree.closeNodeScope(jjtn001,  1);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	    } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  1);	        jjtreeCloseNodeScope(jjtn001);	      }	    }	  }	
final public void UnaryExpressionNotPlusMinus() throws ParseException {	  Token t = null;	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case BANG:	    case TILDE:	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case TILDE:	        t = jj_consume_token(TILDE);	        break;	      case BANG:	        t = jj_consume_token(BANG);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	      UnaryExpression();	      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);	      boolean jjtc001 = true;	      jjtree.openNodeScope(jjtn001);	      jjtreeOpenNodeScope(jjtn001);	      try {	      jjtree.closeNodeScope(jjtn001,  1);	      jjtc001 = false;	      jjtreeCloseNodeScope(jjtn001);	      jjtn001.kind = t.kind;	      } finally {	      if (jjtc001) {	        jjtree.closeNodeScope(jjtn001,  1);	        jjtreeCloseNodeScope(jjtn001);	      }	      }	      break;	    default:	      if (jj_2_9(2147483647)) {	        CastExpression();	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case BOOLEAN:	        case BYTE:	        case CHAR:	        case DOUBLE:	        case FALSE:	        case FLOAT:	        case INT:	        case LONG:	        case NEW:	        case NULL:	        case SHORT:	        case TRUE:	        case VOID:	        case INTEGER_LITERAL:	        case FLOATING_POINT_LITERAL:	        case CHARACTER_LITERAL:	        case STRING_LITERAL:	        case IDENTIFIER:	        case LPAREN:	          PostfixExpression();	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    }	  }	
final public void CastLookahead() throws ParseException {	    if (jj_2_10(2)) {	      jj_consume_token(LPAREN);	      PrimitiveType();	    } else if (jj_2_11(2147483647)) {	      jj_consume_token(LPAREN);	      AmbiguousName();	      jj_consume_token(LBRACKET);	      jj_consume_token(RBRACKET);	    } else {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case LPAREN:	        jj_consume_token(LPAREN);	        AmbiguousName();	        jj_consume_token(RPAREN);	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case TILDE:	          jj_consume_token(TILDE);	          break;	        case BANG:	          jj_consume_token(BANG);	          break;	        case LPAREN:	          jj_consume_token(LPAREN);	          break;	        case IDENTIFIER:	          jj_consume_token(IDENTIFIER);	          break;	        case NEW:	          jj_consume_token(NEW);	          break;	        case FALSE:	        case NULL:	        case TRUE:	        case VOID:	        case INTEGER_LITERAL:	        case FLOATING_POINT_LITERAL:	        case CHARACTER_LITERAL:	        case STRING_LITERAL:	          Literal();	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    }	  }	
final public void PostfixExpression() throws ParseException {	  Token t = null;	    if (jj_2_12(2147483647)) {	      PrimaryExpression();	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case INCR:	        t = jj_consume_token(INCR);	        break;	      case DECR:	        t = jj_consume_token(DECR);	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);	                                boolean jjtc001 = true;	                                jjtree.openNodeScope(jjtn001);	                                jjtreeOpenNodeScope(jjtn001);	      try {	                                jjtree.closeNodeScope(jjtn001,  1);	                                jjtc001 = false;	                                jjtreeCloseNodeScope(jjtn001);	                jjtn001.kind = t.kind; jjtn001.postfix = true;	      } finally {	                                if (jjtc001) {	                                  jjtree.closeNodeScope(jjtn001,  1);	                                  jjtreeCloseNodeScope(jjtn001);	                                }	      }	    } else {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	        PrimaryExpression();	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    }	  }	
final public void CastExpression() throws ParseException {	 /*@bgen(jjtree) CastExpression */	  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      if (jj_2_13(2147483647)) {	        jj_consume_token(LPAREN);	        Type();	        jj_consume_token(RPAREN);	        UnaryExpression();	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case LPAREN:	          jj_consume_token(LPAREN);	          Type();	          jj_consume_token(RPAREN);	          UnaryExpressionNotPlusMinus();	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void PrimaryExpression() throws ParseException {	                                               /*@bgen(jjtree) PrimaryExpression */	  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      PrimaryPrefix();	      label_17:	      while (true) {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case LBRACE:	        case LBRACKET:	        case DOT:	          ;	          break;	        default:	          break label_17;	        }	        PrimarySuffix();	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void MethodInvocation() throws ParseException {	                                             /*@bgen(jjtree) MethodInvocation */	  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      AmbiguousName();	      Arguments();	    } catch (Throwable jjte000) {	     if (jjtc000) {	       jjtree.clearNodeScope(jjtn000);	       jjtc000 = false;	     } else {	       jjtree.popNode();	     }	     if (jjte000 instanceof RuntimeException) {	       {if (true) throw (RuntimeException)jjte000;}	     }	     if (jjte000 instanceof ParseException) {	       {if (true) throw (ParseException)jjte000;}	     }	     {if (true) throw (Error)jjte000;}	    } finally {	     if (jjtc000) {	       jjtree.closeNodeScope(jjtn000, true);	       jjtreeCloseNodeScope(jjtn000);	     }	    }	  }	
final public void PrimaryPrefix() throws ParseException {	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case FALSE:	    case NULL:	    case TRUE:	    case VOID:	    case INTEGER_LITERAL:	    case FLOATING_POINT_LITERAL:	    case CHARACTER_LITERAL:	    case STRING_LITERAL:	      Literal();	      break;	    case LPAREN:	      jj_consume_token(LPAREN);	      Expression();	      jj_consume_token(RPAREN);	      break;	    case NEW:	      AllocationExpression();	      break;	    default:	      if (jj_2_14(2147483647)) {	        MethodInvocation();	      } else if (jj_2_15(2147483647)) {	        Type();	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case IDENTIFIER:	          AmbiguousName();	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    }	  }	
final public void PrimarySuffix() throws ParseException {	 /*@bgen(jjtree) PrimarySuffix */	    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);	    boolean jjtc000 = true;	    jjtree.openNodeScope(jjtn000);	    jjtreeOpenNodeScope(jjtn000);Token t = null;	    try {	      if (jj_2_16(2)) {	        jj_consume_token(DOT);	        jj_consume_token(CLASS);	                jjtree.closeNodeScope(jjtn000, true);	                jjtc000 = false;	                jjtreeCloseNodeScope(jjtn000);	        jjtn000.operation = BSHPrimarySuffix.CLASS;	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case LBRACKET:	          jj_consume_token(LBRACKET);	          Expression();	          jj_consume_token(RBRACKET);	                         jjtree.closeNodeScope(jjtn000, true);	                         jjtc000 = false;	                         jjtreeCloseNodeScope(jjtn000);	        jjtn000.operation = BSHPrimarySuffix.INDEX;	          break;	        case DOT:	          jj_consume_token(DOT);	          t = jj_consume_token(IDENTIFIER);	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	          case LPAREN:	            Arguments();	            break;	          default:	            ;	          }	                                         jjtree.closeNodeScope(jjtn000, true);	                                         jjtc000 = false;	                                         jjtreeCloseNodeScope(jjtn000);	        jjtn000.operation = BSHPrimarySuffix.NAME;	        jjtn000.field = t.image;	          break;	        case LBRACE:	          jj_consume_token(LBRACE);	          Expression();	          jj_consume_token(RBRACE);	                         jjtree.closeNodeScope(jjtn000, true);	                         jjtc000 = false;	                         jjtreeCloseNodeScope(jjtn000);	        jjtn000.operation = BSHPrimarySuffix.PROPERTY;	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void Literal() throws ParseException {	 /*@bgen(jjtree) Literal */	    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);	    boolean jjtc000 = true;	    jjtree.openNodeScope(jjtn000);	    jjtreeOpenNodeScope(jjtn000);Token x;	    boolean b;	    String literal;	    char ch;	    try {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case INTEGER_LITERAL:	        x = jj_consume_token(INTEGER_LITERAL);	    jjtree.closeNodeScope(jjtn000, true);	    jjtc000 = false;	    jjtreeCloseNodeScope(jjtn000);	    literal = x.image;	    ch = literal.charAt(literal.length()-1);	    if(ch == 'l' || ch == 'L')	    {	        literal = literal.substring(0,literal.length()-1);		        // This really should be Long.decode, but there isn't one. As a result,	        // hex and octal literals ending in 'l' or 'L' don't work.	        jjtn000.value = new Primitive( new Long( literal ).longValue() );	    }	    else	                try {	                jjtn000.value = new Primitive(	                                Integer.decode( literal ).intValue() );	                } catch ( NumberFormatException e ) {	                        {if (true) throw createParseException(	                                "Error or number too big for integer type: "+ literal );}	                }	        break;	      case FLOATING_POINT_LITERAL:	        x = jj_consume_token(FLOATING_POINT_LITERAL);	    jjtree.closeNodeScope(jjtn000, true);	    jjtc000 = false;	    jjtreeCloseNodeScope(jjtn000);	    literal = x.image;	    ch = literal.charAt(literal.length()-1);	    if(ch == 'f' || ch == 'F')	    {	        literal = literal.substring(0,literal.length()-1);	        jjtn000.value = new Primitive( new Float( literal ).floatValue() );	    }	    else	    {	        if(ch == 'd' || ch == 'D')	            literal = literal.substring(0,literal.length()-1);		        jjtn000.value = new Primitive( new Double( literal ).doubleValue() );	    }	        break;	      case CHARACTER_LITERAL:	        x = jj_consume_token(CHARACTER_LITERAL);	                            jjtree.closeNodeScope(jjtn000, true);	                            jjtc000 = false;	                            jjtreeCloseNodeScope(jjtn000);	                try {	                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );	                } catch ( Exception e ) {	                        {if (true) throw createParseException("Error parsing character: "+x.image);}	                }	        break;	      case STRING_LITERAL:	        x = jj_consume_token(STRING_LITERAL);	                         jjtree.closeNodeScope(jjtn000, true);	                         jjtc000 = false;	                         jjtreeCloseNodeScope(jjtn000);	                try {	                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );	                } catch ( Exception e ) {	                        {if (true) throw createParseException("Error parsing string: "+x.image);}	                }	        break;	      case FALSE:	      case TRUE:	        b = BooleanLiteral();	                          jjtree.closeNodeScope(jjtn000, true);	                          jjtc000 = false;	                          jjtreeCloseNodeScope(jjtn000);	    jjtn000.value = new Primitive( b );	        break;	      case NULL:	        NullLiteral();	                  jjtree.closeNodeScope(jjtn000, true);	                  jjtc000 = false;	                  jjtreeCloseNodeScope(jjtn000);	    jjtn000.value = Primitive.NULL;	        break;	      case VOID:	        VoidLiteral();	                 jjtree.closeNodeScope(jjtn000, true);	                 jjtc000 = false;	                 jjtreeCloseNodeScope(jjtn000);	    jjtn000.value = Primitive.VOID;	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public boolean BooleanLiteral() throws ParseException {	    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	    case TRUE:	      jj_consume_token(TRUE);	           {if (true) return true;}	      break;	    case FALSE:	      jj_consume_token(FALSE);	            {if (true) return false;}	      break;	    default:	      jj_consume_token(-1);	      throw new ParseException();	    }	    throw new Error("Missing return statement in function");	  }	
final public void NullLiteral() throws ParseException {	    jj_consume_token(NULL);	  }	
final public void VoidLiteral() throws ParseException {	    jj_consume_token(VOID);	  }	
final public void Arguments() throws ParseException {	 /*@bgen(jjtree) Arguments */	  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(LPAREN);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        ArgumentList();	        break;	      default:	        ;	      }	      jj_consume_token(RPAREN);	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ArgumentList() throws ParseException {	    Expression();	    label_18:	    while (true) {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case COMMA:	        ;	        break;	      default:	        break label_18;	      }	      jj_consume_token(COMMA);	      Expression();	    }	  }	
final public void AllocationExpression() throws ParseException {	 /*@bgen(jjtree) AllocationExpression */	  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      if (jj_2_18(2)) {	        jj_consume_token(NEW);	        PrimitiveType();	        ArrayDimensions();	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case NEW:	          jj_consume_token(NEW);	          AmbiguousName();	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	          case LBRACKET:	            ArrayDimensions();	            break;	          case LPAREN:	            Arguments();	            if (jj_2_17(2)) {	              Block();	            } else {	              ;	            }	            break;	          default:	            jj_consume_token(-1);	            throw new ParseException();	          }	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ArrayDimensions() throws ParseException {	 /*@bgen(jjtree) ArrayDimensions */	  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      if (jj_2_21(2)) {	        label_19:	        while (true) {	          jj_consume_token(LBRACKET);	          Expression();	          jj_consume_token(RBRACKET);	                                        jjtn000.addDefinedDimension();	          if (jj_2_19(2)) {	            ;	          } else {	            break label_19;	          }	        }	        label_20:	        while (true) {	          if (jj_2_20(2)) {	            ;	          } else {	            break label_20;	          }	          jj_consume_token(LBRACKET);	          jj_consume_token(RBRACKET);	                           jjtn000.addUndefinedDimension();	        }	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case LBRACKET:	          label_21:	          while (true) {	            jj_consume_token(LBRACKET);	            jj_consume_token(RBRACKET);	              jjtn000.addUndefinedDimension();	            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	            case LBRACKET:	              ;	              break;	            default:	              break label_21;	            }	          }	          ArrayInitializer();	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void Statement() throws ParseException {	    if (jj_2_22(2)) {	      LabeledStatement();	    } else {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case LBRACE:	        Block();	        break;	      case SEMICOLON:	        EmptyStatement();	        break;	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        StatementExpression();	        jj_consume_token(SEMICOLON);	        break;	      case SWITCH:	        SwitchStatement();	        break;	      case IF:	        IfStatement();	        break;	      case WHILE:	        WhileStatement();	        break;	      case DO:	        DoStatement();	        break;	      default:	        if (isRegularForStatement()) {	          ForStatement();	        } else {	          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	          case FOR:	            EnhancedForStatement();	            break;	          case BREAK:	            BreakStatement();	            break;	          case CONTINUE:	            ContinueStatement();	            break;	          case RETURN:	            ReturnStatement();	            break;	          case SYNCHRONIZED:	            SynchronizedStatement();	            break;	          case THROW:	            ThrowStatement();	            break;	          case TRY:	            TryStatement();	            break;	          default:	            jj_consume_token(-1);	            throw new ParseException();	          }	        }	      }	    }	  }	
final public void LabeledStatement() throws ParseException {	    jj_consume_token(IDENTIFIER);	    jj_consume_token(COLON);	    Statement();	  }	
final public void Block() throws ParseException {	 /*@bgen(jjtree) Block */	  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(LBRACE);	      label_22:	      while (true) {	        if (jj_2_23(1)) {	          ;	        } else {	          break label_22;	        }	        BlockStatement();	      }	      jj_consume_token(RBRACE);	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void BlockStatement() throws ParseException {	    if (jj_2_24(2147483647)) {	      ClassDeclaration();	    } else if (jj_2_25(2147483647)) {	      MethodDeclaration();	    } else if (jj_2_26(2147483647)) {	      MethodDeclaration();	    } else if (jj_2_27(2147483647)) {	      TypedVariableDeclaration();	      jj_consume_token(SEMICOLON);	    } else if (jj_2_28(1)) {	      Statement();	    } else {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case IMPORT:	      case STATIC:	        ImportDeclaration();	        break;	      case PACKAGE:	        PackageDeclaration();	        break;	      case FORMAL_COMMENT:	        FormalComment();	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    }	  }	
final public void FormalComment() throws ParseException {	 /*@bgen(jjtree) #FormalComment( retainComments) */	        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);	        boolean jjtc000 = true;	        jjtree.openNodeScope(jjtn000);	        jjtreeOpenNodeScope(jjtn000);Token t;	    try {	      t = jj_consume_token(FORMAL_COMMENT);	                              jjtree.closeNodeScope(jjtn000,  retainComments);	                              jjtc000 = false;	                              jjtreeCloseNodeScope(jjtn000);	                jjtn000.text=t.image;	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000,  retainComments);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final public void EmptyStatement() throws ParseException {	    jj_consume_token(SEMICOLON);	  }	
final public void StatementExpression() throws ParseException {	    Expression();	  }	
final public void SwitchStatement() throws ParseException {	 /*@bgen(jjtree) SwitchStatement */	  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(SWITCH);	      jj_consume_token(LPAREN);	      Expression();	      jj_consume_token(RPAREN);	      jj_consume_token(LBRACE);	      label_23:	      while (true) {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case CASE:	        case _DEFAULT:	          ;	          break;	        default:	          break label_23;	        }	        SwitchLabel();	        label_24:	        while (true) {	          if (jj_2_29(1)) {	            ;	          } else {	            break label_24;	          }	          BlockStatement();	        }	      }	      jj_consume_token(RBRACE);	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void SwitchLabel() throws ParseException {	 /*@bgen(jjtree) SwitchLabel */	  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case CASE:	        jj_consume_token(CASE);	        Expression();	        jj_consume_token(COLON);	        break;	      case _DEFAULT:	        jj_consume_token(_DEFAULT);	        jj_consume_token(COLON);	                  jjtree.closeNodeScope(jjtn000, true);	                  jjtc000 = false;	                  jjtreeCloseNodeScope(jjtn000);	                  jjtn000.isDefault = true;	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void IfStatement() throws ParseException {	 /*@bgen(jjtree) IfStatement */	  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(IF);	      jj_consume_token(LPAREN);	      Expression();	      jj_consume_token(RPAREN);	      Statement();	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case ELSE:	        jj_consume_token(ELSE);	        Statement();	        break;	      default:	        ;	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void WhileStatement() throws ParseException {	 /*@bgen(jjtree) WhileStatement */	  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(WHILE);	      jj_consume_token(LPAREN);	      Expression();	      jj_consume_token(RPAREN);	      Statement();	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void DoStatement() throws ParseException {	 /*@bgen(jjtree) WhileStatement */	  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(DO);	      Statement();	      jj_consume_token(WHILE);	      jj_consume_token(LPAREN);	      Expression();	      jj_consume_token(RPAREN);	      jj_consume_token(SEMICOLON);	          jjtree.closeNodeScope(jjtn000, true);	          jjtc000 = false;	          jjtreeCloseNodeScope(jjtn000);	          jjtn000.isDoStatement=true;	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ForStatement() throws ParseException {	 /*@bgen(jjtree) ForStatement */	  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);Token t = null;	    try {	      jj_consume_token(FOR);	      jj_consume_token(LPAREN);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case ABSTRACT:	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FINAL:	      case FLOAT:	      case INT:	      case LONG:	      case NATIVE:	      case NEW:	      case NULL:	      case PRIVATE:	      case PROTECTED:	      case PUBLIC:	      case SHORT:	      case STATIC:	      case STRICTFP:	      case SYNCHRONIZED:	      case TRANSIENT:	      case TRUE:	      case VOID:	      case VOLATILE:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        ForInit();	                          jjtn000.hasForInit=true;	        break;	      default:	        ;	      }	      jj_consume_token(SEMICOLON);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        Expression();	                         jjtn000.hasExpression=true;	        break;	      default:	        ;	      }	      jj_consume_token(SEMICOLON);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        ForUpdate();	                        jjtn000.hasForUpdate=true;	        break;	      default:	        ;	      }	      jj_consume_token(RPAREN);	      Statement();	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void EnhancedForStatement() throws ParseException {	 /*@bgen(jjtree) EnhancedForStatement */	  BSHEnhancedForStatement jjtn000 = new BSHEnhancedForStatement(JJTENHANCEDFORSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);Token t = null;	    try {	      if (jj_2_30(4)) {	        jj_consume_token(FOR);	        jj_consume_token(LPAREN);	        t = jj_consume_token(IDENTIFIER);	        jj_consume_token(COLON);	        Expression();	        jj_consume_token(RPAREN);	        Statement();	                  jjtree.closeNodeScope(jjtn000, true);	                  jjtc000 = false;	                  jjtreeCloseNodeScope(jjtn000);	                  jjtn000.varName = t.image;	      } else {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case FOR:	          jj_consume_token(FOR);	          jj_consume_token(LPAREN);	          Type();	          t = jj_consume_token(IDENTIFIER);	          jj_consume_token(COLON);	          Expression();	          jj_consume_token(RPAREN);	          Statement();	                  jjtree.closeNodeScope(jjtn000, true);	                  jjtc000 = false;	                  jjtreeCloseNodeScope(jjtn000);	                  jjtn000.varName = t.image;	          break;	        default:	          jj_consume_token(-1);	          throw new ParseException();	        }	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ForInit() throws ParseException {	  Token t = null;	    if (jj_2_31(2147483647)) {	      TypedVariableDeclaration();	    } else {	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        StatementExpressionList();	        break;	      default:	        jj_consume_token(-1);	        throw new ParseException();	      }	    }	  }	
/**		Declared a typed variable.		Untyped variables are not declared per-se but are handled by the part		of the grammar that deals with assignments.	*/	  final public void TypedVariableDeclaration() throws ParseException {	 /*@bgen(jjtree) TypedVariableDeclaration */	        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);	        boolean jjtc000 = true;	        jjtree.openNodeScope(jjtn000);	        jjtreeOpenNodeScope(jjtn000);Token t = null;	        Modifiers mods;	    try {	      mods = Modifiers(Modifiers.FIELD, false);	      Type();	      VariableDeclarator();	      label_25:	      while (true) {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case COMMA:	          ;	          break;	        default:	          break label_25;	        }	        jj_consume_token(COMMA);	        VariableDeclarator();	      }	          jjtree.closeNodeScope(jjtn000, true);	          jjtc000 = false;	          jjtreeCloseNodeScope(jjtn000);	        jjtn000.modifiers = mods;	    } catch (Throwable jjte000) {	          if (jjtc000) {	            jjtree.clearNodeScope(jjtn000);	            jjtc000 = false;	          } else {	            jjtree.popNode();	          }	          if (jjte000 instanceof RuntimeException) {	            {if (true) throw (RuntimeException)jjte000;}	          }	          if (jjte000 instanceof ParseException) {	            {if (true) throw (ParseException)jjte000;}	          }	          {if (true) throw (Error)jjte000;}	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000, true);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final public void StatementExpressionList() throws ParseException {	 /*@bgen(jjtree) StatementExpressionList */	  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      StatementExpression();	      label_26:	      while (true) {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case COMMA:	          ;	          break;	        default:	          break label_26;	        }	        jj_consume_token(COMMA);	        StatementExpression();	      }	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ForUpdate() throws ParseException {	    StatementExpressionList();	  }	
final public void BreakStatement() throws ParseException {	 /*@bgen(jjtree) ReturnStatement */	  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(BREAK);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case IDENTIFIER:	        jj_consume_token(IDENTIFIER);	        break;	      default:	        ;	      }	      jj_consume_token(SEMICOLON);	                                 jjtree.closeNodeScope(jjtn000, true);	                                 jjtc000 = false;	                                 jjtreeCloseNodeScope(jjtn000);	                                 jjtn000.kind = BREAK;	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ContinueStatement() throws ParseException {	 /*@bgen(jjtree) ReturnStatement */	  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(CONTINUE);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case IDENTIFIER:	        jj_consume_token(IDENTIFIER);	        break;	      default:	        ;	      }	      jj_consume_token(SEMICOLON);	                                    jjtree.closeNodeScope(jjtn000, true);	                                    jjtc000 = false;	                                    jjtreeCloseNodeScope(jjtn000);	                                    jjtn000.kind = CONTINUE;	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ReturnStatement() throws ParseException {	 /*@bgen(jjtree) ReturnStatement */	  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(RETURN);	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case BOOLEAN:	      case BYTE:	      case CHAR:	      case DOUBLE:	      case FALSE:	      case FLOAT:	      case INT:	      case LONG:	      case NEW:	      case NULL:	      case SHORT:	      case TRUE:	      case VOID:	      case INTEGER_LITERAL:	      case FLOATING_POINT_LITERAL:	      case CHARACTER_LITERAL:	      case STRING_LITERAL:	      case IDENTIFIER:	      case LPAREN:	      case BANG:	      case TILDE:	      case INCR:	      case DECR:	      case PLUS:	      case MINUS:	        Expression();	        break;	      default:	        ;	      }	      jj_consume_token(SEMICOLON);	                                  jjtree.closeNodeScope(jjtn000, true);	                                  jjtc000 = false;	                                  jjtreeCloseNodeScope(jjtn000);	                                  jjtn000.kind = RETURN;	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void SynchronizedStatement() throws ParseException {	 /*@bgen(jjtree) Block */	  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(SYNCHRONIZED);	      jj_consume_token(LPAREN);	      Expression();	      jj_consume_token(RPAREN);	      Block();	                                                jjtree.closeNodeScope(jjtn000, true);	                                                jjtc000 = false;	                                                jjtreeCloseNodeScope(jjtn000);	                jjtn000.isSynchronized=true;	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void ThrowStatement() throws ParseException {	 /*@bgen(jjtree) ThrowStatement */	  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);	    try {	      jj_consume_token(THROW);	      Expression();	      jj_consume_token(SEMICOLON);	    } catch (Throwable jjte000) {	    if (jjtc000) {	      jjtree.clearNodeScope(jjtn000);	      jjtc000 = false;	    } else {	      jjtree.popNode();	    }	    if (jjte000 instanceof RuntimeException) {	      {if (true) throw (RuntimeException)jjte000;}	    }	    if (jjte000 instanceof ParseException) {	      {if (true) throw (ParseException)jjte000;}	    }	    {if (true) throw (Error)jjte000;}	    } finally {	    if (jjtc000) {	      jjtree.closeNodeScope(jjtn000, true);	      jjtreeCloseNodeScope(jjtn000);	    }	    }	  }	
final public void TryStatement() throws ParseException {	 /*@bgen(jjtree) TryStatement */	  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);	  boolean jjtc000 = true;	  jjtree.openNodeScope(jjtn000);	  jjtreeOpenNodeScope(jjtn000);boolean closed = false;	    try {	      jj_consume_token(TRY);	      Block();	      label_27:	      while (true) {	        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	        case CATCH:	          ;	          break;	        default:	          break label_27;	        }	        jj_consume_token(CATCH);	        jj_consume_token(LPAREN);	        FormalParameter();	        jj_consume_token(RPAREN);	        Block();	                                                      closed = true;	      }	      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {	      case FINALLY:	        jj_consume_token(FINALLY);	        Block();	                              closed = true;	        break;	      default:	        ;	      }	          jjtree.closeNodeScope(jjtn000, true);	          jjtc000 = false;	          jjtreeCloseNodeScope(jjtn000);	                if ( !closed ) {if (true) throw generateParseException();}	    } catch (Throwable jjte000) {	          if (jjtc000) {	            jjtree.clearNodeScope(jjtn000);	            jjtc000 = false;	          } else {	            jjtree.popNode();	          }	          if (jjte000 instanceof RuntimeException) {	            {if (true) throw (RuntimeException)jjte000;}	          }	          if (jjte000 instanceof ParseException) {	            {if (true) throw (ParseException)jjte000;}	          }	          {if (true) throw (Error)jjte000;}	    } finally {	          if (jjtc000) {	            jjtree.closeNodeScope(jjtn000, true);	            jjtreeCloseNodeScope(jjtn000);	          }	    }	  }	
final private boolean jj_2_1(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_1(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_2(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_2(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_3(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_3(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_4(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_4(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_5(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_5(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_6(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_6(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_7(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_7(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_8(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_8(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_9(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_9(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_10(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_10(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_11(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_11(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_12(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_12(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_13(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_13(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_14(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_14(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_15(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_15(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_16(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_16(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_17(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_17(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_18(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_18(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_19(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_19(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_20(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_20(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_21(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_21(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_22(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_22(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_23(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_23(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_24(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_24(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_25(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_25(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_26(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_26(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_27(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_27(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_28(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_28(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_29(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_29(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_30(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_30(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_2_31(int xla) {	    jj_la = xla; jj_lastpos = jj_scanpos = token;	    try { return !jj_3_31(); }	    catch(LookaheadSuccess ls) { return true; }	  }	
final private boolean jj_3R_46() {	    if (jj_3R_91()) return true;	    return false;	  }	
final private boolean jj_3R_28() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_46()) {	    jj_scanpos = xsp;	    if (jj_3R_47()) {	    jj_scanpos = xsp;	    if (jj_3R_48()) {	    jj_scanpos = xsp;	    if (jj_3R_49()) {	    jj_scanpos = xsp;	    if (jj_3_28()) {	    jj_scanpos = xsp;	    if (jj_3R_50()) {	    jj_scanpos = xsp;	    if (jj_3R_51()) {	    jj_scanpos = xsp;	    if (jj_3R_52()) return true;	    }	    }	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3_23() {	    if (jj_3R_28()) return true;	    return false;	  }	
final private boolean jj_3R_161() {	    if (jj_3R_164()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_169()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_38() {	    if (jj_scan_token(LBRACE)) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_23()) { jj_scanpos = xsp; break; }	    }	    if (jj_scan_token(RBRACE)) return true;	    return false;	  }	
final private boolean jj_3R_158() {	    if (jj_3R_161()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_167()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_40() {	    if (jj_scan_token(IDENTIFIER)) return true;	    if (jj_scan_token(COLON)) return true;	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_156() {	    if (jj_scan_token(HOOK)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(COLON)) return true;	    if (jj_3R_108()) return true;	    return false;	  }	
final private boolean jj_3R_165() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(108)) {	    jj_scanpos = xsp;	    if (jj_scan_token(109)) return true;	    }	    if (jj_3R_158()) return true;	    return false;	  }	
final private boolean jj_3R_153() {	    if (jj_3R_158()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_165()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_90() {	    if (jj_3R_124()) return true;	    return false;	  }	
final private boolean jj_3R_89() {	    if (jj_3R_123()) return true;	    return false;	  }	
final private boolean jj_3R_88() {	    if (jj_3R_122()) return true;	    return false;	  }	
final private boolean jj_3R_162() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(98)) {	    jj_scanpos = xsp;	    if (jj_scan_token(99)) return true;	    }	    if (jj_3R_153()) return true;	    return false;	  }	
final private boolean jj_3R_87() {	    if (jj_3R_121()) return true;	    return false;	  }	
final private boolean jj_3R_148() {	    if (jj_3R_153()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_162()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_86() {	    if (jj_3R_120()) return true;	    return false;	  }	
final private boolean jj_3R_85() {	    if (jj_3R_119()) return true;	    return false;	  }	
final private boolean jj_3R_84() {	    if (jj_3R_118()) return true;	    return false;	  }	
final private boolean jj_3R_159() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(96)) {	    jj_scanpos = xsp;	    if (jj_scan_token(97)) return true;	    }	    if (jj_3R_148()) return true;	    return false;	  }	
final private boolean jj_3R_83() {	    if (jj_3R_117()) return true;	    return false;	  }	
final private boolean jj_3R_135() {	    if (jj_3R_148()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_159()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_82() {	    if (jj_3R_116()) return true;	    return false;	  }	
final private boolean jj_3R_81() {	    if (jj_3R_115()) return true;	    return false;	  }	
final private boolean jj_3R_80() {	    if (jj_3R_114()) return true;	    return false;	  }	
final private boolean jj_3R_108() {	    if (jj_3R_135()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_156()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3R_79() {	    if (jj_3R_113()) return true;	    return false;	  }	
final private boolean jj_3R_78() {	    if (jj_3R_112()) return true;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3_17() {	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3R_77() {	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3R_45() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_22()) {	    jj_scanpos = xsp;	    if (jj_3R_77()) {	    jj_scanpos = xsp;	    if (jj_scan_token(78)) {	    jj_scanpos = xsp;	    if (jj_3R_78()) {	    jj_scanpos = xsp;	    if (jj_3R_79()) {	    jj_scanpos = xsp;	    if (jj_3R_80()) {	    jj_scanpos = xsp;	    if (jj_3R_81()) {	    jj_scanpos = xsp;	    if (jj_3R_82()) {	    jj_scanpos = xsp;	    lookingAhead = true;	    jj_semLA = isRegularForStatement();	    lookingAhead = false;	    if (!jj_semLA || jj_3R_83()) {	    jj_scanpos = xsp;	    if (jj_3R_84()) {	    jj_scanpos = xsp;	    if (jj_3R_85()) {	    jj_scanpos = xsp;	    if (jj_3R_86()) {	    jj_scanpos = xsp;	    if (jj_3R_87()) {	    jj_scanpos = xsp;	    if (jj_3R_88()) {	    jj_scanpos = xsp;	    if (jj_3R_89()) {	    jj_scanpos = xsp;	    if (jj_3R_90()) return true;	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3_22() {	    if (jj_3R_40()) return true;	    return false;	  }	
final private boolean jj_3R_34() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(81)) {	    jj_scanpos = xsp;	    if (jj_scan_token(120)) {	    jj_scanpos = xsp;	    if (jj_scan_token(121)) {	    jj_scanpos = xsp;	    if (jj_scan_token(127)) {	    jj_scanpos = xsp;	    if (jj_scan_token(118)) {	    jj_scanpos = xsp;	    if (jj_scan_token(119)) {	    jj_scanpos = xsp;	    if (jj_scan_token(122)) {	    jj_scanpos = xsp;	    if (jj_scan_token(126)) {	    jj_scanpos = xsp;	    if (jj_scan_token(124)) {	    jj_scanpos = xsp;	    if (jj_scan_token(128)) {	    jj_scanpos = xsp;	    if (jj_scan_token(129)) {	    jj_scanpos = xsp;	    if (jj_scan_token(130)) {	    jj_scanpos = xsp;	    if (jj_scan_token(131)) {	    jj_scanpos = xsp;	    if (jj_scan_token(132)) {	    jj_scanpos = xsp;	    if (jj_scan_token(133)) return true;	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_111() {	    if (jj_scan_token(COMMA)) return true;	    if (jj_3R_29()) return true;	    return false;	  }	
final private boolean jj_3R_160() {	    if (jj_scan_token(LBRACKET)) return true;	    if (jj_scan_token(RBRACKET)) return true;	    return false;	  }	
final private boolean jj_3R_152() {	    if (jj_3R_69()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_17()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3R_157() {	    Token xsp;	    if (jj_3R_160()) return true;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_160()) { jj_scanpos = xsp; break; }	    }	    if (jj_3R_97()) return true;	    return false;	  }	
final private boolean jj_3_8() {	    if (jj_3R_33()) return true;	    if (jj_3R_34()) return true;	    return false;	  }	
final private boolean jj_3_20() {	    if (jj_scan_token(LBRACKET)) return true;	    if (jj_scan_token(RBRACKET)) return true;	    return false;	  }	
final private boolean jj_3R_151() {	    if (jj_3R_150()) return true;	    return false;	  }	
final private boolean jj_3_19() {	    if (jj_scan_token(LBRACKET)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RBRACKET)) return true;	    return false;	  }	
final private boolean jj_3R_107() {	    if (jj_3R_33()) return true;	    if (jj_3R_34()) return true;	    if (jj_3R_39()) return true;	    return false;	  }	
final private boolean jj_3_21() {	    Token xsp;	    if (jj_3_19()) return true;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_19()) { jj_scanpos = xsp; break; }	    }	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_20()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_150() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_21()) {	    jj_scanpos = xsp;	    if (jj_3R_157()) return true;	    }	    return false;	  }	
final private boolean jj_3R_71() {	    if (jj_3R_108()) return true;	    return false;	  }	
final private boolean jj_3R_39() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_70()) {	    jj_scanpos = xsp;	    if (jj_3R_71()) return true;	    }	    return false;	  }	
final private boolean jj_3R_70() {	    if (jj_3R_107()) return true;	    return false;	  }	
final private boolean jj_3R_145() {	    if (jj_scan_token(NEW)) return true;	    if (jj_3R_29()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_151()) {	    jj_scanpos = xsp;	    if (jj_3R_152()) return true;	    }	    return false;	  }	
final private boolean jj_3_18() {	    if (jj_scan_token(NEW)) return true;	    if (jj_3R_36()) return true;	    if (jj_3R_150()) return true;	    return false;	  }	
final private boolean jj_3R_130() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_18()) {	    jj_scanpos = xsp;	    if (jj_3R_145()) return true;	    }	    return false;	  }	
final private boolean jj_3R_147() {	    if (jj_scan_token(COMMA)) return true;	    if (jj_3R_39()) return true;	    return false;	  }	
final private boolean jj_3R_76() {	    if (jj_3R_29()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_111()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_134() {	    if (jj_3R_39()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_147()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_106() {	    if (jj_3R_134()) return true;	    return false;	  }	
final private boolean jj_3_7() {	    if (jj_scan_token(DOT)) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3R_69() {	    if (jj_scan_token(LPAREN)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_106()) jj_scanpos = xsp;	    if (jj_scan_token(RPAREN)) return true;	    return false;	  }	
final private boolean jj_3R_29() {	    if (jj_scan_token(IDENTIFIER)) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_7()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_68() {	    if (jj_scan_token(DOUBLE)) return true;	    return false;	  }	
final private boolean jj_3R_67() {	    if (jj_scan_token(FLOAT)) return true;	    return false;	  }	
final private boolean jj_3R_155() {	    if (jj_scan_token(FALSE)) return true;	    return false;	  }	
final private boolean jj_3R_66() {	    if (jj_scan_token(LONG)) return true;	    return false;	  }	
final private boolean jj_3R_65() {	    if (jj_scan_token(INT)) return true;	    return false;	  }	
final private boolean jj_3R_154() {	    if (jj_scan_token(TRUE)) return true;	    return false;	  }	
final private boolean jj_3R_149() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_154()) {	    jj_scanpos = xsp;	    if (jj_3R_155()) return true;	    }	    return false;	  }	
final private boolean jj_3R_64() {	    if (jj_scan_token(SHORT)) return true;	    return false;	  }	
final private boolean jj_3R_56() {	    if (jj_3R_29()) return true;	    return false;	  }	
final private boolean jj_3R_63() {	    if (jj_scan_token(BYTE)) return true;	    return false;	  }	
final private boolean jj_3R_62() {	    if (jj_scan_token(CHAR)) return true;	    return false;	  }	
final private boolean jj_3R_61() {	    if (jj_scan_token(BOOLEAN)) return true;	    return false;	  }	
final private boolean jj_3R_36() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_61()) {	    jj_scanpos = xsp;	    if (jj_3R_62()) {	    jj_scanpos = xsp;	    if (jj_3R_63()) {	    jj_scanpos = xsp;	    if (jj_3R_64()) {	    jj_scanpos = xsp;	    if (jj_3R_65()) {	    jj_scanpos = xsp;	    if (jj_3R_66()) {	    jj_scanpos = xsp;	    if (jj_3R_67()) {	    jj_scanpos = xsp;	    if (jj_3R_68()) return true;	    }	    }	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_144() {	    if (jj_scan_token(57)) return true;	    return false;	  }	
final private boolean jj_3R_74() {	    if (jj_3R_32()) return true;	    return false;	  }	
final private boolean jj_3R_42() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_73()) {	    jj_scanpos = xsp;	    if (jj_3R_74()) return true;	    }	    return false;	  }	
final private boolean jj_3R_73() {	    if (jj_scan_token(VOID)) return true;	    return false;	  }	
final private boolean jj_3R_143() {	    if (jj_scan_token(41)) return true;	    return false;	  }	
final private boolean jj_3_6() {	    if (jj_scan_token(LBRACKET)) return true;	    if (jj_scan_token(RBRACKET)) return true;	    return false;	  }	
final private boolean jj_3R_142() {	    if (jj_3R_149()) return true;	    return false;	  }	
final private boolean jj_3R_55() {	    if (jj_3R_36()) return true;	    return false;	  }	
final private boolean jj_3R_110() {	    if (jj_scan_token(COMMA)) return true;	    if (jj_3R_109()) return true;	    return false;	  }	
final private boolean jj_3R_141() {	    if (jj_scan_token(STRING_LITERAL)) return true;	    return false;	  }	
final private boolean jj_3R_32() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_55()) {	    jj_scanpos = xsp;	    if (jj_3R_56()) return true;	    }	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_6()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_140() {	    if (jj_scan_token(CHARACTER_LITERAL)) return true;	    return false;	  }	
final private boolean jj_3R_190() {	    if (jj_scan_token(FINALLY)) return true;	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3_4() {	    if (jj_scan_token(COMMA)) return true;	    if (jj_3R_31()) return true;	    return false;	  }	
final private boolean jj_3R_189() {	    if (jj_scan_token(CATCH)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_109()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3R_136() {	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3_5() {	    if (jj_3R_32()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3R_75() {	    if (jj_3R_109()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_110()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_109() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_5()) {	    jj_scanpos = xsp;	    if (jj_3R_136()) return true;	    }	    return false;	  }	
final private boolean jj_3R_124() {	    if (jj_scan_token(TRY)) return true;	    if (jj_3R_38()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_189()) { jj_scanpos = xsp; break; }	    }	    xsp = jj_scanpos;	    if (jj_3R_190()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3R_43() {	    if (jj_scan_token(LPAREN)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_75()) jj_scanpos = xsp;	    if (jj_scan_token(RPAREN)) return true;	    return false;	  }	
final private boolean jj_3R_163() {	    if (jj_3R_31()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_4()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_139() {	    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;	    return false;	  }	
final private boolean jj_3R_97() {	    if (jj_scan_token(LBRACE)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_163()) jj_scanpos = xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(79)) jj_scanpos = xsp;	    if (jj_scan_token(RBRACE)) return true;	    return false;	  }	
final private boolean jj_3R_30() {	    if (jj_scan_token(DOT)) return true;	    if (jj_scan_token(STAR)) return true;	    return false;	  }	
final private boolean jj_3R_123() {	    if (jj_scan_token(THROW)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3R_180() {	    if (jj_scan_token(ASSIGN)) return true;	    if (jj_3R_31()) return true;	    return false;	  }	
final private boolean jj_3R_54() {	    if (jj_3R_39()) return true;	    return false;	  }	
final private boolean jj_3R_188() {	    if (jj_3R_39()) return true;	    return false;	  }	
final private boolean jj_3R_53() {	    if (jj_3R_97()) return true;	    return false;	  }	
final private boolean jj_3R_31() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_53()) {	    jj_scanpos = xsp;	    if (jj_3R_54()) return true;	    }	    return false;	  }	
final private boolean jj_3R_122() {	    if (jj_scan_token(SYNCHRONIZED)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3R_177() {	    if (jj_scan_token(COMMA)) return true;	    if (jj_3R_176()) return true;	    return false;	  }	
final private boolean jj_3R_210() {	    if (jj_scan_token(COMMA)) return true;	    if (jj_3R_112()) return true;	    return false;	  }	
final private boolean jj_3R_121() {	    if (jj_scan_token(RETURN)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_188()) jj_scanpos = xsp;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3R_129() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_138()) {	    jj_scanpos = xsp;	    if (jj_3R_139()) {	    jj_scanpos = xsp;	    if (jj_3R_140()) {	    jj_scanpos = xsp;	    if (jj_3R_141()) {	    jj_scanpos = xsp;	    if (jj_3R_142()) {	    jj_scanpos = xsp;	    if (jj_3R_143()) {	    jj_scanpos = xsp;	    if (jj_3R_144()) return true;	    }	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_138() {	    if (jj_scan_token(INTEGER_LITERAL)) return true;	    return false;	  }	
final private boolean jj_3R_146() {	    if (jj_3R_69()) return true;	    return false;	  }	
final private boolean jj_3R_176() {	    if (jj_scan_token(IDENTIFIER)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_180()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3R_105() {	    if (jj_3R_129()) return true;	    return false;	  }	
final private boolean jj_3R_120() {	    if (jj_scan_token(CONTINUE)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(69)) jj_scanpos = xsp;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3R_119() {	    if (jj_scan_token(BREAK)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(69)) jj_scanpos = xsp;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3R_195() {	    if (jj_3R_205()) return true;	    return false;	  }	
final private boolean jj_3R_128() {	    if (jj_scan_token(IMPORT)) return true;	    if (jj_scan_token(STAR)) return true;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3R_133() {	    if (jj_scan_token(LBRACE)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RBRACE)) return true;	    return false;	  }	
final private boolean jj_3R_205() {	    if (jj_3R_112()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_210()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_132() {	    if (jj_scan_token(DOT)) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_146()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3_3() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(48)) jj_scanpos = xsp;	    if (jj_scan_token(IMPORT)) return true;	    if (jj_3R_29()) return true;	    xsp = jj_scanpos;	    if (jj_3R_30()) jj_scanpos = xsp;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3R_94() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_3()) {	    jj_scanpos = xsp;	    if (jj_3R_128()) return true;	    }	    return false;	  }	
final private boolean jj_3R_93() {	    if (jj_3R_41()) return true;	    if (jj_3R_32()) return true;	    if (jj_3R_176()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_177()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_131() {	    if (jj_scan_token(LBRACKET)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RBRACKET)) return true;	    return false;	  }	
final private boolean jj_3R_95() {	    if (jj_scan_token(PACKAGE)) return true;	    if (jj_3R_29()) return true;	    return false;	  }	
final private boolean jj_3_2() {	    if (jj_scan_token(IDENTIFIER)) return true;	    if (jj_scan_token(LPAREN)) return true;	    return false;	  }	
final private boolean jj_3R_175() {	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3_16() {	    if (jj_scan_token(DOT)) return true;	    if (jj_scan_token(CLASS)) return true;	    return false;	  }	
final private boolean jj_3R_104() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_16()) {	    jj_scanpos = xsp;	    if (jj_3R_131()) {	    jj_scanpos = xsp;	    if (jj_3R_132()) {	    jj_scanpos = xsp;	    if (jj_3R_133()) return true;	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_174() {	    if (jj_scan_token(THROWS)) return true;	    if (jj_3R_76()) return true;	    return false;	  }	
final private boolean jj_3_15() {	    if (jj_3R_32()) return true;	    if (jj_scan_token(DOT)) return true;	    if (jj_scan_token(CLASS)) return true;	    return false;	  }	
final private boolean jj_3_31() {	    if (jj_3R_41()) return true;	    if (jj_3R_32()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3_14() {	    if (jj_3R_37()) return true;	    return false;	  }	
final private boolean jj_3R_126() {	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3R_127() {	    if (jj_3R_42()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3R_92() {	    if (jj_3R_41()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_126()) {	    jj_scanpos = xsp;	    if (jj_3R_127()) return true;	    }	    if (jj_3R_43()) return true;	    xsp = jj_scanpos;	    if (jj_3R_174()) jj_scanpos = xsp;	    xsp = jj_scanpos;	    if (jj_3R_175()) {	    jj_scanpos = xsp;	    if (jj_scan_token(78)) return true;	    }	    return false;	  }	
final private boolean jj_3R_204() {	    if (jj_3R_205()) return true;	    return false;	  }	
final private boolean jj_3R_103() {	    if (jj_3R_29()) return true;	    return false;	  }	
final private boolean jj_3R_203() {	    if (jj_3R_93()) return true;	    return false;	  }	
final private boolean jj_3R_194() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_203()) {	    jj_scanpos = xsp;	    if (jj_3R_204()) return true;	    }	    return false;	  }	
final private boolean jj_3R_102() {	    if (jj_3R_32()) return true;	    return false;	  }	
final private boolean jj_3R_58() {	    if (jj_3R_104()) return true;	    return false;	  }	
final private boolean jj_3R_125() {	    if (jj_scan_token(INTERFACE)) return true;	    return false;	  }	
final private boolean jj_3R_101() {	    if (jj_3R_37()) return true;	    return false;	  }	
final private boolean jj_3R_100() {	    if (jj_3R_130()) return true;	    return false;	  }	
final private boolean jj_3R_99() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    return false;	  }	
final private boolean jj_3R_137() {	    if (jj_scan_token(FOR)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_32()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    if (jj_scan_token(COLON)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_184() {	    if (jj_scan_token(ELSE)) return true;	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_173() {	    if (jj_scan_token(IMPLEMENTS)) return true;	    if (jj_3R_76()) return true;	    return false;	  }	
final private boolean jj_3R_57() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_98()) {	    jj_scanpos = xsp;	    if (jj_3R_99()) {	    jj_scanpos = xsp;	    if (jj_3R_100()) {	    jj_scanpos = xsp;	    if (jj_3R_101()) {	    jj_scanpos = xsp;	    if (jj_3R_102()) {	    jj_scanpos = xsp;	    if (jj_3R_103()) return true;	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_98() {	    if (jj_3R_129()) return true;	    return false;	  }	
final private boolean jj_3R_172() {	    if (jj_scan_token(EXTENDS)) return true;	    if (jj_3R_29()) return true;	    return false;	  }	
final private boolean jj_3_30() {	    if (jj_scan_token(FOR)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    if (jj_scan_token(COLON)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_118() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_30()) {	    jj_scanpos = xsp;	    if (jj_3R_137()) return true;	    }	    return false;	  }	
final private boolean jj_3R_37() {	    if (jj_3R_29()) return true;	    if (jj_3R_69()) return true;	    return false;	  }	
final private boolean jj_3R_185() {	    if (jj_3R_194()) return true;	    return false;	  }	
final private boolean jj_3R_91() {	    if (jj_3R_41()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(13)) {	    jj_scanpos = xsp;	    if (jj_3R_125()) return true;	    }	    if (jj_scan_token(IDENTIFIER)) return true;	    xsp = jj_scanpos;	    if (jj_3R_172()) jj_scanpos = xsp;	    xsp = jj_scanpos;	    if (jj_3R_173()) jj_scanpos = xsp;	    if (jj_3R_38()) return true;	    return false;	  }	
final private boolean jj_3_13() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_36()) return true;	    return false;	  }	
final private boolean jj_3R_187() {	    if (jj_3R_195()) return true;	    return false;	  }	
final private boolean jj_3R_186() {	    if (jj_3R_39()) return true;	    return false;	  }	
final private boolean jj_3R_33() {	    if (jj_3R_57()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_58()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_217() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_32()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_208()) return true;	    return false;	  }	
final private boolean jj_3R_216() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_32()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_191()) return true;	    return false;	  }	
final private boolean jj_3R_117() {	    if (jj_scan_token(FOR)) return true;	    if (jj_scan_token(LPAREN)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_185()) jj_scanpos = xsp;	    if (jj_scan_token(SEMICOLON)) return true;	    xsp = jj_scanpos;	    if (jj_3R_186()) jj_scanpos = xsp;	    if (jj_scan_token(SEMICOLON)) return true;	    xsp = jj_scanpos;	    if (jj_3R_187()) jj_scanpos = xsp;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_214() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_216()) {	    jj_scanpos = xsp;	    if (jj_3R_217()) return true;	    }	    return false;	  }	
final private boolean jj_3_12() {	    if (jj_3R_33()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(100)) {	    jj_scanpos = xsp;	    if (jj_scan_token(101)) return true;	    }	    return false;	  }	
final private boolean jj_3R_219() {	    if (jj_3R_33()) return true;	    return false;	  }	
final private boolean jj_3R_116() {	    if (jj_scan_token(DO)) return true;	    if (jj_3R_45()) return true;	    if (jj_scan_token(WHILE)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3_11() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_29()) return true;	    if (jj_scan_token(LBRACKET)) return true;	    return false;	  }	
final private boolean jj_3R_218() {	    if (jj_3R_33()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(100)) {	    jj_scanpos = xsp;	    if (jj_scan_token(101)) return true;	    }	    return false;	  }	
final private boolean jj_3R_215() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_218()) {	    jj_scanpos = xsp;	    if (jj_3R_219()) return true;	    }	    return false;	  }	
final private boolean jj_3R_72() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(43)) {	    jj_scanpos = xsp;	    if (jj_scan_token(44)) {	    jj_scanpos = xsp;	    if (jj_scan_token(45)) {	    jj_scanpos = xsp;	    if (jj_scan_token(51)) {	    jj_scanpos = xsp;	    if (jj_scan_token(27)) {	    jj_scanpos = xsp;	    if (jj_scan_token(39)) {	    jj_scanpos = xsp;	    if (jj_scan_token(52)) {	    jj_scanpos = xsp;	    if (jj_scan_token(58)) {	    jj_scanpos = xsp;	    if (jj_scan_token(10)) {	    jj_scanpos = xsp;	    if (jj_scan_token(48)) {	    jj_scanpos = xsp;	    if (jj_scan_token(49)) return true;	    }	    }	    }	    }	    }	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_115() {	    if (jj_scan_token(WHILE)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_60() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_29()) return true;	    if (jj_scan_token(RPAREN)) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(87)) {	    jj_scanpos = xsp;	    if (jj_scan_token(86)) {	    jj_scanpos = xsp;	    if (jj_scan_token(72)) {	    jj_scanpos = xsp;	    if (jj_scan_token(69)) {	    jj_scanpos = xsp;	    if (jj_scan_token(40)) {	    jj_scanpos = xsp;	    if (jj_3R_105()) return true;	    }	    }	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_59() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_29()) return true;	    if (jj_scan_token(LBRACKET)) return true;	    if (jj_scan_token(RBRACKET)) return true;	    return false;	  }	
final private boolean jj_3_9() {	    if (jj_3R_35()) return true;	    return false;	  }	
final private boolean jj_3_29() {	    if (jj_3R_28()) return true;	    return false;	  }	
final private boolean jj_3R_114() {	    if (jj_scan_token(IF)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_3R_45()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_184()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3R_41() {	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_72()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_35() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3_10()) {	    jj_scanpos = xsp;	    if (jj_3R_59()) {	    jj_scanpos = xsp;	    if (jj_3R_60()) return true;	    }	    }	    return false;	  }	
final private boolean jj_3_10() {	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_36()) return true;	    return false;	  }	
final private boolean jj_3R_213() {	    if (jj_3R_215()) return true;	    return false;	  }	
final private boolean jj_3R_212() {	    if (jj_3R_214()) return true;	    return false;	  }	
final private boolean jj_3R_202() {	    if (jj_scan_token(_DEFAULT)) return true;	    if (jj_scan_token(COLON)) return true;	    return false;	  }	
final private boolean jj_3R_211() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(87)) {	    jj_scanpos = xsp;	    if (jj_scan_token(86)) return true;	    }	    if (jj_3R_191()) return true;	    return false;	  }	
final private boolean jj_3R_208() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_211()) {	    jj_scanpos = xsp;	    if (jj_3R_212()) {	    jj_scanpos = xsp;	    if (jj_3R_213()) return true;	    }	    }	    return false;	  }	
final private boolean jj_3R_201() {	    if (jj_scan_token(CASE)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(COLON)) return true;	    return false;	  }	
final private boolean jj_3R_193() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_201()) {	    jj_scanpos = xsp;	    if (jj_3R_202()) return true;	    }	    return false;	  }	
final private boolean jj_3R_183() {	    if (jj_3R_193()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3_29()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_207() {	    if (jj_scan_token(DECR)) return true;	    if (jj_3R_33()) return true;	    return false;	  }	
final private boolean jj_3_1() {	    if (jj_3R_28()) return true;	    return false;	  }	
final private boolean jj_3R_113() {	    if (jj_scan_token(SWITCH)) return true;	    if (jj_scan_token(LPAREN)) return true;	    if (jj_3R_39()) return true;	    if (jj_scan_token(RPAREN)) return true;	    if (jj_scan_token(LBRACE)) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_183()) { jj_scanpos = xsp; break; }	    }	    if (jj_scan_token(RBRACE)) return true;	    return false;	  }	
final private boolean jj_3R_209() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(104)) {	    jj_scanpos = xsp;	    if (jj_scan_token(105)) {	    jj_scanpos = xsp;	    if (jj_scan_token(111)) return true;	    }	    }	    if (jj_3R_191()) return true;	    return false;	  }	
final private boolean jj_3R_206() {	    if (jj_scan_token(INCR)) return true;	    if (jj_3R_33()) return true;	    return false;	  }	
final private boolean jj_3R_199() {	    if (jj_3R_208()) return true;	    return false;	  }	
final private boolean jj_3R_198() {	    if (jj_3R_207()) return true;	    return false;	  }	
final private boolean jj_3R_197() {	    if (jj_3R_206()) return true;	    return false;	  }	
final private boolean jj_3R_196() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(102)) {	    jj_scanpos = xsp;	    if (jj_scan_token(103)) return true;	    }	    if (jj_3R_191()) return true;	    return false;	  }	
final private boolean jj_3R_191() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_196()) {	    jj_scanpos = xsp;	    if (jj_3R_197()) {	    jj_scanpos = xsp;	    if (jj_3R_198()) {	    jj_scanpos = xsp;	    if (jj_3R_199()) return true;	    }	    }	    }	    return false;	  }	
final private boolean jj_3R_44() {	    if (jj_scan_token(THROWS)) return true;	    if (jj_3R_76()) return true;	    return false;	  }	
final private boolean jj_3R_112() {	    if (jj_3R_39()) return true;	    return false;	  }	
final private boolean jj_3R_181() {	    if (jj_3R_191()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_209()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_200() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(102)) {	    jj_scanpos = xsp;	    if (jj_scan_token(103)) return true;	    }	    if (jj_3R_181()) return true;	    return false;	  }	
final private boolean jj_3R_178() {	    if (jj_3R_181()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_200()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_96() {	    if (jj_scan_token(FORMAL_COMMENT)) return true;	    return false;	  }	
final private boolean jj_3R_192() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(112)) {	    jj_scanpos = xsp;	    if (jj_scan_token(113)) {	    jj_scanpos = xsp;	    if (jj_scan_token(114)) {	    jj_scanpos = xsp;	    if (jj_scan_token(115)) {	    jj_scanpos = xsp;	    if (jj_scan_token(116)) {	    jj_scanpos = xsp;	    if (jj_scan_token(117)) return true;	    }	    }	    }	    }	    }	    if (jj_3R_178()) return true;	    return false;	  }	
final private boolean jj_3R_171() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(90)) {	    jj_scanpos = xsp;	    if (jj_scan_token(95)) return true;	    }	    if (jj_3R_166()) return true;	    return false;	  }	
final private boolean jj_3R_170() {	    if (jj_3R_178()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_192()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_52() {	    if (jj_3R_96()) return true;	    return false;	  }	
final private boolean jj_3R_182() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(84)) {	    jj_scanpos = xsp;	    if (jj_scan_token(85)) {	    jj_scanpos = xsp;	    if (jj_scan_token(82)) {	    jj_scanpos = xsp;	    if (jj_scan_token(83)) {	    jj_scanpos = xsp;	    if (jj_scan_token(91)) {	    jj_scanpos = xsp;	    if (jj_scan_token(92)) {	    jj_scanpos = xsp;	    if (jj_scan_token(93)) {	    jj_scanpos = xsp;	    if (jj_scan_token(94)) return true;	    }	    }	    }	    }	    }	    }	    }	    if (jj_3R_170()) return true;	    return false;	  }	
final private boolean jj_3_27() {	    if (jj_3R_41()) return true;	    if (jj_3R_32()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    return false;	  }	
final private boolean jj_3R_51() {	    if (jj_3R_95()) return true;	    return false;	  }	
final private boolean jj_3R_168() {	    if (jj_3R_170()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_182()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_50() {	    if (jj_3R_94()) return true;	    return false;	  }	
final private boolean jj_3_26() {	    if (jj_3R_41()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    if (jj_3R_43()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_44()) jj_scanpos = xsp;	    if (jj_scan_token(LBRACE)) return true;	    return false;	  }	
final private boolean jj_3R_179() {	    if (jj_scan_token(INSTANCEOF)) return true;	    if (jj_3R_32()) return true;	    return false;	  }	
final private boolean jj_3_28() {	    if (jj_3R_45()) return true;	    return false;	  }	
final private boolean jj_3R_166() {	    if (jj_3R_168()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_3R_179()) jj_scanpos = xsp;	    return false;	  }	
final private boolean jj_3_25() {	    if (jj_3R_41()) return true;	    if (jj_3R_42()) return true;	    if (jj_scan_token(IDENTIFIER)) return true;	    if (jj_scan_token(LPAREN)) return true;	    return false;	  }	
final private boolean jj_3R_49() {	    if (jj_3R_93()) return true;	    if (jj_scan_token(SEMICOLON)) return true;	    return false;	  }	
final private boolean jj_3_24() {	    if (jj_3R_41()) return true;	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(13)) {	    jj_scanpos = xsp;	    if (jj_scan_token(37)) return true;	    }	    return false;	  }	
final private boolean jj_3R_167() {	    if (jj_scan_token(XOR)) return true;	    if (jj_3R_161()) return true;	    return false;	  }	
final private boolean jj_3R_48() {	    if (jj_3R_92()) return true;	    return false;	  }	
final private boolean jj_3R_164() {	    if (jj_3R_166()) return true;	    Token xsp;	    while (true) {	      xsp = jj_scanpos;	      if (jj_3R_171()) { jj_scanpos = xsp; break; }	    }	    return false;	  }	
final private boolean jj_3R_47() {	    if (jj_3R_92()) return true;	    return false;	  }	
final private boolean jj_3R_169() {	    Token xsp;	    xsp = jj_scanpos;	    if (jj_scan_token(106)) {	    jj_scanpos = xsp;	    if (jj_scan_token(107)) return true;	    }	    if (jj_3R_164()) return true;	    return false;	  }	
public Parser(java.io.InputStream stream) {	    jj_input_stream = new JavaCharStream(stream, 1, 1);	    token_source = new ParserTokenManager(jj_input_stream);	    token = new Token();	    jj_ntk = -1;	  }	
public void ReInit(java.io.InputStream stream) {	    jj_input_stream.ReInit(stream, 1, 1);	    token_source.ReInit(jj_input_stream);	    token = new Token();	    jj_ntk = -1;	    jjtree.reset();	  }	
public Parser(java.io.Reader stream) {	    jj_input_stream = new JavaCharStream(stream, 1, 1);	    token_source = new ParserTokenManager(jj_input_stream);	    token = new Token();	    jj_ntk = -1;	  }	
public void ReInit(java.io.Reader stream) {	    jj_input_stream.ReInit(stream, 1, 1);	    token_source.ReInit(jj_input_stream);	    token = new Token();	    jj_ntk = -1;	    jjtree.reset();	  }	
public Parser(ParserTokenManager tm) {	    token_source = tm;	    token = new Token();	    jj_ntk = -1;	  }	
public void ReInit(ParserTokenManager tm) {	    token_source = tm;	    token = new Token();	    jj_ntk = -1;	    jjtree.reset();	  }	
final private Token jj_consume_token(int kind) throws ParseException {	    Token oldToken;	    if ((oldToken = token).next != null) token = token.next;	    else token = token.next = token_source.getNextToken();	    jj_ntk = -1;	    if (token.kind == kind) {	      return token;	    }	    token = oldToken;	    throw generateParseException();	  }	
final private boolean jj_scan_token(int kind) {	    if (jj_scanpos == jj_lastpos) {	      jj_la--;	      if (jj_scanpos.next == null) {	        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();	      } else {	        jj_lastpos = jj_scanpos = jj_scanpos.next;	      }	    } else {	      jj_scanpos = jj_scanpos.next;	    }	    if (jj_scanpos.kind != kind) return true;	    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;	    return false;	  }	
final public Token getNextToken() {	    if (token.next != null) token = token.next;	    else token = token.next = token_source.getNextToken();	    jj_ntk = -1;	    return token;	  }	
final public Token getToken(int index) {	    Token t = lookingAhead ? jj_scanpos : token;	    for (int i = 0; i < index; i++) {	      if (t.next != null) t = t.next;	      else t = t.next = token_source.getNextToken();	    }	    return t;	  }	
final private int jj_ntk() {	    if ((jj_nt=token.next) == null)	      return (jj_ntk = (token.next=token_source.getNextToken()).kind);	    else	      return (jj_ntk = jj_nt.kind);	  }	
public ParseException generateParseException() {	    Token errortok = token.next;	    int line = errortok.beginLine, column = errortok.beginColumn;	    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;	    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);	  }	
final public void enable_tracing() {	  }	
final public void disable_tracing() {	  }	
public static final ParserRule createSequenceRule(			int posMatch, String seq, ParserRuleSet delegate, byte id)		{			return new ParserRule(SEQ, seq.substring(0,1),				posMatch, seq.toCharArray(), null,				0, null, delegate, id, MATCH_TYPE_CONTEXT, null);		}	
/**		 * @deprecated Use {@link #createRegexpSequenceRule(String,int,String,ParserRuleSet,byte,boolean)} instead		 */		public static final ParserRule createRegexpSequenceRule(			char hashChar, int posMatch, String seq,			ParserRuleSet delegate, byte id, boolean ignoreCase)			throws PatternSyntaxException		{			return createRegexpSequenceRule(String.valueOf(hashChar), posMatch,				seq, delegate, id, ignoreCase);		}	
public static final ParserRule createRegexpSequenceRule(			String hashChar, int posMatch, String seq,			ParserRuleSet delegate, byte id, boolean ignoreCase)			throws PatternSyntaxException		{			return new ParserRule(SEQ | REGEXP, hashChar, posMatch,				null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),				0, null, delegate, id, MATCH_TYPE_CONTEXT, null);		}	
public static final ParserRule createRegexpSequenceRule(			int posMatch, char[] hashChars, String seq,			ParserRuleSet delegate, byte id, boolean ignoreCase)			throws PatternSyntaxException		{			return new ParserRule(hashChars, SEQ | REGEXP, posMatch,				null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),				0, null, delegate, id, MATCH_TYPE_CONTEXT, null);		}	
public static final ParserRule createSpanRule(			int startPosMatch, String start, int endPosMatch, String end,			ParserRuleSet delegate, byte id, byte matchType,			boolean noLineBreak, boolean noWordBreak, String escape)		{			int ruleAction = SPAN |				((noLineBreak) ? NO_LINE_BREAK : 0) |				((noWordBreak) ? NO_WORD_BREAK : 0);				return new ParserRule(ruleAction, start.substring(0,1), startPosMatch,				start.toCharArray(), null,				endPosMatch, end.toCharArray(),				delegate, id, matchType, escape);		}	
public static final ParserRule createRegexpSpanRule(			String hashChar, int startPosMatch, String start,			int endPosMatch, String end, ParserRuleSet delegate, byte id,			byte matchType, boolean noLineBreak, boolean noWordBreak,			boolean ignoreCase, String escape)			throws PatternSyntaxException		{			int ruleAction = SPAN | REGEXP |				((noLineBreak) ? NO_LINE_BREAK : 0) |				((noWordBreak) ? NO_WORD_BREAK : 0);				return new ParserRule(ruleAction, hashChar, startPosMatch, null,				Pattern.compile(start,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),				endPosMatch, end.toCharArray(), delegate, id, matchType,				escape);		}	
public static final ParserRule createRegexpSpanRule(			int startPosMatch, char[] hashChars, String start,			int endPosMatch, String end, ParserRuleSet delegate, byte id,			byte matchType, boolean noLineBreak, boolean noWordBreak,			boolean ignoreCase, String escape)			throws PatternSyntaxException		{			int ruleAction = SPAN | REGEXP |				((noLineBreak) ? NO_LINE_BREAK : 0) |				((noWordBreak) ? NO_WORD_BREAK : 0);				return new ParserRule(hashChars, ruleAction, startPosMatch, null,				Pattern.compile(start,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),				endPosMatch, end.toCharArray(), delegate, id,				matchType, escape);		}	
public static final ParserRule createEOLSpanRule(			int posMatch, String seq, ParserRuleSet delegate, byte id,			byte matchType)		{			int ruleAction = EOL_SPAN | NO_LINE_BREAK;				return new ParserRule(ruleAction, seq.substring(0,1), posMatch,				seq.toCharArray(), null, 0, null,				delegate, id, matchType, null);		}	
/**		 * @deprecated Use {@link #createRegexpEOLSpanRule(String,int,String,ParserRuleSet,byte,byte,boolean)} instead		 */		public static final ParserRule createRegexpEOLSpanRule(			char hashChar, int posMatch, String seq, ParserRuleSet delegate,			byte id, byte matchType, boolean ignoreCase)			throws PatternSyntaxException		{			return createRegexpEOLSpanRule(String.valueOf(hashChar),				posMatch,seq,delegate,id,matchType,ignoreCase);		}	
public static final ParserRule createRegexpEOLSpanRule(			String hashChar, int posMatch, String seq, ParserRuleSet delegate,			byte id, byte matchType, boolean ignoreCase)			throws PatternSyntaxException		{			int ruleAction = EOL_SPAN | REGEXP | NO_LINE_BREAK;				return new ParserRule(ruleAction, hashChar, posMatch,				null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),				0, null, delegate, id, matchType, null);		}	
public static final ParserRule createRegexpEOLSpanRule(			int posMatch, char[] hashChars, String seq, ParserRuleSet delegate,			byte id, byte matchType, boolean ignoreCase)			throws PatternSyntaxException		{			int ruleAction = EOL_SPAN | REGEXP | NO_LINE_BREAK;				return new ParserRule(hashChars, ruleAction, posMatch,				null, Pattern.compile(seq,(ignoreCase ? Pattern.CASE_INSENSITIVE : 0)),				0, null, delegate, id, matchType, null);		}	
public static final ParserRule createMarkFollowingRule(			int posMatch, String seq, byte id, byte matchType)		{			int ruleAction = MARK_FOLLOWING;				return new ParserRule(ruleAction, seq.substring(0,1), posMatch,				seq.toCharArray(), null, 0, null, null, id, matchType,				null);		}	
public static final ParserRule createMarkPreviousRule(			int posMatch, String seq, byte id, byte matchType)		{			int ruleAction = MARK_PREVIOUS;				return new ParserRule(ruleAction, seq.substring(0,1), posMatch,				seq.toCharArray(), null, 0, null, null, id, matchType,				null);		}	
public static final ParserRule createEscapeRule(String seq)		{			int ruleAction = IS_ESCAPE;				return new ParserRule(ruleAction, seq.substring(0,1),				0, seq.toCharArray(), null, 0, null,				null, Token.NULL, MATCH_TYPE_CONTEXT, null);		}	
public String toString()		{			StringBuilder result = new StringBuilder();			result.append(getClass().getName()).append("[action=");			switch (action & MAJOR_ACTIONS)			{				case SEQ: result.append("SEQ"); break;				case SPAN: result.append("SPAN"); break;				case MARK_PREVIOUS: result.append("MARK_PREVIOUS"); break;				case MARK_FOLLOWING: result.append("MARK_FOLLOWING"); break;				case EOL_SPAN: result.append("EOL_SPAN"); break;				default: result.append("UNKNOWN"); break;			}			int actionHints = action & ACTION_HINTS;			result.append("[matchType=").append(matchType == MATCH_TYPE_CONTEXT ? "MATCH_TYPE_CONTEXT" : (matchType == MATCH_TYPE_RULE ? "MATCH_TYPE_RULE" : Token.tokenToString(matchType)));			result.append(",NO_LINE_BREAK=").append((actionHints & NO_LINE_BREAK) != 0);			result.append(",NO_WORD_BREAK=").append((actionHints & NO_WORD_BREAK) != 0);			result.append(",IS_ESCAPE=").append((actionHints & IS_ESCAPE) != 0);			result.append(",REGEXP=").append((actionHints & REGEXP) != 0);			result.append("],upHashChar=").append(upHashChar);			result.append(",upHashChars=").append(Arrays.toString(upHashChars));			result.append(",startPosMatch=");			result.append("[AT_LINE_START=").append((startPosMatch & AT_LINE_START) != 0);			result.append(",AT_WHITESPACE_END=").append((startPosMatch & AT_WHITESPACE_END) != 0);			result.append(",AT_WORD_START=").append((startPosMatch & AT_WORD_START) != 0);			result.append("],start=").append(null==start?null:String.valueOf(start));			result.append(",startRegexp=").append(startRegexp);			result.append(",endPosMatch=");			result.append("[AT_LINE_START=").append((endPosMatch & AT_LINE_START) != 0);			result.append(",AT_WHITESPACE_END=").append((endPosMatch & AT_WHITESPACE_END) != 0);			result.append(",AT_WORD_START=").append((endPosMatch & AT_WORD_START) != 0);			result.append("],end=").append(null==end?null:String.valueOf(end));			result.append(",delegate=").append(delegate);			result.append(",escapeRule=").append(escapeRule);			result.append(",token=").append(Token.tokenToString(token)).append(']');			return result.toString();		}	
private ParserRule(int action, String hashChar,			int startPosMatch, char[] start, Pattern startRegexp,			int endPosMatch, char[] end,			ParserRuleSet delegate, byte token, byte matchType,			String escape)		{			this.action = action;			this.upHashChar = null == hashChar ? null : hashChar.toUpperCase();			this.upHashChars = null;			this.startPosMatch = startPosMatch;			this.start = start;			this.startRegexp = startRegexp;			this.endPosMatch = endPosMatch;			this.end = end;			this.delegate = delegate;			this.token = token;			this.matchType = matchType;			this.escapeRule = (escape != null && escape.length() > 0) ?						createEscapeRule(escape) : null;				if(this.delegate == null)			{				if((action & MAJOR_ACTIONS) != SEQ)				{					this.delegate = ParserRuleSet.getStandardRuleSet(token);				}			}		}	
private ParserRule(char[] hashChars, int action,			int startPosMatch, char[] start, Pattern startRegexp,			int endPosMatch, char[] end,			ParserRuleSet delegate, byte token, byte matchType,			String escape)		{			this.action = action;			this.upHashChar = null;			Set<Character> hashCharsSet = new HashSet<Character>();			for (char c : hashChars)			{				hashCharsSet.add(Character.toUpperCase(c));			}			this.upHashChars = new char[hashCharsSet.size()];			int i = 0;			for (Character c : hashCharsSet)			{				this.upHashChars[i++] = c;			}			Arrays.sort(this.upHashChars);			this.startPosMatch = startPosMatch;			this.start = start;			this.startRegexp = startRegexp;			this.endPosMatch = endPosMatch;			this.end = end;			this.delegate = delegate;			this.token = token;			this.matchType = matchType;			this.escapeRule = (escape != null && escape.length() > 0) ?						createEscapeRule(escape) : null;				if(this.delegate == null)			{				if((action & MAJOR_ACTIONS) != SEQ)				{					this.delegate = ParserRuleSet.getStandardRuleSet(token);				}			}		}	
/**		 * Returns a parser rule set that highlights everything with the		 * specified token type.		 * @param id The token type		 */		public static ParserRuleSet getStandardRuleSet(byte id)		{			return standard[id];		}	
public ParserRuleSet(String modeName, String setName)		{			this.modeName = modeName;			this.setName = setName;			ruleMap = new HashMap<Character, List<ParserRule>>();			imports = new ArrayList<ParserRuleSet>();		}	
public String getModeName()		{			return modeName;		}	
public String getSetName()		{			return setName;		}	
public String getName()		{			return modeName + "::" + setName;		}	
public Hashtable<String, String> getProperties()		{			return props;		}	
public void setProperties(Hashtable<String, String> props)		{			this.props = props;			_noWordSep = null;		}	
/**		 * Resolves all rulesets added with {@link #addRuleSet(ParserRuleSet)}.		 * @since jEdit 4.2pre3		 */		public void resolveImports()		{			for (ParserRuleSet ruleset : imports)			{				if (!ruleset.imports.isEmpty())				{					//prevent infinite recursion					ruleset.imports.remove(this);					ruleset.resolveImports();				}					for (List<ParserRule> rules : ruleset.ruleMap.values())				{					for (ParserRule rule : rules)					{						addRule(rule);					}				}					if (ruleset.keywords != null)				{					if (keywords == null)						keywords = new KeywordMap(ignoreCase);					keywords.add(ruleset.keywords);				}			}			imports.clear();		}	
/**		 * Adds all rules contained in the given ruleset.		 * @param ruleset The ruleset		 * @since jEdit 4.2pre3		 */		public void addRuleSet(ParserRuleSet ruleset)		{			imports.add(ruleset);		}	
public void addRule(ParserRule r)		{			ruleCount++;			Character[] keys;			if (null == r.upHashChars)			{				keys = new Character[1];				if ((null == r.upHashChar) || (0 >= r.upHashChar.length()))				{					keys[0] = null;				}				else				{					keys[0] = Character.valueOf(r.upHashChar.charAt(0));				}			}			else			{				keys = new Character[r.upHashChars.length];				int i = 0;				for (char upHashChar : r.upHashChars)				{					keys[i++] = upHashChar;				}			}			for (Character key : keys)			{				List<ParserRule> rules = ruleMap.get(key);				if (null == rules)				{					rules = new ArrayList<ParserRule>();					ruleMap.put(key,rules);				}				int ruleAmount = rules.size();				rules.add(r);				// fill the deprecated ParserRule.next pointer				if (ruleAmount > 0)				{					rules.get(ruleAmount).next = r;				}			}		}	
/**		* @deprecated As the linking between rules is not anymore done within the rule, use {@link #getRules(Character)} instead		*/		@Deprecated		public ParserRule getRules(char ch)		{			List<ParserRule> rules = getRules(Character.valueOf(ch));			return rules.get(0);		}	
public List<ParserRule> getRules(Character key)		{			List<ParserRule> rulesForNull = ruleMap.get(null);			boolean emptyForNull = (rulesForNull == null) || (rulesForNull.size() == 0);			Character upperKey = null == key ? null : Character.valueOf(Character.toUpperCase(key.charValue()));			List<ParserRule> rulesForKey = null == upperKey ? null : ruleMap.get(upperKey);			boolean emptyForKey = (rulesForKey == null) || (rulesForKey.size() == 0);			if (emptyForNull && emptyForKey)			{				return Collections.emptyList();			}			else if (emptyForKey)			{				return rulesForNull;			}			else if (emptyForNull)			{				return rulesForKey;			}			else			{				int size = rulesForNull.size() + rulesForKey.size();				ArrayList<ParserRule> mixed = new ArrayList<ParserRule>(size);				mixed.addAll(rulesForKey);				mixed.addAll(rulesForNull);				// fill the deprecated ParserRule.next pointer				rulesForKey.get(rulesForKey.size() - 1).next = rulesForNull.get(0);				return mixed;			}		}	
public int getRuleCount()		{			return ruleCount;		}	
/**		 * Returns the number of chars that can be read before the rule parsing stops.		 *		 * @return a number of chars or -1 (default value) if there is no limit		 */		public int getTerminateChar()		{			return terminateChar;		}	
public void setTerminateChar(int atChar)		{			terminateChar = (atChar >= 0) ? atChar : -1;		}	
public boolean getIgnoreCase()		{			return ignoreCase;		}	
public void setIgnoreCase(boolean b)		{			ignoreCase = b;		}	
public KeywordMap getKeywords()		{			return keywords;		}	
public void setKeywords(KeywordMap km)		{			keywords = km;			_noWordSep = null;		}	
public boolean getHighlightDigits()		{			return highlightDigits;		}	
public void setHighlightDigits(boolean highlightDigits)		{			this.highlightDigits = highlightDigits;		}	
public Pattern getDigitRegexp()		{			return digitRE;		}	
public void setDigitRegexp(Pattern digitRE)		{			this.digitRE = digitRE;		}	
public ParserRule getEscapeRule()		{			return escapeRule;		}	
public void setEscapeRule(ParserRule escapeRule)		{			this.escapeRule = escapeRule;		}	
public byte getDefault()		{			return defaultToken;		}	
public void setDefault(byte def)		{			defaultToken = def;		}	
public String getNoWordSep()		{			if(_noWordSep == null)			{				_noWordSep = noWordSep;				if(noWordSep == null)					noWordSep = "";				if(keywords != null)					noWordSep += keywords.getNonAlphaNumericChars();			}			return noWordSep;		}	
public void setNoWordSep(String noWordSep)		{			this.noWordSep = noWordSep;			_noWordSep = null;		}	
/**		 * Returns if this is a built-in ruleset.		 * @since jEdit 4.2pre1		 */		public boolean isBuiltIn()		{			return builtIn;		}	
@Override		public String toString()		{			return getClass().getName() + '[' + modeName + "::" + setName + ']';		}	
public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }	
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1, long active2)	{	   switch (pos)	   {	      case 0:	         if ((active1 & 0x200020000000000L) != 0L)	            return 56;	         if ((active0 & 0x3eL) != 0L)	            return 0;	         if ((active1 & 0x10000L) != 0L)	            return 11;	         if ((active0 & 0xffffffffffffc00L) != 0L)	         {	            jjmatchedKind = 69;	            return 35;	         }	         return -1;	      case 1:	         if ((active0 & 0x100600000L) != 0L)	            return 35;	         if ((active0 & 0xffffffeff9ffc00L) != 0L)	         {	            if (jjmatchedPos != 1)	            {	               jjmatchedKind = 69;	               jjmatchedPos = 1;	            }	            return 35;	         }	         return -1;	      case 2:	         if ((active0 & 0xefffecebfdffc00L) != 0L)	         {	            if (jjmatchedPos != 2)	            {	               jjmatchedKind = 69;	               jjmatchedPos = 2;	            }	            return 35;	         }	         if ((active0 & 0x100013040000000L) != 0L)	            return 35;	         return -1;	      case 3:	         if ((active0 & 0xc7ffcae3e5d3c00L) != 0L)	         {	            if (jjmatchedPos != 3)	            {	               jjmatchedKind = 69;	               jjmatchedPos = 3;	            }	            return 35;	         }	         if ((active0 & 0x28002408182c000L) != 0L)	            return 35;	         return -1;	      case 4:	         if ((active0 & 0x86080003c053000L) != 0L)	            return 35;	         if ((active0 & 0x41f7cae02580c00L) != 0L)	         {	            if (jjmatchedPos != 4)	            {	               jjmatchedKind = 69;	               jjmatchedPos = 4;	            }	            return 35;	         }	         return -1;	      case 5:	         if ((active0 & 0x41a1c2a12180c00L) != 0L)	         {	            jjmatchedKind = 69;	            jjmatchedPos = 5;	            return 35;	         }	         if ((active0 & 0x45608400400000L) != 0L)	            return 35;	         return -1;	      case 6:	         if ((active0 & 0x41a102a00080400L) != 0L)	         {	            jjmatchedKind = 69;	            jjmatchedPos = 6;	            return 35;	         }	         if ((active0 & 0xc0012100800L) != 0L)	            return 35;	         return -1;	      case 7:	         if ((active0 & 0x402000000080400L) != 0L)	            return 35;	         if ((active0 & 0x18102a00000000L) != 0L)	         {	            jjmatchedKind = 69;	            jjmatchedPos = 7;	            return 35;	         }	         return -1;	      case 8:	         if ((active0 & 0x8000a00000000L) != 0L)	         {	            jjmatchedKind = 69;	            jjmatchedPos = 8;	            return 35;	         }	         if ((active0 & 0x10102000000000L) != 0L)	            return 35;	         return -1;	      case 9:	         if ((active0 & 0x8000000000000L) != 0L)	         {	            jjmatchedKind = 69;	            jjmatchedPos = 9;	            return 35;	         }	         if ((active0 & 0xa00000000L) != 0L)	            return 35;	         return -1;	      case 10:	         if ((active0 & 0x8000000000000L) != 0L)	         {	            if (jjmatchedPos != 10)	            {	               jjmatchedKind = 69;	               jjmatchedPos = 10;	            }	            return 35;	         }	         return -1;	      case 11:	         if ((active0 & 0x8000000000000L) != 0L)	            return 35;	         return -1;	      default :	         return -1;	   }	}	
private final int jjStartNfa_0(int pos, long active0, long active1, long active2)	{	   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1, active2), pos + 1);	}	
private final int jjStopAtPos(int pos, int kind)	{	   jjmatchedKind = kind;	   jjmatchedPos = pos;	   return pos + 1;	}	
private final int jjStartNfaWithStates_0(int pos, int kind, int state)	{	   jjmatchedKind = kind;	   jjmatchedPos = pos;	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) { return pos + 1; }	   return jjMoveNfa_0(state, pos + 1);	}	
private final int jjMoveStringLiteralDfa0_0()	{	   switch(curChar)	   {	      case 9:	         return jjStartNfaWithStates_0(0, 2, 0);	      case 10:	         return jjStartNfaWithStates_0(0, 5, 0);	      case 12:	         return jjStartNfaWithStates_0(0, 4, 0);	      case 13:	         return jjStartNfaWithStates_0(0, 3, 0);	      case 32:	         return jjStartNfaWithStates_0(0, 1, 0);	      case 33:	         jjmatchedKind = 86;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x80000000L, 0x0L);	      case 37:	         jjmatchedKind = 111;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000000L, 0x0L);	      case 38:	         jjmatchedKind = 106;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x400000400000000L, 0x0L);	      case 40:	         return jjStopAtPos(0, 72);	      case 41:	         return jjStopAtPos(0, 73);	      case 42:	         jjmatchedKind = 104;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000000000000L, 0x0L);	      case 43:	         jjmatchedKind = 102;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x40001000000000L, 0x0L);	      case 44:	         return jjStopAtPos(0, 79);	      case 45:	         jjmatchedKind = 103;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x80002000000000L, 0x0L);	      case 46:	         return jjStartNfaWithStates_0(0, 80, 11);	      case 47:	         jjmatchedKind = 105;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000000L, 0x0L);	      case 58:	         return jjStopAtPos(0, 89);	      case 59:	         return jjStopAtPos(0, 78);	      case 60:	         jjmatchedKind = 84;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000008000000L, 0x1L);	      case 61:	         jjmatchedKind = 81;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000L, 0x0L);	      case 62:	         jjmatchedKind = 82;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x14000020000000L, 0x14L);	      case 63:	         return jjStopAtPos(0, 88);	      case 64:	         return jjMoveStringLiteralDfa1_0(0x0L, 0x282a280a50280000L, 0x2aL);	      case 91:	         return jjStopAtPos(0, 76);	      case 93:	         return jjStopAtPos(0, 77);	      case 94:	         jjmatchedKind = 110;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x4000000000000000L, 0x0L);	      case 97:	         return jjMoveStringLiteralDfa1_0(0x400L, 0x0L, 0x0L);	      case 98:	         return jjMoveStringLiteralDfa1_0(0x5800L, 0x0L, 0x0L);	      case 99:	         return jjMoveStringLiteralDfa1_0(0xfa000L, 0x0L, 0x0L);	      case 100:	         return jjMoveStringLiteralDfa1_0(0x700000L, 0x0L, 0x0L);	      case 101:	         return jjMoveStringLiteralDfa1_0(0x3800000L, 0x0L, 0x0L);	      case 102:	         return jjMoveStringLiteralDfa1_0(0x7c000000L, 0x0L, 0x0L);	      case 103:	         return jjMoveStringLiteralDfa1_0(0x80000000L, 0x0L, 0x0L);	      case 105:	         return jjMoveStringLiteralDfa1_0(0x3f00000000L, 0x0L, 0x0L);	      case 108:	         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L, 0x0L);	      case 110:	         return jjMoveStringLiteralDfa1_0(0x38000000000L, 0x0L, 0x0L);	      case 112:	         return jjMoveStringLiteralDfa1_0(0x3c0000000000L, 0x0L, 0x0L);	      case 114:	         return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L, 0x0L);	      case 115:	         return jjMoveStringLiteralDfa1_0(0xf800000000000L, 0x0L, 0x0L);	      case 116:	         return jjMoveStringLiteralDfa1_0(0x1f0000000000000L, 0x0L, 0x0L);	      case 118:	         return jjMoveStringLiteralDfa1_0(0x600000000000000L, 0x0L, 0x0L);	      case 119:	         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L, 0x0L);	      case 123:	         return jjStopAtPos(0, 74);	      case 124:	         jjmatchedKind = 108;	         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000000100000000L, 0x0L);	      case 125:	         return jjStopAtPos(0, 75);	      case 126:	         return jjStopAtPos(0, 87);	      default :	         return jjMoveNfa_0(6, 0);	   }	}	
private final int jjMoveStringLiteralDfa1_0(long active0, long active1, long active2)	{	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(0, active0, active1, active2);	      return 1;	   }	   switch(curChar)	   {	      case 38:	         if ((active1 & 0x400000000L) != 0L)	            return jjStopAtPos(1, 98);	         break;	      case 43:	         if ((active1 & 0x1000000000L) != 0L)	            return jjStopAtPos(1, 100);	         break;	      case 45:	         if ((active1 & 0x2000000000L) != 0L)	            return jjStopAtPos(1, 101);	         break;	      case 60:	         if ((active1 & 0x1000000000000L) != 0L)	         {	            jjmatchedKind = 112;	            jjmatchedPos = 1;	         }	         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0L, active2, 0x1L);	      case 61:	         if ((active1 & 0x4000000L) != 0L)	            return jjStopAtPos(1, 90);	         else if ((active1 & 0x8000000L) != 0L)	            return jjStopAtPos(1, 91);	         else if ((active1 & 0x20000000L) != 0L)	            return jjStopAtPos(1, 93);	         else if ((active1 & 0x80000000L) != 0L)	            return jjStopAtPos(1, 95);	         else if ((active1 & 0x40000000000000L) != 0L)	            return jjStopAtPos(1, 118);	         else if ((active1 & 0x80000000000000L) != 0L)	            return jjStopAtPos(1, 119);	         else if ((active1 & 0x100000000000000L) != 0L)	            return jjStopAtPos(1, 120);	         else if ((active1 & 0x200000000000000L) != 0L)	            return jjStopAtPos(1, 121);	         else if ((active1 & 0x400000000000000L) != 0L)	            return jjStopAtPos(1, 122);	         else if ((active1 & 0x1000000000000000L) != 0L)	            return jjStopAtPos(1, 124);	         else if ((active1 & 0x4000000000000000L) != 0L)	            return jjStopAtPos(1, 126);	         else if ((active1 & 0x8000000000000000L) != 0L)	            return jjStopAtPos(1, 127);	         break;	      case 62:	         if ((active1 & 0x4000000000000L) != 0L)	         {	            jjmatchedKind = 114;	            jjmatchedPos = 1;	         }	         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000000000000L, active2, 0x14L);	      case 97:	         return jjMoveStringLiteralDfa2_0(active0, 0x48004018000L, active1, 0x800000800000000L, active2, 0L);	      case 98:	         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0x280000000000L, active2, 0L);	      case 101:	         return jjMoveStringLiteralDfa2_0(active0, 0x410000100000L, active1, 0L, active2, 0L);	      case 102:	         if ((active0 & 0x100000000L) != 0L)	            return jjStartNfaWithStates_0(1, 32, 35);	         break;	      case 103:	         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x40080000L, active2, 0L);	      case 104:	         return jjMoveStringLiteralDfa2_0(active0, 0x860800000020000L, active1, 0L, active2, 0L);	      case 105:	         return jjMoveStringLiteralDfa2_0(active0, 0x18000000L, active1, 0L, active2, 0L);	      case 108:	         return jjMoveStringLiteralDfa2_0(active0, 0x20802000L, active1, 0x2000010200000L, active2, 0x2L);	      case 109:	         return jjMoveStringLiteralDfa2_0(active0, 0x600000000L, active1, 0L, active2, 0L);	      case 110:	         return jjMoveStringLiteralDfa2_0(active0, 0x3801000000L, active1, 0L, active2, 0L);	      case 111:	         if ((active0 & 0x200000L) != 0L)	         {	            jjmatchedKind = 21;	            jjmatchedPos = 1;	         }	         return jjMoveStringLiteralDfa2_0(active0, 0x6000040c04c0800L, active1, 0x2000000200000000L, active2, 0L);	      case 114:	         return jjMoveStringLiteralDfa2_0(active0, 0x190180000001000L, active1, 0x28000000000000L, active2, 0x28L);	      case 116:	         return jjMoveStringLiteralDfa2_0(active0, 0x3000000000000L, active1, 0L, active2, 0L);	      case 117:	         return jjMoveStringLiteralDfa2_0(active0, 0x220000000000L, active1, 0L, active2, 0L);	      case 119:	         return jjMoveStringLiteralDfa2_0(active0, 0x4000000000000L, active1, 0L, active2, 0L);	      case 120:	         return jjMoveStringLiteralDfa2_0(active0, 0x2000000L, active1, 0L, active2, 0L);	      case 121:	         return jjMoveStringLiteralDfa2_0(active0, 0x8000000004000L, active1, 0L, active2, 0L);	      case 124:	         if ((active1 & 0x100000000L) != 0L)	            return jjStopAtPos(1, 96);	         break;	      default :	         break;	   }	   return jjStartNfa_0(0, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(0, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(1, active0, active1, active2);	      return 2;	   }	   switch(curChar)	   {	      case 61:	         if ((active2 & 0x1L) != 0L)	            return jjStopAtPos(2, 128);	         else if ((active2 & 0x4L) != 0L)	            return jjStopAtPos(2, 130);	         break;	      case 62:	         if ((active1 & 0x10000000000000L) != 0L)	         {	            jjmatchedKind = 116;	            jjmatchedPos = 2;	         }	         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0L, active2, 0x10L);	      case 97:	         return jjMoveStringLiteralDfa3_0(active0, 0x11000000022000L, active1, 0L, active2, 0L);	      case 98:	         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L, active2, 0L);	      case 99:	         return jjMoveStringLiteralDfa3_0(active0, 0x40000000000L, active1, 0L, active2, 0L);	      case 101:	         return jjMoveStringLiteralDfa3_0(active0, 0x1000L, active1, 0x2000000000000L, active2, 0x2L);	      case 102:	         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L, active2, 0L);	      case 105:	         return jjMoveStringLiteralDfa3_0(active0, 0xa04080000000000L, active1, 0x28280000000000L, active2, 0x28L);	      case 108:	         return jjMoveStringLiteralDfa3_0(active0, 0x400020004000000L, active1, 0L, active2, 0L);	      case 110:	         return jjMoveStringLiteralDfa3_0(active0, 0x80040180c0000L, active1, 0x800000800000000L, active2, 0L);	      case 111:	         return jjMoveStringLiteralDfa3_0(active0, 0x900020000800L, active1, 0L, active2, 0L);	      case 112:	         return jjMoveStringLiteralDfa3_0(active0, 0x600000000L, active1, 0L, active2, 0L);	      case 114:	         if ((active0 & 0x40000000L) != 0L)	            return jjStartNfaWithStates_0(2, 30, 35);	         else if ((active1 & 0x200000000L) != 0L)	         {	            jjmatchedKind = 97;	            jjmatchedPos = 2;	         }	         return jjMoveStringLiteralDfa3_0(active0, 0x62000000000000L, active1, 0x2000000000000000L, active2, 0L);	      case 115:	         return jjMoveStringLiteralDfa3_0(active0, 0x800808400L, active1, 0L, active2, 0L);	      case 116:	         if ((active0 & 0x1000000000L) != 0L)	         {	            jjmatchedKind = 36;	            jjmatchedPos = 2;	         }	         else if ((active1 & 0x80000L) != 0L)	         {	            jjmatchedKind = 83;	            jjmatchedPos = 2;	         }	         else if ((active1 & 0x200000L) != 0L)	         {	            jjmatchedKind = 85;	            jjmatchedPos = 2;	         }	         return jjMoveStringLiteralDfa3_0(active0, 0x40a082014000L, active1, 0x50000000L, active2, 0L);	      case 117:	         return jjMoveStringLiteralDfa3_0(active0, 0x80000001400000L, active1, 0L, active2, 0L);	      case 119:	         if ((active0 & 0x10000000000L) != 0L)	            return jjStartNfaWithStates_0(2, 40, 35);	         break;	      case 121:	         if ((active0 & 0x100000000000000L) != 0L)	            return jjStartNfaWithStates_0(2, 56, 35);	         break;	      default :	         break;	   }	   return jjStartNfa_0(1, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(1, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(2, active0, active1, active2);	      return 3;	   }	   switch(curChar)	   {	      case 61:	         if ((active2 & 0x10L) != 0L)	            return jjStopAtPos(3, 132);	         break;	      case 95:	         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);	      case 97:	         return jjMoveStringLiteralDfa4_0(active0, 0x400000038101000L, active1, 0L, active2, 0L);	      case 98:	         return jjMoveStringLiteralDfa4_0(active0, 0x400000L, active1, 0L, active2, 0L);	      case 99:	         return jjMoveStringLiteralDfa4_0(active0, 0x8000000010000L, active1, 0L, active2, 0L);	      case 100:	         if ((active0 & 0x200000000000000L) != 0L)	            return jjStartNfaWithStates_0(3, 57, 35);	         else if ((active1 & 0x800000000L) != 0L)	         {	            jjmatchedKind = 99;	            jjmatchedPos = 3;	         }	         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);	      case 101:	         if ((active0 & 0x4000L) != 0L)	            return jjStartNfaWithStates_0(3, 14, 35);	         else if ((active0 & 0x8000L) != 0L)	            return jjStartNfaWithStates_0(3, 15, 35);	         else if ((active0 & 0x800000L) != 0L)	            return jjStartNfaWithStates_0(3, 23, 35);	         else if ((active0 & 0x80000000000000L) != 0L)	            return jjStartNfaWithStates_0(3, 55, 35);	         return jjMoveStringLiteralDfa4_0(active0, 0x2002000000L, active1, 0x50000000L, active2, 0L);	      case 102:	         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);	      case 103:	         if ((active0 & 0x4000000000L) != 0L)	            return jjStartNfaWithStates_0(3, 38, 35);	         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);	      case 105:	         return jjMoveStringLiteralDfa4_0(active0, 0x2008000000000L, active1, 0L, active2, 0L);	      case 107:	         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0L, active2, 0L);	      case 108:	         if ((active0 & 0x20000000000L) != 0L)	            return jjStartNfaWithStates_0(3, 41, 35);	         return jjMoveStringLiteralDfa4_0(active0, 0x800200200000800L, active1, 0L, active2, 0L);	      case 109:	         if ((active0 & 0x1000000L) != 0L)	            return jjStartNfaWithStates_0(3, 24, 35);	         break;	      case 110:	         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);	      case 111:	         if ((active0 & 0x80000000L) != 0L)	            return jjStartNfaWithStates_0(3, 31, 35);	         return jjMoveStringLiteralDfa4_0(active0, 0x60000400000000L, active1, 0L, active2, 0L);	      case 114:	         if ((active0 & 0x20000L) != 0L)	            return jjStartNfaWithStates_0(3, 17, 35);	         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L, active1, 0L, active2, 0L);	      case 115:	         return jjMoveStringLiteralDfa4_0(active0, 0x4042000L, active1, 0L, active2, 0L);	      case 116:	         return jjMoveStringLiteralDfa4_0(active0, 0x5100800080400L, active1, 0x280000000000L, active2, 0L);	      case 117:	         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000L, active1, 0L, active2, 0L);	      case 118:	         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L, active2, 0L);	      default :	         break;	   }	   return jjStartNfa_0(2, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(2, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(3, active0, active1, active2);	      return 4;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);	      case 97:	         return jjMoveStringLiteralDfa5_0(active0, 0xc0800000000L, active1, 0x2000000000000000L, active2, 0L);	      case 99:	         return jjMoveStringLiteralDfa5_0(active0, 0x6000000000000L, active1, 0L, active2, 0L);	      case 101:	         if ((active0 & 0x4000000L) != 0L)	            return jjStartNfaWithStates_0(4, 26, 35);	         else if ((active0 & 0x800000000000000L) != 0L)	            return jjStartNfaWithStates_0(4, 59, 35);	         return jjMoveStringLiteralDfa5_0(active0, 0x100200000800L, active1, 0L, active2, 0L);	      case 104:	         if ((active0 & 0x10000L) != 0L)	            return jjStartNfaWithStates_0(4, 16, 35);	         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000000L, active1, 0x28000000000000L, active2, 0x28L);	      case 105:	         return jjMoveStringLiteralDfa5_0(active0, 0x1200000080000L, active1, 0L, active2, 0L);	      case 107:	         if ((active0 & 0x1000L) != 0L)	            return jjStartNfaWithStates_0(4, 12, 35);	         break;	      case 108:	         if ((active0 & 0x8000000L) != 0L)	         {	            jjmatchedKind = 27;	            jjmatchedPos = 4;	         }	         return jjMoveStringLiteralDfa5_0(active0, 0x10400000L, active1, 0L, active2, 0L);	      case 110:	         return jjMoveStringLiteralDfa5_0(active0, 0x2000000L, active1, 0L, active2, 0L);	      case 113:	         if ((active1 & 0x10000000L) != 0L)	            return jjStopAtPos(4, 92);	         else if ((active1 & 0x40000000L) != 0L)	            return jjStopAtPos(4, 94);	         break;	      case 114:	         return jjMoveStringLiteralDfa5_0(active0, 0x402400000400L, active1, 0L, active2, 0L);	      case 115:	         if ((active0 & 0x2000L) != 0L)	            return jjStartNfaWithStates_0(4, 13, 35);	         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000000L, active1, 0L, active2, 0L);	      case 116:	         if ((active0 & 0x40000L) != 0L)	            return jjStartNfaWithStates_0(4, 18, 35);	         else if ((active0 & 0x20000000L) != 0L)	            return jjStartNfaWithStates_0(4, 29, 35);	         else if ((active0 & 0x800000000000L) != 0L)	            return jjStartNfaWithStates_0(4, 47, 35);	         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0x2000000000000L, active2, 0x2L);	      case 117:	         return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0L, active2, 0L);	      case 118:	         return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0L, active2, 0L);	      case 119:	         if ((active0 & 0x20000000000000L) != 0L)	         {	            jjmatchedKind = 53;	            jjmatchedPos = 4;	         }	         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000000L, active1, 0x280000000000L, active2, 0L);	      default :	         break;	   }	   return jjStartNfa_0(3, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(3, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(4, active0, active1, active2);	      return 5;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);	      case 97:	         return jjMoveStringLiteralDfa6_0(active0, 0xc00L, active1, 0x800000000000000L, active2, 0L);	      case 99:	         if ((active0 & 0x200000000000L) != 0L)	            return jjStartNfaWithStates_0(5, 45, 35);	         else if ((active0 & 0x1000000000000L) != 0L)	            return jjStartNfaWithStates_0(5, 48, 35);	         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000L, active1, 0L, active2, 0L);	      case 100:	         return jjMoveStringLiteralDfa6_0(active0, 0x2000000L, active1, 0L, active2, 0L);	      case 101:	         if ((active0 & 0x400000L) != 0L)	            return jjStartNfaWithStates_0(5, 22, 35);	         else if ((active0 & 0x8000000000L) != 0L)	            return jjStartNfaWithStates_0(5, 39, 35);	         break;	      case 102:	         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000L, active1, 0L, active2, 0L);	      case 103:	         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L, active1, 0L, active2, 0L);	      case 104:	         if ((active0 & 0x4000000000000L) != 0L)	            return jjStartNfaWithStates_0(5, 50, 35);	         break;	      case 105:	         return jjMoveStringLiteralDfa6_0(active0, 0x410000000000000L, active1, 0x280000000000L, active2, 0L);	      case 108:	         return jjMoveStringLiteralDfa6_0(active0, 0x10100000L, active1, 0L, active2, 0L);	      case 109:	         return jjMoveStringLiteralDfa6_0(active0, 0x200000000L, active1, 0L, active2, 0L);	      case 110:	         if ((active0 & 0x400000000000L) != 0L)	            return jjStartNfaWithStates_0(5, 46, 35);	         return jjMoveStringLiteralDfa6_0(active0, 0x800080000L, active1, 0L, active2, 0L);	      case 114:	         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);	      case 115:	         if ((active0 & 0x40000000000000L) != 0L)	            return jjStartNfaWithStates_0(5, 54, 35);	         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);	      case 116:	         if ((active0 & 0x400000000L) != 0L)	            return jjStartNfaWithStates_0(5, 34, 35);	         return jjMoveStringLiteralDfa6_0(active0, 0x2080000000000L, active1, 0x28000000000000L, active2, 0x28L);	      default :	         break;	   }	   return jjStartNfa_0(4, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(4, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(5, active0, active1, active2);	      return 6;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x28000000000000L, active2, 0x28L);	      case 97:	         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L, active2, 0L);	      case 99:	         return jjMoveStringLiteralDfa7_0(active0, 0x800000400L, active1, 0L, active2, 0L);	      case 101:	         if ((active0 & 0x40000000000L) != 0L)	            return jjStartNfaWithStates_0(6, 42, 35);	         else if ((active0 & 0x80000000000L) != 0L)	            return jjStartNfaWithStates_0(6, 43, 35);	         return jjMoveStringLiteralDfa7_0(active0, 0x10000200000000L, active1, 0L, active2, 0L);	      case 102:	         return jjMoveStringLiteralDfa7_0(active0, 0x2000000000000L, active1, 0L, active2, 0L);	      case 108:	         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L, active2, 0L);	      case 110:	         if ((active0 & 0x800L) != 0L)	            return jjStartNfaWithStates_0(6, 11, 35);	         break;	      case 111:	         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);	      case 115:	         if ((active0 & 0x2000000L) != 0L)	            return jjStartNfaWithStates_0(6, 25, 35);	         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x2802280000000000L, active2, 0x2L);	      case 116:	         if ((active0 & 0x100000L) != 0L)	            return jjStartNfaWithStates_0(6, 20, 35);	         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000L, active1, 0L, active2, 0L);	      case 117:	         return jjMoveStringLiteralDfa7_0(active0, 0x80000L, active1, 0L, active2, 0L);	      case 121:	         if ((active0 & 0x10000000L) != 0L)	            return jjStartNfaWithStates_0(6, 28, 35);	         break;	      default :	         break;	   }	   return jjStartNfa_0(5, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(5, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(6, active0, active1, active2);	      return 7;	   }	   switch(curChar)	   {	      case 99:	         return jjMoveStringLiteralDfa8_0(active0, 0x2000000000L, active1, 0L, active2, 0L);	      case 101:	         if ((active0 & 0x80000L) != 0L)	            return jjStartNfaWithStates_0(7, 19, 35);	         else if ((active0 & 0x400000000000000L) != 0L)	            return jjStartNfaWithStates_0(7, 58, 35);	         return jjMoveStringLiteralDfa8_0(active0, 0x100800000000L, active1, 0x280000000000L, active2, 0L);	      case 104:	         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);	      case 105:	         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);	      case 110:	         return jjMoveStringLiteralDfa8_0(active0, 0x18000200000000L, active1, 0L, active2, 0L);	      case 112:	         if ((active0 & 0x2000000000000L) != 0L)	            return jjStartNfaWithStates_0(7, 49, 35);	         break;	      case 115:	         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x808000000000000L, active2, 0x8L);	      case 116:	         if ((active0 & 0x400L) != 0L)	            return jjStartNfaWithStates_0(7, 10, 35);	         break;	      case 117:	         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(6, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(6, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(7, active0, active1, active2);	      return 8;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x280000000000L, active2, 0L);	      case 100:	         if ((active0 & 0x100000000000L) != 0L)	            return jjStartNfaWithStates_0(8, 44, 35);	         break;	      case 101:	         if ((active0 & 0x2000000000L) != 0L)	            return jjStartNfaWithStates_0(8, 37, 35);	         break;	      case 103:	         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000000000000000L, active2, 0L);	      case 104:	         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);	      case 105:	         return jjMoveStringLiteralDfa9_0(active0, 0x8000000000000L, active1, 0x802000000000000L, active2, 0x2L);	      case 110:	         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);	      case 111:	         return jjMoveStringLiteralDfa9_0(active0, 0x800000000L, active1, 0L, active2, 0L);	      case 116:	         if ((active0 & 0x10000000000000L) != 0L)	            return jjStartNfaWithStates_0(8, 52, 35);	         return jjMoveStringLiteralDfa9_0(active0, 0x200000000L, active1, 0L, active2, 0L);	      default :	         break;	   }	   return jjStartNfa_0(7, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(7, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(8, active0, active1, active2);	      return 9;	   }	   switch(curChar)	   {	      case 97:	         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x80000000000L, active2, 0L);	      case 102:	         if ((active0 & 0x800000000L) != 0L)	            return jjStartNfaWithStates_0(9, 35, 35);	         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000000000000L, active2, 0x2L);	      case 103:	         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x800000000000000L, active2, 0L);	      case 105:	         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);	      case 110:	         if ((active1 & 0x2000000000000000L) != 0L)	            return jjStopAtPos(9, 125);	         break;	      case 111:	         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x200000000000L, active2, 0L);	      case 115:	         if ((active0 & 0x200000000L) != 0L)	            return jjStartNfaWithStates_0(9, 33, 35);	         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);	      case 122:	         return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);	      default :	         break;	   }	   return jjStartNfa_0(8, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(8, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(9, active0, active1, active2);	      return 10;	   }	   switch(curChar)	   {	      case 101:	         return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000L, active1, 0L, active2, 0L);	      case 102:	         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x8000000000000L, active2, 0x8L);	      case 105:	         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);	      case 110:	         if ((active1 & 0x800000000000000L) != 0L)	            return jjStopAtPos(10, 123);	         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0x80000000000L, active2, 0L);	      case 114:	         if ((active1 & 0x200000000000L) != 0L)	            return jjStopAtPos(10, 109);	         break;	      case 116:	         if ((active1 & 0x2000000000000L) != 0L)	         {	            jjmatchedKind = 113;	            jjmatchedPos = 10;	         }	         return jjMoveStringLiteralDfa11_0(active0, 0L, active1, 0L, active2, 0x2L);	      default :	         break;	   }	   return jjStartNfa_0(9, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(9, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(10, active0, active1, active2);	      return 11;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x2L);	      case 100:	         if ((active0 & 0x8000000000000L) != 0L)	            return jjStartNfaWithStates_0(11, 51, 35);	         else if ((active1 & 0x80000000000L) != 0L)	            return jjStopAtPos(11, 107);	         break;	      case 103:	         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x20000000000000L, active2, 0x20L);	      case 116:	         if ((active1 & 0x8000000000000L) != 0L)	         {	            jjmatchedKind = 115;	            jjmatchedPos = 11;	         }	         return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0L, active2, 0x8L);	      default :	         break;	   }	   return jjStartNfa_0(10, active0, active1, active2);	}	
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1, long old2, long active2)	{	   if (((active0 &= old0) | (active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(10, old0, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(11, 0L, active1, active2);	      return 12;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x8L);	      case 97:	         return jjMoveStringLiteralDfa13_0(active1, 0L, active2, 0x2L);	      case 110:	         return jjMoveStringLiteralDfa13_0(active1, 0x20000000000000L, active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(11, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa13_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(11, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(12, 0L, active1, active2);	      return 13;	   }	   switch(curChar)	   {	      case 97:	         return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x8L);	      case 101:	         return jjMoveStringLiteralDfa14_0(active1, 0x20000000000000L, active2, 0x20L);	      case 115:	         return jjMoveStringLiteralDfa14_0(active1, 0L, active2, 0x2L);	      default :	         break;	   }	   return jjStartNfa_0(12, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa14_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(12, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(13, 0L, active1, active2);	      return 14;	   }	   switch(curChar)	   {	      case 100:	         return jjMoveStringLiteralDfa15_0(active1, 0x20000000000000L, active2, 0x20L);	      case 115:	         return jjMoveStringLiteralDfa15_0(active1, 0L, active2, 0xaL);	      default :	         break;	   }	   return jjStartNfa_0(13, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa15_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(13, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(14, 0L, active1, active2);	      return 15;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa16_0(active1, 0x20000000000000L, active2, 0x20L);	      case 105:	         return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x2L);	      case 115:	         return jjMoveStringLiteralDfa16_0(active1, 0L, active2, 0x8L);	      default :	         break;	   }	   return jjStartNfa_0(14, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa16_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(14, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(15, 0L, active1, active2);	      return 16;	   }	   switch(curChar)	   {	      case 103:	         return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x2L);	      case 105:	         return jjMoveStringLiteralDfa17_0(active1, 0L, active2, 0x8L);	      case 115:	         return jjMoveStringLiteralDfa17_0(active1, 0x20000000000000L, active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(15, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa17_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(15, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(16, 0L, active1, active2);	      return 17;	   }	   switch(curChar)	   {	      case 103:	         return jjMoveStringLiteralDfa18_0(active1, 0L, active2, 0x8L);	      case 104:	         return jjMoveStringLiteralDfa18_0(active1, 0x20000000000000L, active2, 0x20L);	      case 110:	         if ((active2 & 0x2L) != 0L)	            return jjStopAtPos(17, 129);	         break;	      default :	         break;	   }	   return jjStartNfa_0(16, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa18_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(16, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(17, 0L, active1, active2);	      return 18;	   }	   switch(curChar)	   {	      case 105:	         return jjMoveStringLiteralDfa19_0(active1, 0x20000000000000L, active2, 0x20L);	      case 110:	         if ((active2 & 0x8L) != 0L)	            return jjStopAtPos(18, 131);	         break;	      default :	         break;	   }	   return jjStartNfa_0(17, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa19_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(17, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(18, 0L, active1, active2);	      return 19;	   }	   switch(curChar)	   {	      case 102:	         return jjMoveStringLiteralDfa20_0(active1, 0x20000000000000L, active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(18, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa20_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(18, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(19, 0L, active1, active2);	      return 20;	   }	   switch(curChar)	   {	      case 116:	         if ((active1 & 0x20000000000000L) != 0L)	         {	            jjmatchedKind = 117;	            jjmatchedPos = 20;	         }	         return jjMoveStringLiteralDfa21_0(active1, 0L, active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(19, 0L, active1, active2);	}	
private final int jjMoveStringLiteralDfa21_0(long old1, long active1, long old2, long active2)	{	   if (((active1 &= old1) | (active2 &= old2)) == 0L)	      return jjStartNfa_0(19, 0L, old1, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(20, 0L, 0L, active2);	      return 21;	   }	   switch(curChar)	   {	      case 95:	         return jjMoveStringLiteralDfa22_0(active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(20, 0L, 0L, active2);	}	
private final int jjMoveStringLiteralDfa22_0(long old2, long active2)	{	   if (((active2 &= old2)) == 0L)	      return jjStartNfa_0(20, 0L, 0L, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(21, 0L, 0L, active2);	      return 22;	   }	   switch(curChar)	   {	      case 97:	         return jjMoveStringLiteralDfa23_0(active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(21, 0L, 0L, active2);	}	
private final int jjMoveStringLiteralDfa23_0(long old2, long active2)	{	   if (((active2 &= old2)) == 0L)	      return jjStartNfa_0(21, 0L, 0L, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(22, 0L, 0L, active2);	      return 23;	   }	   switch(curChar)	   {	      case 115:	         return jjMoveStringLiteralDfa24_0(active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(22, 0L, 0L, active2);	}	
private final int jjMoveStringLiteralDfa24_0(long old2, long active2)	{	   if (((active2 &= old2)) == 0L)	      return jjStartNfa_0(22, 0L, 0L, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(23, 0L, 0L, active2);	      return 24;	   }	   switch(curChar)	   {	      case 115:	         return jjMoveStringLiteralDfa25_0(active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(23, 0L, 0L, active2);	}	
private final int jjMoveStringLiteralDfa25_0(long old2, long active2)	{	   if (((active2 &= old2)) == 0L)	      return jjStartNfa_0(23, 0L, 0L, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(24, 0L, 0L, active2);	      return 25;	   }	   switch(curChar)	   {	      case 105:	         return jjMoveStringLiteralDfa26_0(active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(24, 0L, 0L, active2);	}	
private final int jjMoveStringLiteralDfa26_0(long old2, long active2)	{	   if (((active2 &= old2)) == 0L)	      return jjStartNfa_0(24, 0L, 0L, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(25, 0L, 0L, active2);	      return 26;	   }	   switch(curChar)	   {	      case 103:	         return jjMoveStringLiteralDfa27_0(active2, 0x20L);	      default :	         break;	   }	   return jjStartNfa_0(25, 0L, 0L, active2);	}	
private final int jjMoveStringLiteralDfa27_0(long old2, long active2)	{	   if (((active2 &= old2)) == 0L)	      return jjStartNfa_0(25, 0L, 0L, old2); 	   try { curChar = input_stream.readChar(); }	   catch(java.io.IOException e) {	      jjStopStringLiteralDfa_0(26, 0L, 0L, active2);	      return 27;	   }	   switch(curChar)	   {	      case 110:	         if ((active2 & 0x20L) != 0L)	            return jjStopAtPos(27, 133);	         break;	      default :	         break;	   }	   return jjStartNfa_0(26, 0L, 0L, active2);	}	
private final void jjCheckNAdd(int state)	{	   if (jjrounds[state] != jjround)	   {	      jjstateSet[jjnewStateCnt++] = state;	      jjrounds[state] = jjround;	   }	}	
private final void jjAddStates(int start, int end)	{	   do {	      jjstateSet[jjnewStateCnt++] = jjnextStates[start];	   } while (start++ != end);	}	
private final void jjCheckNAddTwoStates(int state1, int state2)	{	   jjCheckNAdd(state1);	   jjCheckNAdd(state2);	}	
private final void jjCheckNAddStates(int start, int end)	{	   do {	      jjCheckNAdd(jjnextStates[start]);	   } while (start++ != end);	}	
private final void jjCheckNAddStates(int start)	{	   jjCheckNAdd(jjnextStates[start]);	   jjCheckNAdd(jjnextStates[start + 1]);	}	
private final int jjMoveNfa_0(int startState, int curPos)	{	   int[] nextStates;	   int startsAt = 0;	   jjnewStateCnt = 74;	   int i = 1;	   jjstateSet[0] = startState;	   int j, kind = 0x7fffffff;	   for (;;)	   {	      if (++jjround == 0x7fffffff)	         ReInitRounds();	      if (curChar < 64)	      {	         long l = 1L << curChar;	         MatchLoop: do	         {	            switch(jjstateSet[--i])	            {	               case 6:	                  if ((0x1ffffffffL & l) != 0L)	                  {	                     if (kind > 6)	                        kind = 6;	                     jjCheckNAdd(0);	                  }	                  else if ((0x3ff000000000000L & l) != 0L)	                     jjCheckNAddStates(0, 6);	                  else if (curChar == 47)	                     jjAddStates(7, 9);	                  else if (curChar == 36)	                  {	                     if (kind > 69)	                        kind = 69;	                     jjCheckNAdd(35);	                  }	                  else if (curChar == 34)	                     jjCheckNAddStates(10, 12);	                  else if (curChar == 39)	                     jjAddStates(13, 14);	                  else if (curChar == 46)	                     jjCheckNAdd(11);	                  else if (curChar == 35)	                     jjstateSet[jjnewStateCnt++] = 1;	                  if ((0x3fe000000000000L & l) != 0L)	                  {	                     if (kind > 60)	                        kind = 60;	                     jjCheckNAddTwoStates(8, 9);	                  }	                  else if (curChar == 48)	                  {	                     if (kind > 60)	                        kind = 60;	                     jjCheckNAddStates(15, 17);	                  }	                  break;	               case 56:	                  if (curChar == 42)	                     jjstateSet[jjnewStateCnt++] = 67;	                  else if (curChar == 47)	                  {	                     if (kind > 7)	                        kind = 7;	                     jjCheckNAddStates(18, 20);	                  }	                  if (curChar == 42)	                     jjCheckNAdd(62);	                  break;	               case 0:	                  if ((0x1ffffffffL & l) == 0L)	                     break;	                  if (kind > 6)	                     kind = 6;	                  jjCheckNAdd(0);	                  break;	               case 1:	                  if (curChar == 33)	                     jjCheckNAddStates(21, 23);	                  break;	               case 2:	                  if ((0xffffffffffffdbffL & l) != 0L)	                     jjCheckNAddStates(21, 23);	                  break;	               case 3:	                  if ((0x2400L & l) != 0L && kind > 8)	                     kind = 8;	                  break;	               case 4:	                  if (curChar == 10 && kind > 8)	                     kind = 8;	                  break;	               case 5:	                  if (curChar == 13)	                     jjstateSet[jjnewStateCnt++] = 4;	                  break;	               case 7:	                  if ((0x3fe000000000000L & l) == 0L)	                     break;	                  if (kind > 60)	                     kind = 60;	                  jjCheckNAddTwoStates(8, 9);	                  break;	               case 8:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 60)	                     kind = 60;	                  jjCheckNAddTwoStates(8, 9);	                  break;	               case 10:	                  if (curChar == 46)	                     jjCheckNAdd(11);	                  break;	               case 11:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 64)	                     kind = 64;	                  jjCheckNAddStates(24, 26);	                  break;	               case 13:	                  if ((0x280000000000L & l) != 0L)	                     jjCheckNAdd(14);	                  break;	               case 14:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 64)	                     kind = 64;	                  jjCheckNAddTwoStates(14, 15);	                  break;	               case 16:	                  if (curChar == 39)	                     jjAddStates(13, 14);	                  break;	               case 17:	                  if ((0xffffff7fffffdbffL & l) != 0L)	                     jjCheckNAdd(18);	                  break;	               case 18:	                  if (curChar == 39 && kind > 66)	                     kind = 66;	                  break;	               case 20:	                  if ((0x8400000000L & l) != 0L)	                     jjCheckNAdd(18);	                  break;	               case 21:	                  if ((0xff000000000000L & l) != 0L)	                     jjCheckNAddTwoStates(22, 18);	                  break;	               case 22:	                  if ((0xff000000000000L & l) != 0L)	                     jjCheckNAdd(18);	                  break;	               case 23:	                  if ((0xf000000000000L & l) != 0L)	                     jjstateSet[jjnewStateCnt++] = 24;	                  break;	               case 24:	                  if ((0xff000000000000L & l) != 0L)	                     jjCheckNAdd(22);	                  break;	               case 25:	                  if (curChar == 34)	                     jjCheckNAddStates(10, 12);	                  break;	               case 26:	                  if ((0xfffffffbffffdbffL & l) != 0L)	                     jjCheckNAddStates(10, 12);	                  break;	               case 28:	                  if ((0x8400000000L & l) != 0L)	                     jjCheckNAddStates(10, 12);	                  break;	               case 29:	                  if (curChar == 34 && kind > 67)	                     kind = 67;	                  break;	               case 30:	                  if ((0xff000000000000L & l) != 0L)	                     jjCheckNAddStates(27, 30);	                  break;	               case 31:	                  if ((0xff000000000000L & l) != 0L)	                     jjCheckNAddStates(10, 12);	                  break;	               case 32:	                  if ((0xf000000000000L & l) != 0L)	                     jjstateSet[jjnewStateCnt++] = 33;	                  break;	               case 33:	                  if ((0xff000000000000L & l) != 0L)	                     jjCheckNAdd(31);	                  break;	               case 34:	                  if (curChar != 36)	                     break;	                  if (kind > 69)	                     kind = 69;	                  jjCheckNAdd(35);	                  break;	               case 35:	                  if ((0x3ff001000000000L & l) == 0L)	                     break;	                  if (kind > 69)	                     kind = 69;	                  jjCheckNAdd(35);	                  break;	               case 36:	                  if ((0x3ff000000000000L & l) != 0L)	                     jjCheckNAddStates(0, 6);	                  break;	               case 37:	                  if ((0x3ff000000000000L & l) != 0L)	                     jjCheckNAddTwoStates(37, 38);	                  break;	               case 38:	                  if (curChar != 46)	                     break;	                  if (kind > 64)	                     kind = 64;	                  jjCheckNAddStates(31, 33);	                  break;	               case 39:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 64)	                     kind = 64;	                  jjCheckNAddStates(31, 33);	                  break;	               case 41:	                  if ((0x280000000000L & l) != 0L)	                     jjCheckNAdd(42);	                  break;	               case 42:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 64)	                     kind = 64;	                  jjCheckNAddTwoStates(42, 15);	                  break;	               case 43:	                  if ((0x3ff000000000000L & l) != 0L)	                     jjCheckNAddTwoStates(43, 44);	                  break;	               case 45:	                  if ((0x280000000000L & l) != 0L)	                     jjCheckNAdd(46);	                  break;	               case 46:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 64)	                     kind = 64;	                  jjCheckNAddTwoStates(46, 15);	                  break;	               case 47:	                  if ((0x3ff000000000000L & l) != 0L)	                     jjCheckNAddStates(34, 36);	                  break;	               case 49:	                  if ((0x280000000000L & l) != 0L)	                     jjCheckNAdd(50);	                  break;	               case 50:	                  if ((0x3ff000000000000L & l) != 0L)	                     jjCheckNAddTwoStates(50, 15);	                  break;	               case 51:	                  if (curChar != 48)	                     break;	                  if (kind > 60)	                     kind = 60;	                  jjCheckNAddStates(15, 17);	                  break;	               case 53:	                  if ((0x3ff000000000000L & l) == 0L)	                     break;	                  if (kind > 60)	                     kind = 60;	                  jjCheckNAddTwoStates(53, 9);	                  break;	               case 54:	                  if ((0xff000000000000L & l) == 0L)	                     break;	                  if (kind > 60)	                     kind = 60;	                  jjCheckNAddTwoStates(54, 9);	                  break;	               case 55:	                  if (curChar == 47)	                     jjAddStates(7, 9);	                  break;	               case 57:	                  if ((0xffffffffffffdbffL & l) == 0L)	                     break;	                  if (kind > 7)	                     kind = 7;	                  jjCheckNAddStates(18, 20);	                  break;	               case 58:	                  if ((0x2400L & l) != 0L && kind > 7)	                     kind = 7;	                  break;	               case 59:	                  if (curChar == 10 && kind > 7)	                     kind = 7;	                  break;	               case 60:	                  if (curChar == 13)	                     jjstateSet[jjnewStateCnt++] = 59;	                  break;	               case 61:	                  if (curChar == 42)	                     jjCheckNAdd(62);	                  break;	               case 62:	                  if ((0xfffffbffffffffffL & l) != 0L)	                     jjCheckNAddTwoStates(62, 63);	                  break;	               case 63:	                  if (curChar == 42)	                     jjCheckNAddStates(37, 39);	                  break;	               case 64:	                  if ((0xffff7bffffffffffL & l) != 0L)	                     jjCheckNAddTwoStates(65, 63);	                  break;	               case 65:	                  if ((0xfffffbffffffffffL & l) != 0L)	                     jjCheckNAddTwoStates(65, 63);	                  break;	               case 66:	                  if (curChar == 47 && kind > 9)	                     kind = 9;	                  break;	               case 67:	                  if (curChar == 42)	                     jjCheckNAddTwoStates(68, 69);	                  break;	               case 68:	                  if ((0xfffffbffffffffffL & l) != 0L)	                     jjCheckNAddTwoStates(68, 69);	                  break;	               case 69:	                  if (curChar == 42)	                     jjCheckNAddStates(40, 42);	                  break;	               case 70:	                  if ((0xffff7bffffffffffL & l) != 0L)	                     jjCheckNAddTwoStates(71, 69);	                  break;	               case 71:	                  if ((0xfffffbffffffffffL & l) != 0L)	                     jjCheckNAddTwoStates(71, 69);	                  break;	               case 72:	                  if (curChar == 47 && kind > 68)	                     kind = 68;	                  break;	               case 73:	                  if (curChar == 42)	                     jjstateSet[jjnewStateCnt++] = 67;	                  break;	               default : break;	            }	         } while(i != startsAt);	      }	      else if (curChar < 128)	      {	         long l = 1L << (curChar & 077);	         MatchLoop: do	         {	            switch(jjstateSet[--i])	            {	               case 6:	               case 35:	                  if ((0x7fffffe87fffffeL & l) == 0L)	                     break;	                  if (kind > 69)	                     kind = 69;	                  jjCheckNAdd(35);	                  break;	               case 2:	                  jjAddStates(21, 23);	                  break;	               case 9:	                  if ((0x100000001000L & l) != 0L && kind > 60)	                     kind = 60;	                  break;	               case 12:	                  if ((0x2000000020L & l) != 0L)	                     jjAddStates(43, 44);	                  break;	               case 15:	                  if ((0x5000000050L & l) != 0L && kind > 64)	                     kind = 64;	                  break;	               case 17:	                  if ((0xffffffffefffffffL & l) != 0L)	                     jjCheckNAdd(18);	                  break;	               case 19:	                  if (curChar == 92)	                     jjAddStates(45, 47);	                  break;	               case 20:	                  if ((0x14404410000000L & l) != 0L)	                     jjCheckNAdd(18);	                  break;	               case 26:	                  if ((0xffffffffefffffffL & l) != 0L)	                     jjCheckNAddStates(10, 12);	                  break;	               case 27:	                  if (curChar == 92)	                     jjAddStates(48, 50);	                  break;	               case 28:	                  if ((0x14404410000000L & l) != 0L)	                     jjCheckNAddStates(10, 12);	                  break;	               case 40:	                  if ((0x2000000020L & l) != 0L)	                     jjAddStates(51, 52);	                  break;	               case 44:	                  if ((0x2000000020L & l) != 0L)	                     jjAddStates(53, 54);	                  break;	               case 48:	                  if ((0x2000000020L & l) != 0L)	                     jjAddStates(55, 56);	                  break;	               case 52:	                  if ((0x100000001000000L & l) != 0L)	                     jjCheckNAdd(53);	                  break;	               case 53:	                  if ((0x7e0000007eL & l) == 0L)	                     break;	                  if (kind > 60)	                     kind = 60;	                  jjCheckNAddTwoStates(53, 9);	                  break;	               case 57:	                  if (kind > 7)	                     kind = 7;	                  jjAddStates(18, 20);	                  break;	               case 62:	                  jjCheckNAddTwoStates(62, 63);	                  break;	               case 64:	               case 65:	                  jjCheckNAddTwoStates(65, 63);	                  break;	               case 68:	                  jjCheckNAddTwoStates(68, 69);	                  break;	               case 70:	               case 71:	                  jjCheckNAddTwoStates(71, 69);	                  break;	               default : break;	            }	         } while(i != startsAt);	      }	      else	      {	         int hiByte = (int)(curChar >> 8);	         int i1 = hiByte >> 6;	         long l1 = 1L << (hiByte & 077);	         int i2 = (curChar & 0xff) >> 6;	         long l2 = 1L << (curChar & 077);	         MatchLoop: do	         {	            switch(jjstateSet[--i])	            {	               case 6:	                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))	                  {	                     if (kind > 6)	                        kind = 6;	                     jjCheckNAdd(0);	                  }	                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))	                  {	                     if (kind > 69)	                        kind = 69;	                     jjCheckNAdd(35);	                  }	                  break;	               case 0:	                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))	                     break;	                  if (kind > 6)	                     kind = 6;	                  jjCheckNAdd(0);	                  break;	               case 2:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjAddStates(21, 23);	                  break;	               case 17:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjstateSet[jjnewStateCnt++] = 18;	                  break;	               case 26:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjAddStates(10, 12);	                  break;	               case 34:	               case 35:	                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))	                     break;	                  if (kind > 69)	                     kind = 69;	                  jjCheckNAdd(35);	                  break;	               case 57:	                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))	                     break;	                  if (kind > 7)	                     kind = 7;	                  jjAddStates(18, 20);	                  break;	               case 62:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjCheckNAddTwoStates(62, 63);	                  break;	               case 64:	               case 65:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjCheckNAddTwoStates(65, 63);	                  break;	               case 68:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjCheckNAddTwoStates(68, 69);	                  break;	               case 70:	               case 71:	                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))	                     jjCheckNAddTwoStates(71, 69);	                  break;	               default : break;	            }	         } while(i != startsAt);	      }	      if (kind != 0x7fffffff)	      {	         jjmatchedKind = kind;	         jjmatchedPos = curPos;	         kind = 0x7fffffff;	      }	      ++curPos;	      if ((i = jjnewStateCnt) == (startsAt = 74 - (jjnewStateCnt = startsAt)))	         return curPos;	      try { curChar = input_stream.readChar(); }	      catch(java.io.IOException e) { return curPos; }	   }	}	
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)	{	   switch(hiByte)	   {	      case 0:	         return ((jjbitVec0[i2] & l2) != 0L);	      default : 	         return false;	   }	}	
private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)	{	   switch(hiByte)	   {	      case 0:	         return ((jjbitVec0[i2] & l2) != 0L);	      default : 	         if ((jjbitVec1[i1] & l1) != 0L)	            return true;	         return false;	   }	}	
private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)	{	   switch(hiByte)	   {	      case 0:	         return ((jjbitVec4[i2] & l2) != 0L);	      case 48:	         return ((jjbitVec5[i2] & l2) != 0L);	      case 49:	         return ((jjbitVec6[i2] & l2) != 0L);	      case 51:	         return ((jjbitVec7[i2] & l2) != 0L);	      case 61:	         return ((jjbitVec8[i2] & l2) != 0L);	      default : 	         if ((jjbitVec3[i1] & l1) != 0L)	            return true;	         return false;	   }	}	
public ParserTokenManager(JavaCharStream stream)	{	   if (JavaCharStream.staticFlag)	      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");	   input_stream = stream;	}	
public ParserTokenManager(JavaCharStream stream, int lexState)	{	   this(stream);	   SwitchTo(lexState);	}	
public void ReInit(JavaCharStream stream)	{	   jjmatchedPos = jjnewStateCnt = 0;	   curLexState = defaultLexState;	   input_stream = stream;	   ReInitRounds();	}	
private final void ReInitRounds()	{	   int i;	   jjround = 0x80000001;	   for (i = 74; i-- > 0;)	      jjrounds[i] = 0x80000000;	}	
public void ReInit(JavaCharStream stream, int lexState)	{	   ReInit(stream);	   SwitchTo(lexState);	}	
public void SwitchTo(int lexState)	{	   if (lexState >= 1 || lexState < 0)	      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);	   else	      curLexState = lexState;	}	
protected Token jjFillToken()	{	   Token t = Token.newToken(jjmatchedKind);	   t.kind = jjmatchedKind;	   String im = jjstrLiteralImages[jjmatchedKind];	   t.image = (im == null) ? input_stream.GetImage() : im;	   t.beginLine = input_stream.getBeginLine();	   t.beginColumn = input_stream.getBeginColumn();	   t.endLine = input_stream.getEndLine();	   t.endColumn = input_stream.getEndColumn();	   return t;	}	
public Token getNextToken() 	{	  int kind;	  Token specialToken = null;	  Token matchedToken;	  int curPos = 0;		  EOFLoop :	  for (;;)	  {   	   try   	   {     	      curChar = input_stream.BeginToken();	   }     	   catch(java.io.IOException e)	   {        	      jjmatchedKind = 0;	      matchedToken = jjFillToken();	      matchedToken.specialToken = specialToken;	      return matchedToken;	   }		   jjmatchedKind = 0x7fffffff;	   jjmatchedPos = 0;	   curPos = jjMoveStringLiteralDfa0_0();	   if (jjmatchedKind != 0x7fffffff)	   {	      if (jjmatchedPos + 1 < curPos)	         input_stream.backup(curPos - jjmatchedPos - 1);	      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)	      {	         matchedToken = jjFillToken();	         matchedToken.specialToken = specialToken;	         return matchedToken;	      }	      else	      {	         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)	         {	            matchedToken = jjFillToken();	            if (specialToken == null)	               specialToken = matchedToken;	            else	            {	               matchedToken.specialToken = specialToken;	               specialToken = (specialToken.next = matchedToken);	            }	         }	         continue EOFLoop;	      }	   }	   int error_line = input_stream.getEndLine();	   int error_column = input_stream.getEndColumn();	   String error_after = null;	   boolean EOFSeen = false;	   try { input_stream.readChar(); input_stream.backup(1); }	   catch (java.io.IOException e1) {	      EOFSeen = true;	      error_after = curPos <= 1 ? "" : input_stream.GetImage();	      if (curChar == '\n' || curChar == '\r') {	         error_line++;	         error_column = 0;	      }	      else	         error_column++;	   }	   if (!EOFSeen) {	      input_stream.backup(1);	      error_after = curPos <= 1 ? "" : input_stream.GetImage();	   }	   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);	  }	}	
public PasteFromListDialog(String name, View view, MutableListModel model)		{			super(view,jEdit.getProperty(name + ".title"),true);			this.view = view;			this.listModel = model;				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);			JPanel center = new JPanel(new GridLayout(2,1,2,12));				clips = new JList(model);			clips.setCellRenderer(new Renderer());			clips.setVisibleRowCount(12);				clips.addMouseListener(new MouseHandler());			clips.addListSelectionListener(new ListHandler());				insert = new JButton(jEdit.getProperty("common.insert"));			cancel = new JButton(jEdit.getProperty("common.cancel"));				JLabel label = new JLabel(jEdit.getProperty(name + ".caption"));			label.setBorder(new EmptyBorder(0,0,6,0));			content.add(BorderLayout.NORTH,label);				JScrollPane scroller = new JScrollPane(clips);			scroller.setPreferredSize(new Dimension(500,150));			center.add(scroller);				clipText = new JTextArea();			clipText.setEditable(false);			scroller = new JScrollPane(clipText);			scroller.setPreferredSize(new Dimension(500,150));			center.add(scroller);				content.add(center, BorderLayout.CENTER);				JPanel panel = new JPanel();			panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));			panel.setBorder(new EmptyBorder(12,0,0,0));			panel.add(Box.createGlue());			panel.add(insert);			panel.add(Box.createHorizontalStrut(6));			panel.add(cancel);			panel.add(Box.createGlue());			content.add(panel, BorderLayout.SOUTH);				if(model.getSize() >= 1)				clips.setSelectedIndex(0);			updateButtons();				getRootPane().setDefaultButton(insert);			insert.addActionListener(new ActionHandler());			cancel.addActionListener(new ActionHandler());				GUIUtilities.requestFocus(this,clips);				pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public void ok()		{			Object[] selected = clips.getSelectedValues();			if(selected == null || selected.length == 0)			{				getToolkit().beep();				return;			}				String text = getSelectedClipText();				/**			 * For each selected clip, we remove it, then add it back			 * to the model. This has the effect of moving it to the			 * top of the list.			 */			for(int i = 0; i < selected.length; i++)			{				listModel.removeElement(selected[i]);				listModel.insertElementAt(selected[i],0);			}				view.getTextArea().setSelectedText(text);				dispose();		}	
public void cancel()		{			dispose();		}	
private String getSelectedClipText()		{			Object[] selected = clips.getSelectedValues();			StringBuilder clip = new StringBuilder();			for(int i = 0; i < selected.length; i++)			{				if(i != 0)					clip.append('\n');				clip.append(selected[i]);			}			return clip.toString();		}	
private void updateButtons()		{			int selected = clips.getSelectedIndex();			insert.setEnabled(selected != -1);		}	
private void showClipText()		{			Object[] selected = clips.getSelectedValues();			if(selected == null || selected.length == 0)				clipText.setText("");			else				clipText.setText(getSelectedClipText());			clipText.setCaretPosition(0);		}	
String shorten(String item)			{				StringBuilder buf = new StringBuilder();				// workaround for Swing rendering labels starting				// with <html> using the HTML engine				if(item.toLowerCase().startsWith("<html>"))					buf.append(' ');				boolean ws = true;				for(int i = 0; i < item.length(); i++)				{					char ch = item.charAt(i);					if(Character.isWhitespace(ch))					{						if(ws)							/* do nothing */;						else						{							buf.append(' ');							ws = true;						}					}					else					{						ws = false;						buf.append(ch);					}				}					if(buf.length() == 0)					return jEdit.getProperty("paste-from-list.whitespace");				return buf.toString();			}	
public Component getListCellRendererComponent(				JList list, Object value, int index,				boolean isSelected, boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,index,					isSelected,cellHasFocus);					setText(shorten(value.toString()));					return this;			}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == insert)					ok();				else if(source == cancel)					cancel();			}	
public void valueChanged(ListSelectionEvent evt)			{				showClipText();				updateButtons();			}	
public void mouseClicked(MouseEvent evt)			{				if(evt.getClickCount() == 2)					ok();			}	
/**		 * Creates a new regular expression string matcher.		 * @see java.util.regex.Pattern		 * @param search the search pattern		 * @param ignoreCase <code>true</code> if you want to ignore case		 * @since jEdit 4.3pre5		 */		public PatternSearchMatcher(String search, boolean ignoreCase)		{			pattern = search;			flags = getFlag(ignoreCase);		}	
/**		 * Creates a new regular expression already compiled.		 * @see java.util.regex.Pattern		 * @param re the compiled regex		 * @param ignoreCase <code>true</code> if you want to ignore case		 * @since jEdit 4.3pre13		 */		public PatternSearchMatcher(Pattern re, boolean ignoreCase)		{			this(re.pattern(), ignoreCase);			this.re = re;		}	
/**		 * Returns the offset of the first match of the specified text		 * within this matcher.		 *		 * @param text 		The text to search in		 * @param start 	True if the start of the segment is the beginning		 *			of the buffer		 * @param end 		True if the end of the segment is the end of the		 *			buffer		 * @param firstTime 	If false and the search string matched at the		 *			start offset with length zero, automatically		 *			find next match		 * @param reverse 	If true find match prior to current match		 * 			(this is done by searching from the beginning to		 * 			just prior to the current match, so will be inefficient		 * 			for large buffers)		 *		 * @return A {@link SearchMatcher.Match} object.		 * @since jEdit 4.3pre5		 */		@Override		public SearchMatcher.Match nextMatch(CharSequence text, boolean start,			boolean end, boolean firstTime, boolean reverse)		{			// "For the mean time, there is no way to automatically generate a sexeger"			//			// http://japhy.perlmonk.org/sexeger/sexeger.html			//			// So ... for reverse regex searches we will search 			// the string in the forward direction and 			// return the last match.						// Since we search the String in the forward direction,			// (even for reverse searches) un-reverse the ReverseCharSequence.			if (text instanceof ReverseCharSequence)				text = ((ReverseCharSequence)text).baseSequence();				if (re == null)				re = Pattern.compile(pattern, flags);				Matcher match = re.matcher(text);			if (!match.find())				return null;				// if we're not at the start of the buffer, and the pattern			// begins with "^" and matched the beginning of the region			// being matched, ignore the match and try the next one.			if (!start && match.start() == 0				&& re.pattern().charAt(0) == '^' && !match.find())				return null;				// Special care for zero width matches. Without this care,			// the caller will fall into an infinite loop, for non-reverse			// search.			if (!reverse && !firstTime && match.start() == 0 && match.end() == 0)			{				if (!match.find())					return null;			}				Match previous = null;			while (true)			{				// if we're not at the end of the buffer and we				// match the end of the text, and the pattern ends with a "$",				// ignore the match.				// The match at the end the buffer which immediately follows				// the final newline is also ignored because it is generally				// not expected as an EOL.				if ((!end || (text.charAt(text.length() - 1) == '\n'))					&& match.end() == text.length()					&& pattern.charAt(pattern.length() - 1) == '$')				{					if (previous != null)					{						returnValue.start = previous.start;						returnValue.end = previous.end;						returnValue.substitutions = previous.substitutions;						break;					}					else					{						return null;					}				}					returnValue.substitutions = new String[match.groupCount() + 1];				for(int i = 0; i < returnValue.substitutions.length; i++)				{					returnValue.substitutions[i] = match.group(i);				}						int _start = match.start();				int _end = match.end();						returnValue.start = _start;				returnValue.end = _end;								// For non-reversed searches, we break immediately				// to return the first match.  For reversed searches,				// we continue until no more matches are found				if (!reverse || !match.find())				{					// For reverse search, check for zero width match at					// the end of text.					if (reverse && !firstTime && returnValue.start == text.length()						&& returnValue.end == text.length())					{						if (previous != null)						{							returnValue.start = previous.start;							returnValue.end = previous.end;							returnValue.substitutions = previous.substitutions;						}						else						{							return null;						}					}					break;				}				// Save the result for reverse zero width match.				if (previous == null)				{					previous = new Match();				}				previous.start = returnValue.start;				previous.end = returnValue.end;				previous.substitutions = returnValue.substitutions;			}				if (reverse)			{				// The caller assumes we are searching a reversed				// CharSegment, so we need to reverse the indices				// before returning				int len = returnValue.end - returnValue.start;				returnValue.start = text.length() - returnValue.end;				returnValue.end = returnValue.start + len;			}				return returnValue;		}	
@Override		public String toString()		{			boolean ignoreCase = (flags & Pattern.CASE_INSENSITIVE) != 0;			return "PatternSearchMatcher[" + pattern + ',' + ignoreCase + ']';		}	
static int getFlag(boolean ignoreCase)		{			int flags = Pattern.MULTILINE;			if (ignoreCase)				flags |= Pattern.CASE_INSENSITIVE;			return flags;		}	
/**		 * We only autosave the perspective if it has changed, to avoid spinning		 * up the disk on laptops.		 * @since jEdit 4.2pre13		 */		public static boolean isPerspectiveDirty()		{			return dirty;		}	
/**		 * We only autosave the perspective if it has changed, to avoid spinning		 * up the disk on laptops.		 * @since jEdit 4.2pre13		 */		public static void setPerspectiveDirty(boolean dirty)		{			PerspectiveManager.dirty = dirty;		}	
/**		 * We disable saving of the perspective while the 'close all' dialog is		 * showing.		 * @since jEdit 4.3pre2		 */		public static boolean isPerspectiveEnabled()		{			return enabled;		}	
/**		 * We disable saving of the perspective while the 'close all' dialog is		 * showing.		 * @since jEdit 4.3pre2		 */		public static void setPerspectiveEnabled(boolean enabled)		{			PerspectiveManager.enabled = enabled;		}	
public static View loadPerspective(boolean restoreFiles)		{			if(perspectiveXML == null)				return null;				if(!perspectiveXML.fileExists())				return null;				Log.log(Log.MESSAGE,PerspectiveManager.class,"Loading " + perspectiveXML);				PerspectiveHandler handler = new PerspectiveHandler(restoreFiles);			try			{				perspectiveXML.load(handler);			}			catch(IOException e)			{				Log.log(Log.ERROR,PerspectiveManager.class,e);			}			return handler.view;		}	
public static void savePerspective(boolean autosave)		{			if(!isPerspectiveEnabled() || !jEdit.isStartupDone())				return;				if(perspectiveXML == null)				return;						// backgrounded			if(jEdit.getBufferCount() == 0)				return;				Buffer[] buffers = jEdit.getBuffers();			Collection<Buffer> savedBuffers = new LinkedList<Buffer>();			for (Buffer buffer: buffers)			{				if (!buffer.isNewFile())				{					savedBuffers.add(buffer);				}			}				if(!autosave)				Log.log(Log.MESSAGE,PerspectiveManager.class,"Saving " + perspectiveXML);				String lineSep = System.getProperty("line.separator");				SettingsXML.Saver out = null;				try			{				out = perspectiveXML.openSaver();				out.writeXMLDeclaration();					out.write("<!DOCTYPE PERSPECTIVE SYSTEM \"perspective.dtd\">");				out.write(lineSep);				out.write("<PERSPECTIVE>");				out.write(lineSep);					for (Buffer buffer: savedBuffers)				{					out.write("<BUFFER AUTORELOAD=\"");					out.write(buffer.getAutoReload() ? "TRUE" : "FALSE");					out.write("\" AUTORELOAD_DIALOG=\"");					out.write(buffer.getAutoReloadDialog() ? "TRUE" : "FALSE");					out.write("\">");					out.write(XMLUtilities.charsToEntities(buffer.getPath(), false));					out.write("</BUFFER>");					out.write(lineSep);				}					View[] views = jEdit.getViews();				for(int i = 0; i < views.length; i++)				{					View view = views[i];					// ensures that active view is saved last,					// ie created last on next load, ie in front					// on next load					if(view == jEdit.getActiveView()						&& i != views.length - 1)					{						View last = views[views.length - 1];						views[i] = last;						views[views.length - 1] = view;						view = last;					}						View.ViewConfig config = views[i].getViewConfig();					out.write("<VIEW PLAIN=\"");					out.write(config.plainView ? "TRUE" : "FALSE");					out.write("\">");						out.write("<PANES>");					out.write(lineSep);					out.write(XMLUtilities.charsToEntities(						config.splitConfig,false));					out.write(lineSep);					out.write("</PANES>");					out.write(lineSep);						out.write("<GEOMETRY X=\"");					out.write(String.valueOf(config.x));					out.write("\" Y=\"");					out.write(String.valueOf(config.y));					out.write("\" WIDTH=\"");					out.write(String.valueOf(config.width));					out.write("\" HEIGHT=\"");					out.write(String.valueOf(config.height));					out.write("\" EXT_STATE=\"");					out.write(String.valueOf(config.extState));					out.write("\" />");					out.write(lineSep);						if (config.docking != null)						config.docking.saveLayout(PERSPECTIVE_FILENAME, i);										out.write("</VIEW>");					out.write(lineSep);				}					out.write("</PERSPECTIVE>");				out.write(lineSep);					out.finish();			}			catch(IOException io)			{				Log.log(Log.ERROR,PerspectiveManager.class,"Error saving " + perspectiveXML);				Log.log(Log.ERROR,PerspectiveManager.class,io);			}			finally			{				IOUtilities.closeQuietly(out);			}		}	
PerspectiveHandler(boolean restoreFiles)			{				this.restoreFiles = restoreFiles;				config = new View.ViewConfig();				charData = new StringBuilder();				config.docking = View.getDockingFrameworkProvider().createDockingLayout();			}	
@Override			public InputSource resolveEntity(String publicId, String systemId)			{				return XMLUtilities.findEntity(systemId, "perspective.dtd", getClass());			}	
@Override			public void startElement(String uri, String localName,						 String qName, Attributes attrs)			{				charData.setLength(0);				for (int i = 0; i < attrs.getLength(); i++)				{					String name = attrs.getQName(i);					String value = attrs.getValue(i);					attribute(name, value);				}			}	
private void attribute(String aname, String value)			{				if(aname.equals("X"))					config.x = Integer.parseInt(value);				else if(aname.equals("Y"))					config.y = Integer.parseInt(value);				else if(aname.equals("WIDTH"))					config.width = Integer.parseInt(value);				else if(aname.equals("HEIGHT"))					config.height = Integer.parseInt(value);				else if(aname.equals("EXT_STATE"))					config.extState = Integer.parseInt(value);				else if(aname.equals("PLAIN"))					config.plainView = ("TRUE".equals(value));				else if(aname.equals("AUTORELOAD"))					autoReload = value;				else if(aname.equals("AUTORELOAD_DIALOG"))					autoReloadDialog = value;			}	
/**			 * @return true if the uri points to a remote file			 */			public static boolean skipRemote(String uri)			{				if (jEdit.getBooleanProperty("restore.remote"))					return false;				if(MiscUtilities.isURL(uri))				{					String protocol = MiscUtilities.getProtocolOfURL(uri);					if (!protocol.equals("file")) return true;				}				return false;			}	
@Override			public void endElement(String uri, String localName, String name)			{				if(name.equals("BUFFER"))				{					if (restoreFiles && !skipRemote(charData.toString()))					{						Buffer restored = jEdit.openTemporary(null,null, charData.toString(), false);						// if the autoReload attributes are not present, don't set anything						// it's sufficient to check whether they are present on the first BUFFER element						if (restored != null)						{							if(autoReload != null)								restored.setAutoReload("TRUE".equals(autoReload));							if(autoReloadDialog != null)								restored.setAutoReloadDialog("TRUE".equals(autoReloadDialog));							jEdit.commitTemporary(restored);						}					}				}				else if(name.equals("PANES"))					config.splitConfig = charData.toString();				else if(name.equals("VIEW"))				{					if (config.docking != null)						config.docking.loadLayout(PERSPECTIVE_FILENAME, jEdit.getViewCount());					view = jEdit.newView(view,null,config);					config = new View.ViewConfig();					config.docking = View.getDockingFrameworkProvider().createDockingLayout();				}			}	
@Override			public void characters(char[] ch, int start, int length)			{				charData.append(ch,start,length);			}	
PluginDetailPanel()		{			setLayout(new BorderLayout());			pluginDetail = new JEditorPane();			pluginDetail.setEditable(false);			pluginDetail.setContentType("text/html");			pluginDetail.setBackground(jEdit.getColorProperty("view.bgColor"));			pluginDetail.setForeground(jEdit.getColorProperty("view.fgColor"));			pluginDetail.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, true);			title = new JLabel();			add(title, BorderLayout.NORTH);			JScrollPane scroll = new JScrollPane(pluginDetail);			scroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);			add(scroll);		}	
void setPlugin(Entry entry)		{			if (entry != this.entry)			{				if (entry.status.equals(Entry.LOADED))				{					title.setText("<html><b>"+entry.name+"</b></html>");					StringBuilder builder = new StringBuilder();										builder.append("<b>Version</b>: ").append(entry.version).append("<br/>");					builder.append("<b>Author</b>: ").append(entry.author).append("<br/>");					if (entry.description != null)					{						builder.append("<br/>").append(entry.description);					}					pluginDetail.setText(builder.toString());				}				else				{					title.setText("<html><b>"+entry.jar+"</b></html>");					pluginDetail.setText(null);				}				this.entry = entry;			}		}	
/**		 * Loads a plugin, and its dependent plugins if necessary.		 *		 * @since jEdit 4.3pre7		 */		public static PluginJAR load(String path, boolean loadDependents)		{			PluginJAR jar = jEdit.getPluginJAR(path);			if (jar != null && jar.getPlugin() != null)			{				return jar;			}			jEdit.addPluginJAR(path);			jar = jEdit.getPluginJAR(path);			EditPlugin plugin = jar.getPlugin();			if (plugin == null)			{				// No plugin, maybe it is a library				return jar;			}			String className = plugin.getClassName();			if (loadDependents)			{				Set<String> pluginLoadList = getDependencySet(className);				for (String jarName: pluginLoadList)				{					String jarPath = findPlugin(jarName);					load(jarPath, false);				}			}			// Load extra jars that are part of this plugin			String jars = jEdit.getProperty("plugin." + className + ".jars");			if(jars != null)			{				String dir = MiscUtilities.getParentOfPath(path);				StringTokenizer st = new StringTokenizer(jars);				while(st.hasMoreTokens())				{					String _jarPath = MiscUtilities.constructPath(dir,st.nextToken());					PluginJAR _jar = jEdit.getPluginJAR(_jarPath);					if(_jar == null)					{						jEdit.addPluginJAR(_jarPath);					}				}			}			jar.checkDependencies();			jar.activatePluginIfNecessary();			return jar;		}	
/**		 * Returns the full path name of this plugin's JAR file.		 */		public String getPath()		{			return path;		}	
/**		 * Unlike getPlugin(), will return a PluginJAR that is not yet loaded,		 * given its classname.		 *		 * @param className a class name		 * @return the JARpath of the first PluginJAR it can find which contains this className,		 * 		    or null if not found.		 * @since 4.3pre7		 */		public static String findPlugin(String className)		{			EditPlugin ep = jEdit.getPlugin(className);			if (ep != null) return ep.getPluginJAR().getPath();				for (String JARpath: jEdit.getNotLoadedPluginJARs())			{				PluginJAR pjar = new PluginJAR(new File(JARpath));				if (pjar.containsClass(className))				{					return JARpath;				}			}			return null;		}	
/**		 * @param className a class name		 * @return true if this jar contains a class with that classname.		 * @since jedit 4.3pre7		 */		boolean containsClass(String className)		{			try			{				getZipFile();			}			catch (IOException ioe)			{				throw new RuntimeException(ioe);			}			Enumeration<? extends ZipEntry> itr = zipFile.entries();			while (itr.hasMoreElements())			{				String entry = itr.nextElement().toString();				if (entry.endsWith(".class"))				{					String name = entry.substring(0, entry.length() - 6).replace('/', '.');					if (name.equals(className))						return true;				}			}			return false;			}	
/**		 * Returns the full path name of this plugin's summary file.		 * The summary file is used to store certain information which allows		 * loading of the plugin's resources and core class to be deferred		 * until the plugin is first used. As long as a plugin is using the		 * jEdit 4.2 plugin API, no extra effort is required to take advantage		 * of the summary cache.		 */		public String getCachePath()		{			return cachePath;		}	
/**		 *		 * @param className of a plugin that we wish to load		 * @return an ordered set of JARpaths that contains the		 *      plugins that need to be (re)loaded, in the correct order.		 */		public static Set<String> getDependencySet(String className)		{			String dep;			Set<String> retval = new LinkedHashSet<String>();			int i=0;			while((dep = jEdit.getProperty("plugin." + className + ".depend." + i++)) != null)			{				PluginDepends pluginDepends;				try				{					pluginDepends = getPluginDepends(dep);				}				catch (IllegalArgumentException e)				{					Log.log(Log.ERROR, PluginJAR.class,						className + " has an invalid dependency: " + dep);					continue;				}					if(pluginDepends.what.equals("plugin"))				{					int index2 = pluginDepends.arg.indexOf(' ');					if ( index2 == -1)					{						Log.log(Log.ERROR, PluginJAR.class, className							+ " has an invalid dependency: "							+ dep + " (version is missing)");						continue;					}						String pluginName = pluginDepends.arg.substring(0,index2);					String needVersion = pluginDepends.arg.substring(index2 + 1);					//todo : check version ?					Set<String> loadTheseFirst = getDependencySet(pluginName);					loadTheseFirst.add(pluginName);					loadTheseFirst.addAll(retval);					retval = loadTheseFirst;				}			}			return retval;		}	
/**		 * Returns a file pointing to the plugin JAR.		 */		public File getFile()		{			return file;		}	
/**		 * Returns the plugin's class loader.		 */		public JARClassLoader getClassLoader()		{			return classLoader;		}	
/**		 * Returns the plugin's JAR file, opening it if necessary.		 * @since jEdit 4.2pre1		 */		public synchronized ZipFile getZipFile() throws IOException		{			if(zipFile == null)			{				Log.log(Log.DEBUG,this,"Opening " + path);				zipFile = new ZipFile(path);			}			return zipFile;		}	
/**		 * @deprecated Call getActionSet() instead		 */		public ActionSet getActions()		{			return getActionSet();		}	
/**		 * Returns the plugin's action set for the jEdit action context		 * {@link jEdit#getActionContext()}. These actions are loaded from		 * the <code>actions.xml</code> file; see {@link ActionSet}.		 *.		 * @since jEdit 4.2pre1		 */		public ActionSet getActionSet()		{			return actions;		}	
/**		 * Returns the plugin's action set for the file system browser action		 * context {@link		 * org.gjt.sp.jedit.browser.VFSBrowser#getActionContext()}.		 * These actions are loaded from		 * the <code>browser.actions.xml</code> file; see {@link ActionSet}.		 *.		 * @since jEdit 4.2pre1		 */		public ActionSet getBrowserActionSet()		{			return browserActions;		}	
/**		 * Returns true if all dependencies are satisified, false otherwise.		 * Also if dependencies are not satisfied, the plugin is marked as		 * "broken".		 *		 */		public boolean checkDependencies()		{			if(plugin == null)				return true;			int i = 0;			boolean ok = true;				String name = plugin.getClassName();				String dep;			while((dep = jEdit.getProperty("plugin." + name + ".depend." + i++)) != null)			{				PluginDepends pluginDepends;				try				{					pluginDepends = getPluginDepends(dep);				}				catch (IllegalArgumentException e)				{					Log.log(Log.ERROR,this,name + " has an invalid"						+ " dependency: " + dep);					ok = false;					continue;				}					if(pluginDepends.what.equals("jdk"))				{					if(!pluginDepends.optional && StandardUtilities.compareStrings(						System.getProperty("java.version"),						pluginDepends.arg,false) < 0)					{						String[] args = { pluginDepends.arg,							System.getProperty("java.version") };						jEdit.pluginError(path,"plugin-error.dep-jdk",args);						ok = false;					}				}				else if(pluginDepends.what.equals("jedit"))				{					if(pluginDepends.arg.length() != 11)					{						Log.log(Log.ERROR,this,"Invalid jEdit version"							+ " number: " + pluginDepends.arg);						ok = false;					}						if(!pluginDepends.optional && StandardUtilities.compareStrings(						jEdit.getBuild(),pluginDepends.arg,false) < 0)					{						String needs = MiscUtilities.buildToVersion(pluginDepends.arg);						String[] args = { needs,							jEdit.getVersion() };						jEdit.pluginError(path,							"plugin-error.dep-jedit",args);						ok = false;					}				}				else if(pluginDepends.what.equals("plugin"))				{					int index2 = pluginDepends.arg.indexOf(' ');					if(index2 == -1)					{						Log.log(Log.ERROR,this,name							+ " has an invalid dependency: "							+ dep + " (version is missing)");						ok = false;						continue;					}						String pluginName = pluginDepends.arg.substring(0,index2);					String needVersion = pluginDepends.arg.substring(index2 + 1);					String currVersion = jEdit.getProperty("plugin."						+ pluginName + ".version");						EditPlugin editPlugin = jEdit.getPlugin(pluginName, false);					if(editPlugin == null)					{						if(!pluginDepends.optional)						{							String[] args = { needVersion,								pluginName };							jEdit.pluginError(path,								"plugin-error.dep-plugin.no-version",								args);							ok = false;						}					}					else if(StandardUtilities.compareStrings(						currVersion,needVersion,false) < 0)					{						if(!pluginDepends.optional)						{							String[] args = { needVersion,								pluginName, currVersion };							jEdit.pluginError(path, "plugin-error.dep-plugin",args);							ok = false;						}					}					else if(editPlugin instanceof EditPlugin.Broken)					{						if(!pluginDepends.optional)						{							String[] args = { pluginName };							jEdit.pluginError(path, "plugin-error.dep-plugin.broken",args);							ok = false;						}					}					else					{						PluginJAR jar = editPlugin.getPluginJAR();						if (pluginDepends.optional)						{							jar.theseUseMe.add(path);							weUseThese.add(jar.getPath());						}						else						{							jar.theseRequireMe.add(path);							weRequireThese.add(jar.getPath());						}					}				}				else if(pluginDepends.what.equals("class"))				{					if(!pluginDepends.optional)					{						try						{							classLoader.loadClass(pluginDepends.arg,false);						}						catch(Exception e)						{							String[] args = { pluginDepends.arg };							jEdit.pluginError(path, "plugin-error.dep-class",args);							ok = false;						}					}				}				else				{					Log.log(Log.ERROR,this,name + " has unknown"						+ " dependency: " + dep);					ok = false;				}			}				// each JAR file listed in the plugin's jars property			// needs to know that we need them			String jars = jEdit.getProperty("plugin."				+ plugin.getClassName() + ".jars");			if(jars != null)			{				String dir = MiscUtilities.getParentOfPath(path);					StringTokenizer st = new StringTokenizer(jars);				while(st.hasMoreTokens())				{					String jarPath = MiscUtilities.constructPath(						dir,st.nextToken());					PluginJAR jar = jEdit.getPluginJAR(jarPath);					if(jar == null)					{						String[] args = { jarPath };						jEdit.pluginError(path, "plugin-error.missing-jar",args);						ok = false;					}					else					{						weRequireThese.add(jarPath);						jar.theseRequireMe.add(path);					}				}			}				if(!ok)				breakPlugin();				return ok;		}	
/**		 * Returns the required jars of this plugin.		 *		 * @return the required jars of this plugin		 * @since jEdit 4.3pre12		 */		public Set<String> getRequiredJars()		{			return weRequireThese;		}	
private static PluginDepends getPluginDepends(String dep) throws IllegalArgumentException		{			boolean optional;			if(dep.startsWith("optional "))			{				optional = true;				dep = dep.substring("optional ".length());			}			else			{				optional = false;			}				int index = dep.indexOf(' ');			if(index == -1)				throw new IllegalArgumentException("wrong dependency");				String what = dep.substring(0,index);			String arg = dep.substring(index + 1);			PluginDepends depends = new PluginDepends();			depends.what = what;			depends.arg = arg;			depends.optional = optional;			return depends;		}	
/**		 * If plugin A is needed by B, and B is needed by C, we want to		 * tell the user that A is needed by B and C when they try to		 * unload A.		 *		 * @param dependents a set of plugins which we wish to disable		 * @param listModel a set of plugins which will be affected, and will need		 *  to be disabled also.		 */		public static void transitiveClosure(String[] dependents, List<String> listModel)		{	  		for(int i = 0; i < dependents.length; i++)	  		{	  			String jarPath = dependents[i];	  			if(!listModel.contains(jarPath))	  			{	  				listModel.add(jarPath);	  				PluginJAR jar = jEdit.getPluginJAR(	  					jarPath);	  				transitiveClosure(jar.getDependentPlugins(),	  					listModel);	  			}	  		}	  	}	
public String[] getDependentPlugins()		  {			  return theseRequireMe.toArray(new String[theseRequireMe.size()]);		  }	
/**		 * Returns the plugin core class for this JAR file. Note that if the		 * plugin has not been activated, this will return an instance of		 * {@link EditPlugin.Deferred}. If you need the actual plugin core		 * class instance, call {@link #activatePlugin()} first.		 * If the plugin is not yet loaded, returns null		 *		 * @since jEdit 4.2pre1		 */		public EditPlugin getPlugin()		{			return plugin;		}	
/**		 * Loads the plugin core class. Does nothing if the plugin core class		 * has already been loaded. This method might be called on startup,		 * depending on what properties are set. See {@link EditPlugin#start()}.		 * This method is thread-safe.		 *		 * @since jEdit 4.2pre1		 */		public void activatePlugin()		{			synchronized (this)			{				if (activated)				{					// recursive call					return;				}					activated = true;			}				if (!(plugin instanceof EditPlugin.Deferred))			{				return;			}				String className = plugin.getClassName();				try			{				Class clazz = classLoader.loadClass(className,false);				int modifiers = clazz.getModifiers();				if(Modifier.isInterface(modifiers)					|| Modifier.isAbstract(modifiers)					|| !EditPlugin.class.isAssignableFrom(clazz))				{					Log.log(Log.ERROR,this,"Plugin has properties but does not extend EditPlugin: "						+ className);					breakPlugin();					return;				}					plugin = (EditPlugin)clazz.newInstance();				plugin.jar = this;			}			catch (Throwable t)			{				breakPlugin();					Log.log(Log.ERROR,this,"Error while starting plugin " + className);				Log.log(Log.ERROR,this,t);				String[] args = { t.toString() };				jEdit.pluginError(path,"plugin-error.start-error",args);					return;			}				if (jEdit.isMainThread()				|| SwingUtilities.isEventDispatchThread())			{				startPlugin();			}			else			{				// for thread safety				startPluginLater();			}				EditBus.send(new PluginUpdate(this,PluginUpdate.ACTIVATED,false));		}	
/**		 * Should be called after a new plugin is installed.		 * @since jEdit 4.2pre2		 */		public void activatePluginIfNecessary()		{			String filename = MiscUtilities.getFileName(getPath());			jEdit.setBooleanProperty("plugin-blacklist." + filename, false);			if(!(plugin instanceof EditPlugin.Deferred && plugin != null))			{				return;			}				String className = plugin.getClassName();				// default for plugins that don't specify this property (ie,			// 4.1-style plugins) is to load them on startup			String activate = jEdit.getProperty("plugin."				+ className + ".activate");				if(activate == null)			{				// 4.1 plugin				if(!jEdit.isMainThread())				{					breakPlugin();						jEdit.pluginError(path,"plugin-error.not-42",null);				}				else				{					activatePlugin();				}			}			else			{				// 4.2 plugin					// if at least one property listed here is true,				// load the plugin				boolean load = false;					StringTokenizer st = new StringTokenizer(activate);				while(st.hasMoreTokens())				{					String prop = st.nextToken();					boolean value = jEdit.getBooleanProperty(prop);					if(value)					{						Log.log(Log.DEBUG,this,"Activating "							+ className + " because of " + prop);						load = true;						break;					}				}					if(load)				{					activatePlugin();				}			}		}	
/**		 * Unloads the plugin core class. Does nothing if the plugin core class		 * has not been loaded.		 * This method can only be called from the AWT event dispatch thread!		 * @see EditPlugin#stop()		 *		 * @since jEdit 4.2pre3		 */		public void deactivatePlugin(boolean exit)		{			if(!activated)				return;				if(!exit)			{				// buffers retain a reference to the fold handler in				// question... and the easiest way to handle fold				// handler unloading is this...				Buffer buffer = jEdit.getFirstBuffer();				while(buffer != null)				{					if(buffer.getFoldHandler() != null						&& buffer.getFoldHandler().getClass()						.getClassLoader() == classLoader)					{						buffer.setFoldHandler(							new DummyFoldHandler());					}					buffer = buffer.getNext();				}			}				if(plugin != null && !(plugin instanceof EditPlugin.Broken))			{				if(plugin instanceof EBPlugin)					EditBus.removeFromBus((EBComponent)plugin);					try				{					plugin.stop();				}				catch(Throwable t)				{					Log.log(Log.ERROR,this,"Error while "						+ "stopping plugin:");					Log.log(Log.ERROR,this,t);				}					plugin = new EditPlugin.Deferred(this,					plugin.getClassName());					EditBus.send(new PluginUpdate(this,					PluginUpdate.DEACTIVATED,exit));					if(!exit)				{					// see if this is a 4.1-style plugin					String activate = jEdit.getProperty("plugin."						+ plugin.getClassName() + ".activate");						if(activate == null)					{						breakPlugin();						jEdit.pluginError(path,"plugin-error.not-42",null);					}				}			}				activated = false;		}	
/**		 * Returns the location of the plugin's		 * <code>dockables.xml</code> file.		 * @since jEdit 4.2pre1		 */		public URL getDockablesURI()		{			return dockablesURI;		}	
/**		 * Returns the location of the plugin's		 * <code>services.xml</code> file.		 * @since jEdit 4.2pre1		 */		public URL getServicesURI()		{			return servicesURI;		}	
@Override		public String toString()		{			if(plugin == null)				return path;			else				return path + ",class=" + plugin.getClassName();		}	
public static PluginCacheEntry getPluginCache(PluginJAR plugin)		{			String jarCachePath = plugin.getCachePath();			if(jarCachePath == null)				return null;				DataInputStream din = null;			try			{				PluginCacheEntry cache = new PluginCacheEntry();				cache.plugin = plugin;				cache.modTime = plugin.getFile().lastModified();				din = new DataInputStream(					new BufferedInputStream(					new FileInputStream(jarCachePath)));				if(cache.read(din))					return cache;				else				{					// returns false with outdated cache					return null;				}			}			catch(FileNotFoundException fnf)			{				return null;			}			catch(IOException io)			{				Log.log(Log.ERROR,PluginJAR.class,io);				return null;			}			finally			{				IOUtilities.closeQuietly(din);			}		}	
static void setPluginCache(PluginJAR plugin, PluginCacheEntry cache)		{			String jarCachePath = plugin.getCachePath();			if(jarCachePath == null)				return;				Log.log(Log.DEBUG,PluginJAR.class,"Writing " + jarCachePath);				DataOutputStream dout = null;			try			{				dout = new DataOutputStream(					new BufferedOutputStream(					new FileOutputStream(jarCachePath)));				cache.write(dout);				dout.close();			}			catch(IOException io)			{				Log.log(Log.ERROR,PluginJAR.class,io);				IOUtilities.closeQuietly(dout);				new File(jarCachePath).delete();			}		}	
/**		 * Creates a PluginJAR object which is not necessarily loaded, but can be later.		 * @see #load(String, boolean)		 */		public PluginJAR(File file)		{			path = file.getPath();			String jarCacheDir = jEdit.getJARCacheDirectory();			if(jarCacheDir != null)			{				cachePath = MiscUtilities.constructPath(					jarCacheDir,file.getName() + ".summary");			}			this.file = file;			classLoader = new JARClassLoader(this);			actions = new ActionSet();		}	
void init()		{			PluginCacheEntry cache = getPluginCache(this);			if(cache != null)			{				loadCache(cache);				classLoader.activate();			}			else			{				try				{					cache = generateCache();					if(cache != null)					{						setPluginCache(this,cache);						classLoader.activate();					}				}				catch(IOException io)				{					Log.log(Log.ERROR,this,"Cannot load"						+ " plugin " + path);					Log.log(Log.ERROR,this,io);						String[] args = { io.toString() };					jEdit.pluginError(path,"plugin-error.load-error",args);						uninit(false);				}			}		}	
void uninit(boolean exit)		{			deactivatePlugin(exit);				if(!exit)			{				for (String path : weRequireThese)				{					PluginJAR jar = jEdit.getPluginJAR(path);					if(jar != null)						jar.theseRequireMe.remove(this.path);				}					for (String path : weUseThese)				{					PluginJAR jar = jEdit.getPluginJAR(path);					if(jar != null)						jar.theseUseMe.remove(this.path);				}					classLoader.deactivate();				BeanShell.resetClassManager();					if(actions != null)					jEdit.removeActionSet(actions);				if(browserActions != null)					VFSBrowser.getActionContext().removeActionSet(browserActions);					DockableWindowFactory.getInstance()					.unloadDockableWindows(this);				ServiceManager.unloadServices(this);					jEdit.removePluginProps(properties);					try				{					if(zipFile != null)					{						zipFile.close();						zipFile = null;					}				}				catch(IOException io)				{					Log.log(Log.ERROR,this,io);				}			}		}	
String[] getClasses()		{			return classes;		}	
public String[] getResources()		{			return resources;		}	
private void actionsPresentButNotCoreClass()		{			Log.log(Log.WARNING,this,getPath() + " has an actions.xml but no plugin core class");			actions.setLabel("MISSING PLUGIN CORE CLASS");		}	
private void loadCache(PluginCacheEntry cache)		{			classes = cache.classes;			resources = cache.resources;				/* this should be before dockables are initialized */			if(cache.cachedProperties != null)			{				properties = cache.cachedProperties;				jEdit.addPluginProps(cache.cachedProperties);			}				if(cache.actionsURI != null				&& cache.cachedActionNames != null)			{				actions = new ActionSet(this,					cache.cachedActionNames,					cache.cachedActionToggleFlags,					cache.actionsURI);			}				if(cache.browserActionsURI != null				&& cache.cachedBrowserActionNames != null)			{				browserActions = new ActionSet(this,					cache.cachedBrowserActionNames,					cache.cachedBrowserActionToggleFlags,					cache.browserActionsURI);				VFSBrowser.getActionContext().addActionSet(browserActions);			}				if(cache.dockablesURI != null				&& cache.cachedDockableNames != null				&& cache.cachedDockableActionFlags != null				&& cache.cachedDockableMovableFlags != null)			{				dockablesURI = cache.dockablesURI;				DockableWindowFactory.getInstance()					.cacheDockableWindows(this,					cache.cachedDockableNames,					cache.cachedDockableActionFlags,					cache.cachedDockableMovableFlags);			}				if(actions.size() != 0)				jEdit.addActionSet(actions);				if(cache.servicesURI != null				&& cache.cachedServices != null)			{				servicesURI = cache.servicesURI;				for(int i = 0; i < cache.cachedServices.length;					i++)				{					ServiceManager.Descriptor d						= cache.cachedServices[i];					ServiceManager.registerService(d);				}			}				if(cache.pluginClass != null)			{				// Check if a plugin with the same name				// is already loaded				if(jEdit.getPlugin(cache.pluginClass) != null)				{					jEdit.pluginError(path, "plugin-error.already-loaded",						null);					uninit(false);				}				else				{					String label = jEdit.getProperty(						"plugin." + cache.pluginClass						+ ".name");					actions.setLabel(jEdit.getProperty(						"action-set.plugin",						new String[] { label }));					plugin = new EditPlugin.Deferred(this,						cache.pluginClass);				}			}			else			{				if(actions.size() != 0)					actionsPresentButNotCoreClass();			}		}	
public PluginCacheEntry generateCache() throws IOException		{			properties = new Properties();				List<String> classes = new LinkedList<String>();			List<String> resources = new LinkedList<String>();				ZipFile zipFile = getZipFile();				List<String> plugins = new LinkedList<String>();				PluginCacheEntry cache = new PluginCacheEntry();			cache.modTime = file.lastModified();			cache.cachedProperties = new Properties();				Enumeration<? extends ZipEntry> entries = zipFile.entries();			while(entries.hasMoreElements())			{				ZipEntry entry = entries.nextElement();				String name = entry.getName();				String lname = name.toLowerCase();				if(lname.equals("actions.xml"))				{					cache.actionsURI = classLoader.getResource(name);				}				else if(lname.equals("browser.actions.xml"))				{					cache.browserActionsURI = classLoader.getResource(name);				}				else if(lname.equals("dockables.xml"))				{					dockablesURI = classLoader.getResource(name);					cache.dockablesURI = dockablesURI;				}				else if(lname.equals("services.xml"))				{					servicesURI = classLoader.getResource(name);					cache.servicesURI = servicesURI;				}				else if(lname.endsWith(".props"))				{					InputStream in = classLoader.getResourceAsStream(name);					properties.load(in);					in.close();				}				else if(name.endsWith(".class"))				{					String className = MiscUtilities						.fileToClass(name);					if(className.endsWith("Plugin"))					{						plugins.add(className);					}					classes.add(className);				}				else				{					resources.add(name);				}			}				cache.cachedProperties = properties;			jEdit.addPluginProps(properties);				this.classes = cache.classes =				classes.toArray(				new String[classes.size()]);			this.resources = cache.resources =				resources.toArray(				new String[resources.size()]);				String label = null;				for (String className : plugins)			{				String _label = jEdit.getProperty("plugin."					+ className + ".name");				String version = jEdit.getProperty("plugin."					+ className + ".version");				if(_label == null || version == null)				{					Log.log(Log.WARNING,this,"Ignoring: "						+ className);				}				else				{					cache.pluginClass = className;						// Check if a plugin with the same name					// is already loaded					if(jEdit.getPlugin(className) != null)					{						jEdit.pluginError(path, "plugin-error.already-loaded",							null);						return null;					}					plugin = new EditPlugin.Deferred(this,					     className);					label = _label;						break;				}			}				if(cache.actionsURI != null)			{				actions = new ActionSet(this,null,null,					cache.actionsURI);				actions.load();				cache.cachedActionNames =					actions.getCacheableActionNames();				cache.cachedActionToggleFlags =					new boolean[cache.cachedActionNames.length];				for(int i = 0; i < cache.cachedActionNames.length; i++)				{					 cache.cachedActionToggleFlags[i] =						 jEdit.getBooleanProperty(							 cache.cachedActionNames[i] + ".toggle");				}			}				if(cache.browserActionsURI != null)			{				browserActions =					new ActionSet(this,null,null, cache.browserActionsURI);				browserActions.load();				VFSBrowser.getActionContext().addActionSet(browserActions);				cache.cachedBrowserActionNames =					browserActions.getCacheableActionNames();				cache.cachedBrowserActionToggleFlags = new boolean[					cache.cachedBrowserActionNames.length];				for(int i = 0;					i < cache.cachedBrowserActionNames.length; i++)				{					 cache.cachedBrowserActionToggleFlags[i]					 	= jEdit.getBooleanProperty(					 		cache.cachedBrowserActionNames[i] + ".toggle");				}			}				if(dockablesURI != null)			{				DockableWindowFactory.getInstance()					.loadDockableWindows(this, dockablesURI,cache);			}				if(actions.size() != 0)			{				if(label != null)				{					actions.setLabel(jEdit.getProperty(						"action-set.plugin", new String[] { label }));				}				else					actionsPresentButNotCoreClass();					jEdit.addActionSet(actions);			}				if(servicesURI != null)			{				ServiceManager.loadServices(this,servicesURI,cache);			}				return cache;		}	
private void startPlugin()		{			try			{				plugin.start();			}			catch(Throwable t)			{				breakPlugin();					Log.log(Log.ERROR,PluginJAR.this,					"Error while starting plugin " + plugin.getClassName());				Log.log(Log.ERROR,PluginJAR.this,t);				String[] args = { t.toString() };				jEdit.pluginError(path, "plugin-error.start-error",args);			}				if(plugin instanceof EBPlugin)			{				if(jEdit.getProperty("plugin." + plugin.getClassName()					+ ".activate") == null)				{					// old plugins expected jEdit 4.1-style					// behavior, where a PropertiesChanged					// was sent after plugins were started					((EBComponent)plugin).handleMessage(						new org.gjt.sp.jedit.msg.PropertiesChanged(null));				}				EditBus.addToBus((EBComponent)plugin);			}				// buffers retain a reference to the fold handler in			// question... and the easiest way to handle fold			// handler loading is this...			Buffer buffer = jEdit.getFirstBuffer();			while(buffer != null)			{				FoldHandler handler =					FoldHandler.getFoldHandler(					buffer.getStringProperty("folding"));				// == null before loaded				if(buffer.getFoldHandler() != null					&& handler != null					&& handler != buffer.getFoldHandler())				{					buffer.setFoldHandler(handler);				}				buffer = buffer.getNext();			}		}	
private void startPluginLater()		{			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					if(!activated)						return;						startPlugin();				}			});		}	
private void breakPlugin()		{			plugin = new EditPlugin.Broken(this,plugin.getClassName());				// remove action sets, dockables, etc so that user doesn't			// see the broken plugin			uninit(false);			// but we want properties to hang around			jEdit.addPluginProps(properties);		}	
public boolean read(DataInputStream din) throws IOException			{				int cacheMagic = din.readInt();				if(cacheMagic != MAGIC)					return false;					String cacheBuild = readString(din);				if(!cacheBuild.equals(jEdit.getBuild()))					return false;					long cacheModTime = din.readLong();				if(cacheModTime != modTime)					return false;					actionsURI = readURI(din);				cachedActionNames = readStringArray(din);				cachedActionToggleFlags = readBooleanArray(din);					browserActionsURI = readURI(din);				cachedBrowserActionNames = readStringArray(din);				cachedBrowserActionToggleFlags = readBooleanArray(din);					dockablesURI = readURI(din);				cachedDockableNames = readStringArray(din);				cachedDockableActionFlags = readBooleanArray(din);				cachedDockableMovableFlags = readBooleanArray(din);					servicesURI = readURI(din);				int len = din.readInt();				if(len == 0)					cachedServices = null;				else				{					cachedServices = new ServiceManager.Descriptor[len];					for(int i = 0; i < len; i++)					{						ServiceManager.Descriptor d = new							ServiceManager.Descriptor(							readString(din),							readString(din),							null,							plugin);						cachedServices[i] = d;					}				}					classes = readStringArray(din);				resources = readStringArray(din);					cachedProperties = readMap(din);					pluginClass = readString(din);					return true;			}	
public void write(DataOutputStream dout) throws IOException			{				dout.writeInt(MAGIC);				writeString(dout,jEdit.getBuild());					dout.writeLong(modTime);					writeString(dout,actionsURI);				writeStringArray(dout,cachedActionNames);				writeBooleanArray(dout,cachedActionToggleFlags);					writeString(dout,browserActionsURI);				writeStringArray(dout,cachedBrowserActionNames);				writeBooleanArray(dout,cachedBrowserActionToggleFlags);					writeString(dout,dockablesURI);				writeStringArray(dout,cachedDockableNames);				writeBooleanArray(dout,cachedDockableActionFlags);				writeBooleanArray(dout,cachedDockableMovableFlags);					writeString(dout,servicesURI);				if(cachedServices == null)					dout.writeInt(0);				else				{					dout.writeInt(cachedServices.length);					for(int i = 0; i < cachedServices.length; i++)					{						writeString(dout,cachedServices[i].clazz);						writeString(dout,cachedServices[i].name);					}				}					writeStringArray(dout,classes);				writeStringArray(dout,resources);					writeMap(dout,cachedProperties);					writeString(dout,pluginClass);			}	
private static String readString(DataInputStream din)				throws IOException			{				int len = din.readInt();				if(len == 0)					return null;				char[] str = new char[len];				for(int i = 0; i < len; i++)					str[i] = din.readChar();				return new String(str);			}	
private static URL readURI(DataInputStream din)				throws IOException			{				String str = readString(din);				if(str == null)					return null;				else					return new URL(str);			}	
private static String[] readStringArray(DataInputStream din)				throws IOException			{				int len = din.readInt();				if(len == 0)					return null;				String[] str = new String[len];				for(int i = 0; i < len; i++)				{					str[i] = readString(din);				}				return str;			}	
private static boolean[] readBooleanArray(DataInputStream din)				throws IOException			{				int len = din.readInt();				if(len == 0)					return null;				boolean[] bools = new boolean[len];				for(int i = 0; i < len; i++)				{					bools[i] = din.readBoolean();				}				return bools;			}	
private static Properties readMap(DataInputStream din)				throws IOException			{				Properties returnValue = new Properties();				int count = din.readInt();				for(int i = 0; i < count; i++)				{					String key = readString(din);					String value = readString(din);					if(value == null)						value = "";					returnValue.put(key,value);				}				return returnValue;			}	
private static void writeString(DataOutputStream dout,				Object obj) throws IOException			{				if(obj == null)				{					dout.writeInt(0);				}				else				{					String str = obj.toString();					dout.writeInt(str.length());					dout.writeChars(str);				}			}	
private static void writeStringArray(DataOutputStream dout,				String[] str) throws IOException			{				if(str == null)				{					dout.writeInt(0);				}				else				{					dout.writeInt(str.length);					for(int i = 0; i < str.length; i++)					{						writeString(dout,str[i]);					}				}			}	
private static void writeBooleanArray(DataOutputStream dout,				boolean[] bools) throws IOException			{				if(bools == null)				{					dout.writeInt(0);				}				else				{					dout.writeInt(bools.length);					for(int i = 0; i < bools.length; i++)					{						dout.writeBoolean(bools[i]);					}				}			}	
private static void writeMap(DataOutputStream dout, Map map)				throws IOException			{				dout.writeInt(map.size());				Set<Map.Entry<Object, Object>> set = map.entrySet();				for (Map.Entry<Object, Object> entry : set)				{					writeString(dout,entry.getKey());					writeString(dout,entry.getValue());				}			}	
PluginList(WorkRequest workRequest) 		{			id = jEdit.getProperty("plugin-manager.mirror.id");			this.workRequest = workRequest;			readPluginList(true);		}	
void readPluginList(boolean allowRetry)		{			gzipURL = jEdit.getProperty("plugin-manager.export-url");				if (!id.equals(MirrorList.Mirror.NONE))				gzipURL += "?mirror="+id;					String path = null;			if (jEdit.getSettingsDirectory() == null)			{				cachedURL = gzipURL;			}			else			{				path = jEdit.getSettingsDirectory() + File.separator + "pluginMgr-Cached.xml.gz";				cachedURL = "file:///" + path;			}			boolean downloadIt = !id.equals(jEdit.getProperty("plugin-manager.mirror.cached-id"));			if (path != null)			{				try				{						File f = new File(path);					if (!f.canRead()) downloadIt = true;					long currentTime = System.currentTimeMillis();					long age = currentTime - f.lastModified();					/* By default only download plugin lists every 5 minutes */					long interval = jEdit.getIntegerProperty("plugin-manager.list-cache.minutes", 5) * 60 * 1000;					if (age > interval)					{						Log.log(Log.MESSAGE, this, "PluginList cached copy too old. Downloading from mirror. ");						downloadIt = true;					}				}				catch (Exception e)				{					Log.log(Log.MESSAGE, this, "No cached copy. Downloading from mirror. ");					downloadIt = true;				}			}			if (downloadIt && cachedURL != gzipURL)			{				downloadPluginList();			}			InputStream in = null, inputStream = null;			try			{				if (cachedURL != gzipURL) 					Log.log(Log.MESSAGE, this, "Using cached pluginlist");				inputStream = new URL(cachedURL).openStream();				XMLReader parser = XMLReaderFactory.createXMLReader();				PluginListHandler handler = new PluginListHandler(this, cachedURL);				in = new BufferedInputStream(inputStream);				if(in.markSupported())				{					in.mark(2);					int b1 = in.read();					int b2 = in.read();					in.reset();						if(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)						in = new GZIPInputStream(in);				}				InputSource isrc = new InputSource(new InputStreamReader(in,"UTF8"));				isrc.setSystemId("jedit.jar");				parser.setContentHandler(handler);				parser.setDTDHandler(handler);				parser.setEntityResolver(handler);				parser.setErrorHandler(handler);				parser.parse(isrc);								}			catch (Exception e)			{				Log.log(Log.ERROR, this, "readpluginlist: error", e);				if (cachedURL.startsWith("file:///"))				{					Log.log(Log.DEBUG, this, "Unable to read plugin list, deleting cached file and try again");					new File(cachedURL.substring(8)).delete();					if (allowRetry)					{						plugins.clear();						pluginHash.clear();						pluginSets.clear();						readPluginList(false);					}				}			}			finally			{				IOUtilities.closeQuietly(in);				IOUtilities.closeQuietly(inputStream);			}					}	
/** Caches it locally */		void downloadPluginList()		{			BufferedInputStream is = null;			BufferedOutputStream out = null;			try			{								workRequest.setStatus(jEdit.getProperty("plugin-manager.list-download"));				InputStream inputStream = new URL(gzipURL).openStream();				String fileName = cachedURL.replaceFirst("file:///", "");				out = new BufferedOutputStream(new FileOutputStream(fileName));				long start = System.currentTimeMillis();				is = new BufferedInputStream(inputStream);				IOUtilities.copyStream(4096, null, is, out, false);				jEdit.setProperty("plugin-manager.mirror.cached-id", id);				Log.log(Log.MESSAGE, this, "Updated cached pluginlist " + (System.currentTimeMillis() - start));			}			catch (Exception e)			{				Log.log (Log.ERROR, this, "CacheRemotePluginList: error", e);			}			finally			{				IOUtilities.closeQuietly(out);				IOUtilities.closeQuietly(is);			}		}	
void addPlugin(Plugin plugin)		{			plugin.checkIfInstalled();			plugins.add(plugin);			pluginHash.put(plugin.name,plugin);		}	
void addPluginSet(PluginSet set)		{			pluginSets.add(set);		}	
void finished()		{			// after the entire list is loaded, fill out plugin field			// in dependencies			for(int i = 0; i < plugins.size(); i++)			{				Plugin plugin = plugins.get(i);				for(int j = 0; j < plugin.branches.size(); j++)				{					Branch branch = plugin.branches.get(j);					for(int k = 0; k < branch.deps.size(); k++)					{						Dependency dep = branch.deps.get(k);						if(dep.what.equals("plugin"))							dep.plugin = pluginHash.get(dep.pluginName);					}				}			}		}	
void dump()		{			for(int i = 0; i < plugins.size(); i++)			{				System.err.println(plugins.get(i));				System.err.println();			}		}	
/**		 * Returns the mirror ID.		 *		 * @return the mirror ID		 * @since jEdit 4.3pre3		 */		String getMirrorId()		{			return id;		}	
public String toString()			{				return plugins.toString();			}	
void checkIfInstalled()			{				/* // check if the plugin is already installed.				// this is a bit of hack				PluginJAR[] jars = jEdit.getPluginJARs();				for(int i = 0; i < jars.length; i++)				{					String path = jars[i].getPath();					if(!new File(path).exists())						continue;						if(MiscUtilities.getFileName(path).equals(jar))					{						installed = path;							EditPlugin plugin = jars[i].getPlugin();						if(plugin != null)						{							installedVersion = jEdit.getProperty(								"plugin." + plugin.getClassName()								+ ".version");						}						break;					}				}					String[] notLoaded = jEdit.getNotLoadedPluginJARs();				for(int i = 0; i < notLoaded.length; i++)				{					String path = notLoaded[i];						if(MiscUtilities.getFileName(path).equals(jar))					{						installed = path;						break;					}				} */			}	
String getInstalledVersion()			{				PluginJAR[] jars = jEdit.getPluginJARs();				for(int i = 0; i < jars.length; i++)				{					String path = jars[i].getPath();						if(MiscUtilities.getFileName(path).equals(jar))					{						EditPlugin plugin = jars[i].getPlugin();						if(plugin != null)						{							return jEdit.getProperty(								"plugin." + plugin.getClassName()								+ ".version");						}						else							return null;					}				}					return null;			}	
String getInstalledPath()			{				PluginJAR[] jars = jEdit.getPluginJARs();				for(int i = 0; i < jars.length; i++)				{					String path = jars[i].getPath();						if(MiscUtilities.getFileName(path).equals(jar))						return path;				}					return null;			}	
/**			 * Find the first branch compatible with the running jEdit release.			 */			Branch getCompatibleBranch()			{				for(int i = 0; i < branches.size(); i++)				{					Branch branch = branches.get(i);					if(branch.canSatisfyDependencies())						return branch;				}					return null;			}	
boolean canBeInstalled()			{				Branch branch = getCompatibleBranch();				return branch != null && !branch.obsolete					&& branch.canSatisfyDependencies();			}	
void install(Roster roster, String installDirectory, boolean downloadSource)			{				String installed = getInstalledPath();					Branch branch = getCompatibleBranch();				if(branch.obsolete)				{					if(installed != null)						roster.addRemove(installed);					return;				}					//branch.satisfyDependencies(roster,installDirectory,				//	downloadSource);					if(installed != null)				{					installDirectory = MiscUtilities.getParentOfPath(						installed);				}					roster.addInstall(					installed,					downloadSource ? branch.downloadSource : branch.download,					installDirectory,					downloadSource ? branch.downloadSourceSize : branch.downloadSize);				}	
public String toString()			{				return name;			}	
boolean canSatisfyDependencies()			{				for(int i = 0; i < deps.size(); i++)				{					Dependency dep = deps.get(i);					if(!dep.canSatisfy())						return false;				}					return true;			}	
void satisfyDependencies(Roster roster, String installDirectory,				boolean downloadSource)			{				for(int i = 0; i < deps.size(); i++)				{					Dependency dep = deps.get(i);					dep.satisfy(roster,installDirectory,downloadSource);				}			}	
public String toString()			{				return "[version=" + version + ",download=" + download					+ ",obsolete=" + obsolete + ",deps=" + deps + ']';			}	
Dependency(String what, String from, String to, String pluginName)			{				this.what = what;				this.from = from;				this.to = to;				this.pluginName = pluginName;			}	
boolean isSatisfied()			{				if(what.equals("plugin"))				{					for(int i = 0; i < plugin.branches.size(); i++)					{						String installedVersion = plugin.getInstalledVersion();						if(installedVersion != null							&&						(from == null || StandardUtilities.compareStrings(							installedVersion,from,false) >= 0)							&&							(to == null || StandardUtilities.compareStrings(							      installedVersion,to,false) <= 0))						{							return true;						}					}						return false;				}				else if(what.equals("jdk"))				{					String javaVersion = System.getProperty("java.version").substring(0,3);						if((from == null || StandardUtilities.compareStrings(						javaVersion,from,false) >= 0)						&&						(to == null || StandardUtilities.compareStrings(							     javaVersion,to,false) <= 0))						return true;					else						return false;				}				else if(what.equals("jedit"))				{					String build = jEdit.getBuild();						if((from == null || StandardUtilities.compareStrings(						build,from,false) >= 0)						&&						(to == null || StandardUtilities.compareStrings(							     build,to,false) <= 0))						return true;					else						return false;				}				else				{					Log.log(Log.ERROR,this,"Invalid dependency: " + what);					return false;				}			}	
boolean canSatisfy()			{				if(isSatisfied())					return true;				if (what.equals("plugin"))					return plugin.canBeInstalled();				return false;			}	
void satisfy(Roster roster, String installDirectory,				boolean downloadSource)			{				if(what.equals("plugin"))				{					String installedVersion = plugin.getInstalledVersion();					for(int i = 0; i < plugin.branches.size(); i++)					{						Branch branch = plugin.branches.get(i);						if((installedVersion == null							||						StandardUtilities.compareStrings(							installedVersion,branch.version,false) < 0)							&&						(from == null || StandardUtilities.compareStrings(							branch.version,from,false) >= 0)							&&							(to == null || StandardUtilities.compareStrings(							      branch.version,to,false) <= 0))						{							plugin.install(roster,installDirectory,								downloadSource);							return;						}					}				}			}	
public String toString()			{				return "[what=" + what + ",from=" + from					+ ",to=" + to + ",plugin=" + plugin + ']';			}	
PluginListHandler(PluginList pluginList, String path)		{			this.pluginList = pluginList;			this.path = path;				author = new StringBuilder();			description = new StringBuilder();			pluginSetEntry = new StringBuilder();			download = new StringBuilder();			downloadSource = new StringBuilder();		}	
public InputSource resolveEntity(String publicId, String systemId)		{			return XMLUtilities.findEntity(systemId, "plugins.dtd", getClass());		}	
public void attribute(String aname, String value, boolean isSpecified)		{			if(aname == "NAME")				name = value;			else if(aname == "JAR")				jar = value;			else if(aname == "VERSION")				version = value;			else if(aname == "DATE")				date = value;			else if(aname == "OBSOLETE")				obsolete = ("TRUE".equals(value));			else if(aname == "WHAT")				depWhat = value;			else if(aname == "FROM")				depFrom = value;			else if(aname == "TO")				depTo = value;			else if(aname == "PLUGIN")				depPlugin = value;			else if(aname == "SIZE")			{				size = Integer.parseInt(value);				if(size == 0)					Log.log(Log.WARNING,this,"SIZE = 0");			}		}	
public void characters(char[] c, int off, int len)		{			String tag = peekElement();				if(tag.equals("DESCRIPTION"))			{				description.append(c, off, len);			}			else if(tag.equals("PLUGIN_SET_ENTRY"))				pluginSetEntry.append(c, off, len);			else if(tag.equals("AUTHOR"))			{				if(author.length() != 0)					author.append(", ");				author.append(c, off, len);			}			else if(tag.equals("DOWNLOAD"))				download.append(c, off, len);			else if(tag.equals("DOWNLOAD_SOURCE"))				downloadSource.append(c, off, len);		}	
public void startElement(String uri, String localName,					 String tag, Attributes attrs)		{			for (int i = 0; i < attrs.getLength(); i++)			{				String aName = attrs.getQName(i);				String aValue = attrs.getValue(i);				attribute(aName, aValue, true);			}					tag = pushElement(tag);				if(tag.equals("PLUGIN_SET"))			{				description.setLength(0);				pluginSet = new PluginList.PluginSet();				pluginSet.name = name;			}			else if(tag.equals("PLUGIN"))			{				description.setLength(0);				author.setLength(0);				branch = null;				plugin = new PluginList.Plugin();			}			else if(tag.equals("BRANCH"))			{				download.setLength(0);				branch = new PluginList.Branch();			}			else if(tag.equals("DOWNLOAD"))				downloadSize = size;			else if(tag.equals("DOWNLOAD_SOURCE"))				downloadSourceSize = size;		}	
public void endElement(String uri, String localName, String tag)		{			popElement();				if(tag.equals("PLUGIN_SET"))			{				pluginList.addPluginSet(pluginSet);				pluginSet = null;				pluginSetEntry.setLength(0);			}			else if(tag.equals("PLUGIN_SET_ENTRY"))			{				pluginSet.plugins.add(pluginSetEntry.toString());				pluginSetEntry.setLength(0);			}			else if(tag.equals("PLUGIN"))			{				plugin.jar = jar;				plugin.name = name;				plugin.author = author.toString();				plugin.description = description.toString();				pluginList.addPlugin(plugin);				jar = null;				name = null;				author.setLength(0);				description.setLength(0);			}			else if(tag.equals("BRANCH"))			{				branch.version = version;				branch.date = date;				branch.download = download.toString();				branch.downloadSize = downloadSize;				branch.downloadSource = downloadSource.toString();				branch.downloadSourceSize = downloadSourceSize;				branch.obsolete = obsolete;				plugin.branches.add(branch);				version = null;				download.setLength(0);				downloadSource.setLength(0);				obsolete = false;			}			else if(tag.equals("DEPEND"))			{				PluginList.Dependency dep = new PluginList.Dependency(					depWhat,depFrom,depTo,depPlugin);				branch.deps.add(dep);				depWhat = null;				depFrom = null;				depTo = null;				depPlugin = null;			}		}	
public void startDocument()		{			try			{				pushElement(null);			}			catch (Exception e)			{				Log.log(Log.ERROR, this, e);			}		}	
public void endDocument()		{			pluginList.finished();		}	
private String pushElement(String name)		{			stateStack.push(name);			return name;		}	
private String peekElement()		{			return stateStack.peek();		}	
private String popElement()		{			return stateStack.pop();		}	
/**		 * Returns the currently visible plugin manager window, or null.		 * @since jEdit 4.2pre2		 */		public static PluginManager getInstance()		{			return instance;		}	
public void dispose()		{			instance = null;			EditBus.removeFromBus(this);			EditBus.removeFromBus(installer);			super.dispose();		}	
public void handleMessage(EBMessage message)		{			if (message instanceof PropertiesChanged)			{				if (shouldUpdatePluginList())				{					pluginList = null;					updatePluginList();					if(tabPane.getSelectedIndex() != 0)					{						installer.updateModel();						updater.updateModel();					}				}			}			else if (message instanceof PluginUpdate)			{				if(!queuedUpdate)				{					SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							queuedUpdate = false;							manager.update();						}					});					queuedUpdate = true;				}			}		}	
public static void showPluginManager(Frame parent)		{			if (instance == null)				instance = new PluginManager(parent);			else				instance.toFront();		}	
public void ok()		{			dispose();		}	
public void cancel()		{			dispose();		}	
PluginList getPluginList()		{			return pluginList;		}	
private PluginManager(Frame parent)		{			super(jEdit.getProperty("plugin-manager.title"));			this.parent = parent;			init();		}	
private void init()		{			EditBus.addToBus(this);							/* Setup panes */			JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				tabPane = new JTabbedPane();			tabPane.addTab(jEdit.getProperty("manage-plugins.title"),				manager = new ManagePanel(this));			tabPane.addTab(jEdit.getProperty("update-plugins.title"),				updater = new InstallPanel(this,true));			tabPane.addTab(jEdit.getProperty("install-plugins.title"),				installer = new InstallPanel(this,false));			EditBus.addToBus(installer);			content.add(BorderLayout.CENTER,tabPane);				tabPane.addChangeListener(new ListUpdater());				/* Create the buttons */			Box buttons = new Box(BoxLayout.X_AXIS);				ActionListener al = new ActionHandler();			mgrOptions = new JButton(jEdit.getProperty("plugin-manager.mgr-options"));			mgrOptions.addActionListener(al);			pluginOptions = new JButton(jEdit.getProperty("plugin-manager.plugin-options"));			pluginOptions.addActionListener(al);			done = new JButton(jEdit.getProperty("plugin-manager.done"));			done.addActionListener(al);				buttons.add(Box.createGlue());			buttons.add(mgrOptions);			buttons.add(Box.createHorizontalStrut(6));			buttons.add(pluginOptions);			buttons.add(Box.createHorizontalStrut(6));			buttons.add(done);			buttons.add(Box.createGlue());				getRootPane().setDefaultButton(done);				content.add(BorderLayout.SOUTH,buttons);				setDefaultCloseOperation(DISPOSE_ON_CLOSE);				setIconImage(GUIUtilities.getPluginIcon());				pack();			GUIUtilities.loadGeometry(this, parent, "plugin-manager");			GUIUtilities.addSizeSaver(this, parent, "plugin-manager");			setVisible(true);		}	
/**		* Check if the plugin list should be updated.		* It will return <code>true</code> if the pluginList is <code>null</code>		* or if the mirror id of the current plugin list is not the current preffered mirror id		* and will return always false if the plugin list is currently downloading		*		* @return true if the plugin list should be updated		*/		private boolean shouldUpdatePluginList()		{			return (pluginList == null ||				!pluginList.getMirrorId().equals(jEdit.getProperty("plugin-manager.mirror.id"))) &&				!downloadingPluginList;		}	
private void updatePluginList()		{			if(jEdit.getSettingsDirectory() == null				&& jEdit.getJEditHome() == null)			{				GUIUtilities.error(this,"no-settings",null);				return;			}			if (!shouldUpdatePluginList())			{				return;			}				final Exception[] exception = new Exception[1];				VFSManager.runInWorkThread(new WorkRequest()			{				public void run()				{					try					{						downloadingPluginList = true;						setStatus(jEdit.getProperty(							"plugin-manager.list-download-connect"));						pluginList = new PluginList(this);					}					catch(Exception e)					{						exception[0] = e;					}					finally					{						downloadingPluginList = false;					}				}			});				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					if(exception[0] instanceof SAXParseException)					{						SAXParseException se = (SAXParseException)							exception[0];							int line = se.getLineNumber();						String path = jEdit.getProperty(							"plugin-manager.export-url");						String message = se.getMessage();						Log.log(Log.ERROR,this,path + ':' + line							+ ": " + message);						String[] pp = { path,							String.valueOf(line),							message };						GUIUtilities.error(PluginManager.this,							"plugin-list.xmlerror",pp);					}					else if(exception[0] != null)					{						Exception e = exception[0];							Log.log(Log.ERROR,this,e);						String[] pp = { e.toString() };							String ok = jEdit.getProperty(							"common.ok");						String proxyButton = jEdit.getProperty(							"plugin-list.ioerror.proxy-servers");						int retVal =							JOptionPane.showOptionDialog(							PluginManager.this,							jEdit.getProperty("plugin-list.ioerror.message",pp),							jEdit.getProperty("plugin-list.ioerror.title"),							JOptionPane.YES_NO_OPTION,							JOptionPane.ERROR_MESSAGE,							null,							new Object[] {								proxyButton,								ok							},							ok);							if(retVal == 0)						{							new GlobalOptions(								PluginManager.this,								"firewall");						}					}				}			});		}	
public void processKeyEvents(KeyEvent ke)		{			if ((ke.getID() == KeyEvent.KEY_PRESSED) &&			    (ke.getKeyCode() == KeyEvent.VK_ESCAPE))			{				cancel();				ke.consume();			}		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == done)					ok();				else if (source == mgrOptions)					new GlobalOptions(PluginManager.this,"plugin-manager");				else if (source == pluginOptions)					new PluginOptions(PluginManager.this);			}	
public void stateChanged(ChangeEvent e)			{				Component selected = tabPane.getSelectedComponent();				if(selected == installer || selected == updater)				{					updatePluginList();					installer.updateModel();					updater.updateModel();				}				else if(selected == manager)					manager.update();			}	
public PluginManagerOptionPane()		{			super("plugin-manager");		}	
protected void _init()		{			setLayout(new BorderLayout());					mirrorLabel = new JLabel();			updateMirrorLabel();			JPanel buttonPanel = new JPanel();			buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.Y_AXIS));			JPanel spinnerPanel = null;			if(jEdit.getSettingsDirectory() != null)			{				settingsDir = new JRadioButton(jEdit.getProperty(					"options.plugin-manager.settings-dir"));				settingsDir.setToolTipText(MiscUtilities.constructPath(					jEdit.getSettingsDirectory(),"jars"));				int delay = jEdit.getIntegerProperty("plugin-manager.list-cache.minutes", 10);				spinnerModel = new SpinnerNumberModel(delay, 0, 240, 5);				cacheForSpinner = new JSpinner(spinnerModel);				spinnerPanel = new JPanel();				spinnerPanel.setLayout(new BoxLayout(spinnerPanel, BoxLayout.X_AXIS));				spinnerPanel.add(new JLabel("Cache plugin list for: (minutes)"));				spinnerPanel.add(cacheForSpinner);				spinnerPanel.add(Box.createGlue());							}			JRadioButton appDir = new JRadioButton(jEdit.getProperty(					"options.plugin-manager.app-dir"));			appDir.setToolTipText(MiscUtilities.constructPath(				jEdit.getJEditHome(),"jars"));				miraList = new JList(miraModel = new MirrorModel());			miraList.setSelectionModel(new SingleSelectionModel());				/* Download mirror */			add(BorderLayout.NORTH,mirrorLabel);			add(BorderLayout.CENTER,new JScrollPane(miraList));					buttonPanel.add(Box.createVerticalStrut(6));				/* Update mirror list */			updateMirrors = new JButton(jEdit.getProperty(				"options.plugin-manager.updateMirrors"));			updateMirrors.addActionListener(new ActionHandler());			updateMirrors.setEnabled(false);			VFSManager.runInWorkThread(new UpdateMirrorsThread(false));			JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));			panel.add(updateMirrors);			if (spinnerPanel != null) panel.add(spinnerPanel);			panel.add(updateStatus);			panel.setAlignmentX(Component.LEFT_ALIGNMENT);			buttonPanel.add(panel);				buttonPanel.add(Box.createVerticalStrut(6));				/* Download source */			downloadSource = new JCheckBox(jEdit.getProperty(				"options.plugin-manager.downloadSource"));			downloadSource.setSelected(jEdit.getBooleanProperty("plugin-manager.downloadSource"));			downloadSource.setAlignmentX(Component.LEFT_ALIGNMENT);			buttonPanel.add(downloadSource);				buttonPanel.add(Box.createVerticalStrut(6));				/* Delete downloaded files */			deleteDownloads = new JCheckBox(jEdit.getProperty(				"options.plugin-manager.deleteDownloads"));			deleteDownloads.setSelected(jEdit.getBooleanProperty("plugin-manager.deleteDownloads"));			deleteDownloads.setAlignmentX(Component.LEFT_ALIGNMENT);			buttonPanel.add(deleteDownloads);				buttonPanel.add(Box.createVerticalStrut(6));				/* Install location */			ButtonGroup locGrp = new ButtonGroup();			if(jEdit.getSettingsDirectory() != null)				locGrp.add(settingsDir);			locGrp.add(appDir);			JPanel locPanel = new JPanel();			locPanel.setLayout(new BoxLayout(locPanel,BoxLayout.Y_AXIS));						if(jEdit.getSettingsDirectory() != null)			{				locPanel.add(settingsDir);				locPanel.add(Box.createVerticalStrut(3));			}			locPanel.setBorder(new TitledBorder(				jEdit.getProperty("options.plugin-manager.location")));			locPanel.add(appDir);			locPanel.setAlignmentX(Component.LEFT_ALIGNMENT);			buttonPanel.add(locPanel);				buttonPanel.add(Box.createGlue());			add(BorderLayout.SOUTH,buttonPanel);				if (jEdit.getBooleanProperty("plugin-manager.installUser")				&& jEdit.getSettingsDirectory() != null)				settingsDir.setSelected(true);			else				appDir.setSelected(true);		}	
protected void _save()		{			jEdit.setBooleanProperty("plugin-manager.installUser",				settingsDir != null && settingsDir.isSelected());			jEdit.setBooleanProperty("plugin-manager.downloadSource",downloadSource.isSelected());			jEdit.setBooleanProperty("plugin-manager.deleteDownloads",deleteDownloads.isSelected());			jEdit.setIntegerProperty("plugin-manager.list-cache.minutes", spinnerModel.getNumber().intValue());			if(miraList.getSelectedIndex() != -1)			{				String currentMirror = miraModel.getID(miraList.getSelectedIndex());				String previousMirror = jEdit.getProperty("plugin-manager.mirror.id");					if (!previousMirror.equals(currentMirror))				{					jEdit.setProperty("plugin-manager.mirror.id",currentMirror);					jEdit.setProperty("plugin-manager.mirror.name",(String) miraModel.getElementAt(miraList.getSelectedIndex()));					updateMirrorLabel();					// Insert code to update the plugin managers list here later				}			}		}	
private void updateMirrorLabel()		{			String currentMirror = jEdit.getProperty("plugin-manager.mirror.id");			String mirrorName;			if (currentMirror.equals(MirrorList.Mirror.NONE))			{				mirrorName = "Plugin Central default";			}			else			{				mirrorName = jEdit.getProperty("plugin-manager.mirror.name");				if (mirrorName == null) mirrorName = currentMirror;			}			mirrorLabel.setText(jEdit.getProperty(				"options.plugin-manager.mirror") + ' ' + mirrorName);		}	
MirrorModel()			{				mirrors = new ArrayList<MirrorList.Mirror>();			}	
public String getID(int index)			{				return mirrors.get(index).id;			}	
public int getSize()			{				return mirrors.size();			}	
public Object getElementAt(int index)			{				MirrorList.Mirror mirror = mirrors.get(index);				if(mirror.id.equals(MirrorList.Mirror.NONE))					return jEdit.getProperty("options.plugin-manager.none");				else					return mirror.continent+": "+mirror.description+" ("+mirror.location+')';			}	
public void setList(List<MirrorList.Mirror> mirrors)			{				this.mirrors = mirrors;				fireContentsChanged(this,0,mirrors.size() - 1);			}	
SingleSelectionModel()			{				setSelectionMode(SINGLE_SELECTION);			}	
public void removeSelectionInterval(int index0, int index1) {}	
public void actionPerformed(ActionEvent evt)			{				updateMirrors.setEnabled(false);				updateStatus.setText(jEdit.getProperty("options.plugin-manager.workthread"));				VFSManager.runInWorkThread(new UpdateMirrorsThread(true));			}	
UpdateMirrorsThread(boolean download)			{				this.download = download;			}	
public void run()			{				try				{					setStatus(jEdit.getProperty("options.plugin-manager.workthread"));					setMaximum(3);					setValue(0);						final List<MirrorList.Mirror> mirrors = new ArrayList<MirrorList.Mirror>();					try					{						MirrorList mirrorList = new MirrorList(download, this);						if (download)							saveMirrorList(mirrorList.xml);							mirrors.addAll(mirrorList.mirrors);					}					catch (Exception ex)					{						if (download)						{							Log.log(Log.ERROR,this,ex);							GUIUtilities.error(PluginManagerOptionPane.this,									"ioerror",new String[] { ex.toString() });						}					}						SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							miraModel.setList(mirrors);								String id = jEdit.getProperty("plugin-manager.mirror.id");							int size = miraModel.getSize();							for (int i=0; i < size; i++)							{								if (size == 1 || miraModel.getID(i).equals(id))								{									miraList.setSelectedIndex(i);									break;								}							}						}					});						setValue(3);				}				finally				{					updateMirrors.setEnabled(true);					updateStatus.setText(null);				}			}	
private void saveMirrorList(String xml)			{				String settingsDirectory = jEdit.getSettingsDirectory();				if(settingsDirectory == null)					return;					File mirrorList = new File(MiscUtilities.constructPath(					settingsDirectory,"mirrorList.xml"));				OutputStream out = null;					try				{					out = new BufferedOutputStream(new FileOutputStream(mirrorList));					IOUtilities.copyStream(null, new ByteArrayInputStream(xml.getBytes()), out, false);				}				catch (IOException e)				{					Log.log(Log.ERROR,this, "Unable to write cached mirror list : " + mirrorList);				}				finally				{					IOUtilities.closeQuietly(out);				}			}	
public PluginManagerProgress(PluginManager dialog, Roster roster)		{			super(dialog,jEdit.getProperty("plugin-manager.progress"),true);				this.roster = roster;				JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				progress = new JProgressBar();			progress.setStringPainted(true);			progress.setString(jEdit.getProperty("plugin-manager.progress"));				int maximum = 0;			count = roster.getOperationCount();			for(int i = 0; i < count; i++)			{				maximum += roster.getOperation(i).getMaximum();			}				progress.setMaximum(maximum);			content.add(BorderLayout.NORTH,progress);				stop = new JButton(jEdit.getProperty("plugin-manager.progress.stop"));			stop.addActionListener(new ActionHandler());			JPanel panel = new JPanel(new FlowLayout(				FlowLayout.CENTER,0,0));			panel.add(stop);			content.add(BorderLayout.CENTER,panel);				addWindowListener(new WindowHandler());				pack();			setLocationRelativeTo(dialog);			setVisible(true);		}	
/**		 * @param value the new value		 * @deprecated Use {@link #setValue(long)}		 */		public void setValue(final int value)		{			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					progress.setValue(valueSoFar + value);				}			});		}	
/**		 * Update the progress value.		 *		 * @param value the new value		 * @since jEdit 4.3pre3		 */		public void setValue(final long value)		{			SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						progress.setValue(valueSoFar + (int) value);					}				});		}	
/**		 * This method is unused with the plugin manager.		 *		 * @param value the new max value (it will be ignored)		 * @since jEdit 4.3pre3		 */		public void setMaximum(long value) 		{		}	
/**		 * This method is unused with the plugin manager.		 *		 * @param status the new status (it will be ignored)		 * @since jEdit 4.3pre3		 */		 public void setStatus(String status) 		 {			 setTitle(status);			 progress.setString(status);		}	
public void done()		{			try			{				if(done == count)				{					SwingUtilities.invokeAndWait(new Runnable()					{						public void run()						{							dispose();						}					});				}				else				{					SwingUtilities.invokeAndWait(new Runnable()					{						public void run()						{							valueSoFar += roster.getOperation(done - 1)								.getMaximum();							progress.setValue(valueSoFar);							done++;						}					});				}			}			catch(Exception e)			{			}		}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == stop)				{					thread.stop();					dispose();				}			}	
public void windowOpened(WindowEvent evt)			{				if(done)					return;					done = true;				thread = new RosterThread();				thread.start();			}	
public void windowClosing(WindowEvent evt)			{				thread.stop();				dispose();			}	
RosterThread()			{				super("Plugin manager thread");			}	
public void run()			{				roster.performOperationsInWorkThread(PluginManagerProgress.this);			}	
public PluginOptions(Frame frame)		{			super(frame,"plugin-options",jEdit.getProperty("plugin-options.last"));		}	
public PluginOptions(Frame frame, String pane)		{			super(frame,"plugin-options",pane);		}	
public PluginOptions(Dialog dialog)		{			super(dialog,"plugin-options",jEdit.getProperty("plugin-options.last"));		}	
public PluginOptions(Dialog dialog, String pane)		{			super(dialog,"plugin-options",pane);		}	
protected OptionTreeModel createOptionTreeModel()		{			OptionTreeModel paneTreeModel = new OptionTreeModel();			OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();				// initialize the Plugins branch of the options tree			pluginsGroup = new OptionGroup("plugins");			pluginsGroup.setSort(true);				// Query plugins for option panes			EditPlugin[] plugins = jEdit.getPlugins();			for(int i = 0; i < plugins.length; i++)			{				EditPlugin ep = plugins[i];				if(ep instanceof EditPlugin.Broken)					continue;					String className = ep.getClassName();				if(jEdit.getProperty("plugin." + className + ".activate") == null)				{					// Old API					try					{						ep.createOptionPanes(this);					}					catch(Throwable t)					{						Log.log(Log.ERROR, ep,							"Error creating option pane");						Log.log(Log.ERROR, ep, t);					}				}				else				{					String optionPane = jEdit.getProperty(						"plugin." + className + ".option-pane");					if(optionPane != null)						pluginsGroup.addOptionPane(optionPane);					else					{						String options = jEdit.getProperty(							"plugin." + className							+ ".option-group");						if(options != null)						{							pluginsGroup.addOptionGroup(								new OptionGroup(								"plugin." + className,								jEdit.getProperty("plugin."								+ className + ".name"),								options)							);						}					}				}			}				// only add the Plugins branch if there are OptionPanes			if (pluginsGroup.getMemberCount() == 0)				pluginsGroup.addOptionPane(new NoPluginsPane());				rootGroup.addOptionGroup(pluginsGroup);				return paneTreeModel;		}	
protected OptionGroup getDefaultGroup()		{			return pluginsGroup;		}	
public NoPluginsPane()			{				super("no-plugins");			}	
public PluginResURLConnection(URL url)			throws IOException		{			super(url);				String file = url.getFile();				int index = file.indexOf('!',0);			if(index == -1)			{				plugin = null;				resource = file;			}			else			{				int start;				if(file.charAt(0) == '/')					start = 1;				else					start = 0;					plugin = file.substring(start,index);				resource = file.substring(index + 1);			}				if(plugin != null && resource.startsWith("/"))				resource = resource.substring(1);		}	
public void connect() throws IOException		{			if(!connected)			{				if(plugin == null)				{					in = jEdit.class.getResourceAsStream(resource);				}				else				{					PluginJAR[] plugins = jEdit.getPluginJARs();					for(int i = 0; i < plugins.length; i++)					{						PluginJAR jar = plugins[i];						String jarName =MiscUtilities.getFileName(jar.getPath()).toLowerCase(); 						if(plugin.equalsIgnoreCase(jarName))						{							in = jar.getClassLoader()							            .getResourceAsStream(resource);							break;						}					}				}					if(in == null)				{					throw new IOException("Resource not found: " + plugin + "!" 						+ resource);				}					connected = true;			}		}	
public InputStream getInputStream()			throws IOException		{			connect();			return in;		}	
public String getHeaderField(String name)		{			if(name.equals("content-type"))			{				String lcResource = resource.toLowerCase();				if(lcResource.endsWith(".html"))					return "text/html";				else if(lcResource.endsWith(".txt"))					return "text/plain";				else if(lcResource.endsWith(".rtf"))					return "text/rtf";				else if(lcResource.endsWith(".gif"))					return "image/gif";				else if(lcResource.endsWith(".jpg")					|| lcResource.endsWith(".jpeg"))					return "image/jpeg";				else					return null;			}			else				return null;		}	
public boolean updateEveryTime()		{			return false;		}	
public void update(JMenu menu)		{			// We build a set of lists, each list contains plugin menu			// items that begin with a given letter.			int count = 0;				List<JMenuItem>[] letters = (List<JMenuItem>[])new List[26];			for(int i = 0; i < letters.length; i++)			{				letters[i] = new ArrayList<JMenuItem>();			}				Vector<JMenuItem> pluginMenuItems = new Vector<JMenuItem>();				PluginJAR[] pluginArray = jEdit.getPluginJARs();			for(int i = 0; i < pluginArray.length; i++)			{				PluginJAR jar = pluginArray[i];				EditPlugin plugin = jar.getPlugin();				if(plugin == null)					continue;					JMenuItem menuItem = plugin.createMenuItems();				if(menuItem != null)				{					addToLetterMap(letters,menuItem);					count++;				}				//{{{ old API				else if(jEdit.getProperty("plugin."					+ plugin.getClassName()					+ ".activate") == null)				{					try					{						pluginMenuItems.clear();						plugin.createMenuItems(pluginMenuItems);							Iterator<JMenuItem> iter							= pluginMenuItems.iterator();						while(iter.hasNext())						{							addToLetterMap(letters,								iter.next());							count++;						}					}					catch(Throwable t)					{						Log.log(Log.ERROR,this,							"Error creating menu items"							+ " for plugin");						Log.log(Log.ERROR,this,t);					}				} //}}}			}				if(count == 0)			{				JMenuItem menuItem = new JMenuItem(					jEdit.getProperty("no-plugins.label"));				menuItem.setEnabled(false);				menu.add(menuItem);				return;			}				// Sort each letter			for(int i = 0; i < letters.length; i++)			{				Collections.sort(letters[i],new MenuItemTextComparator());			}				int maxItems = jEdit.getIntegerProperty("menu.spillover",20);				// if less than 20 items, put them directly in the menu			if(count <= maxItems)			{				for(int i = 0; i < letters.length; i++)				{					Iterator<JMenuItem> iter						= letters[i].iterator();					while(iter.hasNext())					{						menu.add(iter.next());					}				}					return;			}				// Collect blocks of up to maxItems of consecutive letters			count = 0;			char first = 'A';			JMenu submenu = new JMenu();			menu.add(submenu);				for(int i = 0; i < letters.length; i++)			{				List<JMenuItem> letter = letters[i];					if(count + letter.size() > maxItems && count != 0)				{					char last = (char)(i + 'A' - 1);					if(last == first)						submenu.setText(String.valueOf(first));					else						submenu.setText(first + " - " + last);					first = (char)(i + 'A');					count = 0;					submenu = null;				}					Iterator<JMenuItem> iter = letter.iterator();				while(iter.hasNext())				{					if(submenu == null)					{						submenu = new JMenu();						menu.add(submenu);					}					submenu.add(iter.next());				}					count += letter.size();			}				if(submenu != null)			{				char last = 'Z';				if(last == first)					submenu.setText(String.valueOf(first));				else					submenu.setText(first + " - " + last);			}		}	
private void addToLetterMap(List<JMenuItem>[] letters, JMenuItem item)		{			char ch = item.getText().charAt(0);			ch = Character.toUpperCase(ch);			if(ch < 'A' || ch > 'Z')			{				Log.log(Log.ERROR,this,"Plugin menu item label must "					+ "begin with A - Z, or a - z: "					+ item.getText());			}			else				letters[ch - 'A'].add(item);		}	
/**		 * Creates a new plugin update message.		 * @param jar The plugin		 * @param what What happened		 * @param exit Is the editor exiting?		 * @since jEdit 4.2pre3		 */		public PluginUpdate(PluginJAR jar, Object what, boolean exit)		{			super(jar);				if(what == null)				throw new NullPointerException("What must be non-null");				this.what = what;			this.exit = exit;		}	
/**		 * Returns what caused this plugin update.		 */		public Object getWhat()		{			return what;		}	
/**		 * Returns true if this plugin is being unloaded as part of the		 * shutdown process, in which case some components like the help		 * viewer and plugin manager ignore the event.		 * @since jEdit 4.2pre3		 */		public boolean isExiting()		{			return exit;		}	
/**		 * Returns the plugin involved.		 */		public PluginJAR getPluginJAR()		{			return (PluginJAR)getSource();		}	
public String paramString()		{			return "what=" + what + ",exit=" + exit + ","				+ super.paramString();		}	
protected PositionChanging(EditPane editPane, Object whatt)		{			super(editPane, whatt);		}	
public PositionChanging(TextArea textArea)		{			super(EditPane.get(textArea), EditPaneUpdate.POSITION_CHANGING);		}	
public PositionChanging(EditPane editPane)		{			super (editPane, EditPaneUpdate.POSITION_CHANGING);		}	
public PositionManager(JEditBuffer buffer)		{			this.buffer = buffer;		}	
public synchronized Position createPosition(int offset)		{			PosBottomHalf bh = new PosBottomHalf(offset);			PosBottomHalf existing = positions.get(bh);			if(existing == null)			{				positions.put(bh,bh);				existing = bh;			}				return new PosTopHalf(existing);		}	
public synchronized void contentInserted(int offset, int length)		{			if(positions.isEmpty())				return;				/* get all positions from offset to the end, inclusive */			Iterator<PosBottomHalf> iter = positions.tailMap(new PosBottomHalf(offset))				.keySet().iterator();				iteration = true;			while(iter.hasNext())			{				iter.next().contentInserted(offset,length);			}			iteration = false;		}	
public synchronized void contentRemoved(int offset, int length)		{			if(positions.isEmpty())				return;				/* get all positions from offset to the end, inclusive */			Iterator<PosBottomHalf> iter = positions.tailMap(new PosBottomHalf(offset))				.keySet().iterator();				iteration = true;			while(iter.hasNext())			{				iter.next().contentRemoved(offset,length);			}			iteration = false;			}	
PosTopHalf(PosBottomHalf bh)			{				this.bh = bh;				bh.ref();			}	
public int getOffset()			{				return bh.offset;			}	
@Override			protected void finalize()			{				synchronized(PositionManager.this)				{					bh.unref();				}			}	
PosBottomHalf(int offset)			{				this.offset = offset;			}	
void ref()			{				ref++;			}	
void unref()			{				if(--ref == 0)					positions.remove(this);			}	
void contentInserted(int offset, int length)			{				if(offset > this.offset)					throw new ArrayIndexOutOfBoundsException();				this.offset += length;				checkInvariants();			}	
void contentRemoved(int offset, int length)			{				if(offset > this.offset)					throw new ArrayIndexOutOfBoundsException();				if(this.offset <= offset + length)					this.offset = offset;				else					this.offset -= length;				checkInvariants();			}	
@Override			public boolean equals(Object o)			{				if(!(o instanceof PosBottomHalf))					return false;					return ((PosBottomHalf)o).offset == offset;			}	
public int compareTo(PosBottomHalf posBottomHalf)			{				if(iteration)					Log.log(Log.ERROR,this,"Consistency failure");				return offset - posBottomHalf.offset;			}	
private void checkInvariants()			{				if(offset < 0 || offset > buffer.getLength())					throw new ArrayIndexOutOfBoundsException();			}	
private Special() { }	
public Primitive( Object value )	    {	        if ( value == null )	            throw new InterpreterError(					"Use Primitve.NULL instead of Primitive(null)");				if ( value != Special.NULL_VALUE 				&& value != Special.VOID_TYPE &&				!isWrapperType( value.getClass() ) 			)	            throw new InterpreterError( "Not a wrapper type: "+value);		        this.value = value;	    }	
public Primitive(boolean value) { this(new Boolean(value)); }	
public Primitive(byte value) { this(new Byte(value)); }	
public Primitive(short value) { this(new Short(value)); }	
public Primitive(char value) { this(new Character(value)); }	
public Primitive(int value) { this(new Integer(value)); }	
public Primitive(long value) { this(new Long(value)); }	
public Primitive(float value) { this(new Float(value)); }	
public Primitive(double value) { this(new Double(value)); }	
/**	    	Return the primitive value stored in its java.lang wrapper class		*/	    public Object getValue()	    {	        if ( value == Special.NULL_VALUE )	            return null;	        else 			if ( value == Special.VOID_TYPE )	                throw new InterpreterError("attempt to unwrap void type");	        else	            return value;	    }	
public String toString()	    {	        if(value == Special.NULL_VALUE)	            return "null";	        else if(value == Special.VOID_TYPE)	            return "void";	        else	            return value.toString();	    }	
/**			Get the corresponding Java primitive TYPE class for this Primitive.			@return the primitive TYPE class type of the value or Void.TYPE for			Primitive.VOID or null value for type of Primitive.NULL		*/	    public Class getType()	    {			if ( this == Primitive.VOID )				return Void.TYPE;				// NULL return null as type... we currently use null type to indicate 			// loose typing throughout bsh.			if ( this == Primitive.NULL )				return null;				return unboxType( value.getClass() );	    }	
/**			Perform a binary operation on two Primitives or wrapper types.			If both original args were Primitives return a Primitive result			else it was mixed (wrapper/primitive) return the wrapper type.			The exception is for boolean operations where we will return the 			primitive type either way.		*/	    public static Object binaryOperation(			Object obj1, Object obj2, int kind)	        throws UtilEvalError	    {			// special primitive types	        if ( obj1 == NULL || obj2 == NULL )	            throw new UtilEvalError(					"Null value or 'null' literal in binary operation");	        if ( obj1 == VOID || obj2 == VOID )	            throw new UtilEvalError(				"Undefined variable, class, or 'void' literal in binary operation");				// keep track of the original types			Class lhsOrgType = obj1.getClass();			Class rhsOrgType = obj2.getClass();				// Unwrap primitives	        if ( obj1 instanceof Primitive )	            obj1 = ((Primitive)obj1).getValue();	        if ( obj2 instanceof Primitive )	            obj2 = ((Primitive)obj2).getValue();		        Object[] operands = promotePrimitives(obj1, obj2);	        Object lhs = operands[0];	        Object rhs = operands[1];		        if(lhs.getClass() != rhs.getClass())	            throw new UtilEvalError("Type mismatch in operator.  " 				+ lhs.getClass() + " cannot be used with " + rhs.getClass() );				Object result;			try {				result = binaryOperationImpl( lhs, rhs, kind );			} catch ( ArithmeticException e ) {				throw new UtilTargetError( "Arithemetic Exception in binary op", e);			}				// If both original args were Primitives return a Primitive result			// else it was mixed (wrapper/primitive) return the wrapper type			// Exception is for boolean result, return the primitive			if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)				|| result instanceof Boolean			)				return new Primitive( result );			else				return result;	    }	
static Object binaryOperationImpl( Object lhs, Object rhs, int kind )	        throws UtilEvalError		{	        if(lhs instanceof Boolean)	            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);	        else if(lhs instanceof Integer)	            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );	        else if(lhs instanceof Long)	            return longBinaryOperation((Long)lhs, (Long)rhs, kind);	        else if(lhs instanceof Float)	            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);	        else if(lhs instanceof Double)	            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);	        else	            throw new UtilEvalError("Invalid types in binary operator" );		}	
static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)	    {	        boolean lhs = B1.booleanValue();	        boolean rhs = B2.booleanValue();		        switch(kind)	        {	            case EQ:	                return new Boolean(lhs == rhs);		            case NE:	                return new Boolean(lhs != rhs);		            case BOOL_OR:	            case BOOL_ORX:	                return new Boolean( lhs || rhs );		            case BOOL_AND:	            case BOOL_ANDX:	                return new Boolean( lhs && rhs );		            default:	                throw new InterpreterError("unimplemented binary operator");	        }	    }	
static Object longBinaryOperation(Long L1, Long L2, int kind)	    {	        long lhs = L1.longValue();	        long rhs = L2.longValue();		        switch(kind)	        {	            // boolean	            case LT:	            case LTX:	                return new Boolean(lhs < rhs);		            case GT:	            case GTX:	                return new Boolean(lhs > rhs);		            case EQ:	                return new Boolean(lhs == rhs);		            case LE:	            case LEX:	                return new Boolean(lhs <= rhs);		            case GE:	            case GEX:	                return new Boolean(lhs >= rhs);		            case NE:	                return new Boolean(lhs != rhs);		            // arithmetic	            case PLUS:	                return new Long(lhs + rhs);		            case MINUS:	                return new Long(lhs - rhs);		            case STAR:	                return new Long(lhs * rhs);		            case SLASH:	                return new Long(lhs / rhs);		            case MOD:	                return new Long(lhs % rhs);		            // bitwise	            case LSHIFT:	            case LSHIFTX:	                return new Long(lhs << rhs);		            case RSIGNEDSHIFT:	            case RSIGNEDSHIFTX:	                return new Long(lhs >> rhs);		            case RUNSIGNEDSHIFT:	            case RUNSIGNEDSHIFTX:	                return new Long(lhs >>> rhs);		            case BIT_AND:	            case BIT_ANDX:	                return new Long(lhs & rhs);		            case BIT_OR:	            case BIT_ORX:	                return new Long(lhs | rhs);		            case XOR:	                return new Long(lhs ^ rhs);		            default:	                throw new InterpreterError(						"Unimplemented binary long operator");	        }	    }	
static Object intBinaryOperation(Integer I1, Integer I2, int kind)	    {	        int lhs = I1.intValue();	        int rhs = I2.intValue();		        switch(kind)	        {	            // boolean	            case LT:	            case LTX:	                return new Boolean(lhs < rhs);		            case GT:	            case GTX:	                return new Boolean(lhs > rhs);		            case EQ:	                return new Boolean(lhs == rhs);		            case LE:	            case LEX:	                return new Boolean(lhs <= rhs);		            case GE:	            case GEX:	                return new Boolean(lhs >= rhs);		            case NE:	                return new Boolean(lhs != rhs);		            // arithmetic	            case PLUS:	                return new Integer(lhs + rhs);		            case MINUS:	                return new Integer(lhs - rhs);		            case STAR:	                return new Integer(lhs * rhs);		            case SLASH:	                return new Integer(lhs / rhs);		            case MOD:	                return new Integer(lhs % rhs);		            // bitwise	            case LSHIFT:	            case LSHIFTX:	                return new Integer(lhs << rhs);		            case RSIGNEDSHIFT:	            case RSIGNEDSHIFTX:	                return new Integer(lhs >> rhs);		            case RUNSIGNEDSHIFT:	            case RUNSIGNEDSHIFTX:	                return new Integer(lhs >>> rhs);		            case BIT_AND:	            case BIT_ANDX:	                return new Integer(lhs & rhs);		            case BIT_OR:	            case BIT_ORX:	                return new Integer(lhs | rhs);		            case XOR:	                return new Integer(lhs ^ rhs);		            default:	                throw new InterpreterError(						"Unimplemented binary integer operator");	        }	    }	
static Object doubleBinaryOperation(Double D1, Double D2, int kind)	        throws UtilEvalError	    {	        double lhs = D1.doubleValue();	        double rhs = D2.doubleValue();		        switch(kind)	        {	            // boolean	            case LT:	            case LTX:	                return new Boolean(lhs < rhs);		            case GT:	            case GTX:	                return new Boolean(lhs > rhs);		            case EQ:	                return new Boolean(lhs == rhs);		            case LE:	            case LEX:	                return new Boolean(lhs <= rhs);		            case GE:	            case GEX:	                return new Boolean(lhs >= rhs);		            case NE:	                return new Boolean(lhs != rhs);		            // arithmetic	            case PLUS:	                return new Double(lhs + rhs);		            case MINUS:	                return new Double(lhs - rhs);		            case STAR:	                return new Double(lhs * rhs);		            case SLASH:	                return new Double(lhs / rhs);		            case MOD:	                return new Double(lhs % rhs);		            // can't shift floating-point values	            case LSHIFT:	            case LSHIFTX:	            case RSIGNEDSHIFT:	            case RSIGNEDSHIFTX:	            case RUNSIGNEDSHIFT:	            case RUNSIGNEDSHIFTX:	                throw new UtilEvalError("Can't shift doubles");		            default:	                throw new InterpreterError(						"Unimplemented binary double operator");	        }	    }	
static Object floatBinaryOperation(Float F1, Float F2, int kind)	        throws UtilEvalError	    {	        float lhs = F1.floatValue();	        float rhs = F2.floatValue();		        switch(kind)	        {	            // boolean	            case LT:	            case LTX:	                return new Boolean(lhs < rhs);		            case GT:	            case GTX:	                return new Boolean(lhs > rhs);		            case EQ:	                return new Boolean(lhs == rhs);		            case LE:	            case LEX:	                return new Boolean(lhs <= rhs);		            case GE:	            case GEX:	                return new Boolean(lhs >= rhs);		            case NE:	                return new Boolean(lhs != rhs);		            // arithmetic	            case PLUS:	                return new Float(lhs + rhs);		            case MINUS:	                return new Float(lhs - rhs);		            case STAR:	                return new Float(lhs * rhs);		            case SLASH:	                return new Float(lhs / rhs);		            case MOD:	                return new Float(lhs % rhs);		            // can't shift floats	            case LSHIFT:	            case LSHIFTX:	            case RSIGNEDSHIFT:	            case RSIGNEDSHIFTX:	            case RUNSIGNEDSHIFT:	            case RUNSIGNEDSHIFTX:	                throw new UtilEvalError("Can't shift floats ");		            default:	                throw new InterpreterError(						"Unimplemented binary float operator");	        }	    }	
/**			Promote primitive wrapper type to to Integer wrapper type		*/	    static Object promoteToInteger(Object wrapper )	    {	        if(wrapper instanceof Character)	            return new Integer(((Character)wrapper).charValue());	        else if((wrapper instanceof Byte) || (wrapper instanceof Short))	            return new Integer(((Number)wrapper).intValue());		        return wrapper;	    }	
/**			Promote the pair of primitives to the maximum type of the two.			e.g. [int,long]->[long,long]		*/	    static Object[] promotePrimitives(Object lhs, Object rhs)	    {	        lhs = promoteToInteger(lhs);	        rhs = promoteToInteger(rhs);		        if((lhs instanceof Number) && (rhs instanceof Number))	        {	            Number lnum = (Number)lhs;	            Number rnum = (Number)rhs;		            boolean b;		            if((b = (lnum instanceof Double)) || (rnum instanceof Double))	            {	                if(b)	                    rhs = new Double(rnum.doubleValue());	                else	                    lhs = new Double(lnum.doubleValue());	            }	            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))	            {	                if(b)	                    rhs = new Float(rnum.floatValue());	                else	                    lhs = new Float(lnum.floatValue());	            }	            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))	            {	                if(b)	                    rhs = new Long(rnum.longValue());	                else	                    lhs = new Long(lnum.longValue());	            }	        }		        return new Object[] { lhs, rhs };	    }	
public static Primitive unaryOperation(Primitive val, int kind)	        throws UtilEvalError	    {	        if (val == NULL)	            throw new UtilEvalError(					"illegal use of null object or 'null' literal");	        if (val == VOID)	            throw new UtilEvalError(					"illegal use of undefined object or 'void' literal");		        Class operandType = val.getType();	        Object operand = promoteToInteger(val.getValue());		        if ( operand instanceof Boolean )	            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));	        else if(operand instanceof Integer)	        {	            int result = intUnaryOperation((Integer)operand, kind);		            // ++ and -- must be cast back the original type	            if(kind == INCR || kind == DECR)	            {	                if(operandType == Byte.TYPE)	                    return new Primitive((byte)result);	                if(operandType == Short.TYPE)	                    return new Primitive((short)result);	                if(operandType == Character.TYPE)	                    return new Primitive((char)result);	            }		            return new Primitive(result);	        }	        else if(operand instanceof Long)	            return new Primitive(longUnaryOperation((Long)operand, kind));	        else if(operand instanceof Float)	            return new Primitive(floatUnaryOperation((Float)operand, kind));	        else if(operand instanceof Double)	            return new Primitive(doubleUnaryOperation((Double)operand, kind));	        else	            throw new InterpreterError(					"An error occurred.  Please call technical support.");	    }	
static boolean booleanUnaryOperation(Boolean B, int kind) 			throws UtilEvalError	    {	        boolean operand = B.booleanValue();	        switch(kind)	        {	            case BANG:	                return !operand;	            default:	                throw new UtilEvalError("Operator inappropriate for boolean");	        }	    }	
static int intUnaryOperation(Integer I, int kind)	    {	        int operand = I.intValue();		        switch(kind)	        {	            case PLUS:	                return operand;	            case MINUS:	                return -operand;	            case TILDE:	                return ~operand;	            case INCR:	                return operand + 1;	            case DECR:	                return operand - 1;	            default:	                throw new InterpreterError("bad integer unaryOperation");	        }	    }	
static long longUnaryOperation(Long L, int kind)	    {	        long operand = L.longValue();		        switch(kind)	        {	            case PLUS:	                return operand;	            case MINUS:	                return -operand;	            case TILDE:	                return ~operand;	            case INCR:	                return operand + 1;	            case DECR:	                return operand - 1;	            default:	                throw new InterpreterError("bad long unaryOperation");	        }	    }	
static float floatUnaryOperation(Float F, int kind)	    {	        float operand = F.floatValue();		        switch(kind)	        {	            case PLUS:	                return operand;	            case MINUS:	                return -operand;	            default:	                throw new InterpreterError("bad float unaryOperation");	        }	    }	
static double doubleUnaryOperation(Double D, int kind)	    {	        double operand = D.doubleValue();		        switch(kind)	        {	            case PLUS:	                return operand;	            case MINUS:	                return -operand;	            default:	                throw new InterpreterError("bad double unaryOperation");	        }	    }	
public int intValue() throws UtilEvalError	    {	        if(value instanceof Number)	            return((Number)value).intValue();	        else	            throw new UtilEvalError("Primitive not a number");	    }	
public boolean booleanValue() throws UtilEvalError	    {	        if(value instanceof Boolean)	            return((Boolean)value).booleanValue();	        else	            throw new UtilEvalError("Primitive not a boolean");	    }	
/**			Determine if this primitive is a numeric type.			i.e. not boolean, null, or void (but including char)		*/		public boolean isNumber() {			return ( !(value instanceof Boolean) 				&& !(this == NULL) && !(this == VOID) );		}	
public Number numberValue() throws UtilEvalError	    {			Object value = this.value;				// Promote character to Number type for these purposes			if (value instanceof Character)				value = new Integer(((Character)value).charValue());		        if (value instanceof Number)	            return (Number)value;	        else	            throw new UtilEvalError("Primitive not a number");	    }	
/**			Primitives compare equal with other Primitives containing an equal			wrapped value.		*/		public boolean equals( Object obj ) 		{			if ( obj instanceof Primitive )				return ((Primitive)obj).value.equals( this.value );			else				return false;		}	
/**			The hash of the Primitive is tied to the hash of the wrapped value but			shifted so that they are not the same.		*/		public int hashCode() 		{			return this.value.hashCode() * 21; // arbitrary		}	
/**			Unwrap primitive values and map voids to nulls.			Non Primitive types remain unchanged.				@param obj object type which may be bsh.Primitive			@return corresponding "normal" Java type, "unwrapping" 				any bsh.Primitive types to their wrapper types.		*/		public static Object unwrap( Object obj ) 		{	        // map voids to nulls for the outside world	        if (obj == Primitive.VOID)	            return null;		        // unwrap primitives	        if (obj instanceof Primitive)	            return((Primitive)obj).getValue();	        else	            return obj;		}	
public static Object [] unwrap( Object[] args )	    {			Object [] oa = new Object[ args.length ];	        for(int i=0; i<args.length; i++)	            oa[i] = unwrap( args[i] );			return oa;	    }	
public static Object [] wrap( Object[] args, Class [] paramTypes )	    {			if ( args == null )				return null;				Object [] oa = new Object[ args.length ];	        for(int i=0; i<args.length; i++)	            oa[i] = wrap( args[i], paramTypes[i] );			return oa;	    }	
/**			Wrap primitive values (as indicated by type param) and nulls in the 			Primitive class.  Values not primitive or null are left unchanged.			Primitive values are represented by their wrapped values in param value.			<p/>			The value null is mapped to Primitive.NULL.			Any value specified with type Void.TYPE is mapped to Primitive.VOID.		*/	    public static Object wrap(			Object value, Class type )	    {	        if ( type == Void.TYPE )	            return Primitive.VOID;		        if ( value == null )	            return Primitive.NULL;				if ( type.isPrimitive() )				return new Primitive( value );				return value;	    }	
/**			Get the appropriate default value per JLS 4.5.4		*/		public static Primitive getDefaultValue( Class type )		{			if ( type == null || !type.isPrimitive() )				return Primitive.NULL;			if ( type == Boolean.TYPE )				return new Primitive( false );				// non boolean primitive, get appropriate flavor of zero			try {				return new Primitive((int)0).castToType( type, Types.CAST );			} catch ( UtilEvalError e ) {				throw new InterpreterError( "bad cast" );			}		}	
/**			Get the corresponding java.lang wrapper class for the primitive TYPE			class.			e.g.  Integer.TYPE -> Integer.class		*/		public static Class boxType( Class primitiveType )		{			Class c = (Class)wrapperMap.get( primitiveType );			if ( c != null )				return c;			throw new InterpreterError( 				"Not a primitive type: "+ primitiveType );		}	
/**			Get the corresponding primitive TYPE class for the java.lang wrapper			class type.			e.g.  Integer.class -> Integer.TYPE		*/		public static Class unboxType( Class wrapperType )		{			Class c = (Class)wrapperMap.get( wrapperType );			if ( c != null )				return c;			throw new InterpreterError( 				"Not a primitive wrapper type: "+wrapperType );		}	
/**			Cast this bsh.Primitive value to a new bsh.Primitive value			This is usually a numeric type cast.  Other cases include:				A boolean can be cast to boolen				null can be cast to any object type and remains null				Attempting to cast a void causes an exception			@param toType is the java object or primitive TYPE class		*/		public Primitive castToType( Class toType, int operation ) 			throws UtilEvalError		{			return castPrimitive( 				toType, getType()/*fromType*/, this/*fromValue*/, 				false/*checkOnly*/, operation );		}	
static Primitive castPrimitive( 			Class toType, Class fromType, Primitive fromValue, 			boolean checkOnly, int operation ) 			throws UtilEvalError		{			/*				Lots of preconditions checked here...				Once things are running smoothly we might comment these out				(That's what assertions are for).			*/			if ( checkOnly && fromValue != null )				throw new InterpreterError("bad cast param 1");			if ( !checkOnly && fromValue == null )				throw new InterpreterError("bad cast param 2");			if ( fromType != null && !fromType.isPrimitive() )				throw new InterpreterError("bad fromType:" +fromType);			if ( fromValue == Primitive.NULL && fromType != null )				throw new InterpreterError("inconsistent args 1");			if ( fromValue == Primitive.VOID && fromType != Void.TYPE )				throw new InterpreterError("inconsistent args 2");				// can't cast void to anything			if ( fromType == Void.TYPE )				if ( checkOnly )					return Types.INVALID_CAST;				else					throw Types.castError( Reflect.normalizeClassName(toType), 						"void value", operation );				// unwrap Primitive fromValue to its wrapper value, etc.			Object value = null; 			if ( fromValue != null )				value = fromValue.getValue();				if ( toType.isPrimitive() )			{				// Trying to cast null to primitive type?				if ( fromType == null )					if ( checkOnly )						return Types.INVALID_CAST;					else						throw Types.castError(							"primitive type:" + toType, "Null value", operation );					// fall through			} else			{				// Trying to cast primitive to an object type				// Primitive.NULL can be cast to any object type				if ( fromType == null )					return checkOnly ? Types.VALID_CAST : 						Primitive.NULL;					if ( checkOnly )					return Types.INVALID_CAST;				else					throw Types.castError(							"object type:" + toType, "primitive value", operation);			}				// can only cast boolean to boolean			if ( fromType == Boolean.TYPE )			{				if ( toType != Boolean.TYPE )					if ( checkOnly )						return Types.INVALID_CAST;					else						throw Types.castError( toType, fromType, operation );					return checkOnly ? Types.VALID_CAST :					fromValue;			}				// Do numeric cast				// Only allow legal Java assignment unless we're a CAST operation			if ( operation == Types.ASSIGNMENT 				&& !Types.isJavaAssignable( toType, fromType ) 			) {				if ( checkOnly )					return Types.INVALID_CAST;				else					throw Types.castError( toType, fromType, operation );			}				return checkOnly ? Types.VALID_CAST :				new Primitive( castWrapper(toType, value) );		}	
public static boolean isWrapperType( Class type )		{			return wrapperMap.get( type ) != null && !type.isPrimitive();		}	
/**			Cast a primitive value represented by its java.lang wrapper type to the			specified java.lang wrapper type.  e.g.  Byte(5) to Integer(5) or			Integer(5) to Byte(5) 			@param toType is the java TYPE type			@param value is the value in java.lang wrapper.			value may not be null.		*/		static Object castWrapper( 			Class toType, Object value ) 		{			if ( !toType.isPrimitive() )				throw new InterpreterError("invalid type in castWrapper: "+toType);			if ( value == null )				throw new InterpreterError("null value in castWrapper, guard");			if ( value instanceof Boolean )			{				if ( toType != Boolean.TYPE )					throw new InterpreterError("bad wrapper cast of boolean");				else					return value;			}				// first promote char to Number type to avoid duplicating code			if ( value instanceof Character )				value = new Integer(((Character)value).charValue());				if ( !(value instanceof Number) )				throw new InterpreterError("bad type in cast");				Number number = (Number)value;				if (toType == Byte.TYPE)				return new Byte(number.byteValue());			if (toType == Short.TYPE)				return new Short(number.shortValue());			if (toType == Character.TYPE)				return new Character((char)number.intValue());			if (toType == Integer.TYPE)				return new Integer(number.intValue());			if (toType == Long.TYPE)				return new Long(number.longValue());			if (toType == Float.TYPE)				return new Float(number.floatValue());			if (toType == Double.TYPE)				return new Double(number.doubleValue());				throw new InterpreterError("error in wrapper cast");		}	
public PrintOptionPane()		{			super("print");		}	
protected void _init()		{			/* Font */			font = new FontSelector(jEdit.getFontProperty("print.font"));			addComponent(jEdit.getProperty("options.print.font"),font);				/* Header */			printHeader = new JCheckBox(jEdit.getProperty("options.print"				+ ".header"));			printHeader.setSelected(jEdit.getBooleanProperty("print.header"));			addComponent(printHeader);				/* Footer */			printFooter = new JCheckBox(jEdit.getProperty("options.print"				+ ".footer"));			printFooter.setSelected(jEdit.getBooleanProperty("print.footer"));			addComponent(printFooter);				/* Line numbering */			printLineNumbers = new JCheckBox(jEdit.getProperty("options.print"				+ ".lineNumbers"));			printLineNumbers.setSelected(jEdit.getBooleanProperty("print.lineNumbers"));			addComponent(printLineNumbers);				/* Color */			color = new JCheckBox(jEdit.getProperty("options.print"				+ ".color"));			color.setSelected(jEdit.getBooleanProperty("print.color"));			addComponent(color);				/* Tab size */			String[] tabSizes = { "2", "4", "8" };			tabSize = new JComboBox(tabSizes);			tabSize.setEditable(true);			tabSize.setSelectedItem(jEdit.getProperty("print.tabSize"));			addComponent(jEdit.getProperty("options.print.tabSize"),tabSize);					/* Print Folds */			printFolds = new JCheckBox(jEdit.getProperty("options.print"				+ ".folds"));			printFolds.setSelected(jEdit.getBooleanProperty("print.folds",true));			addComponent(printFolds);						addSeparator("options.print.workarounds");				/* Spacing workaround */			glyphVector = new JCheckBox(jEdit.getProperty(				"options.print.glyphVector"));			glyphVector.setSelected(jEdit.getBooleanProperty("print.glyphVector"));			addComponent(glyphVector);				/* Force 1.3 print dialog */			force13 = new JCheckBox(jEdit.getProperty(				"options.print.force13"));			force13.setSelected(jEdit.getBooleanProperty("print.force13"));			addComponent(force13);		}	
protected void _save()		{			jEdit.setFontProperty("print.font",font.getFont());			jEdit.setBooleanProperty("print.header",printHeader.isSelected());			jEdit.setBooleanProperty("print.footer",printFooter.isSelected());			jEdit.setBooleanProperty("print.lineNumbers",printLineNumbers.isSelected());			jEdit.setBooleanProperty("print.color",color.isSelected());			jEdit.setProperty("print.tabSize",(String)tabSize.getSelectedItem());			jEdit.setBooleanProperty("print.glyphVector",glyphVector.isSelected());			jEdit.setBooleanProperty("print.force13",force13.isSelected());			jEdit.setBooleanProperty("print.folds",printFolds.isSelected());		}	
/**		 * Creates a new instance with the given root and the default array		 * separator char (':').		 *		 * @param root A non-null string that will be the "root" of the		 *             serialized properties.		 */		protected PropertiesBean(String root)		{			this(root, ':');		}	
/**		 * Creates a new instance with the given root and the given array		 * separator character.		 *		 * @param root A non-null string that will be the "root" of the		 *             serialized properties.		 * @param arraysep A character that will be used to define the		 *                 separator of elements of an array property.		 */		protected PropertiesBean(String root, char arraysep)		{			if (root == null)				throw new IllegalArgumentException("root cannot be null");			this.root = root;			this.arraysep = arraysep;		}	
/**		 * Loads the bean's properties from the given object.		 */		public void load(Properties p)		{			try			{				PropertyDescriptor[] _props = getPropertyDescriptors();				for (int i = 0; i < _props.length; i++)				{					if ("class".equals(_props[i].getName()))						continue;						Method _set = _props[i].getWriteMethod();					if (_set != null)					{						String _pname = root + "." + _props[i].getName();						Object _val = p.getProperty(_pname);						if (_val != null)							_val = parse((String)_val, _props[i].getPropertyType());						try						{							_set.invoke(this, _val);						}						catch (IllegalArgumentException iae)						{							/* Ignore these. */						}					}				}			}			catch (Exception e)			{				// These exceptions shouldn't occur during normal runtime,				// so we catch them and print an error message. Users of this				// class should fix these before releasing the code.				Log.log(Log.ERROR, this, e);			}		}	
/**		 * Saves the bean's properties into the given object.		 */		public void save(Properties p)		{			try			{				PropertyDescriptor[] _props = getPropertyDescriptors();				for (int i = 0; i < _props.length; i++)				{					if ("class".equals(_props[i].getName()))						continue;						Method _get = _props[i].getReadMethod();					if (_get != null)					{						Object _val = _get.invoke(this);						String _pname = root + "." + _props[i].getName();						if (_val != null)							p.setProperty(_pname, encode(_val));						else							p.remove(_pname);					}				}			}			catch (Exception e)			{				// These exceptions shouldn't occur during normal runtime,				// so we catch them and print an error message. Users of this				// class should fix these before releasing the code.				Log.log(Log.ERROR, this, e);			}		}	
/**		 * Cleans the entries related to this object from the given object.		 */		public void clean(Properties p)		{				try			{				PropertyDescriptor[] _props = getPropertyDescriptors();				for (int i = 0; i < _props.length; i++)				{					if ("class".equals(_props[i].getName()))						continue;						String _pname = root + "." + _props[i].getName();					p.remove(_pname);				}			}			catch (Exception e)			{				// These exceptions shouldn't occur during normal runtime,				// so we catch them and print an error message. Users of this				// class should fix these before releasing the code.				Log.log(Log.ERROR, this, e);			}		}	
private PropertyDescriptor[] getPropertyDescriptors()			throws IntrospectionException		{			BeanInfo _info = Introspector.getBeanInfo(getClass());			return _info.getPropertyDescriptors();		}	
private String encode(Object value)		{			Class _class = value.getClass();			if (_class.isArray())			{				StringBuilder _val = new StringBuilder();				int _len = Array.getLength(value);				for (int i = 0; i < _len; i++)				{					String _str = encode(Array.get(value, i));					if (_str == null)						return null;					_val.append(_str);					if (i < _len - 1)						_val.append(arraysep);				}				return _val.toString();			}			else			{				// just make sure it's a supported type.				if (_class != Boolean.class && _class != Boolean.TYPE				    && _class != Character.class && _class != Character.TYPE				    && _class != Double.class && _class != Double.TYPE				    && _class != Float.class && _class != Float.TYPE				    && _class != Integer.class && _class != Integer.TYPE				    && _class != Long.class && _class != Long.TYPE				    && _class != Short.class && _class != Short.TYPE				    && _class != String.class)				{					Log.log(Log.WARNING, this, "unsupported type: " + _class.getName());					return null;				}				return value.toString();			}		}	
private Object parse(String value, Class<?> _class)		{			Object _ret = null;			if (_class.isArray())			{				StringTokenizer st = new StringTokenizer(value, String.valueOf(arraysep));				Class _type = _class.getComponentType();				_ret = Array.newInstance(_type, st.countTokens());				int _cnt = st.countTokens();				for (int i = 0; i < _cnt; i++)				{					Object _val = parse(st.nextToken(), _type);					if (_val == null)						return null;					Array.set(_ret, i, _val);				}			}			else			{				if (_class == Boolean.class || _class == Boolean.TYPE)					_ret = Boolean.valueOf(value);				else if (_class == Character.class || _class == Character.TYPE)					_ret = Character.valueOf(value.charAt(0));				else if (_class == Double.class || _class == Double.TYPE)					_ret = Double.valueOf(value);				else if (_class == Float.class || _class == Float.TYPE)					_ret = Float.valueOf(value);				else if (_class == Integer.class || _class == Integer.TYPE)					_ret = Integer.valueOf(value);				else if (_class == Long.class || _class == Long.TYPE)					_ret = Long.valueOf(value);				else if (_class == Short.class || _class == Short.TYPE)					_ret = Short.valueOf(value);				else if (_class == String.class)					_ret = value;				else					Log.log(Log.WARNING, this, "unsupported type: " + _class.getName());				}			return _ret;		}	
/**		 * Creates a new properties changed message.		 * @param source The message source		 */		public PropertiesChanged(EBComponent source)		{			super(source);		}	
/**		 * Creates a new properties changing message.		 * @param source 	The message source		 * @param state		An enum describing what is happening.		 */		public PropertiesChanging(EBComponent source, State state)		{			super(source);			assert (state != null) : "state shouldn't be null";			this.state = state;		}	
public State getState()		{			return state;		}	
Properties getProperties()		{			Properties total = new Properties();			total.putAll(system);			for (Properties plugin : plugins)				total.putAll(plugin);			total.putAll(site);			total.putAll(user);			return total;		}	
void loadSystemProps(InputStream in)			throws IOException		{			loadProps(system,in);		}	
void loadSiteProps(InputStream in)			throws IOException		{			loadProps(site,in);		}	
void loadUserProps(InputStream in)			throws IOException		{			loadProps(user,in);		}	
void saveUserProps(OutputStream out)			throws IOException		{			user.store(out,"jEdit properties");		}	
Properties loadPluginProps(InputStream in)			throws IOException		{			Properties plugin = new Properties();			loadProps(plugin,in);			plugins.add(plugin);			return plugin;		}	
void addPluginProps(Properties props)		{			plugins.add(props);		}	
void removePluginProps(Properties props)		{			plugins.remove(props);		}	
String getProperty(String name)		{			String value = user.getProperty(name);			if(value != null)				return value;			else				return getDefaultProperty(name);		}	
void setProperty(String name, String value)		{			String prop = getDefaultProperty(name);				/* if value is null:			 * - if default is null, unset user prop			 * - else set user prop to ""			 * else			 * - if default equals value, ignore			 * - if default doesn't equal value, set user			 */			if(value == null)			{				if(prop == null || prop.length() == 0)					user.remove(name);				else					user.setProperty(name,"");			}			else			{				if(value.equals(prop))					user.remove(name);				else					user.setProperty(name,value);			}		}	
public void setTemporaryProperty(String name, String value)		{			user.remove(name);			system.setProperty(name,value);		}	
void unsetProperty(String name)		{			if(getDefaultProperty(name) != null)				user.setProperty(name,"");			else				user.remove(name);		}	
public void resetProperty(String name)		{			user.remove(name);		}	
private String getDefaultProperty(String name)		{			String value = site.getProperty(name);			if(value != null)				return value;				for (Properties plugin : plugins)			{				value = plugin.getProperty(name);				if (value != null)					return value;			}				return system.getProperty(name);		}	
private static void loadProps(Properties into, InputStream in)			throws IOException		{			try			{				into.load(in);			}			finally			{				in.close();			}		}	
RangeMap()		{			fvm = new int[2];			lastfvmget = -1;		}	
RangeMap(RangeMap copy)		{			this.fvm = copy.fvm.clone();			this.fvmcount = copy.fvmcount;		}	
void reset(int lines)		{			lastfvmget = -1;			fvmcount = 2;			fvm[0] = 0;			fvm[1] = lines;		}	
int first()		{			return fvm[0];		}	
int last()		{			return fvm[fvmcount - 1] - 1;		}	
int lookup(int index)		{			return fvm[index];		}	
/**		 * Returns the fold visibility map index for the given line.		 */		int search(int line)		{			if(line < fvm[0])				return -1;			if(line >= fvm[fvmcount - 1])				return fvmcount - 1;				if(lastfvmget != -1)			{				if(line >= fvm[lastfvmget])				{					if(lastfvmget == fvmcount - 1						|| line < fvm[lastfvmget + 1])					{						return lastfvmget;					}				}			}				int start = 0;			int end = fvmcount - 1;		loop:		for(;;)			{				switch(end - start)				{				case 0:					lastfvmget = start;					break loop;				case 1:					int value = fvm[end];					if(value <= line)						lastfvmget = end;					else						lastfvmget = start;					break loop;				default:					int pivot = (end + start) / 2;					value = fvm[pivot];					if(value == line)					{						lastfvmget = pivot;						break loop;					}					else if(value < line)						start = pivot;					else						end = pivot - 1;					break;				}			}				return lastfvmget;		}	
/**		 * Replaces from <code>start</code> to <code>end-1</code> inclusive with		 * <code>put</code>. Update <code>fvmcount</code>.		 */		void put(int start, int end, int[] put)		{			if(Debug.FOLD_VIS_DEBUG)			{				StringBuilder buf = new StringBuilder(50);				buf.append("fvmput(").append(start).append(',');				buf.append(end).append(',');				buf.append('{');				if(put != null)				{					for(int i = 0; i < put.length; i++)					{						if(i != 0)							buf.append(',');						buf.append(put[i]);					}				}				buf.append("})");				Log.log(Log.DEBUG,this,buf.toString());			}			int putl = put == null ? 0 : put.length;				int delta = putl - (end - start);			if(fvmcount + delta > fvm.length)			{				int[] newfvm = new int[(fvm.length << 1) + 1];				System.arraycopy(fvm,0,newfvm,0,fvmcount);				fvm = newfvm;			}				if(delta != 0)			{				System.arraycopy(fvm,end,fvm,start + putl,					fvmcount - end);			}				if(putl != 0)			{				System.arraycopy(put,0,fvm,start,put.length);			}				fvmcount += delta;				dump();				if(fvmcount == 0)				throw new InternalError();		}	
/**		 * Merge previous and next entry if necessary.		 */		void put2(int starti, int endi, int start, int end)		{			if(Debug.FOLD_VIS_DEBUG)			{				Log.log(Log.DEBUG,this,"*fvmput2(" + starti + ","					+ endi + "," + start + "," + end + ")");			}			if(starti != -1 && fvm[starti] == start)			{				if(endi <= fvmcount - 2 && fvm[endi + 1]					== end + 1)				{					put(starti,endi + 2,null);				}				else				{					put(starti,endi + 1,						new int[] { end + 1 });				}			}			else			{				if(endi != fvmcount - 1 && fvm[endi + 1]					== end + 1)				{					put(starti + 1,endi + 2,						new int[] { start });				}				else				{					put(starti + 1,endi + 1,						new int[] { start,						end + 1 });				}			}		}	
int next(int line)		{			int index = search(line);			/* in collapsed range */			if(index % 2 != 0)			{				/* beyond last visible line */				if(fvmcount == index + 1)					return - 1;				/* start of next expanded range */				else					return fvm[index + 1];			}			/* last in expanded range */			else if(line == fvm[index + 1] - 1)			{				/* equal to last visible line */				if(fvmcount == index + 2)					return -1;				/* start of next expanded range */				else					return fvm[index + 2];			}			/* next in expanded range */			else				return line + 1;		}	
int prev(int line)		{			int index = search(line);			/* before first visible line */			if(index == -1)				return -1;			/* in collapsed range */			else if(index % 2 == 1)			{				/* end of prev expanded range */				return fvm[index] - 1;			}			/* first in expanded range */			else if(line == fvm[index])			{				/* equal to first visible line */				if(index == 0)					return -1;				/* end of prev expanded range */				else					return fvm[index - 1] - 1;			}			/* prev in expanded range */			else				return line - 1;		}	
void show(int start, int end)		{			int starti = search(start);			int endi = search(end);				if(starti % 2 == 0)			{				if(endi % 2 == 0)					put(starti + 1,endi + 1,null);				else				{					if(endi != fvmcount - 1						&& fvm[endi + 1] == end + 1)						put(starti + 1,endi + 2,null);					else					{						put(starti + 1,endi,null);						fvm[starti + 1] = end + 1;					}				}			}			else			{				if(endi % 2 == 0)				{					if(starti != -1 && fvm[starti] == start)						put(starti,endi + 1,null);					else					{						put(starti + 1,endi,null);						fvm[starti + 1] = start;					}				}				else					put2(starti,endi,start,end);			}				lastfvmget = -1;		}	
void hide(int start, int end)		{			int starti = search(start);			int endi = search(end);				if(starti % 2 == 0)			{				if(endi % 2 == 0)					put2(starti,endi,start,end);				else				{					if(start == fvm[0])						put(starti,endi + 1,null);					else					{						put(starti + 1,endi,null);						fvm[starti + 1] = start;					}				}			}			else			{				if(endi % 2 == 0)				{					if(end + 1 == fvm[fvmcount - 1])						put(starti + 1,endi + 2,null);					else					{						put(starti + 1,endi,null);						fvm[starti + 1] = end + 1;					}				}				else					put(starti + 1,endi + 1,null);			}				lastfvmget = -1;		}	
int count()		{			return fvmcount;		}	
void dump()		{			if(Debug.FOLD_VIS_DEBUG)			{				StringBuilder buf = new StringBuilder("{");				for(int i = 0; i < fvmcount; i++)				{					if(i != 0)						buf.append(',');					buf.append(fvm[i]);				}				buf.append('}');				Log.log(Log.DEBUG,this,"fvm = " + buf);			}		}	
void contentInserted(int startLine, int numLines)		{			if(numLines != 0)			{				int index = search(startLine);				int start = index + 1;					for(int i = start; i < fvmcount; i++)					fvm[i] += numLines;					lastfvmget = -1;				dump();			}		}	
/**		 * @return If the anchors should be reset.		 */		boolean preContentRemoved(int startLine, int numLines)		{			boolean returnValue = false;				int endLine = startLine + numLines;				/* update fold visibility map. */			int starti = search(startLine);			int endi = search(endLine);				/* both have same visibility; just remove			 * anything in between. */			if(Math.abs(starti % 2) == Math.abs(endi % 2))			{				if(endi - starti == fvmcount)				{					// we're removing from before					// the first visible to after					// the last visible					returnValue = true;					starti = 1;				}				else				{					put(starti + 1,endi + 1,null);					starti++;				}			}			/* collapse 2 */			else if(starti != -1 && fvm[starti] == startLine)			{				if(endi - starti == fvmcount - 1)				{					// we're removing from					// the first visible to after					// the last visible					returnValue = true;					starti = 1;				}				else					put(starti,endi + 1,null);			}			/* shift */			else			{				put(starti + 1,endi,null);				fvm[starti + 1] = startLine;				starti += 2;			}				/* update */			for(int i = starti; i < fvmcount; i++)				fvm[i] -= numLines;				lastfvmget = -1;			dump();				return returnValue;		}	
public void readLock()		{			body.readLock().lock();		}	
public void readUnlock()		{			body.readLock().unlock();		}	
public void writeLock()		{			body.writeLock().lock();		}	
public void writeUnlock()		{			body.writeLock().unlock();		}	
public boolean isWriteLocked()		{			return body.isWriteLocked();		}	
public boolean updateEveryTime()		{			return true;		}	
public void update(JMenu menu)		{			final View view = GUIUtilities.getView(menu);				//{{{ ActionListener...			ActionListener actionListener = new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					VFSBrowser.browseDirectory(view,evt.getActionCommand());						view.getStatus().setMessage(null);				}			}; //}}}				//{{{ MouseListener...			MouseListener mouseListener = new MouseAdapter()			{				public void mouseEntered(MouseEvent evt)				{					view.getStatus().setMessage(						((JMenuItem)evt.getSource())						.getActionCommand());				}					public void mouseExited(MouseEvent evt)				{					view.getStatus().setMessage(null);				}			}; //}}}				HistoryModel model = HistoryModel.getModel("vfs.browser.path");			if(model.getSize() == 0)			{				JMenuItem menuItem = new JMenuItem(					jEdit.getProperty("no-recent-dirs.label"));				menuItem.setEnabled(false);				menu.add(menuItem);				return;			}				boolean sort = jEdit.getBooleanProperty("sortRecent");				int maxItems = jEdit.getIntegerProperty("menu.spillover",20);				Vector<JMenuItem> menuItems = new Vector<JMenuItem>();				for(int i = 0; i < model.getSize(); i++)			{				String path = model.getItem(i);				JMenuItem menuItem = new JMenuItem(MiscUtilities.getFileName(path));				menuItem.setActionCommand(path);				menuItem.addActionListener(actionListener);				menuItem.addMouseListener(mouseListener);				menuItem.setIcon(FileCellRenderer.dirIcon);					if(sort)					menuItems.addElement(menuItem);				else				{					if(menu.getMenuComponentCount() >= maxItems						&& i != model.getSize() - 1)					{						JMenu newMenu = new JMenu(							jEdit.getProperty("common.more"));						menu.add(newMenu);						menu = newMenu;					}						menu.add(menuItem);				}			}				if(sort)			{				Collections.sort(menuItems,						new MenuItemTextComparator());				for(int i = 0; i < menuItems.size(); i++)				{					if(menu.getMenuComponentCount() >= maxItems						&& i != 0)					{						JMenu newMenu = new JMenu(							jEdit.getProperty("common.more"));						menu.add(newMenu);						menu = newMenu;					}						menu.add(menuItems.elementAt(i));				}			}		}	
public boolean updateEveryTime()		{			return false;		}	
public void update(JMenu menu)		{			final View view = GUIUtilities.getView(menu);				//{{{ ActionListener...			ActionListener actionListener = new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					jEdit.openFile(view,evt.getActionCommand());					view.getStatus().setMessage(null);				}			}; //}}}				//{{{ MouseListener...			/*			MouseListener mouseListener = new MouseAdapter()			{				public void mouseEntered(MouseEvent evt)				{					view.getStatus().setMessage(						((JMenuItem)evt.getSource())						.getActionCommand());				}					public void mouseExited(MouseEvent evt)				{					view.getStatus().setMessage(null);				}			};			*/			//}}}						//{{{ ChangeListener...			ChangeListener changeListener = new ChangeListener()			{				public void stateChanged(ChangeEvent e)				{					JMenuItem menuItem = (JMenuItem) e.getSource();										view.getStatus().setMessage(menuItem.isArmed()?menuItem.getActionCommand():null);				} 			}; //}}}				List<BufferHistory.Entry> recentVector = BufferHistory.getHistory();				if(recentVector.isEmpty())			{				JMenuItem menuItem = new JMenuItem(					jEdit.getProperty("no-recent-files.label"));				menuItem.setEnabled(false);				menu.add(menuItem);				return;			}				final List<JMenuItem> menuItems = new ArrayList<JMenuItem>();			final JTextField text = new JTextField();			text.setToolTipText(jEdit.getProperty("recent-files.textfield.tooltip"));			menu.add(text);			text.addKeyListener(new KeyAdapter()			{				public void keyReleased(KeyEvent e)				{					String typedText = text.getText();					for (JMenuItem tempMenuItem : menuItems)					{						if (typedText.length() == 0)						{							tempMenuItem.setEnabled(true);						}						else						{							String fileName = tempMenuItem.getText();							boolean matchesStart = fileName.toLowerCase().startsWith(typedText.toLowerCase());							tempMenuItem.setEnabled(matchesStart);						}					}				}			});				boolean sort = jEdit.getBooleanProperty("sortRecent");				int maxItems = jEdit.getIntegerProperty("menu.spillover",20);				Iterator<BufferHistory.Entry> iter = recentVector.iterator();			while(iter.hasNext())			{				String path = iter.next().path;				JMenuItem menuItem = new JMenuItem(MiscUtilities					.getFileName(path));				menuItem.setActionCommand(path);				menuItem.addActionListener(actionListener);	//			menuItem.addMouseListener(mouseListener);				menuItem.addChangeListener(changeListener);								menuItem.setIcon(FileCellRenderer.fileIcon);					menuItems.add(menuItem);				if (!sort)				{					if (menu.getMenuComponentCount() >= maxItems					    && iter.hasNext())					{						JMenu newMenu = new JMenu(								jEdit.getProperty("common.more"));						menu.add(newMenu);						menu = newMenu;					}						menu.add(menuItem);				}			}				if(sort)			{				Collections.sort(menuItems, new MenuItemTextComparator());				for(int i = 0; i < menuItems.size(); i++)				{					if(menu.getMenuComponentCount() >= maxItems						&& i != 0)					{						JMenu newMenu = new JMenu(							jEdit.getProperty("common.more"));						menu.add(newMenu);						menu = newMenu;					}						menu.add(menuItems.get(i));				}			}			JMenuItem menuItem = new JMenuItem(jEdit.getProperty("clear-recent-files.label"));			menuItem.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent e)				{					BufferHistory.clear();				}			});			menu.addSeparator();			menu.add(menuItem);		}	
public Widget getWidget(View view) 	    {		    Widget rect = new RectSelectWidget(view);		    return rect;	    }	
RectSelectWidget(final View view)		    {			    rectSelect = new ToolTipLabel();			    rectSelect.setHorizontalAlignment(SwingConstants.CENTER);			    rectSelect.setToolTipText(jEdit.getProperty("view.status.rect-tooltip"));			    this.view = view;			    rectSelect.addMouseListener(new MouseAdapter()			    {				    @Override				    public void mouseClicked(MouseEvent evt)				    {					    JEditTextArea textArea = view.getTextArea();					    if (textArea != null)					    	textArea.toggleRectangularSelectionEnabled();				    }			    });		    }	
public JComponent getComponent() 		    {			    return rectSelect;		    }	
public void update() 		    {			    JEditTextArea textArea = view.getTextArea();			    if (textArea != null)			    {				    rectSelect.setText(textArea.isRectangularSelectionEnabled()						       ? "R" : "-");			    }		    }	
public void propertiesChanged()		    {			    // retarded GTK look and feel!			    Font font = new JLabel().getFont();			    //UIManager.getFont("Label.font");			    FontMetrics fm = rectSelect.getFontMetrics(font);			    Dimension dim = new Dimension(							  Math.max(fm.charWidth('-'),fm.charWidth('R')) + 1,							  fm.getHeight());			    rectSelect.setPreferredSize(dim);			    rectSelect.setMaximumSize(dim);			    		    }	
/**			Invoke method on arbitrary object instance.			invocation may be static (through the object instance) or dynamic.			Object may be a bsh scripted object (bsh.This type).		 	@return the result of the method call		*/	    public static Object invokeObjectMethod(			Object object, String methodName, Object[] args, 			Interpreter interpreter, CallStack callstack, SimpleNode callerInfo ) 			throws ReflectError, EvalError, InvocationTargetException		{			// Bsh scripted object			if ( object instanceof This && !This.isExposedThisMethod(methodName) )				return ((This)object).invokeMethod( 					methodName, args, interpreter, callstack, callerInfo,					false/*delcaredOnly*/				);				// Plain Java object, find the java method			try {				BshClassManager bcm =					interpreter == null ? null : interpreter.getClassManager();				Class clas = object.getClass();					Method method = resolveExpectedJavaMethod(					bcm, clas, object, methodName, args, false );					return invokeMethod( method, object, args );			} catch ( UtilEvalError e ) {				throw e.toEvalError( callerInfo, callstack );			}	    }	
/** 			Invoke a method known to be static.			No object instance is needed and there is no possibility of the 			method being a bsh scripted method.		*/	    public static Object invokeStaticMethod(			BshClassManager bcm, Class clas, String methodName, Object [] args )	        throws ReflectError, UtilEvalError, InvocationTargetException	    {	        Interpreter.debug("invoke static Method");	        Method method = resolveExpectedJavaMethod( 				bcm, clas, null, methodName, args, true );			return invokeMethod( method, null, args );	    }	
/**			Invoke the Java method on the specified object, performing needed		 	type mappings on arguments and return values.			@param args may be null		*/		static Object invokeMethod(			Method method, Object object, Object[] args ) 			throws ReflectError, InvocationTargetException		{			if ( args == null )				args = new Object[0];				logInvokeMethod( "Invoking method (entry): ", method, args );				// Map types to assignable forms, need to keep this fast...			Object [] tmpArgs = new Object [ args.length ];			Class [] types = method.getParameterTypes();			try {				for (int i=0; i<args.length; i++)					tmpArgs[i] = Types.castObject(						args[i]/*rhs*/, types[i]/*lhsType*/, Types.ASSIGNMENT );			} catch ( UtilEvalError e ) {				throw new InterpreterError(					"illegal argument type in method invocation: "+e );			}				// unwrap any primitives			tmpArgs = Primitive.unwrap( tmpArgs );				logInvokeMethod( "Invoking method (after massaging values): ",				method, tmpArgs );				try {				Object returnValue = method.invoke( object, tmpArgs );				if ( returnValue == null )					returnValue = Primitive.NULL;				Class returnType = method.getReturnType();					return Primitive.wrap( returnValue, returnType );			} catch( IllegalAccessException e ) {				throw new ReflectError( "Cannot access method " 					+ StringUtil.methodString(						method.getName(), method.getParameterTypes() ) 					+ " in '" + method.getDeclaringClass() + "' :" + e );			}		}	
public static Object getIndex(Object array, int index)	        throws ReflectError, UtilTargetError	    {			if ( Interpreter.DEBUG ) 				Interpreter.debug("getIndex: "+array+", index="+index);	        try {	            Object val = Array.get(array, index);	            return Primitive.wrap( val, array.getClass().getComponentType() );	        }	        catch( ArrayIndexOutOfBoundsException  e1 ) {				throw new UtilTargetError( e1 );	        } catch(Exception e) {	            throw new ReflectError("Array access:" + e);	        }	    }	
public static void setIndex(Object array, int index, Object val)	        throws ReflectError, UtilTargetError	    {	        try {	            val = Primitive.unwrap(val);	            Array.set(array, index, val);	        }	        catch( ArrayStoreException e2 ) {				throw new UtilTargetError( e2 );	        } catch( IllegalArgumentException e1 ) {				throw new UtilTargetError( 					new ArrayStoreException( e1.toString() ) );	        } catch(Exception e) {	            throw new ReflectError("Array access:" + e);	        }	    }	
public static Object getStaticFieldValue(Class clas, String fieldName)	        throws UtilEvalError, ReflectError	    {	        return getFieldValue( clas, null, fieldName, true/*onlystatic*/);	    }	
/**		*/	    public static Object getObjectFieldValue( Object object, String fieldName )	        throws UtilEvalError, ReflectError	    {			if ( object instanceof This )				return ((This)object).namespace.getVariable( fieldName );			else {				try {					return getFieldValue(						object.getClass(), object, fieldName, false/*onlystatic*/);				} catch ( ReflectError e ) {					// no field, try property acces						if ( hasObjectPropertyGetter( object.getClass(), fieldName ) )						return getObjectProperty( object, fieldName );					else						throw e;				}			}	    }	
static LHS getLHSStaticField(Class clas, String fieldName)	        throws UtilEvalError, ReflectError	    {	        Field f = resolveExpectedJavaField( 				clas, fieldName, true/*onlystatic*/);	        return new LHS(f);	    }	
/**			Get an LHS reference to an object field.				This method also deals with the field style property access.			In the field does not exist we check for a property setter.		*/	    static LHS getLHSObjectField( Object object, String fieldName )	        throws UtilEvalError, ReflectError	    {			if ( object instanceof This )			{				// I guess this is when we pass it as an argument?				// Setting locally				boolean recurse = false; 				return new LHS( ((This)object).namespace, fieldName, recurse );			}				try {				Field f = resolveExpectedJavaField( 					object.getClass(), fieldName, false/*staticOnly*/ );				return new LHS(object, f);			} catch ( ReflectError e ) 			{				// not a field, try property access				if ( hasObjectPropertySetter( object.getClass(), fieldName ) )					return new LHS( object, fieldName );				else					throw e;			}	    }	
private static Object getFieldValue(			Class clas, Object object, String fieldName, boolean staticOnly )			throws UtilEvalError, ReflectError	    {	        try {	            Field f = resolveExpectedJavaField( clas, fieldName, staticOnly );		            Object value = f.get(object);	            Class returnType = f.getType();	            return Primitive.wrap( value, returnType );		        } catch( NullPointerException e ) { // shouldn't happen	            throw new ReflectError(					"???" + fieldName + " is not a static field.");	        } catch(IllegalAccessException e) {	            throw new ReflectError("Can't access field: " + fieldName);	        }	    }	
protected static Field resolveJavaField( 			Class clas, String fieldName, boolean staticOnly )	        throws UtilEvalError	    {			try {				return resolveExpectedJavaField( clas, fieldName, staticOnly );			} catch ( ReflectError e ) { 				return null;			}		}	
/**			@throws ReflectError if the field is not found.		*/		/*			Note: this should really just throw NoSuchFieldException... need			to change related signatures and code.		*/	    protected static Field resolveExpectedJavaField( 			Class clas, String fieldName, boolean staticOnly		)	        throws UtilEvalError, ReflectError	    {			Field field;	        try {				if ( Capabilities.haveAccessibility() )					field = findAccessibleField( clas, fieldName );				else					// Class getField() finds only public (and in interfaces, etc.)					field = clas.getField(fieldName);	        }	        catch( NoSuchFieldException e) {	            throw new ReflectError("No such field: " + fieldName );			} catch ( SecurityException e ) {				throw new UtilTargetError( 				"Security Exception while searching fields of: "+clas,				e );			}				if ( staticOnly && !Modifier.isStatic( field.getModifiers() ) )				throw new UtilEvalError(					"Can't reach instance field: "+fieldName					+" from static context: "+clas.getName() );				return field;	    }	
/**			Used when accessibility capability is available to locate an occurrance			of the field in the most derived class or superclass and set its 			accessibility flag.			Note that this method is not needed in the simple non accessible			case because we don't have to hunt for fields.			Note that classes may declare overlapping private fields, so the 			distinction about the most derived is important.  Java doesn't normally			allow this kind of access (super won't show private variables) so 			there is no real syntax for specifying which class scope to use...				@return the Field or throws NoSuchFieldException			@throws NoSuchFieldException if the field is not found		*/		/*			This method should be rewritten to use getFields() and avoid catching			exceptions during the search.		*/		private static Field findAccessibleField( Class clas, String fieldName ) 			throws UtilEvalError, NoSuchFieldException		{			Field field;				// Quick check catches public fields include those in interfaces			try {				field = clas.getField(fieldName);				ReflectManager.RMSetAccessible( field );				return field;			} catch ( NoSuchFieldException e ) { }				// Now, on with the hunt...			while ( clas != null )			{				try {					field = clas.getDeclaredField(fieldName);					ReflectManager.RMSetAccessible( field );					return field;						// Not found, fall through to next class					} catch(NoSuchFieldException e) { }					clas = clas.getSuperclass();			}			throw new NoSuchFieldException( fieldName );		}	
/**			This method wraps resolveJavaMethod() and expects a non-null method		 	result. If the method is not found it throws a descriptive ReflectError.		*/	    protected static Method resolveExpectedJavaMethod(			BshClassManager bcm, Class clas, Object object, 			String name, Object[] args, boolean staticOnly )	        throws ReflectError, UtilEvalError	    {			if ( object == Primitive.NULL )				throw new UtilTargetError( new NullPointerException(					"Attempt to invoke method " +name+" on null value" ) );				Class [] types = Types.getTypes(args);			Method method = resolveJavaMethod( bcm, clas, name, types, staticOnly );				if ( method == null )				throw new ReflectError(					( staticOnly ? "Static method " : "Method " )					+ StringUtil.methodString(name, types) +					" not found in class'" + clas.getName() + "'");				return method;		}	
/**	        The full blown resolver method.  All other method invocation methods			delegate to this.  The method may be static or dynamic unless			staticOnly is set (in which case object may be null).			If staticOnly is set then only static methods will be located.			<p/>				This method performs caching (caches discovered methods through the		 	class manager and utilizes cached methods.)		 	<p/>			 	This method determines whether to attempt to use non-public methods		 	based on Capabilities.haveAccessibility() and will set the accessibilty		 	flag on the method as necessary.		 	<p/>				If, when directed to find a static method, this method locates a more 			specific matching instance method it will throw a descriptive exception 			analogous to the error that the Java compiler would produce.			Note: as of 2.0.x this is a problem because there is no way to work			around this with a cast. 			<p/>				@param staticOnly				The method located must be static, the object param may be null.			@return the method or null if no matching method was found.		*/	    protected static Method resolveJavaMethod(			BshClassManager bcm, Class clas, String name, 			Class [] types, boolean staticOnly )			throws UtilEvalError	    {			if ( clas == null )				throw new InterpreterError("null class");				// Lookup previously cached method			Method method = null;			if ( bcm == null ) 				Interpreter.debug("resolveJavaMethod UNOPTIMIZED lookup");			else				method = bcm.getResolvedMethod( clas, name, types, staticOnly );				if ( method == null )			{				boolean publicOnly = !Capabilities.haveAccessibility();				// Searching for the method may, itself be a priviledged action				try {					method = findOverloadedMethod( clas, name, types, publicOnly );				} catch ( SecurityException e ) {					throw new UtilTargetError( 					"Security Exception while searching methods of: "+clas,					e );				}					checkFoundStaticMethod( method, staticOnly, clas );					// This is the first time we've seen this method, set accessibility				// Note: even if it's a public method, we may have found it in a				// non-public class				if ( method != null && !publicOnly ) {					try {						ReflectManager.RMSetAccessible( method );					} catch ( UtilEvalError e ) { /*ignore*/ }				}					// If succeeded cache the resolved method.				if ( method != null && bcm != null )					bcm.cacheResolvedMethod( clas, types, method );			}				return method;		}	
/**			Get the candidate methods by searching the class and interface graph		 	of baseClass and resolve the most specific.		 	@return the method or null for not found		 */		private static Method findOverloadedMethod(			Class baseClass, String methodName, Class[] types, boolean publicOnly )		{			if ( Interpreter.DEBUG )				Interpreter.debug( "Searching for method: "+					StringUtil.methodString(methodName, types)					+ " in '" + baseClass.getName() + "'" );				Method [] methods = getCandidateMethods(				baseClass, methodName, types.length, publicOnly );				if ( Interpreter.DEBUG )				Interpreter.debug("Looking for most specific method: "+methodName);			Method method = findMostSpecificMethod( types, methods );				return method;		}	
/**			Climb the class and interface inheritence graph of the type and collect			all methods matching the specified name and criterion.  If publicOnly			is true then only public methods in *public* classes or interfaces will			be returned.  In the normal (non-accessible) case this addresses the			problem that arises when a package private class or private inner class			implements a public interface or derives from a public type.		 	<p/>			 	This method primarily just delegates to gatherMethodsRecursive()		 	@see #gatherMethodsRecursive(				Class, String, int, boolean, java.util.Vector)		*/		static Method[] getCandidateMethods(			Class baseClass, String methodName, int numArgs,			boolean publicOnly )		{			Vector  candidates = gatherMethodsRecursive(				baseClass, methodName, numArgs, publicOnly, null/*candidates*/);				// return the methods in an array			Method [] ma = new Method[ candidates.size() ];			candidates.copyInto( ma );			return ma;		}	
/**			Accumulate all methods, optionally including non-public methods,		 	class and interface, in the inheritence tree of baseClass.				This method is analogous to Class getMethods() which returns all public			methods in the inheritence tree.				In the normal (non-accessible) case this also addresses the problem			that arises when a package private class or private inner class			implements a public interface or derives from a public type.  In other			words, sometimes we'll find public methods that we can't use directly			and we have to find the same public method in a parent class or			interface.				@return the candidate methods vector		*/		private static Vector gatherMethodsRecursive(			Class baseClass, String methodName, int numArgs,			boolean publicOnly, Vector candidates )		{			if ( candidates == null )				candidates = new Vector();				// Add methods of the current class to the vector.			// In public case be careful to only add methods from a public class			// and to use getMethods() instead of getDeclaredMethods()			// (This addresses secure environments)			if ( publicOnly ) {				if ( isPublic(baseClass) )					addCandidates( baseClass.getMethods(),						methodName, numArgs, publicOnly, candidates );			} else				addCandidates( baseClass.getDeclaredMethods(),					methodName, numArgs, publicOnly, candidates );				// Does the class or interface implement interfaces?			Class [] intfs = baseClass.getInterfaces();			for( int i=0; i< intfs.length; i++ )				gatherMethodsRecursive(  intfs[i],					methodName, numArgs, publicOnly, candidates );				// Do we have a superclass? (interfaces don't, etc.)			Class superclass = baseClass.getSuperclass();			if ( superclass != null )				gatherMethodsRecursive( superclass,					methodName, numArgs, publicOnly, candidates );				return candidates;		}	
private static Vector addCandidates(			Method [] methods, String methodName,			int numArgs, boolean publicOnly, Vector candidates  )		{			for ( int i = 0; i < methods.length; i++ )			{				Method m = methods[i];				if (  m.getName().equals( methodName )					&& ( m.getParameterTypes().length == numArgs )					&& ( !publicOnly || isPublic( m ) )				)					candidates.add( m );			}			return candidates;		}	
/**			Primary object constructor			This method is simpler than those that must resolve general method			invocation because constructors are not inherited.		 <p/>		 This method determines whether to attempt to use non-public constructors		 based on Capabilities.haveAccessibility() and will set the accessibilty		 flag on the method as necessary.		 <p/>		*/	    static Object constructObject( Class clas, Object[] args )	        throws ReflectError, InvocationTargetException	    {			if ( clas.isInterface() )				throw new ReflectError(					"Can't create instance of an interface: "+clas);		        Object obj = null;	        Class[] types = Types.getTypes(args);	        Constructor con = null;				// Find the constructor.			// (there are no inherited constructors to worry about)			Constructor[] constructors =				Capabilities.haveAccessibility() ?					clas.getDeclaredConstructors() : clas.getConstructors() ;				if ( Interpreter.DEBUG )				Interpreter.debug("Looking for most specific constructor: "+clas);			con = findMostSpecificConstructor(types, constructors);			if ( con == null )				throw cantFindConstructor( clas, types );				if ( !isPublic( con ) )				try {					ReflectManager.RMSetAccessible( con );				} catch ( UtilEvalError e ) { /*ignore*/ }		        args=Primitive.unwrap( args );	        try {	            obj = con.newInstance( args );	        } catch(InstantiationException e) {	            throw new ReflectError("The class "+clas+" is abstract ");	        } catch(IllegalAccessException e) {	            throw new ReflectError(					"We don't have permission to create an instance."					+"Use setAccessibility(true) to enable access." );	        } catch(IllegalArgumentException e) {	            throw new ReflectError("The number of arguments was wrong");	        }			if (obj == null)	            throw new ReflectError("Couldn't construct the object");		        return obj;	    }	
static Constructor findMostSpecificConstructor(			Class[] idealMatch, Constructor[] constructors)	    {			int match = findMostSpecificConstructorIndex(idealMatch, constructors );			return ( match == -1 ) ? null : constructors[ match ];	    }	
static int findMostSpecificConstructorIndex(			Class[] idealMatch, Constructor[] constructors)	    {			Class [][] candidates = new Class [ constructors.length ] [];			for(int i=0; i< candidates.length; i++ )				candidates[i] = constructors[i].getParameterTypes();				return findMostSpecificSignature( idealMatch, candidates );	    }	
/**			Find the best match for signature idealMatch.			It is assumed that the methods array holds only valid candidates			(e.g. method name and number of args already matched).			This method currently does not take into account Java 5 covariant			return types... which I think will require that we find the most			derived return type of otherwise identical best matches.			 	@see #findMostSpecificSignature(Class[], Class[][])			@param methods the set of candidate method which differ only in the		 		types of their arguments.		*/		static Method findMostSpecificMethod(			Class[] idealMatch, Method[] methods )		{			// copy signatures into array for findMostSpecificMethod()			Class [][] candidateSigs = new Class [ methods.length ][];			for(int i=0; i<methods.length; i++)				candidateSigs[i] = methods[i].getParameterTypes();				int match = findMostSpecificSignature( idealMatch, candidateSigs );			return match == -1 ? null : methods[match];		}	
/**	        Implement JLS 15.11.2			Return the index of the most specific arguments match or -1 if no			match is found.			This method is used by both methods and constructors (which		 	unfortunately don't share a common interface for signature info).			 @return the index of the most specific candidate			 */		/*		 Note: Two methods which are equally specific should not be allowed by		 the Java compiler.  In this case BeanShell currently chooses the first		 one it finds.  We could add a test for this case here (I believe) by		 adding another isSignatureAssignable() in the other direction between		 the target and "best" match.  If the assignment works both ways then		 neither is more specific and they are ambiguous.  I'll leave this test		 out for now because I'm not sure how much another test would impact		 performance.  Method selection is now cached at a high level, so a few		 friendly extraneous tests shouldn't be a problem.		*/		static int findMostSpecificSignature(			Class [] idealMatch, Class [][] candidates )		{			for ( int round = Types.FIRST_ROUND_ASSIGNABLE;				  round <= Types.LAST_ROUND_ASSIGNABLE; round++ )			{				Class [] bestMatch = null;				int bestMatchIndex = -1;					for (int i=0; i < candidates.length; i++)				{					Class[] targetMatch = candidates[i];						// If idealMatch fits targetMatch and this is the first match					// or targetMatch is more specific than the best match, make it					// the new best match.					if ( Types.isSignatureAssignable(							idealMatch, targetMatch, round )						&& ( (bestMatch == null) ||							Types.isSignatureAssignable( targetMatch, bestMatch,								Types.JAVA_BASE_ASSIGNABLE )							)					)					{						bestMatch = targetMatch;						bestMatchIndex = i;					}				}					if ( bestMatch != null )					return bestMatchIndex;			}				return -1;		}	
private static String accessorName( String getorset, String propName ) {	        return getorset				+ String.valueOf(Character.toUpperCase(propName.charAt(0)))				+ propName.substring(1);		}	
public static boolean hasObjectPropertyGetter(			Class clas, String propName )		{			String getterName = accessorName("get", propName );			try {				clas.getMethod( getterName, new Class [0] );				return true;			} catch ( NoSuchMethodException e ) { /* fall through */ }			getterName = accessorName("is", propName );			try {				Method m = clas.getMethod( getterName, new Class [0] );				return ( m.getReturnType() == Boolean.TYPE );			} catch ( NoSuchMethodException e ) {				return false;			}		}	
public static boolean hasObjectPropertySetter(			Class clas, String propName )		{			String setterName = accessorName("set", propName );			Method [] methods = clas.getMethods();				// we don't know the right hand side of the assignment yet.			// has at least one setter of the right name?			for(int i=0; i<methods.length; i++)				if ( methods[i].getName().equals( setterName ) )					return true;			return false;		}	
public static Object getObjectProperty(			Object obj, String propName )	        throws UtilEvalError, ReflectError	    {	        Object[] args = new Object[] { };		        Interpreter.debug("property access: ");			Method method = null;				Exception e1=null, e2=null;			try {				String accessorName = accessorName( "get", propName );				method = resolveExpectedJavaMethod(					null/*bcm*/, obj.getClass(), obj, accessorName, args, false );			} catch ( Exception e ) {				e1 = e;			}			if ( method == null )				try {					String accessorName = accessorName( "is", propName );					method = resolveExpectedJavaMethod(						null/*bcm*/, obj.getClass(), obj,						accessorName, args, false );					if ( method.getReturnType() != Boolean.TYPE )						method = null;				} catch ( Exception e ) {					e2 = e;				}			if ( method == null )				throw new ReflectError("Error in property getter: "					+e1 + (e2!=null?" : "+e2:"") );		        try {				return invokeMethod( method, obj, args );	        }	        catch(InvocationTargetException e)	        {	            throw new UtilEvalError("Property accessor threw exception: "					+e.getTargetException() );	        }	    }	
public static void setObjectProperty(			Object obj, String propName, Object value)	        throws ReflectError, UtilEvalError	    {	        String accessorName = accessorName( "set", propName );	        Object[] args = new Object[] { value };		        Interpreter.debug("property access: ");	        try {				Method method = resolveExpectedJavaMethod(					null/*bcm*/, obj.getClass(), obj, accessorName, args, false );				invokeMethod( method, obj, args );	        }	        catch ( InvocationTargetException e )	        {	            throw new UtilEvalError("Property accessor threw exception: "					+e.getTargetException() );	        }	    }	
/**			Return a more human readable version of the type name.			Specifically, array types are returned with postfix "[]" dimensions.			e.g. return "int []" for integer array instead of "class [I" as			would be returned by Class getName() in that case.		*/	    public static String normalizeClassName(Class type)	    {	        if ( !type.isArray() )	            return type.getName();		        StringBuilder className = new StringBuilder();	        try {	            className.append( getArrayBaseType(type).getName() +" ");	            for(int i = 0; i < getArrayDimensions(type); i++)	                className.append("[]");	        } catch( ReflectError e ) { /*shouldn't happen*/ }		        return className.toString();	    }	
/**			returns the dimensionality of the Class			returns 0 if the Class is not an array class		*/	    public static int getArrayDimensions(Class arrayClass)	    {	        if ( !arrayClass.isArray() )	            return 0;		        return arrayClass.getName().lastIndexOf('[') + 1;  // why so cute?	    }	
/**				Returns the base type of an array Class.	    	throws ReflectError if the Class is not an array class.		*/	    public static Class getArrayBaseType(Class arrayClass) throws ReflectError	    {	        if ( !arrayClass.isArray() )	            throw new ReflectError("The class is not an array.");				return arrayClass.getComponentType();		    }	
/**			A command may be implemented as a compiled Java class containing one or			more static invoke() methods of the correct signature.  The invoke()			methods must accept two additional leading arguments of the interpreter			and callstack, respectively. e.g. invoke(interpreter, callstack, ... )			This method adds the arguments and invokes the static method, returning			the result.		*/		public static Object invokeCompiledCommand(			Class commandClass, Object [] args, Interpreter interpreter,			CallStack callstack )			throws UtilEvalError		{	        // add interpereter and namespace to args list	        Object[] invokeArgs = new Object[args.length + 2];	        invokeArgs[0] = interpreter;	        invokeArgs[1] = callstack;	        System.arraycopy( args, 0, invokeArgs, 2, args.length );			BshClassManager bcm = interpreter.getClassManager();			try {	        	return Reflect.invokeStaticMethod(					bcm, commandClass, "invoke", invokeArgs );			} catch ( InvocationTargetException e ) {				throw new UtilEvalError(					"Error in compiled command: "+e.getTargetException() );			} catch ( ReflectError e ) {				throw new UtilEvalError("Error invoking compiled command: "+e );			}		}	
private static void logInvokeMethod( 			String msg, Method method, Object[] args )		{			if ( Interpreter.DEBUG )			{				Interpreter.debug( msg +method+" with args:" );				for(int i=0; i<args.length; i++)					Interpreter.debug(						"args["+i+"] = "+args[i]						+" type = "+args[i].getClass() );			}		}	
private static void checkFoundStaticMethod(			Method method, boolean staticOnly, Class clas )			throws UtilEvalError		{			// We're looking for a static method but found an instance method			if ( method != null && staticOnly && !isStatic( method ) )				throw new UtilEvalError(					"Cannot reach instance method: "					+ StringUtil.methodString(						method.getName(), method.getParameterTypes() )					+ " from static context: "+ clas.getName() );		}	
private static ReflectError cantFindConstructor(			Class clas, Class [] types )		{			if ( types.length == 0 )				return new ReflectError(					"Can't find default constructor for: "+clas);			else				return new ReflectError(					"Can't find constructor: "						+ StringUtil.methodString( clas.getName(), types )						+" in class: "+ clas.getName() );		}	
private static boolean isPublic( Class c ) {			return Modifier.isPublic( c.getModifiers() );		}	
private static boolean isPublic( Method m ) {			return Modifier.isPublic( m.getModifiers() );		}	
private static boolean isPublic( Constructor c ) {			return Modifier.isPublic( c.getModifiers() );		}	
private static boolean isStatic( Method m ) {			return Modifier.isStatic( m.getModifiers() );		}	
public ReflectError() { super(); }	
public ReflectError(String s) { super(s); }	
/**			Return the singleton bsh ReflectManager.			@throws Unavailable		*/		public static ReflectManager getReflectManager() 			throws Unavailable		{			if ( rfm == null ) 			{				Class clas;				try {					clas = Class.forName( "org.gjt.sp.jedit.bsh.reflect.ReflectManagerImpl" );					rfm = (ReflectManager)clas.newInstance();				} catch ( Exception e ) {					throw new Unavailable("Reflect Manager unavailable: "+e);				}			}					return rfm;		}	
/**			Reflect Manager Set Accessible.			Convenience method to invoke the reflect manager.			@throws Unavailable		*/		public static boolean RMSetAccessible( Object obj ) 			throws Unavailable		{			return getReflectManager().setAccessible( obj );		}	
/**			Set a java.lang.reflect Field, Method, Constructor, or Array of			accessible objects to accessible mode.			If the object is not an AccessibleObject then do nothing.			@return true if the object was accessible or false if it was not.		*/	// Arrays incomplete... need to use the array setter		public boolean setAccessible( Object obj ) 		{			if ( obj instanceof AccessibleObject ) {				((AccessibleObject)obj).setAccessible(true);				return true;			} else				return false;		}	
public RegexEncodingDetector(String pattern, String replacement)		{			this.pattern = Pattern.compile(pattern);			this.replacement = replacement;		}	
public String detectEncoding(InputStream sample) throws IOException		{			InputStreamReader reader = new InputStreamReader(sample);			final int bufferSize = 1024;			char[] buffer = new char[bufferSize];			int readSize = reader.read(buffer, 0, bufferSize);			if (readSize > 0)			{				Matcher matcher = pattern.matcher(					CharBuffer.wrap(buffer, 0, readSize));				while (matcher.find())				{					String extracted = extractReplacement(						matcher, replacement);					if (EncodingServer.hasEncoding(extracted))					{						return extracted;					}				}			}			return null;		}	
/**		 * Returns a replaced string for a Matcher which has been matched		 * by find() method.		 */		private static String extractReplacement(Matcher found, String replacement)		{			/*			 * It doesn't make sense to read before start, but			 * appendReplacement() requires to to it.			 */			int found_start = found.start();			int found_end = found.end();			int source_length = found_end - found_start;			StringBuffer replaced = new StringBuffer(found_start + (source_length * 2));			found.appendReplacement(replaced, replacement);			return replaced.substring(found_start);		}	
/**		 * @param collapse If true, then if the next indent rule is		 * an opening bracket, this rule will not increase indent.		 */		public RegexpIndentRule(String regexp, IndentAction prevPrev,			IndentAction prev, IndentAction thisLine, boolean collapse)		throws PatternSyntaxException		{			prevPrevAction = prevPrev;			prevAction = prev;			thisAction = thisLine;			this.regexp = Pattern.compile(regexp, Pattern.CASE_INSENSITIVE );			this.collapse = collapse;		}	
public void apply(JEditBuffer buffer, int thisLineIndex,			int prevLineIndex, int prevPrevLineIndex,			List<IndentAction> indentActions)		{			if(thisAction != null				&& lineMatches(buffer, thisLineIndex))			{				indentActions.add(thisAction);			}			if(prevAction != null				&& prevLineIndex != -1				&& lineMatches(buffer, prevLineIndex))			{				indentActions.add(prevAction);				if (collapse)					indentActions.add(IndentAction.PrevCollapse);			}			if(prevPrevAction != null				&& prevPrevLineIndex != -1				&& lineMatches(buffer, prevPrevLineIndex))			{				indentActions.add(prevPrevAction);				if (collapse)					indentActions.add(IndentAction.PrevPrevCollapse);			}		}	
/**		 * @deprecated		 *   Do not use this. This is here only for compatibility.		 */		@Deprecated		public boolean isMatch(String line)		{			Matcher m = regexp.matcher(line);	//		return regexp.isMatch(line);			return m.matches();		}	
public String toString()		{			return getClass().getName() + '[' + regexp + ']';		}	
public TokenFilter(int originalLength)			{				result = new StringBuilder(originalLength);			}	
public void handleToken(Segment seg				, byte id, int offset, int length				, TokenMarker.LineContext context)			{				// Avoid replacing an empty token into a non empty				// string.				if (length <= 0)				{					return;				}								switch (id)				{				case Token.COMMENT1:				case Token.COMMENT2:				case Token.COMMENT3:				case Token.COMMENT4:					// Replace any comments to a white space					// so that they are simply ignored.					result.append(' ');					break;				case Token.LITERAL1:				case Token.LITERAL2:				case Token.LITERAL3:				case Token.LITERAL4:					// Replace any literals to a '0' which means					// a simple integer literal in most programming					// languages.					result.append('0');					break;				default:					result.append(seg.array						, seg.offset + offset						, length);					break;				}			}	
public void setLineContext(TokenMarker.LineContext lineContext)			{			}	
private boolean lineMatches(JEditBuffer buffer, int lineIndex)		{			TokenFilter filter				= new TokenFilter(buffer.getLineLength(lineIndex));			buffer.markTokens(lineIndex, filter);			return regexp.matcher(filter.result).matches();		}	
/**		 * Creates a new registers changed message.		 * @param source The message source		 */		 public RegisterChanged(EBComponent source, char name)		 {			 super(source);			 registerName = name;		 }	
public char getRegisterName()		 {			 return registerName;		 }	
public String getRegisterValue()		 {			 return Registers.getRegister(registerName).toString();		 }	
public String paramString()		 {			 return "register=" + registerName + "," + super.paramString();		 }	
/**		 * Copies the text selected in the text area into the specified register.		 * This will replace the existing contents of the designated register.		 *		 * @param textArea The text area		 * @param register The register		 * @since jEdit 2.7pre2		 */		public static void copy(TextArea textArea, char register)		{			String selection = textArea.getSelectedText();			if(selection == null)				return;				setRegister(register,selection);			HistoryModel.getModel("clipboard").addItem(selection);			}	
/**		 * Copies the text selected in the text area into the specified		 * register, and then removes it from the buffer.		 *		 * @param textArea The text area		 * @param register The register		 * @since jEdit 2.7pre2		 */		public static void cut(TextArea textArea, char register)		{			if(textArea.isEditable())			{				String selection = textArea.getSelectedText();				if(selection == null)					return;					setRegister(register,selection);				HistoryModel.getModel("clipboard").addItem(selection);					textArea.setSelectedText("");			}			else				textArea.getToolkit().beep();		}	
/**		 * Appends the text selected in the text area to the specified register,		 * with a newline between the old and new text.		 * @param textArea The text area		 * @param register The register		 */		public static void append(TextArea textArea, char register)		{			append(textArea,register,"\n",false);		}	
/**		 * Appends the text selected in the text area to the specified register.		 * @param textArea The text area		 * @param register The register		 * @param separator The separator to insert between the old and new text		 */		public static void append(TextArea textArea, char register,			String separator)		{			append(textArea,register,separator,false);		}	
/**		 * Appends the text selected in the  text area to the specified register.		 * @param textArea The text area		 * @param register The register		 * @param separator The text to insert between the old and new text		 * @param cut Should the current selection be removed?		 * @since jEdit 3.2pre1		 */		public static void append(TextArea textArea, char register,			String separator, boolean cut)		{			if(cut && !textArea.isEditable())			{				textArea.getToolkit().beep();				return;			}				String selection = textArea.getSelectedText();			if(selection == null)				return;				Register reg = getRegister(register);				if(reg != null)			{				String registerContents = reg.toString();				if(registerContents != null)				{					if(registerContents.endsWith(separator))						selection = registerContents + selection;					else						selection = registerContents + separator + selection;				}			}				setRegister(register,selection);			HistoryModel.getModel("clipboard").addItem(selection);				if(cut)				textArea.setSelectedText("");		}	
/**		 * Insets the contents of the specified register into the text area.		 * @param textArea The text area		 * @param register The register		 * @since jEdit 2.7pre2		 */		public static void paste(TextArea textArea, char register)		{			paste(textArea,register,false);		}	
/**		 * Inserts the contents of the specified register into the text area.		 * @param textArea The text area		 * @param register The register		 * @param vertical Vertical (columnar) paste		 * @since jEdit 4.1pre1		 */		public static void paste(TextArea textArea, char register,			boolean vertical)		{			if(!textArea.isEditable())			{				textArea.getToolkit().beep();				return;			}				Register reg = getRegister(register);				if(reg == null)			{				textArea.getToolkit().beep();				return;			}				String selection = reg.toString();			if(selection == null)			{				textArea.getToolkit().beep();				return;			}			JEditBuffer buffer = textArea.getBuffer();			try			{				buffer.beginCompoundEdit();					/* vertical paste */				if(vertical && textArea.getSelectionCount() == 0)				{					int caret = textArea.getCaretPosition();					int caretLine = textArea.getCaretLine();					Selection.Rect rect = new Selection.Rect(						caretLine,caret,caretLine,caret);					textArea.setSelectedText(rect,selection);					caretLine = textArea.getCaretLine();						if(caretLine != textArea.getLineCount() - 1)					{							int startColumn = rect.getStartColumn(							buffer);						int offset = buffer							.getOffsetOfVirtualColumn(							caretLine + 1,startColumn,null);						if(offset == -1)						{							buffer.insertAtColumn(caretLine + 1,startColumn,"");							textArea.setCaretPosition(								buffer.getLineEndOffset(								caretLine + 1) - 1);						}						else						{							textArea.setCaretPosition(								buffer.getLineStartOffset(								caretLine + 1) + offset);						}					}				}				else /* Regular paste */				{					textArea.replaceSelection(selection);				}			}			finally {				buffer.endCompoundEdit();			}			HistoryModel.getModel("clipboard").addItem(selection);		}	
/**		 * Returns the specified register.		 * @param name The name		 */		public static Register getRegister(char name)		{			if(name != '$' && name != '%')			{				if(!loaded)					loadRegisters();			}				if(registers == null || name >= registers.length)				return null;			else				return registers[name];		}	
/**		 * Sets the specified register.		 * @param name The name		 * @param newRegister The new value		 */		public static void setRegister(char name, Register newRegister)		{			touchRegister(name);				if(name >= registers.length)			{				Register[] newRegisters = new Register[					Math.min(1<<16, name<<1)];				System.arraycopy(registers,0,newRegisters,0,					registers.length);				registers = newRegisters;			}				registers[name] = newRegister;			if (listener != null)				listener.registerChanged(name);		}	
/**		 * Sets the specified register.		 * @param name The name		 * @param value The new value		 */		public static void setRegister(char name, String value)		{			touchRegister(name);			Register register = getRegister(name);			if(register != null)			{				register.setValue(value);				if (listener != null)					listener.registerChanged(name);			}			else				setRegister(name,new StringRegister(value));		}	
/**		 * Sets the value of the specified register to <code>null</code>.		 * @param name The register name		 */		public static void clearRegister(char name)		{			if(name >= registers.length)				return;				Register register = registers[name];			if(name == '$' || name == '%')				register.setValue("");			else			{				registers[name] = null;				modified = true;				if (listener != null)					listener.registerChanged(name);			}		}	
/**		 * Returns an array of all available registers. Some of the elements		 * of this array might be <code>null</code>.		 */		public static Register[] getRegisters()		{			if(!loaded)				loadRegisters();			return registers;		}	
/**		 * Returns a string of all defined registers, used by the status bar		 * (eg, "a b $ % ^").		 * @since jEdit 4.2pre2		 */		public static String getRegisterNameString()		{			if(!loaded)				loadRegisters();				StringBuilder buf = new StringBuilder(registers.length << 1);			for(int i = 0; i < registers.length; i++)			{				if(registers[i] != null)				{					if(buf.length() != 0)						buf.append(' ');					buf.append((char)i);				}			}				if(buf.length() == 0)				return null;			else				return buf.toString();		}	
public static void saveRegisters()		{			if(!loaded || !modified)				return;				if (saver != null)			{				saver.saveRegisters();				modified = false;			}		}	
public static void setListener(RegistersListener listener)		{			Registers.listener = listener;		}	
public static void setSaver(RegisterSaver saver)		{			Registers.saver = saver;		}	
public static boolean isLoading()		{			return loading;		}	
public static void setLoading(boolean loading)		{			Registers.loading = loading;		}	
private Registers() {}	
private static void touchRegister(char name)		{			if(name == '%' || name == '$')				return;				if(!loaded)				loadRegisters();				if(!loading)				modified = true;		}	
private static void loadRegisters()		{			if (saver != null)			{				loaded = true;				saver.loadRegisters();			}		}	
public ClipboardRegister(Clipboard clipboard)			{				this.clipboard = clipboard;			}	
/**			 * Sets the clipboard contents.			 */			public void setValue(String value)			{				StringSelection selection = new StringSelection(value);				clipboard.setContents(selection,null);			}	
/**			 * Returns the clipboard contents.			 */			@Override			public String toString()			{				try				{						if (false)					{						/*							This is to debug clipboard problems.								Apparently, jEdit is unable to copy text from clipbard into the current							text buffer if the clipboard was filles using the command								echo test | xselection CLIPBOARD -							under Linux. However, it seems that Java does not offer any							data flavor for this clipboard content (under J2RE 1.5.0_06-b05)							Thus, copying from clipboard seems to be plainly impossible.						*/						Log.log(Log.DEBUG,this,"clipboard.getContents(this)="+clipboard.getContents(this)+'.');						debugListDataFlavors(clipboard.getContents(this));					}						String selection = (String)clipboard						.getContents(this).getTransferData(						DataFlavor.stringFlavor);						boolean trailingEOL = selection.endsWith("\n")						|| selection.endsWith(System.getProperty(						"line.separator"));						// Some Java versions return the clipboard					// contents using the native line separator,					// so have to convert it here					BufferedReader in = new BufferedReader(						new StringReader(selection));					StringBuilder buf = new StringBuilder();					String line;					while((line = in.readLine()) != null)					{						// broken Eclipse workaround!						// 24 Febuary 2004						if(line.endsWith("\0"))						{							line = line.substring(0,								line.length() - 1);						}						buf.append(line);						buf.append('\n');					}					// remove trailing \n					if(!trailingEOL && buf.length() != 0)						buf.setLength(buf.length() - 1);					return buf.toString();				}				catch(Exception e)				{					Log.log(Log.NOTICE,this,e);					return null;				}			}	
protected static void debugListDataFlavors(Transferable transferable)		{			DataFlavor[] dataFlavors = transferable.getTransferDataFlavors();				for (int i = 0;i<dataFlavors.length;i++)			{				DataFlavor dataFlavor = dataFlavors[i];				Log.log(Log.DEBUG,Registers.class,					"debugListDataFlavors(): dataFlavor="+					dataFlavor+'.');			}				if (dataFlavors.length == 0)			{				Log.log(Log.DEBUG,Registers.class,					"debugListDataFlavors(): no dataFlavor supported.");			}		}	
/**			 * Creates a new string register.			 * @param value The contents			 */			public StringRegister(String value)			{				this.value = value;			}	
/**			 * Sets the register contents.			 */			public void setValue(String value)			{				this.value = value;			}	
/**			 * Converts to a string.			 */			@Override			public String toString()			{				return value;			}	
/**			 * Called when this register is no longer available. This			 * implementation does nothing.			 */			public void dispose() {}	
public RegisterViewer(View view, String position)		{			super(new BorderLayout());			this.view = view;			Box toolBar = new Box(BoxLayout.X_AXIS);			JLabel label = new JLabel(				jEdit.getProperty("view-registers.title"));			label.setBorder(new EmptyBorder(0,0,3,0));			toolBar.add(label);						toolBar.add(Box.createGlue());				RolloverButton pasteRegister = new RolloverButton(				GUIUtilities.loadIcon("Paste.png"));			pasteRegister.setToolTipText(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("paste-string-register.label")));			pasteRegister.addActionListener(this);			pasteRegister.setActionCommand("paste-string-register");			toolBar.add(pasteRegister);				RolloverButton clearRegister = new RolloverButton(				GUIUtilities.loadIcon("Clear.png"));			clearRegister.setToolTipText(GUIUtilities.prettifyMenuLabel(				jEdit.getProperty("clear-string-register.label")));			clearRegister.addActionListener(this);			clearRegister.setActionCommand("clear-string-register");			toolBar.add(clearRegister);							add(BorderLayout.NORTH,toolBar);				DefaultListModel registerModel = new DefaultListModel();			registerList = new JList(registerModel);			registerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			registerList.setCellRenderer(new Renderer());			registerList.addListSelectionListener(new ListHandler());			registerList.addMouseListener(new MouseHandler());				contentTextArea = new JTextArea(10,20);			contentTextArea.setEditable(true);			documentHandler = new DocumentHandler();			//contentTextArea.getDocument().addDocumentListener(documentHandler);			contentTextArea.addFocusListener(new FocusHandler());				int orientation = JSplitPane.HORIZONTAL_SPLIT;			if (position.equals(DockableWindowManager.LEFT) ||				position.equals(DockableWindowManager.RIGHT))				orientation = JSplitPane.VERTICAL_SPLIT;				add(BorderLayout.CENTER,splitPane = new JSplitPane(orientation,				jEdit.getBooleanProperty("appearance.continuousLayout"),				new JScrollPane(registerList),				new JScrollPane(contentTextArea)));				refreshList();		}	
public void actionPerformed(ActionEvent evt)		{			String cmd = evt.getActionCommand();			if (cmd.equals("paste-string-register"))				insertRegister();			else if (cmd.equals("clear-string-register"))				clearSelectedIndex();		}	
public void handleMessage(EBMessage msg)		{			if (msg instanceof RegisterChanged)			{				if (((RegisterChanged)msg).getRegisterName() != '%')					refreshList();			}			else if (msg instanceof PropertiesChanged)			{				GUIUtilities.initContinuousLayout(splitPane);			}			}	
@Override		public void addNotify()		{			super.addNotify();			EditBus.addToBus(this);		}	
@Override		public void removeNotify()		{			super.removeNotify();			EditBus.removeFromBus(this);		}	
public void move(String newPosition)		{			int orientation = JSplitPane.HORIZONTAL_SPLIT;			if (newPosition.equals(DockableWindowManager.LEFT) ||				newPosition.equals(DockableWindowManager.RIGHT))				orientation = JSplitPane.VERTICAL_SPLIT;			splitPane.setOrientation(orientation);			revalidate();		}	
private void clearSelectedIndex()		{			Object o = registerList.getSelectedValue();			if (o != null && o instanceof Character)			{				Registers.clearRegister(((Character)o).charValue());				refreshList();			}		}	
private void refreshList()		{			DefaultListModel registerModel = (DefaultListModel)registerList.getModel();			Object o = registerList.getSelectedValue();			int selected = -1;			if (o != null && o instanceof Character)				selected = ((Character)o).charValue();				registerModel.removeAllElements();			Registers.Register[] registers = Registers.getRegisters();				int index = 0;			for(int i = 0; i < registers.length; i++)			{				Registers.Register reg = registers[i];				if(reg == null)					continue;				if (i == '%')					continue;					String value = reg.toString();				if(value == null) // || value.length() == 0)					continue;				if (i == selected)					index = registerModel.size();				registerModel.addElement(Character.valueOf((char)i));			}				if(registerModel.getSize() == 0)			{				registerModel.addElement(jEdit.getProperty("view-registers.none"));				registerList.setEnabled(false);			}			else				registerList.setEnabled(true);			registerList.setSelectedIndex(index);		}	
private void insertRegister()		{			Object o = registerList.getSelectedValue();			if (o == null || !(o instanceof Character))				return;			Registers.Register reg = Registers.getRegister(((Character)o).charValue());			view.getTextArea().setSelectedText(reg.toString());			view.getTextArea().requestFocus();		}	
@Override			public Component getListCellRendererComponent(				JList list, Object value, int index,				boolean isSelected, boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,				index,isSelected,cellHasFocus);					if(value instanceof Character)				{					char name = ((Character)value).charValue();						String label;						if(name == '\n')						label = "\n";					else if(name == '\t')						label = "\t";					else if(name == '$')						label = jEdit.getProperty("view-registers.clipboard");					else if(name == '%')						label = jEdit.getProperty("view-registers.selection");					else						label = String.valueOf(name);					Register register = Registers.getRegister(name);					String registerValue;					if (register == null)					{						// The register is not defined anymore, it has been removed before						// the painting event						registerValue = jEdit.getProperty("view-registers.undefined");					}					else					{						registerValue = register.toString();						if (registerValue.length() > 100)							registerValue = registerValue.substring(0,100)+"...";						registerValue = registerValue.replaceAll("\n"," ");						registerValue = registerValue.replaceAll("\t"," ");					}					setText(label + " : " + registerValue);				}					return this;				}	
public void valueChanged(ListSelectionEvent evt)			{							Object value = registerList.getSelectedValue();				if(!(value instanceof Character))				{					if (!editing)					{						contentTextArea.setText("");						contentTextArea.setEditable(false);					}					return;				}					char name = ((Character)value).charValue();					Registers.Register reg = Registers.getRegister(name);				if(reg == null)				{					if (!editing)					{						contentTextArea.setText("");						contentTextArea.setEditable(false);					}						return;				}												if (!editing)				{					contentTextArea.setText(reg.toString());					contentTextArea.setEditable(true);					contentTextArea.setCaretPosition(0);				}			}	
@Override			public void mouseClicked(MouseEvent evt)			{				int i = registerList.locationToIndex(evt.getPoint());				if (i != -1)					registerList.setSelectedIndex(i);				if (GUIUtilities.isPopupTrigger(evt))				{					if (popup == null)					{						popup = new JPopupMenu();						JMenuItem item = GUIUtilities.loadMenuItem("paste");						popup.add(item);						item = new JMenuItem(jEdit.getProperty("clear-string-register.label"));						item.addActionListener(new ActionListener()						{							public void actionPerformed(ActionEvent e)							{								clearSelectedIndex();							}						});						popup.add(item);					}					GUIUtilities.showPopupMenu(popup, registerList, evt.getX(), evt.getY(), false);				}				else if (evt.getClickCount() % 2 == 0)					insertRegister();			}	
public void changedUpdate(DocumentEvent e)			{				updateRegisterSafely();			}	
public void insertUpdate(DocumentEvent e)			{				updateRegisterSafely();			}	
public void removeUpdate(DocumentEvent e)			{				updateRegisterSafely();			}	
private void updateRegisterSafely()			{				try				{					editing = true;					updateRegister();				}				finally				{					editing = false;				}			}	
private void updateRegister()			{				Object value = registerList.getSelectedValue();				if(!(value instanceof Character))					return;				char name = ((Character)value).charValue();				Registers.setRegister(name,contentTextArea.getText());			}	
public void focusGained(FocusEvent e)			{				contentTextArea.getDocument().addDocumentListener(documentHandler);			}	
public void focusLost(FocusEvent e)			{				contentTextArea.getDocument().removeDocumentListener(documentHandler);			}	
public boolean updateEveryTime()		{			return false;		}	
public void update(JMenu menu)		{			view = GUIUtilities.getView(menu);				// auto detect			JMenuItem auto = new JMenuItem(				jEdit.getProperty("vfs.browser.commands.encoding.auto-detect"));			auto.setActionCommand("auto-detect");			auto.addActionListener(this);			menu.add(auto);			menu.addSeparator();			// all the enabled encodings + the system encoding			String[] encodings = MiscUtilities.getEncodings(true);			String systemEncoding = System.getProperty("file.encoding");				if (Arrays.binarySearch(encodings, systemEncoding) < 0)			{				String[] tmp_a = new String[encodings.length + 1];				System.arraycopy(encodings, 0, tmp_a, 0, encodings.length);				tmp_a[encodings.length] = systemEncoding;				encodings = tmp_a;			}				Arrays.sort(encodings);				int maxItems = jEdit.getIntegerProperty("menu.spillover",20);			for (int i = 0; i < encodings.length; i++)			{				JMenuItem mi = new JMenuItem(encodings[i]);				mi.setActionCommand("encoding@" + encodings[i]);				mi.addActionListener(this);				if ((menu.getMenuComponentCount() >= maxItems) && (i < encodings.length))				{					JMenu newMenu = new JMenu(jEdit.getProperty("common.more"));					menu.add(newMenu);					menu = newMenu;				}				menu.add(mi);			}				menu.addSeparator();				// option to prompt for the encoding			JMenuItem other = new JMenuItem(				jEdit.getProperty("vfs.browser.other-encoding.label"));			other.setActionCommand("other-encoding");			other.addActionListener(this);			menu.add(other);		}	
public void actionPerformed(ActionEvent ae)		{			JMenuItem mi = (JMenuItem) ae.getSource();			String action = mi.getActionCommand();			String encoding = null;			Hashtable props = null;				if (action.startsWith("encoding@"))			{				encoding = action.substring(9);			}			else if (action.equals("other-encoding"))			{				encoding = JOptionPane.showInputDialog(view,					jEdit.getProperty("encoding-prompt.message"),					jEdit.getProperty("encoding-prompt.title"),					JOptionPane.QUESTION_MESSAGE);				if (encoding == null)					return;					if (!EncodingServer.hasEncoding(encoding))				{					String msg = jEdit.getProperty("reload-encoding.error",							new Object[] { encoding });					JOptionPane.showMessageDialog(view,						msg,						jEdit.getProperty("common.error"),						JOptionPane.ERROR_MESSAGE);					return;				}			}				if (encoding != null)			{				props = new Hashtable();				props.put(Buffer.ENCODING, encoding);				// Disable auto-detect because user explicitly				// specify an encoding.				props.put(Buffer.ENCODING_AUTODETECT, false);			}				String path = view.getBuffer().getPath();			jEdit.closeBuffer(view, view.getBuffer());			jEdit.openFile(view,null,path,false,props);		}	
public static void main( String args[] )			throws Exception		{			if ( args.length < 2 ) {				System.out.println(					"usage: Remote URL(http|bsh) file [ file ] ... ");				System.exit(1);			}			String url = args[0];			String text = getFile(args[1]);			int ret = eval( url, text );			System.exit( ret );			}	
/**			Evaluate text in the interpreter at url, returning a possible integer		 	return value.		*/		public static int eval( String url, String text )			throws IOException		{			String returnValue = null;			if ( url.startsWith( "http:" ) ) {				returnValue = doHttp( url, text );			} else if ( url.startsWith( "bsh:" ) ) {				returnValue = doBsh( url, text );			} else				throw new IOException( "Unrecognized URL type."					+"Scheme must be http:// or bsh://");				try {				return Integer.parseInt( returnValue );			} catch ( Exception e ) {				// this convention may change...				return 0;			}		}	
static String doBsh( String url, String text ) 		{ 		    OutputStream out;		    InputStream in;		    String host = "";		    String port = "";		    String returnValue = "-1";			String orgURL = url;		    			// Need some format checking here		    try {				url = url.substring(6); // remove the bsh://				// get the index of the : between the host and the port is located				int index = url.indexOf(":");				host = url.substring(0,index);				port = url.substring(index+1,url.length());			} catch ( Exception ex ) {				System.err.println("Bad URL: "+orgURL+": "+ex  );				return returnValue;		    }			    try {				System.out.println("Connecting to host : " 					+ host + " at port : " + port);				Socket s = new Socket(host, Integer.parseInt(port) + 1);								out = s.getOutputStream();				in = s.getInputStream();								sendLine( text, out );					BufferedReader bin = new BufferedReader( 					new InputStreamReader(in));				  String line;				  while ( (line=bin.readLine()) != null )					System.out.println( line );					// Need to scrape a value from the last line?				returnValue="1";				return returnValue;		    } catch(Exception ex) {				System.err.println("Error communicating with server: "+ex);				return returnValue;		    }		}	
private static void sendLine( String line, OutputStream outPipe )			throws IOException		{			outPipe.write( line.getBytes() );			outPipe.flush();	    }	
static String doHttp( String postURL, String text )		{			String returnValue = null;			StringBuilder sb = new StringBuilder();			sb.append( "bsh.client=Remote" );			sb.append( "&bsh.script=" );			sb.append( URLEncoder.encode( text ) );			/*			// This requires Java 1.3			try {				sb.append( URLEncoder.encode( text, "8859_1" ) );			} catch ( UnsupportedEncodingException e ) {				e.printStackTrace();			}			*/			String formData = sb.toString(  );				try {			  URL url = new URL( postURL );			  HttpURLConnection urlcon =				  (HttpURLConnection) url.openConnection(  );			  urlcon.setRequestMethod("POST");			  urlcon.setRequestProperty("Content-type",				  "application/x-www-form-urlencoded");			  urlcon.setDoOutput(true);			  urlcon.setDoInput(true);			  PrintWriter pout = new PrintWriter( new OutputStreamWriter(				  urlcon.getOutputStream(), "8859_1"), true );			  pout.print( formData );			  pout.flush();				  // read results...			  int rc = urlcon.getResponseCode();			  if ( rc != HttpURLConnection.HTTP_OK )				System.out.println("Error, HTTP response: "+rc );				  returnValue = urlcon.getHeaderField("Bsh-Return");				  BufferedReader bin = new BufferedReader(				new InputStreamReader( urlcon.getInputStream() ) );			  String line;			  while ( (line=bin.readLine()) != null )				System.out.println( line );				  System.out.println( "Return Value: "+returnValue );				} catch (MalformedURLException e) {			  System.out.println(e);     // bad postURL			} catch (IOException e2) {			  System.out.println(e2);    // I/O error			}				return returnValue;		}	
static String getFile( String name )			throws FileNotFoundException, IOException		{			StringBuilder sb = new StringBuilder();			BufferedReader bin = new BufferedReader( new FileReader( name ) );			String line;			while ( (line=bin.readLine()) != null )				sb.append( line ).append( "\n" );			return sb.toString();		}	
public ReturnControl( int kind, Object value, SimpleNode returnPoint ) {			this.kind = kind;			this.value = value;			this.returnPoint = returnPoint;		}	
public ReverseCharSequence(CharSequence base)		{			this.base = base;		}	
public CharSequence baseSequence()		{			return base;		}	
public char charAt(int index)		{			return base.charAt(base.length() - index - 1);		}	
public int length()		{			return base.length();		}	
public CharSequence subSequence(int start, int end)		{			int baseLength = base.length();			return new ReverseCharSequence(				base.subSequence(baseLength - end, baseLength - start));		}	
public String toString()		{			int baseLength = base.length();			StringBuilder builder = new StringBuilder(baseLength);			for (int i = baseLength - 1; i >= 0; --i)			{				builder.append(base.charAt(i));			}			return builder.toString();		}	
/**		 * Setup the border (invisible initially)		 */		public RolloverButton()		{			//setContentAreaFilled(true);			addMouseListener(new MouseOverHandler());		}	
/**		 * Setup the border (invisible initially)		 *		 * @param icon the icon of this button		 */		public RolloverButton(Icon icon)		{			this();				setIcon(icon);		}	
public void updateUI()		{			super.updateUI();			//setBorder(originalBorder);			setBorderPainted(false);			setRequestFocusEnabled(false);			setMargin(new Insets(1,1,1,1));		}	
public void setEnabled(boolean b)		{			super.setEnabled(b);			setBorderPainted(false);			repaint();		}	
public void setBorderPainted(boolean b)		{			try			{				revalidateBlocked = true;				super.setBorderPainted(b);				setContentAreaFilled(b);			}			finally			{				revalidateBlocked = false;			}		}	
/**		 * We block calls to revalidate() from a setBorderPainted(), for		 * performance reasons.		 */		public void revalidate()		{			if(!revalidateBlocked)				super.revalidate();		}	
public void paint(Graphics g)		{			if(isEnabled())				super.paint(g);			else			{				Graphics2D g2 = (Graphics2D)g;				g2.setComposite(c);				super.paint(g2);			}		}	
public void mouseEntered(MouseEvent e)			{				setContentAreaFilled(true);				setBorderPainted(isEnabled());			}	
public void mouseExited(MouseEvent e)			{				setContentAreaFilled(false);				setBorderPainted(false);			}	
Roster()		{			operations = new ArrayList<Operation>();			toLoad = new ArrayList<String>();		}	
/**		 * Add a remove operation for the given jar		 * @param jar the jar name		 */		void addRemove(String jar)		{			addOperation(new Remove(jar));		}	
void addInstall(String installed, String url, String installDirectory,			int size)		{			addOperation(new Install(installed,url,installDirectory,size));		}	
public Operation getOperation(int i)		{			return operations.get(i);		}	
int getOperationCount()		{			return operations.size();		}	
boolean isEmpty()		{			return operations.isEmpty();		}	
void performOperationsInWorkThread(PluginManagerProgress progress)		{			for(int i = 0; i < operations.size(); i++)			{				Operation op = operations.get(i);				op.runInWorkThread(progress);				progress.done();					if(Thread.interrupted())					return;			}		}	
void performOperationsInAWTThread(Component comp)		{			for(int i = 0; i < operations.size(); i++)			{				Operation op = operations.get(i);				op.runInAWTThread(comp);			}				// add the JARs before checking deps since dep check might			// require all JARs to be present			for(int i = 0; i < toLoad.size(); i++)			{				String pluginName = toLoad.get(i);				if(jEdit.getPluginJAR(pluginName) != null)				{					Log.log(Log.WARNING,this,"Already loaded: "						+ pluginName);				}				else					jEdit.addPluginJAR(pluginName);			}				for(int i = 0; i < toLoad.size(); i++)			{				String pluginName = toLoad.get(i);				PluginJAR plugin = jEdit.getPluginJAR(pluginName);				if(plugin != null)					plugin.checkDependencies();			}				// now activate the plugins			for(int i = 0; i < toLoad.size(); i++)			{				String pluginName = toLoad.get(i);				PluginJAR plugin = jEdit.getPluginJAR(pluginName);				if(plugin != null)					plugin.activatePluginIfNecessary();			}		}	
private void addOperation(Operation op)		{			for(int i = 0; i < operations.size(); i++)			{				if(operations.get(i).equals(op))					return;			}				operations.add(op);		}	
private static String getDownloadDir()		{			if(downloadDir == null)			{				String settings = jEdit.getSettingsDirectory();				if(settings == null)					settings = System.getProperty("user.home");				downloadDir = new File(MiscUtilities.constructPath(					settings,"PluginManager.download"));				downloadDir.mkdirs();			}				return downloadDir.getPath();		}	
public void runInWorkThread(PluginManagerProgress progress)			{			}	
public void runInAWTThread(Component comp)			{			}	
public int getMaximum()			{				return 0;			}	
Remove(String jar)			{				this.jar = jar;			}	
public void runInAWTThread(Component comp)			{				// close JAR file and all JARs that depend on this				PluginJAR jar = jEdit.getPluginJAR(this.jar);				if(jar != null)				{					unloadPluginJAR(jar);				}					toLoad.remove(this.jar);					// remove cache file					// move JAR first				File jarFile = new File(this.jar);				File srcFile = new File(this.jar.substring(0, this.jar.length() - 4));					Log.log(Log.NOTICE,this,"Deleting " + jarFile);					boolean ok = jarFile.delete();					if(srcFile.exists())				{					ok &= recursiveDelete(srcFile);				}					if(!ok)				{					String[] args = {this.jar};					GUIUtilities.error(comp,"plugin-manager.remove-failed",args);				}			}	
/**			 * This should go into a public method somewhere.			 * @param jar the jar of the plugin			 */			private void unloadPluginJAR(PluginJAR jar)			{				String[] dependents = jar.getDependentPlugins();				for (String path: dependents) 				{					PluginJAR _jar = jEdit.getPluginJAR(path);					if(_jar != null)					{						toLoad.add(path);						unloadPluginJAR(_jar);						// clear cache file						String cachePath = jar.getCachePath();						if(cachePath != null)							new File(cachePath).delete();						}				}				jEdit.removePluginJAR(jar,false);							}	
public boolean equals(Object o)			{				return o instanceof Remove				       && ((Remove) o).jar.equals(jar);			}	
Install(String installed, String url, String installDirectory,				int size)			{				// catch those hooligans passing null urls				if(url == null)					throw new NullPointerException();					this.installed = installed;				this.url = url;				this.installDirectory = installDirectory;				this.size = size;			}	
public int getMaximum()			{				return size;			}	
public void runInWorkThread(PluginManagerProgress progress)			{				String fileName = MiscUtilities.getFileName(url);					path = download(progress,fileName,url);			}	
public void runInAWTThread(Component comp)			{				// check if download failed				if(path == null)					return;					// if download OK, remove existing version				if(installed != null)					new Remove(installed).runInAWTThread(comp);					ZipFile zipFile = null;					try				{					zipFile = new ZipFile(path);						Enumeration<? extends ZipEntry> e = zipFile.entries();					while(e.hasMoreElements())					{						ZipEntry entry = e.nextElement();						String name = entry.getName().replace('/',File.separatorChar);						File file = new File(installDirectory,name);						if(entry.isDirectory())							file.mkdirs();						else						{							new File(file.getParent()).mkdirs();							InputStream in = null;							FileOutputStream out = null;							try							{								in = zipFile.getInputStream(entry);								out = new FileOutputStream(file);								IOUtilities.copyStream(4096,									null,									in,									out,false);							}							finally							{								IOUtilities.closeQuietly(in);								IOUtilities.closeQuietly(out);							}							if(file.getName().toLowerCase().endsWith(".jar"))								toLoad.add(file.getPath());						}					}				}				catch(InterruptedIOException iio)				{				}				catch(ZipException e)				{					Log.log(Log.ERROR,this,e);					GUIUtilities.error(null,"plugin-error-download",new Object[]{""});				}				catch(IOException io)				{					Log.log(Log.ERROR,this,io);						String[] args = { io.getMessage() };					GUIUtilities.error(null,"ioerror",args);				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);				}				finally				{					try					{						if(zipFile != null)							zipFile.close();					}					catch(IOException io)					{						Log.log(Log.ERROR,this,io);					}						if(jEdit.getBooleanProperty(						"plugin-manager.deleteDownloads"))					{						new File(path).delete();					}				}			}	
public boolean equals(Object o)			{				return o instanceof Install				       && ((Install) o).url.equals(url);			}	
private String download(PluginManagerProgress progress,				String fileName, String url)			{				try				{					String host = jEdit.getProperty("plugin-manager.mirror.id");					if (host == null || host.equals(MirrorList.Mirror.NONE))						host = "default";										String path = MiscUtilities.constructPath(getDownloadDir(),fileName);					URLConnection conn = new URL(url).openConnection();					progress.setStatus(jEdit.getProperty("plugin-manager.progress",new String[] {fileName, host}));					InputStream in = null;					FileOutputStream out = null;					try					{						in = conn.getInputStream();						out = new FileOutputStream(path);						if(!IOUtilities.copyStream(progress,in,out,true))							return null;					}					finally					{						IOUtilities.closeQuietly(in);						IOUtilities.closeQuietly(out);					}										return path;				}				catch(InterruptedIOException iio)				{					// do nothing, user clicked 'Stop'					return null;				}				catch(FileNotFoundException e)				{					Log.log(Log.ERROR,this,e);						SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							GUIUtilities.error(null,"plugin-error-download",new Object[]{""});						}					});						return null;				}				catch(final IOException io)				{					Log.log(Log.ERROR,this,io);						SwingUtilities.invokeLater(new Runnable()					{						public void run()						{							String[] args = { io.getMessage() };							GUIUtilities.error(null,"plugin-error-download",args);						}					});						return null;				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);						return null;				}			}	
public SaveBackupOptionPane()		{			super("save-back");		}	
@Override		protected void _init()		{			/* Two-stage save */			twoStageSave = new JCheckBox(jEdit.getProperty(				"options.save-back.twoStageSave"));			twoStageSave.setSelected(jEdit.getBooleanProperty(				"twoStageSave"));			twoStageSave.setToolTipText(jEdit.getProperty(				"options.save-back.twoStageSave.tooltip"));			addComponent(twoStageSave);				/* Confirm save all */			confirmSaveAll = new JCheckBox(jEdit.getProperty(				"options.save-back.confirmSaveAll"));			confirmSaveAll.setSelected(jEdit.getBooleanProperty(				"confirmSaveAll"));			addComponent(confirmSaveAll);				/* Autosave interval */			autosave = new NumericTextField(jEdit.getProperty("autosave"), true);			addComponent(jEdit.getProperty("options.save-back.autosave"),autosave);				/* Autosave untitled buffers */			autosaveUntitled = new JCheckBox(jEdit.getProperty(				"options.save-back.autosaveUntitled"));			autosaveUntitled.setSelected(jEdit.getBooleanProperty("autosaveUntitled"));			addComponent(autosaveUntitled);				suppressNotSavedConfirmUntitled = new JCheckBox(jEdit.getProperty(				"options.save-back.suppressNotSavedConfirmUntitled"));			suppressNotSavedConfirmUntitled.setSelected(				jEdit.getBooleanProperty("suppressNotSavedConfirmUntitled"));			addComponent(suppressNotSavedConfirmUntitled);				useMD5forDirtyCalculation = new JCheckBox(jEdit.getProperty(				"options.save-back.useMD5forDirtyCalculation"));			useMD5forDirtyCalculation.setToolTipText(jEdit.getProperty(				"options.save-back.useMD5forDirtyCalculation.tooltip"));			useMD5forDirtyCalculation.setSelected(				jEdit.getBooleanProperty("useMD5forDirtyCalculation"));			addComponent(useMD5forDirtyCalculation);							/* Backup count */			backups = new NumericTextField(jEdit.getProperty("backups"), true);			addComponent(jEdit.getProperty("options.save-back.backups"),backups);				/* Backup directory */			backupDirectory = new JTextField(jEdit.getProperty(				"backup.directory"));			JButton browseBackupDirectory = new JButton("...");			browseBackupDirectory.addActionListener(new MyActionListener());			JPanel panel = new JPanel(new BorderLayout());			panel.add(backupDirectory);			panel.add(browseBackupDirectory, BorderLayout.EAST);			addComponent(jEdit.getProperty("options.save-back.backupDirectory"),				panel);				/* Backup filename prefix */			backupPrefix = new JTextField(jEdit.getProperty("backup.prefix"));			addComponent(jEdit.getProperty("options.save-back.backupPrefix"),				backupPrefix);				/* Backup suffix */			backupSuffix = new JTextField(jEdit.getProperty(				"backup.suffix"));			addComponent(jEdit.getProperty("options.save-back.backupSuffix"),				backupSuffix);				/* Backup on every save */			backupEverySave = new JCheckBox(jEdit.getProperty(				"options.save-back.backupEverySave"));			backupEverySave.setSelected(jEdit.getBooleanProperty("backupEverySave"));			addComponent(backupEverySave);		}	
@Override		protected void _save()		{			jEdit.setBooleanProperty("twoStageSave",twoStageSave.isSelected());			jEdit.setBooleanProperty("confirmSaveAll",confirmSaveAll.isSelected());			jEdit.setProperty("autosave", this.autosave.getText());			jEdit.setProperty("backups",backups.getText());			jEdit.setProperty("backup.directory",backupDirectory.getText());			jEdit.setProperty("backup.prefix",backupPrefix.getText());			jEdit.setProperty("backup.suffix",backupSuffix.getText());			jEdit.setBooleanProperty("backupEverySave", backupEverySave.isSelected());			boolean newAutosave = autosaveUntitled.isSelected();			boolean oldAutosave = jEdit.getBooleanProperty("autosaveUntitled");			jEdit.setBooleanProperty("autosaveUntitled", newAutosave);			jEdit.setBooleanProperty("suppressNotSavedConfirmUntitled",					suppressNotSavedConfirmUntitled.isSelected());			jEdit.setBooleanProperty("useMD5forDirtyCalculation",					useMD5forDirtyCalculation.isSelected());			if ((!newAutosave || jEdit.getIntegerProperty("autosave",0) == 0) && oldAutosave)			{				Buffer[] buffers = jEdit.getBuffers();				for (Buffer buffer : buffers)				{					if (buffer.isUntitled())					{						buffer.removeAutosaveFile();					}				}			}		}	
public void actionPerformed(ActionEvent e)			{				String[] choosenFolder =					GUIUtilities.showVFSFileDialog(null,					   			       backupDirectory.getText(),					   			       VFSBrowser.CHOOSE_DIRECTORY_DIALOG,					   			       false);				if (choosenFolder != null)					backupDirectory.setText(choosenFolder[0]);			}	
@Override		public void visit(EditPane editPane)		{			editPane.saveCaretInfo();		}	
ScreenLineManager(JEditBuffer buffer)		{			this.buffer = buffer;			if(!buffer.isLoading())				reset();		}	
boolean isScreenLineCountValid(int line)		{			return (screenLines[line] & SCREEN_LINES_VALID_MASK) != 0;		}	
/**		 * Returns how many screen lines contains the given physical line.		 * It can be greater than 1 when using soft wrap		 *		 * @param line the physical line		 * @return the screen line count		 */		int getScreenLineCount(int line)		{			return screenLines[line] >> SCREEN_LINES_SHIFT;		}	
/**		 * Sets the number of screen lines that the specified physical line		 * is split into.		 * @param line the line number		 * @param count the line count (1 if no wrap)		 */		void setScreenLineCount(int line, int count)		{			if(count > Short.MAX_VALUE)			{				// limitations...				count = Short.MAX_VALUE;			}				if(Debug.SCREEN_LINES_DEBUG)				Log.log(Log.DEBUG,this,new Exception("setScreenLineCount(" + line + ',' + count + ')'));			screenLines[line] = (short)(count << SCREEN_LINES_SHIFT				| SCREEN_LINES_VALID_MASK);		}	
void invalidateScreenLineCounts()		{			int lineCount = buffer.getLineCount();			for(int i = 0; i < lineCount; i++)				screenLines[i] &= ~SCREEN_LINES_VALID_MASK;		}	
void reset()		{			screenLines = new short[buffer.getLineCount()];		}	
public void contentInserted(int startLine, int numLines)		{			int endLine = startLine + numLines;			screenLines[startLine] &= ~SCREEN_LINES_VALID_MASK;				int lineCount = buffer.getLineCount();				if(numLines > 0)			{				if(screenLines.length <= lineCount)				{					short[] screenLinesN = new short[((lineCount + 1) << 1)];					System.arraycopy(screenLines,0,screenLinesN,0,							 screenLines.length);					screenLines = screenLinesN;				}					System.arraycopy(screenLines,startLine,screenLines,					endLine,lineCount - endLine);					for(int i = 0; i < numLines; i++)					screenLines[startLine + i] = 0;			}		}	
public void contentRemoved(int startLine, int numLines)		{			int endLine = startLine + numLines;			screenLines[startLine] &= ~SCREEN_LINES_VALID_MASK;				if(numLines > 0 && endLine != screenLines.length)			{				System.arraycopy(screenLines,endLine + 1,screenLines,					startLine + 1,screenLines.length - endLine - 1);			}		}	
public void addLayoutComponent(String name, Component comp)		{			if(name.equals(CENTER))				center = comp;			else if(name.equals(RIGHT))				right = comp;			else if(name.equals(LEFT))				left = comp;			else if(name.equals(BOTTOM))				bottom = comp;			else if(name.equals(TOP))				top = comp;		}	
public void removeLayoutComponent(Component comp)		{			if(center == comp)				center = null;			else if(right == comp)				right = null;			else if(left == comp)				left = null;			else if(bottom == comp)				bottom = null;			else if(top == comp)				top = null;		}	
public Dimension preferredLayoutSize(Container parent)		{			Dimension dim = new Dimension();			Insets insets = getInsets(parent);				dim.width = insets.left + insets.right;			dim.height = insets.top + insets.bottom;				Dimension leftPref = left.getPreferredSize();			dim.width += leftPref.width;			Dimension centerPref = center.getPreferredSize();			dim.width += centerPref.width;			dim.height += centerPref.height;			Dimension rightPref = right.getPreferredSize();			dim.width += rightPref.width;			Dimension bottomPref = bottom.getPreferredSize();			dim.height += bottomPref.height;			if(top != null)			{				Dimension topPref = top.getPreferredSize();				dim.height += topPref.height;			}				return dim;		}	
public Dimension minimumLayoutSize(Container parent)		{			Dimension dim = new Dimension();			Insets insets = getInsets(parent);				dim.width = insets.left + insets.right;			dim.height = insets.top + insets.bottom;				Dimension leftPref = left.getMinimumSize();			dim.width += leftPref.width;			Dimension centerPref = center.getMinimumSize();			dim.width += centerPref.width; 			dim.height += centerPref.height;			Dimension rightPref = right.getMinimumSize();			dim.width += rightPref.width;			Dimension bottomPref = bottom.getMinimumSize();			dim.height += bottomPref.height;			if(top != null)			{				Dimension topPref = top.getMinimumSize();				dim.height += topPref.height;			}						return dim;		}	
public void layoutContainer(Container parent)		{			Dimension size = parent.getSize();			Insets insets = getInsets(parent);				int itop = insets.top;			int ileft = insets.left;			int ibottom = insets.bottom;			int iright = insets.right;				int rightWidth = right.getPreferredSize().width;			int leftWidth = left.getPreferredSize().width;			int topHeight;			if(top != null)			{				topHeight = top.getPreferredSize().height;			}			else			{				topHeight = 0;			}			int bottomHeight = bottom.getPreferredSize().height;			int centerWidth = Math.max(0,size.width - leftWidth				- rightWidth - ileft - iright);			int centerHeight = Math.max(0,size.height - topHeight				- bottomHeight - itop - ibottom);							left.setBounds(				ileft,				itop+topHeight,				leftWidth,				centerHeight);				center.setBounds(				ileft + leftWidth,				itop+topHeight,				centerWidth,				centerHeight);				right.setBounds(				ileft + leftWidth + centerWidth,				itop+topHeight,				rightWidth,				centerHeight);				bottom.setBounds(				ileft,				itop + topHeight + centerHeight,				Math.max(0,size.width - bottom.getHeight()					- ileft - iright),				bottomHeight);			if(top != null)			{				top.setBounds(					ileft,					itop,					leftWidth+centerWidth+rightWidth,					topHeight);			}		}	
private Insets getInsets(Component parent)		{			Border border = ((JComponent)parent).getBorder();			if(border == null)				return new Insets(0,0,0,0);			else				return border.getBorderInsets(parent);		}	
ScrollLineCount(DisplayManager displayManager,			TextArea textArea)		{			super(displayManager,textArea);		}	
@Override		public void changed() {}	
@Override		public void reset()		{			if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"reset()");				physicalLine = displayManager.getFirstVisibleLine();			int scrollLine = 0;			while(physicalLine != -1)			{				scrollLine += displayManager					.getScreenLineCount(physicalLine);				physicalLine = displayManager					.getNextVisibleLine(physicalLine);			}				this.scrollLine = scrollLine;			physicalLine = displayManager.getBuffer().getLineCount();		}	
/**		 * Sets the current search string.		 * @param search The new search string		 */		public static void setSearchString(String search)		{			if(search.equals(SearchAndReplace.search))				return;				SearchAndReplace.search = search;			matcher = null;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the current search string.		 */		public static String getSearchString()		{			return search;		}	
/**		 * Sets the current replacement string.		 * @param replace The new replacement string		 */		public static void setReplaceString(String replace)		{			if(replace.equals(SearchAndReplace.replace))				return;				SearchAndReplace.replace = replace;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the current replacement string.		 */		public static String getReplaceString()		{			return replace;		}	
/**		 * Sets the ignore case flag.		 * @param ignoreCase True if searches should be case insensitive,		 * false otherwise		 */		public static void setIgnoreCase(boolean ignoreCase)		{			if(ignoreCase == SearchAndReplace.ignoreCase)				return;				SearchAndReplace.ignoreCase = ignoreCase;			matcher = null;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the state of the ignore case flag.		 * @return True if searches should be case insensitive,		 * false otherwise		 */		public static boolean getIgnoreCase()		{			return ignoreCase;		}	
/**		 * Sets the state of the regular expression flag.		 * @param regexp True if regular expression searches should be		 * performed		 */		public static void setRegexp(boolean regexp)		{			if(regexp == SearchAndReplace.regexp)				return;				SearchAndReplace.regexp = regexp;			if(regexp && reverse)				reverse = false;				matcher = null;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the state of the regular expression flag.		 * @return True if regular expression searches should be performed		 */		public static boolean getRegexp()		{			return regexp;		}	
/**		 * Determines whether a reverse search will conducted from the current		 * position to the beginning of a buffer. Note that reverse search and		 * regular expression search is mutually exclusive; enabling one will		 * disable the other.		 * @param reverse True if searches should go backwards,		 * false otherwise		 */		public static void setReverseSearch(boolean reverse)		{			if(reverse == SearchAndReplace.reverse)				return;				SearchAndReplace.reverse = reverse;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the state of the reverse search flag.		 * @return True if searches should go backwards,		 * false otherwise		 */		public static boolean getReverseSearch()		{			return reverse;		}	
/**		 * Sets the state of the BeanShell replace flag.		 * @param beanshell True if the replace string is a BeanShell expression		 * @since jEdit 3.2pre2		 */		public static void setBeanShellReplace(boolean beanshell)		{			if(beanshell == SearchAndReplace.beanshell)				return;				SearchAndReplace.beanshell = beanshell;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the state of the BeanShell replace flag.		 * @return True if the replace string is a BeanShell expression		 * @since jEdit 3.2pre2		 */		public static boolean getBeanShellReplace()		{			return beanshell;		}	
/**		 * Sets the state of the auto wrap around flag.		 * @param wrap If true, the 'continue search from start' dialog		 * will not be displayed		 * @since jEdit 3.2pre2		 */		public static void setAutoWrapAround(boolean wrap)		{			if(wrap == SearchAndReplace.wrap)				return;				SearchAndReplace.wrap = wrap;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the state of the auto wrap around flag.		 * @since jEdit 3.2pre2		 */		public static boolean getAutoWrapAround()		{			return wrap;		}	
/**		 * Sets a custom search string matcher. Note that calling		 * {@link #setSearchString(String)},		 * {@link #setIgnoreCase(boolean)}, or {@link #setRegexp(boolean)}		 * will reset the matcher to the default.		 */		public static void setSearchMatcher(SearchMatcher matcher)		{			SearchAndReplace.matcher = matcher;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the current search string matcher.		 * @return a SearchMatcher or null if there is no search or if the matcher can match empty String		 *		 * @exception IllegalArgumentException if regular expression search		 * is enabled, the search string or replacement string is invalid		 * @since jEdit 4.1pre7		 */		public static SearchMatcher getSearchMatcher()			throws Exception {			if (matcher != null)				return matcher;				if (search == null || "".equals(search))				return null;				if (regexp)			{				Pattern re = Pattern.compile(search, 					PatternSearchMatcher.getFlag(ignoreCase));				matcher = new PatternSearchMatcher(re, ignoreCase);			}			else				matcher = new BoyerMooreSearchMatcher(search, ignoreCase);				return matcher;		}	
/**		 * Sets the current search file set.		 * @param fileset The file set to perform searches in		 * @see AllBufferSet		 * @see CurrentBufferSet		 * @see DirectoryListSet		 */		public static void setSearchFileSet(SearchFileSet fileset)		{			SearchAndReplace.fileset = fileset;				EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Returns the current search file set.		 */		public static SearchFileSet getSearchFileSet()		{			return fileset;		}	
/**		 * Returns if the replacement string will assume the same case as		 * each specific occurrence of the search string.		 * @since jEdit 4.2pre10		 */		public static boolean getSmartCaseReplace()		{			return (replace != null				&& TextUtilities.getStringCase(replace)				== TextUtilities.LOWER_CASE);		}	
/**		 * Performs a HyperSearch.		 * @param view The view		 * @since jEdit 2.7pre3		 */		public static boolean hyperSearch(View view)		{			return hyperSearch(view,false);		}	
/**		 * Performs a HyperSearch.		 * @param view The view		 * @param selection If true, will only search in the current selection.		 * Note that the file set must be the current buffer file set for this		 * to work.		 * @since jEdit 4.0pre1		 */		public static boolean hyperSearch(View view, boolean selection)		{			// component that will parent any dialog boxes			Component comp = SearchDialog.getSearchDialog(view);			if(comp == null)				comp = view;				record(view,"hyperSearch(view," + selection + ')',false,				!selection);				view.getDockableWindowManager().addDockableWindow(				HyperSearchResults.NAME);			HyperSearchResults results = (HyperSearchResults)				view.getDockableWindowManager()				.getDockable(HyperSearchResults.NAME);			results.searchStarted();				try			{				SearchMatcher matcher = getSearchMatcher();				if(matcher == null)				{					view.getToolkit().beep();					results.searchFailed();					return false;				}					Selection[] s;				if(selection)				{					s = view.getTextArea().getSelection();					if(s == null)					{						results.searchFailed();						return false;					}				}				else					s = null;				VFSManager.runInWorkThread(new HyperSearchRequest(view,					matcher,results,s));				return true;			}			catch(Exception e)			{				results.searchFailed();				handleError(comp,e);				return false;			}		}	
/**		 * Finds the next occurrence of the search string.		 * @param view The view		 * @return True if the operation was successful, false otherwise		 */		public static boolean find(View view)		{			// component that will parent any dialog boxes			Component comp = SearchDialog.getSearchDialog(view);			if(comp == null || !comp.isShowing())				comp = view;				String path = fileset.getNextFile(view,null);			if(path == null)			{				GUIUtilities.error(comp,"empty-fileset",null);				return false;			}				boolean _reverse = reverse && fileset instanceof CurrentBufferSet;				try			{				view.showWaitCursor();					SearchMatcher matcher = getSearchMatcher();				if(matcher == null)				{					view.getToolkit().beep();					return false;				}					record(view,"find(view)",false,true);					boolean repeat = false;	loop:			for(;;)				{					while(path != null)					{						Buffer buffer = jEdit.openTemporary(							view,null,path,false);							/* this is stupid and misleading.						 * but 'path' is not used anywhere except						 * the above line, and if this is done						 * after the 'continue', then we will						 * either hang, or be forced to duplicate						 * it inside the buffer == null, or add						 * a 'finally' clause. you decide which one's						 * worse. */						path = fileset.getNextFile(view,path);							if(buffer == null)							continue loop;							// Wait for the buffer to load						if(!buffer.isLoaded())							VFSManager.waitForRequests();							int start;							if(view.getBuffer() == buffer && !repeat)						{							JEditTextArea textArea = view.getTextArea();							Selection s = textArea.getSelectionAtOffset(								textArea.getCaretPosition());							if(s == null)								start = textArea.getCaretPosition();							else if(_reverse)								start = s.getStart();							else								start = s.getEnd();						}						else if(_reverse)							start = buffer.getLength();						else							start = 0;							if(find(view,buffer,start,repeat,_reverse))							return true;					}						if(repeat)					{						if(!BeanShell.isScriptRunning())						{							view.getStatus().setMessageAndClear(								jEdit.getProperty("view.status.search-not-found"));								view.getToolkit().beep();						}						return false;					}						boolean restart;						// if auto wrap is on, always restart search.					// if auto wrap is off, and we're called from					// a macro, stop search. If we're called					// interactively, ask the user what to do.					if(wrap)					{						if(!BeanShell.isScriptRunning())						{							view.getStatus().setMessageAndClear(								jEdit.getProperty("view.status.auto-wrap"));							// beep if beep property set							if(jEdit.getBooleanProperty("search.beepOnSearchAutoWrap"))							{								view.getToolkit().beep();							}						}						restart = true;					}					else if(BeanShell.isScriptRunning())					{						restart = false;					}					else					{						Integer[] args = {Integer.valueOf(_reverse ? 1 : 0)};						int result = GUIUtilities.confirm(comp,							"keepsearching",args,							JOptionPane.YES_NO_OPTION,							JOptionPane.QUESTION_MESSAGE);						restart = (result == JOptionPane.YES_OPTION);					}						if(restart)					{						// start search from beginning						path = fileset.getFirstFile(view);						repeat = true;					}					else						break loop;				}			}			catch(Exception e)			{				handleError(comp,e);			}			finally			{				view.hideWaitCursor();			}				return false;		}	
/**		 * Finds the next instance of the search string in the specified		 * buffer.		 * @param view The view		 * @param buffer The buffer		 * @param start Location where to start the search		 */		public static boolean find(View view, Buffer buffer, int start)			throws Exception		{			return find(view,buffer,start,false,false);		}	
/**		 * Finds the next instance of the search string in the specified		 * buffer.		 * @param view The view		 * @param buffer The buffer		 * @param start Location where to start the search		 * @param firstTime See {@link SearchMatcher#nextMatch(CharSequence,boolean,boolean,boolean,boolean)}.		 * @since jEdit 4.1pre7		 */		public static boolean find(View view, Buffer buffer, int start,			boolean firstTime, boolean reverse) throws Exception		{						EditBus.send(new PositionChanging(view.getEditPane()));						SearchMatcher matcher = getSearchMatcher();			if(matcher == null)			{				view.getToolkit().beep();				return false;			}				CharSequence text;			boolean startOfBuffer;			boolean endOfBuffer;			if(reverse)			{				text = new ReverseCharSequence(buffer.getSegment(0,start));				startOfBuffer = true;				endOfBuffer = (start == buffer.getLength());			}			else			{				text = buffer.getSegment(start,buffer.getLength() - start);				startOfBuffer = (start == 0);				endOfBuffer = true;			}			SearchMatcher.Match match = matcher.nextMatch(text,				startOfBuffer,endOfBuffer,firstTime,reverse);			if(match != null)			{				jEdit.commitTemporary(buffer);				view.setBuffer(buffer,true);				JEditTextArea textArea = view.getTextArea();					if(reverse)				{					textArea.setSelection(new Selection.Range(						start - match.end,						start - match.start));					// make sure end of match is visible					textArea.scrollTo(start - match.start,false);					textArea.moveCaretPosition(start - match.end);				}				else				{					textArea.setSelection(new Selection.Range(						start + match.start,						start + match.end));					textArea.moveCaretPosition(start + match.end);					// make sure start of match is visible					textArea.scrollTo(start + match.start,false);				}					return true;			}			else				return false;		}	
/**		 * Replaces the current selection with the replacement string.		 * @param view The view		 * @return True if the operation was successful, false otherwise		 */		public static boolean replace(View view)		{			// component that will parent any dialog boxes			Component comp = SearchDialog.getSearchDialog(view);			if(comp == null)				comp = view;				JEditTextArea textArea = view.getTextArea();				Buffer buffer = view.getBuffer();			if(!buffer.isEditable())				return false;				boolean smartCaseReplace = getSmartCaseReplace();				Selection[] selection = textArea.getSelection();			if (selection.length == 0)			{				view.getToolkit().beep();				return false;			}				record(view,"replace(view)",true,false);				// a little hack for reverse replace and find			int caret = textArea.getCaretPosition();			Selection s = textArea.getSelectionAtOffset(caret);			if(s != null)				caret = s.getStart();				try			{				buffer.beginCompoundEdit();					SearchMatcher matcher = getSearchMatcher();				if(matcher == null)					return false;					initReplace();					int retVal = 0;					for(int i = 0; i < selection.length; i++)				{					s = selection[i];						retVal += replaceInSelection(view,textArea,						buffer,matcher,smartCaseReplace,s);				}					boolean _reverse = !regexp && reverse && fileset instanceof CurrentBufferSet;				if(_reverse)				{					// so that Replace and Find continues from					// the right location					textArea.moveCaretPosition(caret);				}				else				{					s = textArea.getSelectionAtOffset(						textArea.getCaretPosition());					if(s != null)						textArea.moveCaretPosition(s.getEnd());				}					if(!BeanShell.isScriptRunning())				{					Object[] args = {Integer.valueOf(retVal),					                 Integer.valueOf(1)};					view.getStatus().setMessageAndClear(jEdit.getProperty(						"view.status.replace-all",args));				}					if(retVal == 0)				{					view.getToolkit().beep();					return false;				}					return true;			}			catch(Exception e)			{				handleError(comp,e);			}			finally			{				buffer.endCompoundEdit();			}				return false;		}	
/**		 * Replaces text in the specified range with the replacement string.		 * @param view The view		 * @param buffer The buffer		 * @param start The start offset		 * @param end The end offset		 * @return True if the operation was successful, false otherwise		 */		public static boolean replace(View view, Buffer buffer, int start, int end)		{			if(!buffer.isEditable())				return false;				// component that will parent any dialog boxes			Component comp = SearchDialog.getSearchDialog(view);			if(comp == null)				comp = view;				boolean smartCaseReplace = getSmartCaseReplace();				try			{				buffer.beginCompoundEdit();					SearchMatcher matcher = getSearchMatcher();				if(matcher == null)					return false;					initReplace();					int retVal = 0;					retVal += _replace(view,buffer,matcher,start,end,					smartCaseReplace);					if(retVal != 0)					return true;			}			catch(Exception e)			{				handleError(comp,e);			}			finally			{				buffer.endCompoundEdit();			}				return false;		}	
/**		 * Replaces all occurrences of the search string with the replacement		 * string.		 * @param view The view		 * @return the number of modified files		 */		public static boolean replaceAll(View view)		{			return replaceAll(view,false);		}	
/**		 * Replaces all occurrences of the search string with the replacement		 * string.		 * @param view The view		 * @param dontOpenChangedFiles Whether to open changed files or to autosave them quietly		 * @return the number of modified files		 */		public static boolean replaceAll(View view, boolean dontOpenChangedFiles)		{			// component that will parent any dialog boxes			Component comp = SearchDialog.getSearchDialog(view);			if(comp == null)				comp = view;				if(fileset.getFileCount(view) == 0)			{				GUIUtilities.error(comp,"empty-fileset",null);				return false;			}				record(view,"replaceAll(view)",true,true);				view.showWaitCursor();				boolean smartCaseReplace = (replace != null				&& TextUtilities.getStringCase(replace)				== TextUtilities.LOWER_CASE);				int fileCount = 0;			int occurCount = 0;			try			{				SearchMatcher matcher = getSearchMatcher();				if(matcher == null)					return false;					initReplace();					String path = fileset.getFirstFile(view);	loop:			while(path != null)				{					Buffer buffer = jEdit.openTemporary(						view,null,path,false);						/* this is stupid and misleading.					 * but 'path' is not used anywhere except					 * the above line, and if this is done					 * after the 'continue', then we will					 * either hang, or be forced to duplicate					 * it inside the buffer == null, or add					 * a 'finally' clause. you decide which one's					 * worse. */					path = fileset.getNextFile(view,path);						if(buffer == null)						continue loop;						// Wait for buffer to finish loading					if(buffer.isPerformingIO())						VFSManager.waitForRequests();						if(!buffer.isEditable())						continue loop;						// Leave buffer in a consistent state if					// an error occurs					int retVal = 0;						try					{						buffer.beginCompoundEdit();						retVal = _replace(view,buffer,matcher,							0,buffer.getLength(),							smartCaseReplace);					}					finally					{						buffer.endCompoundEdit();					}						if(retVal != 0)					{						fileCount++;						occurCount += retVal;						if (dontOpenChangedFiles)						{							buffer.save(null,null);						}						else						{							jEdit.commitTemporary(buffer);							jEdit.getBufferSetManager().addBuffer(view, buffer);						}					}				}			}			catch(Exception e)			{				handleError(comp,e);			}			finally			{				view.hideWaitCursor();			}				/* Don't do this when playing a macro, cos it's annoying */			if(!BeanShell.isScriptRunning())			{				Object[] args = {Integer.valueOf(occurCount),				                 Integer.valueOf(fileCount)};				view.getStatus().setMessageAndClear(jEdit.getProperty(					"view.status.replace-all",args));				if(occurCount == 0)					view.getToolkit().beep();			}				return (fileCount != 0);		}	
/**		 * Escapes characters with special meaning in a regexp.		 * @param str the string to escape		 * @param multiline Should \n be escaped?		 * @return the string with escaped characters		 * @since jEdit 4.3pre1		 */		public static String escapeRegexp(String str, boolean multiline)		{			return StandardUtilities.charsToEscapes(str,				"\r\t\\()[]{}$^*+?|."				+ (multiline ? "" : "\n"));		}	
/**		 * Loads search and replace state from the properties.		 */		public static void load()		{			search = jEdit.getProperty("search.find.value");			replace = jEdit.getProperty("search.replace.value");			ignoreCase = jEdit.getBooleanProperty("search.ignoreCase.toggle");			regexp = jEdit.getBooleanProperty("search.regexp.toggle");			beanshell = jEdit.getBooleanProperty("search.beanshell.toggle");			wrap = jEdit.getBooleanProperty("search.wrap.toggle");				fileset = new CurrentBufferSet();				// Tags plugin likes to call this method at times other than			// startup; so we need to fire a SearchSettingsChanged to			// notify the search bar and so on.			matcher = null;			EditBus.send(new SearchSettingsChanged(null));		}	
/**		 * Saves search and replace state to the properties.		 */		public static void save()		{			jEdit.setProperty("search.find.value",search);			jEdit.setProperty("search.replace.value",replace);			jEdit.setBooleanProperty("search.ignoreCase.toggle",ignoreCase);			jEdit.setBooleanProperty("search.regexp.toggle",regexp);			jEdit.setBooleanProperty("search.beanshell.toggle",beanshell);			jEdit.setBooleanProperty("search.wrap.toggle",wrap);		}	
static void handleError(Component comp, Exception e)		{			Log.log(Log.ERROR,SearchAndReplace.class,e);			if(comp instanceof Dialog)			{				new TextAreaDialog((Dialog)comp,					beanshell ? "searcherror-bsh"					: "searcherror",e);			}			else			{				new TextAreaDialog((Frame)comp,					beanshell ? "searcherror-bsh"					: "searcherror",e);			}		}	
/**		 * Set up BeanShell replace if necessary.		 */		private static void initReplace() throws Exception		{			if(beanshell && replace.length() != 0)			{				replaceMethod = BeanShell.cacheBlock("replace",					"return (" + replace + ");",true);			}			else				replaceMethod = null;		}	
private static void record(View view, String action,			boolean replaceAction, boolean recordFileSet)		{			Macros.Recorder recorder = view.getMacroRecorder();				if(recorder != null)			{				recorder.record("SearchAndReplace.setSearchString(\""					+ StandardUtilities.charsToEscapes(search) + "\");");					if(replaceAction)				{					recorder.record("SearchAndReplace.setReplaceString(\""						+ StandardUtilities.charsToEscapes(replace) + "\");");					recorder.record("SearchAndReplace.setBeanShellReplace("						+ beanshell + ");");				}				else				{					// only record this if doing a find next					recorder.record("SearchAndReplace.setAutoWrapAround("						+ wrap + ");");					recorder.record("SearchAndReplace.setReverseSearch("						+ reverse + ");");				}					recorder.record("SearchAndReplace.setIgnoreCase("					+ ignoreCase + ");");				recorder.record("SearchAndReplace.setRegexp("					+ regexp + ");");					if(recordFileSet)				{					recorder.record("SearchAndReplace.setSearchFileSet("						+ fileset.getCode() + ");");				}					recorder.record("SearchAndReplace." + action + ';');			}		}	
private static int replaceInSelection(View view, TextArea textArea,			Buffer buffer, SearchMatcher matcher, boolean smartCaseReplace,			Selection s) throws Exception		{			/* if an occurence occurs at the			beginning of the selection, the			selection start will get moved.			this sucks, so we hack to avoid it. */			int start = s.getStart();				int returnValue;				if(s instanceof Selection.Range)			{				returnValue = _replace(view,buffer,matcher,					s.getStart(),s.getEnd(),					smartCaseReplace);					textArea.removeFromSelection(s);				textArea.addToSelection(new Selection.Range(					start,s.getEnd()));			}			else if(s instanceof Selection.Rect)			{				Selection.Rect rect = (Selection.Rect)s;				int startCol = rect.getStartColumn(					buffer);				int endCol = rect.getEndColumn(					buffer);					returnValue = 0;				for(int j = s.getStartLine(); j <= s.getEndLine(); j++)				{					returnValue += _replace(view,buffer,matcher,						getColumnOnOtherLine(buffer,j,startCol),						getColumnOnOtherLine(buffer,j,endCol),						smartCaseReplace);				}				textArea.addToSelection(new Selection.Rect(					start,s.getEnd()));			}			else				throw new RuntimeException("Unsupported: " + s);				return returnValue;		}	
/**		 * Replaces all occurrences of the search string with the replacement		 * string.		 * @param view The view		 * @param buffer The buffer		 * @param start The start offset		 * @param end The end offset		 * @param matcher The search matcher to use		 * @param smartCaseReplace See user's guide		 * @return The number of occurrences replaced		 */		private static int _replace(View view, JEditBuffer buffer,			SearchMatcher matcher, int start, int end,			boolean smartCaseReplace)			throws Exception		{			int occurCount = 0;				boolean endOfLine = (buffer.getLineEndOffset(				buffer.getLineOfOffset(end)) - 1 == end);				int offset = start;	loop:		for(int counter = 0; ; counter++)			{				boolean startOfLine = (buffer.getLineStartOffset(					buffer.getLineOfOffset(offset)) == offset);					CharSequence text = buffer.getSegment(offset,end - offset);				SearchMatcher.Match occur = matcher.nextMatch(					text,startOfLine,endOfLine,counter == 0,false);				if(occur == null)					break loop;					String found = text.subSequence(					occur.start, occur.end).toString();					int length = replaceOne(view,buffer,occur,offset,					found,smartCaseReplace);				if(length == -1)					offset += occur.end;				else				{					offset += occur.start + length;					end += (length - found.length());					occurCount++;				}			}				return occurCount;		}	
/**		 * Replace one occurrence of the search string with the		 * replacement string.		 */		private static int replaceOne(View view, JEditBuffer buffer,			SearchMatcher.Match occur, int offset, String found,			boolean smartCaseReplace)			throws Exception		{			String subst = replaceOne(view,occur,found);			if(smartCaseReplace && ignoreCase)			{				int strCase = TextUtilities.getStringCase(found);				if(strCase == TextUtilities.LOWER_CASE)					subst = subst.toLowerCase();				else if(strCase == TextUtilities.UPPER_CASE)					subst = subst.toUpperCase();				else if(strCase == TextUtilities.TITLE_CASE)					subst = TextUtilities.toTitleCase(subst);			}				if(subst != null)			{				int start = offset + occur.start;				int end = offset + occur.end;					if (end - start > 0)					buffer.remove(start,end - start);				buffer.insert(start,subst);				return subst.length();			}			else				return -1;		}	
private static String replaceOne(View view,			SearchMatcher.Match occur, String found)			throws Exception		{			if(regexp)			{				if(replaceMethod != null)					return regexpBeanShellReplace(view,occur);				else					return regexpReplace(occur,found);			}			else			{				if(replaceMethod != null)					return literalBeanShellReplace(view,found);				else					return replace;			}		}	
private static String regexpBeanShellReplace(View view,			SearchMatcher.Match occur) throws Exception		{			for(int i = 0; i < occur.substitutions.length; i++)			{				replaceNS.setVariable("_" + i,					occur.substitutions[i]);			}				Object obj = BeanShell.runCachedBlock(				replaceMethod,view,replaceNS);			if(obj == null)				return "";			else				return obj.toString();		}	
private static String regexpReplace(SearchMatcher.Match occur,			String found) throws Exception		{			StringBuilder buf = new StringBuilder();				for(int i = 0; i < replace.length(); i++)			{				char ch = replace.charAt(i);				switch(ch)				{				case '$':					if(i == replace.length() - 1)					{						// last character of the replace string, 						// it is not a capturing group						buf.append(ch);						break;					}						ch = replace.charAt(++i);					if(ch == '$')					{						// It was $$, so it is an escaped $						buf.append('$');					}					else if(ch == '0')					{						// $0 meaning the first capturing group :						// the found value						buf.append(found);					}					else if(Character.isDigit(ch))					{						int n = ch - '0';						while (i < replace.length() - 1)						{							ch = replace.charAt(++i);							if (Character.isDigit(ch))							{								n = n * 10 + (ch - '0');							}							else							{								// The character is not 								// a digit, going back and								// end loop								i--;								break;							}						}						if(n < occur							.substitutions							.length)						{							String subs = occur.substitutions[n];							if (subs != null)								buf.append(subs);						}					}					break;				case '\\':					if(i == replace.length() - 1)					{						buf.append('\\');						break;					}					ch = replace.charAt(++i);					switch(ch)					{					case 'n':						buf.append('\n');						break;					case 't':						buf.append('\t');						break;					default:						buf.append(ch);						break;					}					break;				default:					buf.append(ch);					break;				}			}				return buf.toString();		}	
private static String literalBeanShellReplace(View view, String found)			throws Exception		{			replaceNS.setVariable("_0",found);			Object obj = BeanShell.runCachedBlock(				replaceMethod,				view,replaceNS);			if(obj == null)				return "";			else				return obj.toString();		}	
/**		 * Should be somewhere else...		 */		private static int getColumnOnOtherLine(Buffer buffer, int line,			int col)		{			int returnValue = buffer.getOffsetOfVirtualColumn(				line,col,null);			if(returnValue == -1)				return buffer.getLineEndOffset(line) - 1;			else				return buffer.getLineStartOffset(line) + returnValue;		}	
public SearchBar(final View view, boolean temp)		{			this.view = view;				setLayout(new BoxLayout(this,BoxLayout.X_AXIS));				setFloatable(false);			add(Box.createHorizontalStrut(2));				JLabel label = new JLabel(jEdit.getProperty("view.search.find"));			add(label);						add(Box.createHorizontalStrut(12));						add(find = new HistoryTextField("find"));			find.setSelectAllOnFocus(true);				SyntaxStyle style = GUIUtilities.parseStyle(jEdit.getProperty("view.style.invalid"), "Dialog", 12);			errorBackground = style.getBackgroundColor();			errorForeground = style.getForegroundColor();			defaultBackground = find.getBackground();			defaultForeground = find.getForeground();			Dimension max = find.getPreferredSize();			max.width = Integer.MAX_VALUE;			find.setMaximumSize(max);			ActionHandler actionHandler = new ActionHandler();			find.addKeyListener(new KeyHandler());			find.addActionListener(actionHandler);			find.getDocument().addDocumentListener(new DocumentHandler());				Insets margin = new Insets(1,1,1,1);				addSeparator(new Dimension(12, 12));						add(ignoreCase = new JCheckBox(jEdit.getProperty(				"search.case")));			ignoreCase.addActionListener(actionHandler);			ignoreCase.setMargin(margin);			ignoreCase.setOpaque(false);			ignoreCase.setRequestFocusEnabled(false);			add(Box.createHorizontalStrut(2));						add(regexp = new JCheckBox(jEdit.getProperty(				"search.regexp")));			regexp.addActionListener(actionHandler);			regexp.setMargin(margin);			regexp.setOpaque(false);			regexp.setRequestFocusEnabled(false);			add(Box.createHorizontalStrut(2));						add(hyperSearch = new JCheckBox(jEdit.getProperty(				"search.hypersearch")));			hyperSearch.addActionListener(actionHandler);			hyperSearch.setMargin(margin);			hyperSearch.setOpaque(false);			hyperSearch.setRequestFocusEnabled(false);				update();				//{{{ Create the timer used by incremental search			timer = new Timer(0,new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					if(!incrementalSearch(searchStart,searchReverse))					{						if(!incrementalSearch(							(searchReverse							? view.getBuffer().getLength()							: 0),searchReverse))						{							// not found at all.							view.getStatus().setMessageAndClear(								jEdit.getProperty(								"view.status.search-not-found"));						}					}				}			}); //}}}				// if 'temp' is true, hide search bar after user is done with it			this.isRemovable = temp;				setCloseButtonVisibility();		}	
public HistoryTextField getField()		{			return find;		}	
public void setHyperSearch(boolean hyperSearch)		{			jEdit.setBooleanProperty("view.search.hypersearch.toggle",hyperSearch);			this.hyperSearch.setSelected(hyperSearch);		}	
public void update()		{			ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());			regexp.setSelected(SearchAndReplace.getRegexp());			hyperSearch.setSelected(jEdit.getBooleanProperty(				"view.search.hypersearch.toggle"));		}	
public void propertiesChanged()		{			// Option may have been changed			isRemovable = !(jEdit.getBooleanProperty("view.showSearchbar"));						Log.log(Log.DEBUG, this, "in SearchBar.propertiesChanged(), isRemovable = " + isRemovable);						setCloseButtonVisibility();					}	
private void find(boolean reverse)		{			timer.stop();				String text = find.getText();			//{{{ If nothing entered, show search and replace dialog box			if(text.length() == 0)			{				jEdit.setBooleanProperty("search.hypersearch.toggle",					hyperSearch.isSelected());				SearchDialog.showSearchDialog(view,null,SearchDialog.CURRENT_BUFFER);			} //}}}			//{{{ HyperSearch			else if(hyperSearch.isSelected())			{				if(isRemovable)				{					view.removeToolBar(SearchBar.this);				}				else					find.setText(null);					SearchAndReplace.setSearchString(text);				SearchAndReplace.setSearchFileSet(new CurrentBufferSet());				SearchAndReplace.hyperSearch(view);			} //}}}			//{{{ Incremental search			else			{				// on enter, start search from end				// of current match to find next one				int start;				JEditTextArea textArea = view.getTextArea();				Selection s = textArea.getSelectionAtOffset(					textArea.getCaretPosition());				if(s == null)					start = textArea.getCaretPosition();				else if(reverse)					start = s.getStart();				else					start = s.getEnd();					if(!incrementalSearch(start,reverse))				{					// not found. start from					// beginning					if(!incrementalSearch(reverse						? view.getBuffer().getLength()						: 0,reverse))					{						// not found at all.						view.getStatus().setMessageAndClear(							jEdit.getProperty(							"view.status.search-not-found"));					}					else					{						// inform user search restarted						view.getStatus().setMessageAndClear(							jEdit.getProperty("view.status.auto-wrap"));						// beep if beep property set						if(jEdit.getBooleanProperty("search.beepOnSearchAutoWrap"))						{							getToolkit().beep();						}					}				}			} //}}}		}	
private boolean incrementalSearch(int start, boolean reverse)		{			/* For example, if the current fileset is a directory,			 * C+g will find the next match within that fileset.			 * This can be annoying if you have just done an			 * incremental search and want the next occurrence			 * in the current buffer. */			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());			SearchAndReplace.setSearchString(find.getText());			SearchAndReplace.setReverseSearch(reverse);				boolean ret = false;			try			{				if(SearchAndReplace.find(view,view.getBuffer(),start,false,reverse))					ret = true;			}			catch(Exception e)			{				Log.log(Log.DEBUG,this,e);					// invalid regexp, ignore				// return true to avoid annoying beeping while				// typing a re				ret = true;			}			if (ret)			{				if (wasError)				{					find.setForeground(defaultForeground);					find.setBackground(defaultBackground);					wasError = false;				}			}			else			{				if (!wasError)				{					find.setForeground(errorForeground);					find.setBackground(errorBackground);					wasError = true;				}			}					return ret;		}	
private void timerIncrementalSearch(int start, boolean reverse)		{			searchStart = start;			searchReverse = reverse;				timer.stop();			timer.setRepeats(false);			timer.setInitialDelay(150);			timer.start();		}	
private void setCloseButtonVisibility()		{			if(isRemovable)			{				if(close == null)				{					close = new RolloverButton(GUIUtilities.loadIcon("closebox.gif"));					close.addActionListener(new ActionHandler());					close.setToolTipText(jEdit.getProperty(						"view.search.close-tooltip"));				}				add(close);			}			else if(close != null)				remove(close);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == find)					find(false);				else if(source == hyperSearch)				{					jEdit.setBooleanProperty("view.search.hypersearch.toggle",						hyperSearch.isSelected());					update();				}				else if(source == ignoreCase)				{					SearchAndReplace.setIgnoreCase(ignoreCase						.isSelected());				}				else if(source == regexp)				{					SearchAndReplace.setRegexp(regexp						.isSelected());				}				else if(source == close)				{					view.removeToolBar(SearchBar.this);					view.getEditPane().focusOnTextArea();				}			}	
public void insertUpdate(DocumentEvent evt)			{				// on insert, start search from beginning of				// current match. This will continue to highlight				// the current match until another match is found				if(!hyperSearch.isSelected())				{					int start;					JEditTextArea textArea = view.getTextArea();					Selection s = textArea.getSelectionAtOffset(						textArea.getCaretPosition());					if(s == null)						start = textArea.getCaretPosition();					else						start = s.getStart();						timerIncrementalSearch(start,false);				}			}	
public void removeUpdate(DocumentEvent evt)			{				// on backspace, restart from beginning				if(!hyperSearch.isSelected())				{					String text = find.getText();					if(text.length() != 0)					{						// don't beep if not found.						// subsequent beeps are very						// annoying when backspacing an						// invalid search string.						if(regexp.isSelected())						{							// reverse regexp search							// not supported yet, so							// 'simulate' with restart							timerIncrementalSearch(0,false);						}						else						{							int start;							JEditTextArea textArea = view.getTextArea();							Selection s = textArea.getSelectionAtOffset(								textArea.getCaretPosition());							if(s == null)								start = textArea.getCaretPosition();							else								start = s.getStart();							timerIncrementalSearch(start,true);						}					}				}			}	
public void changedUpdate(DocumentEvent evt) {}	
public void keyPressed(KeyEvent evt)			{				switch(evt.getKeyCode())				{				case KeyEvent.VK_ESCAPE:					if(isRemovable)					{						view.removeToolBar(SearchBar.this);					}					evt.consume();					view.getEditPane().focusOnTextArea();					break;				case KeyEvent.VK_ENTER:					if(evt.isShiftDown())					{						evt.consume();						find(true);					}					break;				}			}	
public void focusLost(FocusEvent e)			{				getField().addCurrentToHistory();			}	
public static SearchDialog getSearchDialog(View view)		{			if(Debug.DISABLE_SEARCH_DIALOG_POOL)				return new SearchDialog(view);			else			{					SearchDialog searchDialog = viewHash.get(view);				if (searchDialog == null)				{					searchDialog = new SearchDialog(view);					viewHash.put(view, searchDialog);				}				return searchDialog;			}		}	
/**		 * Displays a search and replace dialog box, reusing an existing one		 * if necessary.		 * @param view The view		 * @param searchString The search string		 * @param searchIn One of CURRENT_BUFFER, ALL_BUFFERS, or DIRECTORY		 * @since jEdit 4.0pre6		 */		public static void showSearchDialog(View view, String searchString,			int searchIn)		{			final SearchDialog dialog = getSearchDialog(view);				dialog.setSearchString(searchString,searchIn);				// ugly workaround			if(OperatingSystem.isUnix() && !OperatingSystem.isMacOS())				dialog.setVisible(false);				// I'm not sure if calling requestFocus() is strictly necessary			// (focus looks fine without this, on Linux at least), but			// it doesn't hurt to leave it here.			SwingUtilities.invokeLater(new Runnable() 			{				public void run() 				{					dialog.toFront();					dialog.requestFocus();						// Ensure that the dialog gets the focus. Just bringing						// it to front just not necessarily give it the focus.					dialog.find.requestFocus();						// Given that the dialog has the focus, set the focus						// to the 'find' field.				}			});			dialog.setVisible(true);		}	
/**		 * Sets the search string.		 *		 * @param searchString The search string		 * @param searchIn One of {@link #CURRENT_BUFFER}, {@link #ALL_BUFFERS}, or {@link #DIRECTORY}		 * @since jEdit 4.0pre5		 */		public void setSearchString(String searchString, int searchIn)		{			find.setText(null);			replace.setText(null);				if(searchString == null)			{				searchCurrentBuffer.setSelected(true);				HistoryModel model = find.getModel();				if (!model.isEmpty())				{					find.setText(model.getItem(0));					find.selectAll();				}			}			else			{				if(searchString.indexOf('\n') == -1)				{					if(SearchAndReplace.getRegexp())					{						find.setText(SearchAndReplace.escapeRegexp(							searchString,true));					}					else						find.setText(searchString);					find.selectAll();					searchCurrentBuffer.setSelected(true);				}				else if(searchIn == CURRENT_BUFFER)				{					searchSelection.setSelected(true);					hyperSearch.setSelected(true);				}			}				if(searchIn == CURRENT_BUFFER)			{				if(!searchSelection.isSelected())				{					// might be already selected, see above.					searchCurrentBuffer.setSelected(true);						/* this property is only loaded and saved if					 * the 'current buffer' file set is selected.					 * otherwise, it defaults to on. */					hyperSearch.setSelected(jEdit.getBooleanProperty(						"search.hypersearch.toggle"));				}			}			else if(searchIn == ALL_BUFFERS)			{				searchAllBuffers.setSelected(true);				hyperSearch.setSelected(true);			}			else if(searchIn == DIRECTORY)			{				SearchFileSet fileset = SearchAndReplace.getSearchFileSet();					if(fileset instanceof DirectoryListSet)				{					filter.setText(((DirectoryListSet)fileset)						.getFileFilter());					directory.setText(((DirectoryListSet)fileset)						.getDirectory());					searchSubDirectories.setSelected(((DirectoryListSet)fileset)						.isRecursive());				}					hyperSearch.setSelected(true);				searchDirectory.setSelected(true);			}				updateEnabled();		}	
public void ok()		{			try			{				setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));					if(!save(false))					return;					if(searchSelection.isSelected()					&& view.getTextArea().getSelectionCount() == 0)				{					GUIUtilities.error(view,"search-no-selection",null);					return;				}					if(hyperSearch.isSelected() || searchSelection.isSelected())				{					if(SearchAndReplace.hyperSearch(view,						searchSelection.isSelected()))						closeOrKeepDialog();				}				else				{					if(SearchAndReplace.find(view))						closeOrKeepDialog();					else					{						toFront();						requestFocus();						find.requestFocus();					}				}			}			finally			{				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));			}		}	
public void cancel()		{			save(true);			GUIUtilities.saveGeometry(this,"search");			setVisible(false);		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof SearchSettingsChanged)			{				if(!saving)					load();			}		}	
@Override		public void dispose()		{			EditBus.removeFromBus(this);			viewHash.remove(view);			super.dispose();		}	
/**		 * Creates a new search and replace dialog box.		 * @param view The view		 */		private SearchDialog(View view)		{			super(view,jEdit.getProperty("search.title"),false);				this.view = view;				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(0,12,12,12));			setContentPane(content);				JPanel centerPanel = new JPanel(new BorderLayout());			centerPanel.add(BorderLayout.CENTER,createFieldPanel());			centerPanel.add(BorderLayout.SOUTH,createSearchSettingsPanel());			content.add(BorderLayout.CENTER,centerPanel);			content.add(BorderLayout.SOUTH,createMultiFilePanel());				content.add(BorderLayout.EAST,createButtonsPanel());				pack();			jEdit.unsetProperty("search.width");			jEdit.unsetProperty("search.d-width");			jEdit.unsetProperty("search.height");			jEdit.unsetProperty("search.d-height");			GUIUtilities.loadGeometry(this,"search");				load();				EditBus.addToBus(this);		}	
private void createFindLabelAndField(JPanel fieldPanel,			GridBagConstraints cons)		{			JLabel label = new JLabel(jEdit.getProperty("search.find"));						label.setDisplayedMnemonic(jEdit.getProperty("search.find.mnemonic")				.charAt(0));			find = new HistoryTextArea("find");			find.setName("find");			find.setColumns(25);			find.setToolTipText(jEdit.getProperty("search.find.tooltip"));			label.setToolTipText(jEdit.getProperty("search.find.tooltip"));			label.setLabelFor(find);			label.setBorder(new EmptyBorder(12,0,2,0));				cons.gridx = 0;			cons.weightx = 0.0;			cons.weighty = 0.0;			fieldPanel.add(label,cons);			cons.gridy++;			cons.weightx = 1.0;			cons.weighty = 1.0;			fieldPanel.add(new JScrollPane(find),cons);			cons.gridy++;		}	
private void createReplaceLabelAndField(JPanel fieldPanel,			GridBagConstraints cons)		{			JLabel label = new JLabel(jEdit.getProperty("search.replace"));			label.setDisplayedMnemonic(jEdit.getProperty("search.replace.mnemonic")				.charAt(0));			label.setBorder(new EmptyBorder(12,0,0,0));				cons.gridx = 0;			cons.weightx = 0.0;			cons.weighty = 0.0;			fieldPanel.add(label,cons);			cons.gridy++;				ButtonGroup grp = new ButtonGroup();			ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler();				// we use a custom JRadioButton subclass that returns			// false for isFocusTraversable() so that the user can			// tab from the search field to the replace field with			// one keystroke				stringReplace = new MyJRadioButton(jEdit.getProperty(				"search.string-replace-btn"));			stringReplace.addActionListener(replaceActionHandler);			grp.add(stringReplace);			cons.gridwidth = 1;			fieldPanel.add(stringReplace,cons);			cons.gridx++;			cons.insets = new Insets(0,12,0,0);				beanShellReplace = new MyJRadioButton(jEdit.getProperty(				"search.beanshell-replace-btn"));			beanShellReplace.addActionListener(replaceActionHandler);			grp.add(beanShellReplace);			fieldPanel.add(beanShellReplace,cons);			cons.gridx = 0;			cons.gridwidth = 2;			cons.insets = new Insets(0,0,0,0);				replace = new HistoryTextArea("replace");			replace.setName("replace");			replace.setToolTipText(jEdit.getProperty("search.find.tooltip"));			label.setLabelFor(replace);				cons.gridx = 0;			cons.gridy++;			cons.weightx = 1.0;			cons.weighty = 1.0;			fieldPanel.add(new JScrollPane(replace),cons);			cons.gridy++;		}	
private JPanel createFieldPanel()		{			JPanel fieldPanel = new JPanel(new GridBagLayout());			fieldPanel.setBorder(new EmptyBorder(0,0,12,12));				GridBagConstraints cons = new GridBagConstraints();			cons.fill = GridBagConstraints.BOTH;			cons.gridy = 0;			cons.gridwidth = 2;				createFindLabelAndField(fieldPanel,cons);			createReplaceLabelAndField(fieldPanel,cons);				return fieldPanel;		}	
private JPanel createSearchSettingsPanel()		{			JPanel searchSettings = new JPanel(new VariableGridLayout(				VariableGridLayout.FIXED_NUM_COLUMNS,3));			searchSettings.setBorder(new EmptyBorder(0,0,12,12));				SettingsActionHandler actionHandler = new SettingsActionHandler();			ButtonGroup fileset = new ButtonGroup();			ButtonGroup direction = new ButtonGroup();				searchSettings.add(new JLabel(jEdit.getProperty("search.fileset")));				searchSettings.add(new JLabel(jEdit.getProperty("search.settings")));				searchSettings.add(new JLabel(jEdit.getProperty("search.direction")));				searchSelection = new JRadioButton(jEdit.getProperty("search.selection"));			searchSelection.setMnemonic(jEdit.getProperty("search.selection.mnemonic")				.charAt(0));			fileset.add(searchSelection);			searchSettings.add(searchSelection);			searchSelection.addActionListener(actionHandler);				keepDialog = new JCheckBox(jEdit.getProperty("search.keep"));			keepDialog.setMnemonic(jEdit.getProperty("search.keep.mnemonic")				.charAt(0));			searchSettings.add(keepDialog);				searchBack = new JRadioButton(jEdit.getProperty("search.back"));			searchBack.setMnemonic(jEdit.getProperty("search.back.mnemonic")				.charAt(0));			direction.add(searchBack);			searchSettings.add(searchBack);			searchBack.addActionListener(actionHandler);				searchCurrentBuffer = new JRadioButton(jEdit.getProperty("search.current"));			searchCurrentBuffer.setMnemonic(jEdit.getProperty("search.current.mnemonic")				.charAt(0));			fileset.add(searchCurrentBuffer);			searchSettings.add(searchCurrentBuffer);			searchCurrentBuffer.addActionListener(actionHandler);				ignoreCase = new JCheckBox(jEdit.getProperty("search.case"));			ignoreCase.setMnemonic(jEdit.getProperty("search.case.mnemonic")				.charAt(0));			searchSettings.add(ignoreCase);			ignoreCase.addActionListener(actionHandler);				searchForward = new JRadioButton(jEdit.getProperty("search.forward"));			searchForward.setMnemonic(jEdit.getProperty("search.forward.mnemonic")				.charAt(0));			direction.add(searchForward);			searchSettings.add(searchForward);			searchForward.addActionListener(actionHandler);				searchAllBuffers = new JRadioButton(jEdit.getProperty("search.all"));			searchAllBuffers.setMnemonic(jEdit.getProperty("search.all.mnemonic")				.charAt(0));			fileset.add(searchAllBuffers);			searchSettings.add(searchAllBuffers);			searchAllBuffers.addActionListener(actionHandler);				regexp = new JCheckBox(jEdit.getProperty("search.regexp"));			regexp.setMnemonic(jEdit.getProperty("search.regexp.mnemonic")				.charAt(0));			searchSettings.add(regexp);			regexp.addActionListener(actionHandler);				wrap = new JCheckBox(jEdit.getProperty("search.wrap"));			wrap.setMnemonic(jEdit.getProperty("search.wrap.mnemonic")				.charAt(0));			searchSettings.add(wrap);			wrap.addActionListener(actionHandler);				searchDirectory = new JRadioButton(jEdit.getProperty("search.directory"));			searchDirectory.setMnemonic(jEdit.getProperty("search.directory.mnemonic")				.charAt(0));			fileset.add(searchDirectory);			searchSettings.add(searchDirectory);			searchDirectory.addActionListener(actionHandler);				hyperSearch = new JCheckBox(jEdit.getProperty("search.hypersearch"));			hyperSearch.setMnemonic(jEdit.getProperty("search.hypersearch.mnemonic")				.charAt(0));			searchSettings.add(hyperSearch);			hyperSearch.addActionListener(actionHandler);				return searchSettings;		}	
private JPanel createMultiFilePanel()		{			JPanel multifile = new JPanel();				GridBagLayout layout = new GridBagLayout();			multifile.setLayout(layout);				GridBagConstraints cons = new GridBagConstraints();			cons.gridy = cons.gridwidth = cons.gridheight = 1;			cons.anchor = GridBagConstraints.WEST;			cons.fill = GridBagConstraints.HORIZONTAL;				MultiFileActionHandler actionListener = new MultiFileActionHandler();			filter = new HistoryTextField("search.filter");						filter.setToolTipText(jEdit.getProperty("glob.tooltip"));			filter.addActionListener(actionListener);				cons.insets = new Insets(0,0,3,0);				JLabel label = new JLabel(jEdit.getProperty("search.filterField"),				SwingConstants.RIGHT);			label.setBorder(new EmptyBorder(0,0,0,12));			label.setDisplayedMnemonic(jEdit.getProperty("search.filterField.mnemonic")				.charAt(0));			label.setLabelFor(filter);			cons.weightx = 0.0;			layout.setConstraints(label,cons);			multifile.add(label);				cons.gridwidth = 2;			cons.insets = new Insets(0,0,3,6);			cons.weightx = 1.0;			layout.setConstraints(filter,cons);			multifile.add(filter);				cons.gridwidth = 1;			cons.weightx = 0.0;			cons.insets = new Insets(0,0,3,0);				synchronize = new JButton(jEdit.getProperty(				"search.synchronize"));			synchronize.setToolTipText(jEdit.getProperty(				"search.synchronize.tooltip"));			synchronize.setMnemonic(jEdit.getProperty(				"search.synchronize.mnemonic")				.charAt(0));			synchronize.addActionListener(actionListener);			layout.setConstraints(synchronize,cons);			multifile.add(synchronize);				cons.gridy++;				directory = new HistoryTextField("search.directory");			directory.setColumns(25);			directory.addActionListener(actionListener);				label = new JLabel(jEdit.getProperty("search.directoryField"),				SwingConstants.RIGHT);			label.setBorder(new EmptyBorder(0,0,0,12));				label.setDisplayedMnemonic(jEdit.getProperty("search.directoryField.mnemonic")				.charAt(0));			label.setLabelFor(directory);			cons.insets = new Insets(0,0,3,0);			cons.weightx = 0.0;			layout.setConstraints(label,cons);			multifile.add(label);				cons.insets = new Insets(0,0,3,6);			cons.weightx = 1.0;			cons.gridwidth = 2;			layout.setConstraints(directory,cons);			multifile.add(directory);				choose = new JButton(jEdit.getProperty("search.choose"));			choose.setMnemonic(jEdit.getProperty("search.choose.mnemonic")				.charAt(0));			cons.insets = new Insets(0,0,3,0);			cons.weightx = 0.0;			cons.gridwidth = 1;			layout.setConstraints(choose,cons);			multifile.add(choose);			choose.addActionListener(actionListener);				cons.insets = new Insets(0,0,0,0);			cons.gridy++;			cons.gridwidth = 3;				JPanel dirCheckBoxPanel = new JPanel();	 		searchSubDirectories = new JCheckBox(jEdit.getProperty(	 			"search.subdirs"));	 		String mnemonic = jEdit.getProperty(				"search.subdirs.mnemonic");			searchSubDirectories.setMnemonic(mnemonic.charAt(0));			searchSubDirectories.setSelected(jEdit.getBooleanProperty("search.subdirs.toggle"));			skipHidden = new JCheckBox(jEdit.getProperty("search.skipHidden"));			skipHidden.setSelected(jEdit.getBooleanProperty("search.skipHidden.toggle", true));			skipBinaryFiles = new JCheckBox(jEdit.getProperty("search.skipBinary"));			skipBinaryFiles.setSelected(jEdit.getBooleanProperty("search.skipBinary.toggle", true));			dirCheckBoxPanel.add(searchSubDirectories);			dirCheckBoxPanel.add(skipHidden);			dirCheckBoxPanel.add(skipBinaryFiles);				cons.insets = new Insets(0, 0, 0, 0);			cons.gridy++;			cons.gridwidth = 4;			layout.setConstraints(dirCheckBoxPanel, cons);		 		multifile.add(dirCheckBoxPanel);				return multifile;		}	
private Box createButtonsPanel()		{			Box box = new Box(BoxLayout.Y_AXIS);				ButtonActionHandler actionHandler = new ButtonActionHandler();				box.add(Box.createVerticalStrut(12));				JPanel grid = new JPanel(new GridLayout(5,1,0,12));				findBtn = new JButton(jEdit.getProperty("search.findBtn"));			/* findBtn.setMnemonic(jEdit.getProperty("search.findBtn.mnemonic")				.charAt(0)); */			getRootPane().setDefaultButton(findBtn);			grid.add(findBtn);			findBtn.addActionListener(actionHandler);				/* replaceBtn = new JButton(jEdit.getProperty("search.replaceBtn"));			replaceBtn.setMnemonic(jEdit.getProperty("search.replaceBtn.mnemonic")				.charAt(0));			grid.add(replaceBtn);			replaceBtn.addActionListener(actionHandler); */				replaceAndFindBtn = new JButton(jEdit.getProperty("search.replaceAndFindBtn"));			replaceAndFindBtn.setMnemonic(jEdit.getProperty("search.replaceAndFindBtn.mnemonic")				.charAt(0));			grid.add(replaceAndFindBtn);			replaceAndFindBtn.addActionListener(actionHandler);				replaceAllBtn = new JButton(jEdit.getProperty("search.replaceAllBtn"));			replaceAllBtn.setMnemonic(jEdit.getProperty("search.replaceAllBtn.mnemonic")				.charAt(0));			grid.add(replaceAllBtn);			replaceAllBtn.addActionListener(actionHandler);				closeBtn = new JButton(jEdit.getProperty("common.close"));			grid.add(closeBtn);			closeBtn.addActionListener(actionHandler);				grid.setMaximumSize(grid.getPreferredSize());				box.add(grid);			box.add(Box.createGlue());				return box;		}	
private void updateEnabled()		{			wrap.setEnabled(!hyperSearch.isSelected()				&& !searchSelection.isSelected());				boolean reverseEnabled = !hyperSearch.isSelected()				&& searchCurrentBuffer.isSelected();			searchBack.setEnabled(reverseEnabled);			searchForward.setEnabled(reverseEnabled);			if(!reverseEnabled)				searchForward.setSelected(true);				filter.setEnabled(searchAllBuffers.isSelected()				|| searchDirectory.isSelected());				boolean searchDirs = searchDirectory.isSelected();			directory.setEnabled(searchDirs);			choose.setEnabled(searchDirs);			searchSubDirectories.setEnabled(searchDirs);			skipHidden.setEnabled(searchDirs);			skipBinaryFiles.setEnabled(searchDirs);						synchronize.setEnabled(searchAllBuffers.isSelected()				|| searchDirectory.isSelected());				findBtn.setEnabled(!searchSelection.isSelected()				|| hyperSearch.isSelected());			replaceAndFindBtn.setEnabled(!hyperSearch.isSelected()				&& !searchSelection.isSelected());		}	
/**		 * @param cancel If true, we don't bother the user with warning messages		 */		private boolean save(boolean cancel)		{			try			{				// prevents us from handling SearchSettingsChanged				// as a result of below				saving = true;				SearchAndReplace.setIgnoreCase(ignoreCase.isSelected());				SearchAndReplace.setRegexp(regexp.isSelected());				SearchAndReplace.setReverseSearch(searchBack.isSelected());				SearchAndReplace.setAutoWrapAround(wrap.isSelected());				jEdit.setBooleanProperty("search.subdirs.toggle", searchSubDirectories.isSelected());				jEdit.setBooleanProperty("search.skipHidden.toggle", skipHidden.isSelected());				jEdit.setBooleanProperty("search.skipBinary.toggle", skipBinaryFiles.isSelected());					String filter = this.filter.getText();				this.filter.addCurrentToHistory();				if(filter.length() == 0)					filter = "*";					SearchFileSet fileset = SearchAndReplace.getSearchFileSet();					boolean recurse = searchSubDirectories.isSelected();					if(searchSelection.isSelected())					fileset = new CurrentBufferSet();				else if(searchCurrentBuffer.isSelected())				{					fileset = new CurrentBufferSet();						jEdit.setBooleanProperty("search.hypersearch.toggle",						hyperSearch.isSelected());				}				else if(searchAllBuffers.isSelected())					fileset = new AllBufferSet(filter);				else if(searchDirectory.isSelected())				{					String directory = this.directory.getText();					this.directory.addCurrentToHistory();					directory = MiscUtilities.constructPath(						view.getBuffer().getDirectory(),directory);						if((VFSManager.getVFSForPath(directory).getCapabilities()						& VFS.LOW_LATENCY_CAP) == 0)					{						if(cancel)							return false;							int retVal = GUIUtilities.confirm(							this,"remote-dir-search",							null,JOptionPane.YES_NO_OPTION,							JOptionPane.WARNING_MESSAGE);						if(retVal != JOptionPane.YES_OPTION)							return false;					}						if(fileset instanceof DirectoryListSet)					{						DirectoryListSet dset = (DirectoryListSet)fileset;						dset.setDirectory(directory);						dset.setFileFilter(filter);						dset.setRecursive(recurse);						EditBus.send(new SearchSettingsChanged(null));					}					else						fileset = new DirectoryListSet(directory,filter,recurse);				}				else				{					// can't happen					fileset = null;				}					jEdit.setBooleanProperty("search.subdirs.toggle",					recurse);				jEdit.setBooleanProperty("search.keepDialog.toggle",					keepDialog.isSelected());					SearchAndReplace.setSearchFileSet(fileset);					replace.addCurrentToHistory();				SearchAndReplace.setReplaceString(replace.getText());					if(find.getText().length() == 0)				{					if(!cancel)						getToolkit().beep();					return false;				}					find.addCurrentToHistory();				SearchAndReplace.setSearchString(find.getText());					return true;			}			finally			{				saving = false;			}		}	
private void closeOrKeepDialog()		{			if(keepDialog.isSelected())			{				// Windows bug workaround in case a YES/NO confirm				// was shown					// ... but if HyperSearch results window is floating,				// the workaround causes problems!				if(!hyperSearch.isSelected())				{					toFront();					requestFocus();					find.requestFocus();				}			}			else			{				GUIUtilities.saveGeometry(this,"search");				setVisible(false);			}		}	
private void load()		{			ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());			regexp.setSelected(SearchAndReplace.getRegexp());			wrap.setSelected(SearchAndReplace.getAutoWrapAround());				if(SearchAndReplace.getReverseSearch())				searchBack.setSelected(true);			else				searchForward.setSelected(true);				if(SearchAndReplace.getBeanShellReplace())			{				replace.setModel("replace.script");				beanShellReplace.setSelected(true);			}			else			{				replace.setModel("replace");				stringReplace.setSelected(true);			}				SearchFileSet fileset = SearchAndReplace.getSearchFileSet();				HistoryModel model = filter.getModel();			if(model.getSize() != 0)				filter.setText(model.getItem(0));			else			{				filter.setText('*' + MiscUtilities					.getFileExtension(view.getBuffer()					.getName()));			}			model = directory.getModel();			if(model.getSize() != 0)				directory.setText(model.getItem(0));			else				directory.setText(view.getBuffer().getDirectory());				searchSubDirectories.setSelected(jEdit.getBooleanProperty(				"search.subdirs.toggle"));				if(fileset instanceof DirectoryListSet)			{				filter.setText(((DirectoryListSet)fileset)					.getFileFilter());				directory.setText(((DirectoryListSet)fileset)					.getDirectory());				searchSubDirectories.setSelected(((DirectoryListSet)fileset)					.isRecursive());			}			else if(fileset instanceof AllBufferSet)			{				filter.setText(((AllBufferSet)fileset)					.getFileFilter());			}				directory.addCurrentToHistory();				keepDialog.setSelected(jEdit.getBooleanProperty(				"search.keepDialog.toggle"));		}	
MyJRadioButton(String label)			{				super(label);			}	
@Override			public boolean isFocusable()			{				return false;			}	
public void actionPerformed(ActionEvent evt)			{				replace.setModel(beanShellReplace.isSelected()					? "replace.script"					: "replace");				SearchAndReplace.setBeanShellReplace(					beanShellReplace.isSelected());			}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();					if(source == searchCurrentBuffer)					hyperSearch.setSelected(false);				else if(source == searchSelection					|| source == searchAllBuffers					|| source == searchDirectory)					hyperSearch.setSelected(true);					save(true);				updateEnabled();			}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == choose)				{					String[] dirs = GUIUtilities.showVFSFileDialog(						SearchDialog.this,						view,directory.getText(),						VFSBrowser.CHOOSE_DIRECTORY_DIALOG,						false);					if(dirs != null)						directory.setText(dirs[0]);				}				else if(evt.getSource() == synchronize)				{					synchronizeMultiFileSettings();				}				else // source is directory or filter field				{					// just as if Enter was pressed in another					// text field					ok();				}			}	
private void synchronizeMultiFileSettings()			{				directory.setText(view.getBuffer().getDirectory());					SearchFileSet fileset = SearchAndReplace.getSearchFileSet();					if(fileset instanceof AllBufferSet)				{					filter.setText(((AllBufferSet)fileset)						.getFileFilter());				}				else				{					filter.setText('*' + MiscUtilities						.getFileExtension(view.getBuffer()						.getName()));				}			}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();					if(source == closeBtn)					cancel();				else if(source == findBtn || source == find					|| source == replace)				{					ok();				}				else if(source == replaceAndFindBtn)				{					save(false);					if(SearchAndReplace.replace(view))						ok();					else						getToolkit().beep();				}				else if(source == replaceAllBtn)				{					if(searchSelection.isSelected() &&						view.getTextArea().getSelectionCount()						== 0)					{						GUIUtilities.error(view,"search-no-selection",null);						return;					}						setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));						if(!save(false))					{						setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));						getToolkit().beep();						return;					}						if(searchSelection.isSelected())					{						if(SearchAndReplace.replace(view))							closeOrKeepDialog();						else							getToolkit().beep();					}					else					{						if(SearchAndReplace.replaceAll(view))							closeOrKeepDialog();						else							getToolkit().beep();					}						setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));				}			}	
public SearchMatcher()		{			returnValue = new Match();		}	
/**		 * Creates a new search and replace settings changed message.		 * @param source The message source		 */		public SearchSettingsChanged(EBComponent source)		{			super(source);		}	
public SegmentBuffer(int capacity)		{			ensureCapacity(capacity);		}	
public void append(char ch)		{			ensureCapacity(count + 1);			array[offset + count] = ch;			count++;		}	
public void append(char[] text, int off, int len)		{			ensureCapacity(count + len);			System.arraycopy(text,off,array,count,len);			count += len;		}	
private void ensureCapacity(int capacity)		{			if(array == null)				array = new char[capacity];			else if(capacity >= array.length)			{				char[] arrayN = new char[capacity * 2];				System.arraycopy(array,0,arrayN,0,count);				array = arrayN;			}		}	
public SegmentCharSequence(Segment seg)		{			this(seg, false);		}	
/**		 * @deprecated		 *   Use ReverseCharSequence to get reverse view of this class (or		 *   any other CharSequence). This class doesn't support		 *   subSequence() and toString() for reversed instance.		 */		@Deprecated		public SegmentCharSequence(Segment seg, boolean reverse)		{			this(seg, 0, seg.count);			this.reverse = reverse;		}	
public SegmentCharSequence(Segment seg, int off, int len)		{			this.offset = off;			this.length = len;			this.seg = seg;		}	
public char charAt(int index)		{			if (reverse)				index = length - index - 1;			return seg.array[seg.offset + offset + index];		}	
public int length()		{			return length;		}	
public CharSequence subSequence(int start, int end)		{			if (reverse)				throw new IllegalStateException("reverse sub-sequences are not supported");			return new SegmentCharSequence(seg, offset + start, end - start);		}	
public String toString()		{			return new String(seg.array, offset+seg.offset, length);		}	
/**		 * Returns the start offset of this selection.		 */		public int getStart()		{			return start;		}	
/**		 * Returns the end offset of this selection.		 */		public int getEnd()		{			return end;		}	
/**		 * Returns the starting line number of this selection.		 */		public int getStartLine()		{			return startLine;		}	
/**		 * Returns the ending line number of this selection.		 */		public int getEndLine()		{			return endLine;		}	
/**		 * Returns if this selection and the specified selection overlap.		 * @param s The other selection		 * @since jEdit 4.1pre1		 */		public boolean overlaps(Selection s)		{			if((start >= s.start && start <= s.end)				|| (end >= s.start && end <= s.end))				return true;			else				return false;		}	
@Override		public String toString()		{			return getClass().getName() + "[start=" + start				+ ",end=" + end + ",startLine=" + startLine				+ ",endLine=" + endLine + ']';		}	
@Override		public Object clone()		{			try			{				return super.clone();			}			catch(CloneNotSupportedException e)			{				throw new InternalError("I just drank a whole "					+ "bottle of cough syrup and I feel "					+ "funny!");			}		}	
protected Selection()		{		}	
protected Selection(Selection sel)		{			this.start = sel.start;			this.end = sel.end;		}	
protected Selection(int start, int end)		{			this.start = start;			this.end = end;		}	
public Range()			{			}	
public Range(Selection sel)			{				super(sel);			}	
public Range(int start, int end)			{				super(start,end);			}	
@Override			public int getStart(JEditBuffer buffer, int line)			{				if(line == startLine)					return start;				else					return buffer.getLineStartOffset(line);			}	
@Override			public int getEnd(JEditBuffer buffer, int line)			{				if(line == endLine)					return end;				else					return buffer.getLineEndOffset(line) - 1;			}	
@Override			void getText(JEditBuffer buffer, StringBuilder buf)			{				buf.append(buffer.getText(start,end - start));			}	
/**			 * Replace the selection with the given text			 * @param buffer the buffer			 * @param text the text			 * @return the offset at the end of the inserted text			 */			@Override			int setText(JEditBuffer buffer, String text)			{				buffer.remove(start,end - start);				if(text != null && text.length() != 0)				{					buffer.insert(start,text);					return start + text.length();				}				else					return start;			}	
@Override			boolean contentInserted(JEditBuffer buffer, int startLine, int start,				int numLines, int length)			{				boolean changed = false;					if(this.start >= start)				{					this.start += length;					if(numLines != 0)						this.startLine = buffer.getLineOfOffset(this.start);					changed = true;				}					if(this.end >= start)				{					this.end += length;					if(numLines != 0)						this.endLine = buffer.getLineOfOffset(this.end);					changed = true;				}					return changed;			}	
@Override			boolean contentRemoved(JEditBuffer buffer, int startLine, int start,				int numLines, int length)			{				int end = start + length;				boolean changed = false;					if(this.start > start && this.start <= end)				{					this.start = start;					changed = true;				}				else if(this.start > end)				{					this.start -= length;					changed = true;				}					if(this.end > start && this.end <= end)				{					this.end = start;					changed = true;				}				else if(this.end > end)				{					this.end -= length;					changed = true;				}					if(changed && numLines != 0)				{					this.startLine = buffer.getLineOfOffset(this.start);					this.endLine = buffer.getLineOfOffset(this.end);				}					return changed;			}	
public Rect()			{			}	
public Rect(Selection sel)			{				super(sel);			}	
public Rect(int start, int end)			{				super(start,end);			}	
public Rect(int startLine, int start, int endLine, int end)			{				this.startLine = startLine;				this.start = start;				this.endLine = endLine;				this.end = end;			}	
public Rect(JEditBuffer buffer, int startLine, int startColumn,				int endLine, int endColumn)			{				this.startLine = startLine;				this.endLine = endLine;					int[] width = new int[1];				int startOffset = buffer.getOffsetOfVirtualColumn(startLine,					startColumn,width);				if(startOffset == -1)				{					extraStartVirt = startColumn - width[0];					//startOffset = buffer.getLineEndOffset(startLine) - 1;				}				/*else					startOffset += buffer.getLineStartOffset(startLine);*/					int endOffset = buffer.getOffsetOfVirtualColumn(endLine,					endColumn,width);				if(endOffset == -1)				{					extraEndVirt = endColumn - width[0];					//endOffset = buffer.getLineEndOffset(endLine) - 1;				}				/*else					endOffset += buffer.getLineStartOffset(endLine);*/			}	
public int getStartColumn(JEditBuffer buffer)			{				int virtColStart = buffer.getVirtualWidth(startLine,					start - buffer.getLineStartOffset(startLine)) + extraStartVirt;				int virtColEnd = buffer.getVirtualWidth(endLine,					end - buffer.getLineStartOffset(endLine)) + extraEndVirt;				return Math.min(virtColStart,virtColEnd);			}	
public int getEndColumn(JEditBuffer buffer)			{				int virtColStart = buffer.getVirtualWidth(startLine,					start - buffer.getLineStartOffset(startLine)) + extraStartVirt;				int virtColEnd = buffer.getVirtualWidth(endLine,					end - buffer.getLineStartOffset(endLine)) + extraEndVirt;				return Math.max(virtColStart,virtColEnd);			}	
@Override			public int getStart(JEditBuffer buffer, int line)			{				return getColumnOnOtherLine(buffer,line,					getStartColumn(buffer));			}	
@Override			public int getEnd(JEditBuffer buffer, int line)			{				return getColumnOnOtherLine(buffer,line,					getEndColumn(buffer));			}	
@Override			void getText(JEditBuffer buffer, StringBuilder buf)			{				int start = getStartColumn(buffer);				int end = getEndColumn(buffer);					for(int i = startLine; i <= endLine; i++)				{					int lineStart = buffer.getLineStartOffset(i);					int lineLen = buffer.getLineLength(i);						int rectStart = buffer.getOffsetOfVirtualColumn(						i,start,null);					if(rectStart == -1)						rectStart = lineLen;						int rectEnd = buffer.getOffsetOfVirtualColumn(						i,end,null);					if(rectEnd == -1)						rectEnd = lineLen;						if(rectEnd < rectStart)						System.err.println(i + ":::" + start + ':' + end							+ " ==> " + rectStart + ':' + rectEnd);					buf.append(buffer.getText(lineStart + rectStart,						rectEnd - rectStart));						if(i != endLine)						buf.append('\n');				}			}	
/**			 * Replace the selection with the given text			 * @param buffer the buffer			 * @param text the text			 * @return the offset at the end of the inserted text			 */			@Override			int setText(JEditBuffer buffer, String text)			{				int startColumn = getStartColumn(buffer);				int endColumn = getEndColumn(buffer);					int tabSize = buffer.getTabSize();					int maxWidth = 0;				int totalLines = 0;				/** This list will contains Strings and Integer. */				List<Object> lines = new ArrayList<Object>();					//{{{ Split the text into lines				if(text != null)				{					int lastNewline = 0;					int currentWidth = startColumn;					for(int i = 0; i < text.length(); i++)					{						char ch = text.charAt(i);						if(ch == '\n')						{							totalLines++;							lines.add(text.substring(								lastNewline,i));							lastNewline = i + 1;							maxWidth = Math.max(maxWidth,currentWidth);							lines.add(currentWidth);							currentWidth = startColumn;						}						else if(ch == '\t')							currentWidth += tabSize - (currentWidth % tabSize);						else							currentWidth++;					}						if(lastNewline != text.length())					{						totalLines++;						lines.add(text.substring(lastNewline));						lines.add(currentWidth);						maxWidth = Math.max(maxWidth,currentWidth);					}				} //}}}					//{{{ Insert the lines into the buffer				int endOffset = 0;				int[] total = new int[1];				int lastLine = Math.max(startLine + totalLines - 1,endLine);				for(int i = startLine; i <= lastLine; i++)				{					if(i == buffer.getLineCount())						buffer.insert(buffer.getLength(),"\n");						int lineStart = buffer.getLineStartOffset(i);					int lineLen = buffer.getLineLength(i);						int rectStart = buffer.getOffsetOfVirtualColumn(						i,startColumn,total);					int startWhitespace;					if(rectStart == -1)					{						startWhitespace = startColumn - total[0];						rectStart = lineLen;					}					else						startWhitespace = 0;						int rectEnd = buffer.getOffsetOfVirtualColumn(						i,endColumn,null);					if(rectEnd == -1)						rectEnd = lineLen;						buffer.remove(rectStart + lineStart,rectEnd - rectStart);						if(startWhitespace != 0)					{						buffer.insert(rectStart + lineStart,							StandardUtilities.createWhiteSpace(startWhitespace,0));					}						int endWhitespace;					if(totalLines == 0)					{						if(rectEnd == lineLen)							endWhitespace = 0;						else							endWhitespace = maxWidth - startColumn;					}					else					{						int index = 2 * ((i - startLine) % totalLines);						String str = (String)lines.get(index);						buffer.insert(rectStart + lineStart + startWhitespace,str);						if(rectEnd == lineLen)							endWhitespace = 0;						else						{							endWhitespace = maxWidth								- (Integer) lines.get(index + 1);						}						startWhitespace += str.length();					}						if(endWhitespace != 0)					{						buffer.insert(rectStart + lineStart							+ startWhitespace,							StandardUtilities.createWhiteSpace(endWhitespace,0));					}						endOffset = rectStart + lineStart						+ startWhitespace						+ endWhitespace;				} //}}}					//{{{ Move the caret down a line				if(text == null || text.length() == 0)					return end;				else					return endOffset;				//}}}			}	
@Override			boolean contentInserted(JEditBuffer buffer, int startLine, int start,				int numLines, int length)			{				if(this.end < start)					return false;					this.end += length;					if(this.startLine > startLine)				{					this.start += length;					if(numLines != 0)					{						this.startLine = buffer.getLineOfOffset(							this.start);						this.endLine = buffer.getLineOfOffset(							this.end);					}					return true;				}					int endVirtualColumn = buffer.getVirtualWidth(					this.endLine,end					- buffer.getLineStartOffset(this.endLine));					if(this.start == start)				{					int startVirtualColumn = buffer.getVirtualWidth(						this.startLine,start						- buffer.getLineStartOffset(						this.startLine));						this.start += length;						int newStartVirtualColumn						= buffer.getVirtualWidth(							startLine,start -							buffer.getLineStartOffset(							this.startLine));						int[] totalVirtualWidth = new int[1];					int newEnd = buffer.getOffsetOfVirtualColumn(						this.endLine,endVirtualColumn +						newStartVirtualColumn -						startVirtualColumn,						totalVirtualWidth);						if(newEnd != -1)					{						end = buffer.getLineStartOffset(							this.endLine) + newEnd;					}					else					{						end = buffer.getLineEndOffset(							this.endLine) - 1;						extraEndVirt = totalVirtualWidth[0]							- endVirtualColumn;					}				}				else if(this.start > start)				{					this.start += length;					if(numLines != 0)					{						this.startLine = buffer.getLineOfOffset(							this.start);					}				}					if(numLines != 0)					this.endLine = buffer.getLineOfOffset(this.end);				int newEndVirtualColumn = buffer.getVirtualWidth(					endLine,					end - buffer.getLineStartOffset(this.endLine));				if(startLine == this.endLine && extraEndVirt != 0)				{					extraEndVirt += endVirtualColumn - newEndVirtualColumn;				}				else if(startLine == this.startLine					&& extraStartVirt != 0)				{					extraStartVirt += endVirtualColumn - newEndVirtualColumn;				}					return true;			}	
@Override			boolean contentRemoved(JEditBuffer buffer, int startLine, int start,				int numLines, int length)			{				int end = start + length;				boolean changed = false;					if(this.start > start && this.start <= end)				{					this.start = start;					changed = true;				}				else if(this.start > end)				{					this.start -= length;					changed = true;				}					if(this.end > start && this.end <= end)				{					this.end = start;					changed = true;				}				else if(this.end > end)				{					this.end -= length;					changed = true;				}					if(changed && numLines != 0)				{					this.startLine = buffer.getLineOfOffset(this.start);					this.endLine = buffer.getLineOfOffset(this.end);				}					return changed;			}	
private static int getColumnOnOtherLine(JEditBuffer buffer, int line,				int col)			{				int returnValue = buffer.getOffsetOfVirtualColumn(					line,col,null);				if(returnValue == -1)					return buffer.getLineEndOffset(line) - 1;				else					return buffer.getLineStartOffset(line) + returnValue;			}	
public Widget getWidget(View view)		{			Widget selectionLengthWidget = new SelectionLengthWidget(view);			return selectionLengthWidget;		}	
SelectionLengthWidget(View view)			{				this.view = view;				textArea = view.getTextArea();				selectionLength = new SelectionLength();				selectionLength.setForeground(jEdit.getColorProperty("view.status.foreground"));				selectionLength.setBackground(jEdit.getColorProperty("view.status.background"));			}	
public JComponent getComponent()			{				return selectionLength;			}	
public void update()			{			}	
public void propertiesChanged()			{			}	
public void handleMessage(EBMessage message)			{				if (message instanceof ViewUpdate)				{					ViewUpdate viewUpdate = (ViewUpdate) message;					if (viewUpdate.getView() == view && viewUpdate.getWhat() == ViewUpdate.EDIT_PANE_CHANGED)					{						if (textArea != null)						{							textArea.removeCaretListener(selectionLength);						}						textArea = view.getTextArea();						if (selectionLength.visible)							textArea.addCaretListener(selectionLength);					}				}			}	
@Override				public void addNotify()				{					super.addNotify();					visible = true;					textArea.addCaretListener(this);				}	
@Override				public void removeNotify()				{					visible = false;					textArea.removeCaretListener(this);					super.removeNotify();				}	
public void caretUpdate(CaretEvent e)				{					Selection selection = textArea.getSelectionAtOffset(textArea.getCaretPosition());					if (selection == null)					{						setText("");					}					else					{						int selectionEnd = selection.getEnd();						int selectionStart = selection.getStart();						int len;						if (selection instanceof Selection.Rect)						{							int startLine = selection.getStartLine();							int endLine = selection.getEndLine();							JEditTextArea textArea = view.getTextArea();							int startLineOffset = textArea.getLineStartOffset(startLine);							int endLineOffset = textArea.getLineStartOffset(endLine);							int lines = endLine - startLine + 1;							int columns = (selectionEnd - endLineOffset) -								(selectionStart - startLineOffset);							len = lines * columns;						}						else							len = selectionEnd - selectionStart;						setText(Integer.toString(len));					}				}	
SelectionManager(TextArea textArea)		{			this.textArea = textArea;			selection = new ArrayList<Selection>();		}	
/**		 * Returns the number of selections. This can be used to test		 * for the existence of selections.		 */		int getSelectionCount()		{			return selection.size();		}	
/**		 * Returns the current selection.		 * @since jEdit 3.2pre1		 */		public Selection[] getSelection()		{			return selection.toArray(				new Selection[selection.size()]);		}	
/**		 * Sets the selection. Nested and overlapping selections are merged		 * where possible.		 */		void setSelection(Selection[] selection)		{			this.selection.clear();			addToSelection(selection);		}	
/**		 * Adds to the selection. Nested and overlapping selections are merged		 * where possible. Null elements of the array are ignored.		 * @param selection The new selection		 * since jEdit 3.2pre1		 */		void addToSelection(Selection[] selection)		{			if(selection != null)			{				for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					if(s != null)						addToSelection(s);				}			}		}	
void addToSelection(Selection addMe)		{			if(addMe.start > addMe.end)			{				throw new IllegalArgumentException(addMe.start					+ " > " + addMe.end);			}			else if(addMe.start == addMe.end)			{				if(addMe instanceof Selection.Range)					return;				else if(addMe instanceof Selection.Rect)				{					if(((Selection.Rect)addMe).extraEndVirt == 0)						return;				}			}				Iterator<Selection> iter = selection.iterator();			while(iter.hasNext())			{				// try and merge existing selections one by				// one with the new selection				Selection s = iter.next();				if(s.overlaps(addMe))				{					addMe.start = Math.min(s.start,addMe.start);					addMe.end = Math.max(s.end,addMe.end);					iter.remove();				}			}				addMe.startLine = textArea.getLineOfOffset(addMe.start);			addMe.endLine = textArea.getLineOfOffset(addMe.end);				boolean added = false;				for(int i = 0; i < selection.size(); i++)			{				Selection s = selection.get(i);				if(addMe.start < s.start)				{					selection.add(i,addMe);					added = true;					break;				}			}				if(!added)				selection.add(addMe);				textArea.invalidateLineRange(addMe.startLine,addMe.endLine);		}	
/**		 * Sets the selection. Nested and overlapping selections are merged		 * where possible.		 */		void setSelection(Selection selection)		{			this.selection.clear();				if(selection != null)				addToSelection(selection);		}	
/**		 * Returns the selection containing the specific offset, or <code>null</code>		 * if there is no selection at that offset.		 * @param offset The offset		 * @since jEdit 3.2pre1		 */		Selection getSelectionAtOffset(int offset)		{			if(selection != null)			{				for (Selection s : selection)				{					if(offset >= s.start && offset <= s.end)						return s;				}			}				return null;		}	
/**		 * Deactivates the specified selection.		 * @param sel The selection		 */		void removeFromSelection(Selection sel)		{			selection.remove(sel);		}	
/**		 * Resizes the selection at the specified offset, or creates a new		 * one if there is no selection at the specified offset. This is a		 * utility method that is mainly useful in the mouse event handler		 * because it handles the case of end being before offset gracefully		 * (unlike the rest of the selection API).		 * @param offset The offset		 * @param end The new selection end		 * @param extraEndVirt Only for rectangular selections - specifies how		 * far it extends into virtual space.		 * @param rect Make the selection rectangular?		 */		void resizeSelection(int offset, int end, int extraEndVirt,			boolean rect)		{			boolean reversed = false;			if(end < offset)			{				int tmp = offset;				offset = end;				end = tmp;				reversed = true;			}				Selection newSel;			if(rect)			{				Selection.Rect rectSel = new Selection.Rect(offset,end);				if(reversed)					rectSel.extraStartVirt = extraEndVirt;				else					rectSel.extraEndVirt = extraEndVirt;				newSel = rectSel;			}			else				newSel = new Selection.Range(offset,end);				addToSelection(newSel);		}	
/**		 * Returns a sorted array of line numbers on which a selection or		 * selections are present.<p>		 *		 * This method is the most convenient way to iterate through selected		 * lines in a buffer. The line numbers in the array returned by this		 * method can be passed as a parameter to such methods as		 * {@link org.gjt.sp.jedit.Buffer#getLineText(int)}.		 */		int[] getSelectedLines()		{				Set<Integer> set = new TreeSet<Integer>();			for (Selection s : selection)			{				int endLine =					s.end == textArea.getLineStartOffset(s.endLine)					? s.endLine - 1					: s.endLine;					for(int j = s.startLine; j <= endLine; j++)				{					set.add(j);				}			}					int[] returnValue = new int[set.size()];			int i = 0;			for (Integer line : set)				returnValue[i++] = line;				return returnValue;		}	
void invertSelection()		{			Selection[] newSelection = new Selection[selection.size() + 1];			int lastOffset = 0;			for(int i = 0; i < selection.size(); i++)			{				Selection s = selection.get(i);				newSelection[i] = new Selection.Range(lastOffset,					s.getStart());				lastOffset = s.getEnd();			}			newSelection[selection.size()] = new Selection.Range(				lastOffset,textArea.getBufferLength());			setSelection(newSelection);		}	
/**		 * Returns the x co-ordinates of the selection start and end on the		 * given line. May return null.		 */		int[] getSelectionStartAndEnd(int screenLine, int physicalLine,			Selection s)		{			int start = textArea.getScreenLineStartOffset(screenLine);			int end = textArea.getScreenLineEndOffset(screenLine);				if(end <= s.start || start > s.end)				return null;				int selStartScreenLine;			if(textArea.displayManager.isLineVisible(s.startLine))				selStartScreenLine = textArea.getScreenLineOfOffset(s.start);			else				selStartScreenLine = -1;				int selEndScreenLine;			if(textArea.displayManager.isLineVisible(s.endLine))				selEndScreenLine = textArea.getScreenLineOfOffset(s.end);			else				selEndScreenLine = -1;				JEditBuffer buffer = textArea.getBuffer();				int lineStart = buffer.getLineStartOffset(physicalLine);			int x1, x2;				if(s instanceof Selection.Rect)			{				start -= lineStart;				end -= lineStart;					Selection.Rect rect = (Selection.Rect)s;				int _start = rect.getStartColumn(buffer);				int _end = rect.getEndColumn(buffer);					int lineLen = buffer.getLineLength(physicalLine);					int[] total = new int[1];					int rectStart = buffer.getOffsetOfVirtualColumn(					physicalLine,_start,total);				if(rectStart == -1)				{					x1 = (_start - total[0]) * textArea.charWidth;					rectStart = lineLen;				}				else					x1 = 0;					int rectEnd = buffer.getOffsetOfVirtualColumn(					physicalLine,_end,total);				if(rectEnd == -1)				{					x2 = (_end - total[0]) * textArea.charWidth;					rectEnd = lineLen;				}				else					x2 = 0;					if(end <= rectStart || start > rectEnd)					return null;					x1 = rectStart < start ? 0					: x1 + textArea.offsetToXY(physicalLine,					rectStart).x;				x2 = rectEnd > end ? textArea.getWidth()					: x2 + textArea.offsetToXY(physicalLine,					rectEnd).x;			}			else if(selStartScreenLine == selEndScreenLine				&& selStartScreenLine != -1)			{				x1 = textArea.offsetToXY(physicalLine,					s.start - lineStart).x;				x2 = textArea.offsetToXY(physicalLine,					s.end - lineStart).x;			}			else if(screenLine == selStartScreenLine)			{				x1 = textArea.offsetToXY(physicalLine,					s.start - lineStart).x;				x2 = textArea.getWidth();			}			else if(screenLine == selEndScreenLine)			{				x1 = 0;				x2 = textArea.offsetToXY(physicalLine,					s.end - lineStart).x;			}			else			{				x1 = 0;				x2 = textArea.getWidth();			}				if(x1 < 0)				x1 = 0;			if(x2 < 0)				x2 = 0;				if(x1 == x2)				x2++;				return new int[] { x1, x2 };		}	
/**		 * Returns if the given point is inside a selection.		 * Used by drag and drop code in MouseHandler below.		 */		boolean insideSelection(int x, int y)		{			int offset = textArea.xyToOffset(x,y);				Selection s = textArea.getSelectionAtOffset(offset);			if(s == null)				return false;				int screenLine = textArea.getScreenLineOfOffset(offset);			if(screenLine == -1)				return false;				int[] selectionStartAndEnd = getSelectionStartAndEnd(				screenLine,textArea.getLineOfOffset(offset),s);			if(selectionStartAndEnd == null)				return false;				return x >= selectionStartAndEnd[0]				&& x <= selectionStartAndEnd[1];		}	
public SelectLineRange(View view)		{			super(view,jEdit.getProperty("selectlinerange.title"),true);			this.view = view;				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,0));			setContentPane(content);				JLabel label = new JLabel(jEdit.getProperty(				"selectlinerange.caption"));			label.setBorder(new EmptyBorder(0,0,6,12));			content.add(BorderLayout.NORTH,label);				JPanel panel = createFieldPanel();				content.add(BorderLayout.CENTER,panel);				panel = new JPanel();			panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));			panel.setBorder(new EmptyBorder(6,0,0,12));			panel.add(Box.createGlue());			panel.add(Box.createGlue());			ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(this);			getRootPane().setDefaultButton(ok);			panel.add(ok);			panel.add(Box.createHorizontalStrut(6));			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(this);			panel.add(cancel);			panel.add(Box.createGlue());				content.add(panel,BorderLayout.SOUTH);				GUIUtilities.requestFocus(this,startField);				pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public void ok()		{			int startLine;			int endLine;				try			{				startLine = Integer.parseInt(startField.getText()) - 1;				endLine = Integer.parseInt(endField.getText()) - 1;			}			catch(NumberFormatException nf)			{				getToolkit().beep();				return;			}				Buffer buffer = view.getBuffer();				if(startLine < 0 || endLine >= buffer.getLineCount()				|| startLine > endLine)			{				getToolkit().beep();				return;			}				JEditTextArea textArea = view.getTextArea();			Selection s = new Selection.Range(				buffer.getLineStartOffset(startLine),				buffer.getLineEndOffset(endLine) - 1);			if(textArea.isMultipleSelectionEnabled())				textArea.addToSelection(s);			else				textArea.setSelection(s);			textArea.moveCaretPosition(buffer.getLineEndOffset(endLine) - 1);				dispose();		}	
public void cancel()		{			dispose();		}	
public void actionPerformed(ActionEvent evt)		{			Object source = evt.getSource();			if(source == ok)				ok();			else if(source == cancel)				cancel();		}	
private JPanel createFieldPanel()		{			GridBagLayout layout = new GridBagLayout();			JPanel panel = new JPanel(layout);				GridBagConstraints cons = new GridBagConstraints();			cons.insets = new Insets(0,0,6,12);			cons.gridwidth = cons.gridheight = 1;			cons.gridx = cons.gridy = 0;			cons.fill = GridBagConstraints.BOTH;			JLabel label = new JLabel(jEdit.getProperty("selectlinerange.start"),				SwingConstants.RIGHT);			layout.setConstraints(label,cons);			panel.add(label);				startField = new JTextField(10);			cons.gridx = 1;			cons.weightx = 1.0f;			layout.setConstraints(startField,cons);			panel.add(startField);				label = new JLabel(jEdit.getProperty("selectlinerange.end"),				SwingConstants.RIGHT);			cons.gridx = 0;			cons.weightx = 0.0f;			cons.gridy = 1;			layout.setConstraints(label,cons);			panel.add(label);				endField = new JTextField(10);			cons.gridx = 1;			cons.weightx = 1.0f;			layout.setConstraints(endField,cons);			panel.add(endField);				return panel;		}	
ServiceListHandler(PluginJAR plugin, URL uri)		{			this.plugin = plugin;			this.uri = uri;			code = new StringBuilder();			stateStack = new Stack<String>();			cachedServices = new LinkedList<ServiceManager.Descriptor>();		}	
public InputSource resolveEntity(String publicId, String systemId)		{			return XMLUtilities.findEntity(systemId, "services.dtd", getClass());		}	
public void characters(char[] c, int off, int len)		{			String tag = peekElement();			if (tag == "SERVICE")				code.append(c, off, len);		}	
public void startElement(String uri, String localName,					 String tag, Attributes attrs)		{			tag = pushElement(tag);			serviceName = attrs.getValue("NAME");			serviceClass = attrs.getValue("CLASS");		}	
public void endElement(String uri, String localName, String name)		{			String tag = peekElement();				if(name.equals(tag))			{				if (tag.equals("SERVICE"))				{					ServiceManager.Descriptor d =						new ServiceManager.Descriptor(						serviceClass,serviceName,code.toString(),plugin);					ServiceManager.registerService(d);					cachedServices.add(d);					code.setLength(0);				}					popElement();			}			else			{				// can't happen				throw new InternalError();			}		}	
public void startDocument()		{			try			{				pushElement(null);			}			catch (Exception e)			{				Log.log(Log.ERROR, e, e);			}		}	
public ServiceManager.Descriptor[] getCachedServices()		{			return cachedServices.toArray(				new ServiceManager.Descriptor[cachedServices.size()]);		}	
private String pushElement(String name)		{			name = (name == null) ? null : name.intern();				stateStack.push(name);				return name;		}	
private String peekElement()		{			return stateStack.peek();		}	
private String popElement()		{			return stateStack.pop();		}	
/**		 * Loads a <code>services.xml</code> file.		 * @since jEdit 4.2pre1		 */		public static void loadServices(PluginJAR plugin, URL uri,			PluginJAR.PluginCacheEntry cache)		{			ServiceListHandler dh = new ServiceListHandler(plugin,uri);			try			{				if (!XMLUtilities.parseXML(uri.openStream(), dh)					&& cache != null)				{					cache.cachedServices = dh.getCachedServices();				}			}			catch (IOException ioe)			{				Log.log(Log.ERROR, ServiceManager.class, ioe);			}		}	
/**		 * Removes all services belonging to the specified plugin.		 * @param plugin The plugin		 * @since jEdit 4.2pre1		 */		public static void unloadServices(PluginJAR plugin)		{			Iterator<Descriptor> descriptors = serviceMap.keySet().iterator();			while(descriptors.hasNext())			{				Descriptor d = descriptors.next();				if(d.plugin == plugin)					descriptors.remove();			}		}	
/**		 * Registers a service. Plugins should provide a		 * <code>services.xml</code> file instead of calling this directly.		 *		 * @param clazz The service class		 * @param name The service name		 * @param code BeanShell code to create an instance of this		 * @param plugin The plugin JAR, or null if this is a built-in service		 *		 * @since jEdit 4.2pre1		 */		public static void registerService(String clazz, String name,			String code, PluginJAR plugin)		{			Descriptor d = new Descriptor(clazz,name,code,plugin);			serviceMap.put(d,d);		}	
/**		 * Unregisters a service.		 *		 * @param clazz The service class		 * @param name The service name		 *		 * @since jEdit 4.2pre1		 */		public static void unregisterService(String clazz, String name)		{			Descriptor d = new Descriptor(clazz,name);			serviceMap.remove(d);		}	
/**		 * Returns all known service class types.		 *		 * @since jEdit 4.2pre1		 */		public static String[] getServiceTypes()		{			Set<String> returnValue = new HashSet<String>();				Set<Descriptor> keySet = serviceMap.keySet();			for (Descriptor d : keySet)				returnValue.add(d.clazz);				return returnValue.toArray(				new String[returnValue.size()]);		}	
/**		 * Returns the names of all registered services with the given		 * class. For example, calling this with a parameter of		 * "org.gjt.sp.jedit.io.VFS" returns all known virtual file		 * systems.		 *		 * @param clazz The class name		 * @since jEdit 4.2pre1		 */		public static String[] getServiceNames(String clazz)		{			List<String> returnValue = new ArrayList<String>();				Set<Descriptor> keySet = serviceMap.keySet();			for (Descriptor d : keySet)				if(d.clazz.equals(clazz))					returnValue.add(d.name);					return returnValue.toArray(				new String[returnValue.size()]);		}	
/**		 * Returns an instance of the given service. The first time this is		 * called for a given service, the BeanShell code is evaluated. The		 * result is cached for future invocations, so in effect services are		 * singletons.		 *		 * @param clazz The service class		 * @param name The service name		 * @since jEdit 4.2pre1		 */		public static Object getService(String clazz, String name)		{			// they never taught you this in undergrad computer science			Descriptor key = new Descriptor(clazz,name);			Descriptor value = serviceMap.get(key);			if(value == null)			{				// unknown service - <clazz,name> not in table				return null;			}			else			{				if(value.code == null)				{					loadServices(value.plugin,						value.plugin.getServicesURI(),						null);					value = serviceMap.get(key);				}				return value.getInstance();			}		}	
/**		 * Registers a service.		 *		 * @since jEdit 4.2pre1		 */		static void registerService(Descriptor d)		{			serviceMap.put(d,d);		}	
Descriptor(String clazz, String name)			{				this.clazz = clazz;				this.name  = name;			}	
Descriptor(String clazz, String name, String code,				PluginJAR plugin)			{				this.clazz  = clazz;				this.name   = name;				this.code   = code;				this.plugin = plugin;			}	
Object getInstance()			{				if(instanceIsNull)					return null;				else if(instance == null)				{					// lazy instantiation					instance = BeanShell.eval(null,						BeanShell.getNameSpace(),						code);					if(instance == null)					{						// avoid re-running script if it gives						// us null						instanceIsNull = true;					}				}					return instance;			}	
public int hashCode()			{				return name.hashCode();			}	
public boolean equals(Object o)			{				if(o instanceof Descriptor)				{					Descriptor d = (Descriptor)o;					return d.clazz.equals(clazz)						&& d.name.equals(name);				}				else					return false;			}	
/**			 * Returns the fold handler with the specified name, or null if			 * there is no registered handler with that name.			 * @param name The name of the desired fold handler			 * @return the FoldHandler or null if it doesn't exist			 * @since jEdit 4.3pre10			 */			public FoldHandler getFoldHandler(String name)			{				FoldHandler handler = (FoldHandler) getService(SERVICE,name);				return handler;			}	
/**			 * Returns an array containing the names of all registered fold			 * handlers.			 *			 * @since jEdit 4.3pre10			 */			public String[] getFoldModes()			{				String[] handlers = getServiceNames(SERVICE);				Arrays.sort(handlers,new StandardUtilities.StringCompare<String>());				return handlers;			}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof VFSUpdate)			{				VFSUpdate vmsg = (VFSUpdate)msg;				maybeReload(vmsg.getPath());			}		}	
private void maybeReload(String path)		{			String jEditHome = jEdit.getJEditHome();			String settingsDirectory = jEdit.getSettingsDirectory();				if(!MiscUtilities.isURL(path))				path = MiscUtilities.resolveSymlinks(path);				// On Windows and MacOS, path names are case insensitive			if((VFSManager.getVFSForPath(path).getCapabilities()				& VFS.CASE_INSENSITIVE_CAP) != 0)			{				path = path.toLowerCase();				jEditHome = jEditHome.toLowerCase();				if(settingsDirectory != null)					settingsDirectory = settingsDirectory.toLowerCase();			}				// XXX: does this really belong here?			SearchFileSet fileset = SearchAndReplace.getSearchFileSet();			if(fileset instanceof DirectoryListSet)			{				DirectoryListSet dirset = (DirectoryListSet)fileset;				String dir = MiscUtilities.resolveSymlinks(					dirset.getDirectory());				if(path.startsWith(dir))					dirset.invalidateCachedList();			}				if(jEditHome != null && path.startsWith(jEditHome))				path = path.substring(jEditHome.length());			else if(settingsDirectory != null && path.startsWith(settingsDirectory))				path = path.substring(settingsDirectory.length());			else			{				// not in settings directory or jEdit home directory.				// no need to reload anything.				return;			}				if(path.startsWith(File.separator) || path.startsWith("/"))				path = path.substring(1);				if(path.startsWith("macros"))				Macros.loadMacros();			else if(path.startsWith("modes") && (path.endsWith(".xml")				|| path.endsWith("catalog")))				jEdit.reloadModes();		}	
/**			 * Write the XML 1.0 declaration.			 * This should be the first output.			 */			public void writeXMLDeclaration() throws IOException			{				writeXMLDeclaration("1.0");			}	
/**			 * Write the XML declaration of a specific version.			 * This should be the first output.			 */			public void writeXMLDeclaration(String version)				throws IOException			{				write("<?xml"					+ " version=\"" + version + "\""					+ " encoding=\"" + encoding + "\""					+ " ?>");				newLine();			}	
/**			 * Perform the final step of saving.			 */			public void finish() throws IOException			{				close();				jEdit.backupSettingsFile(file);				file.delete();				twoStageSaveFile.renameTo(file);				knownLastModified = file.lastModified();			}	
Saver() throws IOException			{				this(new File(file.getParentFile(),					"#" + file.getName() + "#save#"));			}	
private Saver(File twoStageSaveFile) throws IOException			{				super(new OutputStreamWriter(					new FileOutputStream(twoStageSaveFile)					, encoding));				this.twoStageSaveFile = twoStageSaveFile;			}	
/**		 * Construct a SettingsXML with specific location and name.		 * @param settingsDirectory		 * 	The settings directory of jedit		 * @param name		 * 	The file name will be (name + ".xml")		 */		public SettingsXML(String settingsDirectory, String name)		{			String filename = name + ".xml";			file = new File(MiscUtilities.constructPath(				settingsDirectory, filename));		}	
public SettingsXML(File f)		{			file = f;		}	
/**		 * Returns true if the file exists.		 */		public boolean fileExists()		{			return file.exists();		}	
/**		 * Parse the XML file to load.		 * @param handler		 * 	The handler to receive SAX notifications.		 */		public void load(DefaultHandler handler) throws IOException		{			XMLUtilities.parseXML(new FileInputStream(file), handler);			knownLastModified = file.lastModified();		}	
/**		 * Open the file to save in XML.		 */		public Saver openSaver() throws IOException		{			return new Saver();		}	
/**		 * Returns true if the file has been changed on disk.		 * This is based on the last modified time at the last saving		 * or loading.		 */		public boolean hasChangedOnDisk()		{			return file.exists()				&& (file.lastModified() != knownLastModified);		}	
/**		 * Returns the file's path.		 */		public String toString()		{			return file.toString();		}	
public void paintFoldEnd(Gutter gutter, Graphics2D gfx, int screenLine,				int physicalLine, int y, int lineHeight, JEditBuffer buffer)		{			gfx.setColor(gutter.getFoldColor());			int _y = y + lineHeight / 2;			int _x = 5;			gfx.drawLine(_x,y,_x,_y+3);			gfx.drawLine(_x,_y+3,_x+4,_y+3);			boolean nested = (physicalLine < buffer.getLineCount() - 1 &&				buffer.getFoldLevel(physicalLine + 1) > 0);			if (nested)				gfx.drawLine(_x,y+4,_x,y+lineHeight-1);		}	
public void paintFoldMiddle(Gutter gutter, Graphics2D gfx, int screenLine,				int physicalLine, int y, int lineHeight, JEditBuffer buffer)		{			gfx.setColor(gutter.getFoldColor());			gfx.drawLine(5,y,5,y+lineHeight-1);		}	
public void paintFoldStart(Gutter gutter, Graphics2D gfx, int screenLine,				int physicalLine, boolean nextLineVisible, int y, int lineHeight,				JEditBuffer buffer)		{			int _y = y + lineHeight / 2;			int _x = 5;			gfx.setColor(gutter.getFoldColor());			paintFoldShape(gfx, _y - 4, _y + 4);			gfx.drawLine(_x-2,_y,_x+2,_y);			boolean nested = (buffer.getFoldLevel(physicalLine) > 0);			if (nested)				gfx.drawLine(_x,y,_x,_y-5);			if (nextLineVisible)				gfx.drawLine(_x,_y+5,_x,y+lineHeight-1);			else			{				gfx.drawLine(_x,_y-2,_x,_y+2);				if (nested)					gfx.drawLine(_x,_y+4,_x,y+lineHeight-1);			}		}	
/**		 * Constructor for the ShortcutPrefixActiveEvent object		 *		 * @param bindings Description of the Parameter		 * @param active   Description of the Parameter		 */		public ShortcutPrefixActiveEvent(Hashtable bindings, boolean active)		{			super(new Object());			this.bindings = bindings;			this.active = active;		}	
/**		 * Adds a feature to the ChangeEventListener attribute of the		 * ShortcutPrefixActiveEvent class		 *		 * @param l The feature to be added to the ChangeEventListener attribute		 */		public static void addChangeEventListener(ChangeListener l)		{			listenerList.add(ChangeListener.class, l);			Log.log(Log.DEBUG, ShortcutPrefixActiveEvent.class, "Listener added.  " + listenerList.getListenerList().length + " left.");		}	
/**		 * Description of the Method		 *		 * @param l Description of the Parameter		 */		public static void removeChangeEventListener(ChangeListener l)		{			listenerList.remove(ChangeListener.class, l);			Log.log(Log.DEBUG, ShortcutPrefixActiveEvent.class, "Listener removed.  " + listenerList.getListenerList().length + " left.");		}	
/**		 * Description of the Method		 *		 * @param bindings                       Description of the Parameter		 * @param listeningForShortcutCompletion Description of the Parameter		 */		public static void firePrefixStateChange(Hashtable bindings, boolean listeningForShortcutCompletion)		{			//Log.log( Log.DEBUG, ShortcutPrefixActiveEvent.class, "firePrefixStateChange() called, listening? " + listeningForShortcutCompletion );			// Guaranteed to return a non-null array			Object[] listeners = listenerList.getListenerList();			//Log.log( Log.DEBUG, ShortcutPrefixActiveEvent.class, listeners.length + " listeners." );			// Process the listeners last to first, notifying			// those that are interested in this event			for (int i = listeners.length - 2; i >= 0; i -= 2)			{				//Log.log( Log.DEBUG, ShortcutPrefixActiveEvent.class, "firePrefixStateChange() called, listening? " + listeningForShortcutCompletion );				ChangeEvent event = new ShortcutPrefixActiveEvent(bindings, listeningForShortcutCompletion);				((ChangeListener) listeners[i + 1]).stateChanged(event);			}		}	
/**		 * Gets the bindings attribute of the ShortcutPrefixActiveEvent object		 *		 * @return The bindings value		 */		public Hashtable getBindings()		{			return bindings;		}	
/**		 * Gets the active attribute of the ShortcutPrefixActiveEvent object		 *		 * @return The active value		 */		public boolean getActive()		{			return active;		}	
public ShortcutsOptionPane()		{			super("shortcuts");		}	
@Override		protected void _init()		{			allBindings = new Vector<KeyBinding>();				setLayout(new BorderLayout(12,12));				initModels();				selectModel = new JComboBox(models);			selectModel.addActionListener(new ActionHandler());			selectModel.setToolTipText(jEdit.getProperty("options.shortcuts.select.tooltip"));			Box north = Box.createHorizontalBox();			north.add(new JLabel(jEdit.getProperty(				"options.shortcuts.select.label")));			north.add(Box.createHorizontalStrut(6));			north.add(selectModel);				filterTF = new JTextField(40);			filterTF.setToolTipText(jEdit.getProperty("options.shortcuts.filter.tooltip"));			filterTF.getDocument().addDocumentListener(new DocumentListener()			{				public void changedUpdate(DocumentEvent e)				{					setFilter();				}					public void insertUpdate(DocumentEvent e)				{					setFilter();				}					public void removeUpdate(DocumentEvent e)				{					setFilter();				}			});			JButton clearButton = new JButton(jEdit.getProperty(					"options.shortcuts.clear.label"));			clearButton.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent arg0)				{					filterTF.setText("");					filterTF.requestFocus();				}			});				JPanel filterPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));			filterPanel.add(new JLabel(jEdit.getProperty("options.shortcuts.filter.label")));			filterPanel.add(filterTF);			filterPanel.add(clearButton);				keyTable = new JTable(filteredModel);			filteredModel.setTable(keyTable);			keyTable.getTableHeader().setReorderingAllowed(false);			keyTable.getTableHeader().addMouseListener(new HeaderMouseHandler());			keyTable.addMouseListener(new TableMouseHandler());			Dimension d = keyTable.getPreferredSize();			d.height = Math.min(d.height,200);			JScrollPane scroller = new JScrollPane(keyTable);			scroller.setPreferredSize(d);			JPanel tableFilterPanel = new JPanel(new BorderLayout());			tableFilterPanel.add(BorderLayout.NORTH,filterPanel);			tableFilterPanel.add(BorderLayout.CENTER,scroller);				add(BorderLayout.NORTH,north);			add(BorderLayout.CENTER,tableFilterPanel);			try			{				selectModel.setSelectedIndex(jEdit.getIntegerProperty("options.shortcuts.select.index", 0));			}			catch (IllegalArgumentException eae) {}		}	
@Override		protected void _save()		{			if(keyTable.getCellEditor() != null)				keyTable.getCellEditor().stopCellEditing();				for (ShortcutsModel model : models)				model.save();				Macros.loadMacros();		}	
private void setFilter()		{			filteredModel.setFilter(filterTF.getText());		}	
private void initModels()		{			List<KeyBinding[]> allBindings = new Vector<KeyBinding[]>();			models = new Vector<ShortcutsModel>();			ActionSet[] actionSets = jEdit.getActionSets();			for(int i = 0; i < actionSets.length; i++)			{				ActionSet actionSet = actionSets[i];				if(actionSet.getActionCount() != 0)				{					String modelLabel = actionSet.getLabel();					if(modelLabel == null)					{						Log.log(Log.ERROR,this,"Empty action set: "							+ actionSet.getPluginJAR());					}					ShortcutsModel model = createModel(modelLabel,							actionSet.getActionNames());					models.addElement(model);					allBindings.addAll(model.getBindings());				}			}			if (models.size() > 1)				models.addElement(new ShortcutsModel("All", allBindings));			Collections.sort(models,new StandardUtilities.StringCompare<ShortcutsModel>(true));			ShortcutsModel currentModel = models.elementAt(0);			filteredModel = new FilteredTableModel<ShortcutsModel>(currentModel)			{				@Override				public String prepareFilter(String filter)				{					return filter.toLowerCase();				}					@Override				public boolean passFilter(int row, String filter)				{					String name = delegated.getBindingAt(row, 0).label.toLowerCase();					return name.contains(filter);				}			};		}	
private ShortcutsModel createModel(String modelLabel, String[] actions)		{			List<GrabKeyDialog.KeyBinding[]> bindings = new Vector<GrabKeyDialog.KeyBinding[]>(actions.length);				for(int i = 0; i < actions.length; i++)			{				String name = actions[i];				EditAction ea = jEdit.getAction(name);				String label = ea.getLabel();				// Skip certain actions this way				if(label == null)					continue;					label = GUIUtilities.prettifyMenuLabel(label);				addBindings(name,label,bindings);			}				return new ShortcutsModel(modelLabel,bindings);		}	
private void addBindings(String name, String label, List<GrabKeyDialog.KeyBinding[]> bindings)		{			GrabKeyDialog.KeyBinding[] b = new GrabKeyDialog.KeyBinding[2];				b[0] = createBinding(name,label,				jEdit.getProperty(name + ".shortcut"));			b[1] = createBinding(name,label,				jEdit.getProperty(name + ".shortcut2"));				bindings.add(b);		}	
private GrabKeyDialog.KeyBinding createBinding(String name,			String label, String shortcut)		{			if(shortcut != null && shortcut.length() == 0)				shortcut = null;				GrabKeyDialog.KeyBinding binding				= new GrabKeyDialog.KeyBinding(name,label,shortcut,false);				allBindings.add(binding);			return binding;		}	
@Override			public void mouseClicked(MouseEvent evt)			{				ShortcutsModel shortcutsModel = filteredModel.getDelegated();				switch(keyTable.getTableHeader().columnAtPoint(evt.getPoint()))				{				case 0:					shortcutsModel.sort(0);					break;				case 1:					shortcutsModel.sort(1);					break;				case 2:					shortcutsModel.sort(2);					break;				}				setFilter();			}	
@Override			public void mouseClicked(MouseEvent evt)			{				int row = keyTable.getSelectedRow();				int col = keyTable.getSelectedColumn();				if(col != 0 && row != -1)				{					 GrabKeyDialog gkd = new GrabKeyDialog(						GUIUtilities.getParentDialog(						ShortcutsOptionPane.this),						filteredModel.getDelegated().getBindingAt(filteredModel.getTrueRow(row), col - 1),						allBindings,null);					if(gkd.isOK())						filteredModel.setValueAt(							gkd.getShortcut(),row,col);				}			}	
public void actionPerformed(ActionEvent evt)			{				ShortcutsModel newModel					= (ShortcutsModel)selectModel.getSelectedItem();				if(filteredModel.getDelegated() != newModel)				{					jEdit.setIntegerProperty("options.shortcuts.select.index", selectModel.getSelectedIndex());					filteredModel.setDelegated(newModel);					setFilter();				}			}	
ShortcutsModel(String name, List<GrabKeyDialog.KeyBinding[]> bindings)			{				this.name = name;				this.bindings = bindings;				sort(0);			}	
public List<GrabKeyDialog.KeyBinding[]> getBindings()			{				return bindings;			}	
public void sort(int col)			{				Collections.sort(bindings,new KeyCompare(col));			}	
public int getColumnCount()			{				return 3;			}	
public int getRowCount()			{				return bindings.size();			}	
public Object getValueAt(int row, int col)			{				switch(col)				{				case 0:					return getBindingAt(row,0).label;				case 1:					return getBindingAt(row,0).shortcut;				case 2:					return getBindingAt(row,1).shortcut;				default:					return null;				}			}	
@Override			public void setValueAt(Object value, int row, int col)			{				if(col == 0)					return;					getBindingAt(row,col-1).shortcut = (String)value;					// redraw the whole table because a second shortcut				// might have changed, too				fireTableDataChanged();			}	
@Override			public String getColumnName(int index)			{				switch(index)				{				case 0:					return jEdit.getProperty("options.shortcuts.name");				case 1:					return jEdit.getProperty("options.shortcuts.shortcut1");				case 2:					return jEdit.getProperty("options.shortcuts.shortcut2");				default:					return null;				}			}	
public void save()			{				for (GrabKeyDialog.KeyBinding[] binding : bindings)				{					jEdit.setProperty(						binding[0].name + ".shortcut",						binding[0].shortcut);					jEdit.setProperty(						binding[1].name + ".shortcut2",						binding[1].shortcut);				}			}	
public GrabKeyDialog.KeyBinding getBindingAt(int row, int nr)			{				GrabKeyDialog.KeyBinding[] binding = bindings.get(row);				return binding[nr];			}	
@Override			public String toString()			{				return name;			}	
KeyCompare(int col)				{					this.col = col;				}	
public int compare(GrabKeyDialog.KeyBinding[] k1, GrabKeyDialog.KeyBinding[] k2)				{					String label1 = k1[0].label.toLowerCase();					String label2 = k2[0].label.toLowerCase();						if(col == 0)						return StandardUtilities.compareStrings(							label1,label2,true);					else					{						String shortcut1, shortcut2;						if(col == 1)						{							shortcut1 = k1[0].shortcut;							shortcut2 = k2[0].shortcut;						}						else						{							shortcut1 = k1[1].shortcut;							shortcut2 = k2[1].shortcut;						}							if(shortcut1 == null && shortcut2 != null)							return 1;						else if(shortcut2 == null && shortcut1 != null)							return -1;						else if(shortcut1 == null)							return StandardUtilities.compareStrings(label1,label2,true);						else							return StandardUtilities.compareStrings(shortcut1,shortcut2,true);					}				}	
public SimpleNode(int i) {			id = i;		}	
public void jjtOpen() { }	
public void jjtClose() { }	
public void jjtSetParent(Node n) { parent = n; }	
public Node jjtGetParent() { return parent; }	
public void jjtAddChild(Node n, int i)		{			if (children == null)				children = new Node[i + 1];			else				if (i >= children.length)				{					Node c[] = new Node[i + 1];					System.arraycopy(children, 0, c, 0, children.length);					children = c;				}				children[i] = n;		}	
public Node jjtGetChild(int i) { 			return children[i]; 		}	
public SimpleNode getChild( int i ) {			return (SimpleNode)jjtGetChild(i);		}	
public int jjtGetNumChildren() {			return (children == null) ? 0 : children.length;		}	
public String toString() { return ParserTreeConstants.jjtNodeName[id]; }	
public String toString(String prefix) { return prefix + toString(); }	
public void dump(String prefix)		{			System.out.println(toString(prefix));			if(children != null)			{				for(int i = 0; i < children.length; ++i)				{					SimpleNode n = (SimpleNode)children[i];					if (n != null)					{						n.dump(prefix + " ");					}				}			}		}	
/**			Detach this node from its parent.			This is primarily useful in node serialization.			(see BSHMethodDeclaration)		*/		public void prune() {			jjtSetParent( null );		}	
/**			This is the general signature for evaluation of a node.		*/		public Object eval( CallStack callstack, Interpreter interpreter ) 			throws EvalError		{			throw new InterpreterError(				"Unimplemented or inappropriate for " + getClass().getName() );		}	
/**			Set the name of the source file (or more generally source) of			the text from which this node was parsed.		*/		public void setSourceFile( String sourceFile ) {			this.sourceFile = sourceFile;		}	
/**			Get the name of the source file (or more generally source) of			the text from which this node was parsed.			This will recursively search up the chain of parent nodes until			a source is found or return a string indicating that the source			is unknown.		*/		public String getSourceFile() {			if ( sourceFile == null )				if ( parent != null )					return ((SimpleNode)parent).getSourceFile();				else					return "<unknown file>";			else				return sourceFile;		}	
/**			Get the line number of the starting token		*/		public int getLineNumber() {			return firstToken.beginLine;		}	
/**			Get the text of the tokens comprising this node.		*/		public String getText() 		{			StringBuilder text = new StringBuilder();			Token t = firstToken;			while ( t!=null ) {				text.append(t.image);				if ( !t.image.equals(".") )					text.append(" ");				if ( t==lastToken ||					t.image.equals("{") || t.image.equals(";") )					break;				t=t.next;			}							return text.toString();		}	
public SplashScreen()		{			setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));			setBackground(Color.white);				setFont(defaultFont);			fm = getFontMetrics(defaultFont);			image = getToolkit().getImage(				getClass().getResource("/org/gjt/sp/jedit/icons/splash.png"));			MediaTracker tracker = new MediaTracker(this);			tracker.addImage(image,0);				try			{				tracker.waitForAll();			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);			}			Dimension screen = getToolkit().getScreenSize(); // sane default			win = new JWindow();			GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();			GraphicsDevice[] gs = ge.getScreenDevices();			GraphicsDevice gd = gs[0];			if (gd != null)			{				GraphicsConfiguration gconf = gd.getDefaultConfiguration();				if (gconf != null)				{					Rectangle bounds = gconf.getBounds();					screen = new Dimension(bounds.width, bounds.height);				}			}			Dimension size = new Dimension(image.getWidth(this) + 2,				image.getHeight(this) + 2 + PROGRESS_HEIGHT);			win.setSize(size);				win.getContentPane().add(this, BorderLayout.CENTER);				win.setLocation((screen.width - size.width) / 2,				(screen.height - size.height) / 2);			win.validate();			win.setVisible(true);		}	
public void dispose()		{			win.dispose();		}	
public synchronized void advance()		{			logAdvanceTime(null);			progress++;			repaint();				// wait for it to be painted to ensure progress is updated			// continuously			try			{				wait();			}			catch(InterruptedException ie)			{				Log.log(Log.ERROR,this,ie);			}		}	
public synchronized void advance(String label)		{			logAdvanceTime(label);			progress++;			this.label = label;			repaint();				// wait for it to be painted to ensure progress is updated			// continuously			try			{				wait();			}			catch(InterruptedException ie)			{				Log.log(Log.ERROR,this,ie);			}		}	
private void logAdvanceTime(String label)		{			long currentTime = System.currentTimeMillis();			if (lastLabel != null)			{				Log.log(Log.DEBUG, SplashScreen.class,					lastLabel +':'+(currentTime - lastAdvanceTime) + "ms");			}			if (label != null)			{				lastLabel = label;				lastAdvanceTime = currentTime;				}		}	
@Override		public synchronized void paintComponent(Graphics g)		{			Dimension size = getSize();				g.setColor(Color.black);			g.drawRect(0,0,size.width - 1,size.height - 1);				g.drawImage(image,1,1,this);				// XXX: This should not be hardcoded			g.setColor(Color.white);			g.fillRect(1,image.getHeight(this) + 1,				((win.getWidth() - 2) * progress) / PROGRESS_COUNT, PROGRESS_HEIGHT);				g.setColor(Color.black);				if (label != null)			{				int drawOffsetX = (getWidth() - fm.stringWidth(label)) / 2;				int drawOffsetY = image.getHeight(this) + (PROGRESS_HEIGHT								      + fm.getAscent() + fm.getDescent()) / 2;					paintString(g, label, drawOffsetX, drawOffsetY);			}				String version = "version " + jEdit.getVersion();				int drawOffsetX = (getWidth() / 2) - (fm.stringWidth(version) / 2);			int drawOffsetY = image.getHeight(this) - fm.getDescent() - 2;				paintString(g, version, drawOffsetX, drawOffsetY);				notify();		}	
private void paintString(Graphics g, String version, int drawOffsetX,					 int drawOffsetY)		{			g.setFont( labelFont );				g.setColor( versionColor1 );			g.drawString( version, drawOffsetX, drawOffsetY );			// Draw a highlight effect			g.setColor( versionColor2 );			g.drawString( version, drawOffsetX + 1, drawOffsetY + 1 );		}	
@Override		protected void paintFoldShape(Graphics2D gfx, int top, int bottom)		{			gfx.drawRect(1,top,8,(bottom-top));		}	
/**		 * Creates a new StandaloneTextArea. A reference to the propertyManager is saved and used to read the properties		 * when {@link StandaloneTextArea#propertiesChanged()} is called.		 *		 * @param propertyManager the property manager that contains both shortcut bindings and UI information		 */		public StandaloneTextArea(IPropertyManager propertyManager)		{			super(propertyManager, null);			this.propertyManager = propertyManager;				initInputHandler();				setMouseHandler(new TextAreaMouseHandler(this));			// todo : make TextareaTransferHandler standalone	//		textArea.setTransferHandler(new TextAreaTransferHandler());				JEditActionSet<JEditBeanShellAction> actionSet = new StandaloneActionSet(propertyManager, this, TextArea.class.getResource("textarea.actions.xml"));				addActionSet(actionSet);			actionSet.load();			actionSet.initKeyBindings();				//{{{ init Style property manager			if (SyntaxUtilities.propertyManager == null)			{				SyntaxUtilities.propertyManager = propertyManager;			}			//}}}				initTextArea();				DefaultFoldHandlerProvider foldHandlerProvider = new DefaultFoldHandlerProvider();				FoldHandler.foldHandlerProvider = foldHandlerProvider;			foldHandlerProvider.addFoldHandler(new ExplicitFoldHandler());			foldHandlerProvider.addFoldHandler(new IndentFoldHandler());			foldHandlerProvider.addFoldHandler(new DummyFoldHandler());			JEditBuffer buffer = new JEditBuffer();			TokenMarker tokenMarker = new TokenMarker();			tokenMarker.addRuleSet(new ParserRuleSet("text","MAIN"));			buffer.setTokenMarker(tokenMarker);			setBuffer(buffer);			String property = propertyManager.getProperty("buffer.undoCount");			int undoCount = 100;			if (property != null)				try				{					undoCount = Integer.parseInt(property);				}				catch (NumberFormatException e)				{				}			this.buffer.setUndoLimit(undoCount);			Mode mode = new Mode("text");			mode.setTokenMarker(tokenMarker);			ModeProvider.instance.addMode(mode);			KillRing.setInstance(new KillRing());			KillRing.getInstance().propertiesChanged(100);			}	
/**		 * Initializes the text area by re-reading the properties from the property manager passed to the		 * constructor.		 */		private void initTextArea()		{			initPainter();			initGutter();				setCaretBlinkEnabled(getBooleanProperty(				"view.caretBlink"));				setElectricScroll(getIntegerProperty(				"view.electricBorders",0));				if (buffer == null)				return ;				String property = propertyManager.getProperty("buffer.undoCount");			int undoCount = 100;			if (property != null)			{				try				{					undoCount = Integer.parseInt(property);				}				catch (NumberFormatException e)				{				}			}			buffer.setUndoLimit(undoCount);		}	
private void initGutter()		{			Gutter gutter = getGutter();			gutter.setExpanded(getBooleanProperty(				"view.gutter.lineNumbers"));			int interval = getIntegerProperty(				"view.gutter.highlightInterval",5);			gutter.setHighlightInterval(interval);			gutter.setCurrentLineHighlightEnabled(getBooleanProperty(				"view.gutter.highlightCurrentLine"));			gutter.setStructureHighlightEnabled(getBooleanProperty(				"view.gutter.structureHighlight"));			gutter.setStructureHighlightColor(				getColorProperty("view.gutter.structureHighlightColor"));			gutter.setBackground(				getColorProperty("view.gutter.bgColor"));			gutter.setForeground(				getColorProperty("view.gutter.fgColor"));			gutter.setHighlightedForeground(				getColorProperty("view.gutter.highlightColor"));			gutter.setFoldColor(				getColorProperty("view.gutter.foldColor"));			gutter.setCurrentLineForeground(				getColorProperty("view.gutter.currentLineColor"));			String alignment = getProperty(				"view.gutter.numberAlignment");			if ("right".equals(alignment))			{				gutter.setLineNumberAlignment(Gutter.RIGHT);			}			else if ("center".equals(alignment))			{				gutter.setLineNumberAlignment(Gutter.CENTER);			}			else // left == default case			{				gutter.setLineNumberAlignment(Gutter.LEFT);			}				gutter.setFont(getFontProperty("view.gutter.font"));				int width = getIntegerProperty(				"view.gutter.borderWidth",3);			gutter.setBorder(width,				getColorProperty("view.gutter.focusBorderColor"),				getColorProperty("view.gutter.noFocusBorderColor"),				painter.getBackground());		}	
/**		 * Init the painter of this textarea.		 *		 */		private void initPainter()		{			TextAreaPainter painter = getPainter();			painter.setBlockCaretEnabled(false);				painter.setFont(getFontProperty("view.font"));			painter.setStructureHighlightEnabled(getBooleanProperty(				"view.structureHighlight"));			painter.setStructureHighlightColor(				getColorProperty("view.structureHighlightColor"));			painter.setEOLMarkersPainted(getBooleanProperty(				"view.eolMarkers"));			painter.setEOLMarkerColor(				getColorProperty("view.eolMarkerColor"));			painter.setWrapGuidePainted(getBooleanProperty(				"view.wrapGuide"));			painter.setWrapGuideColor(				getColorProperty("view.wrapGuideColor"));			painter.setCaretColor(				getColorProperty("view.caretColor"));			painter.setSelectionColor(				getColorProperty("view.selectionColor"));			painter.setMultipleSelectionColor(				getColorProperty("view.multipleSelectionColor"));			painter.setBackground(				getColorProperty("view.bgColor"));			painter.setForeground(				getColorProperty("view.fgColor"));			painter.setBlockCaretEnabled(getBooleanProperty(				"view.blockCaret"));			painter.setThickCaretEnabled(getBooleanProperty(				"view.thickCaret"));			painter.setLineHighlightEnabled(getBooleanProperty(				"view.lineHighlight"));			painter.setLineHighlightColor(				getColorProperty("view.lineHighlightColor"));			painter.setAntiAlias(new AntiAlias(getProperty("view.antiAlias")));			painter.setFractionalFontMetricsEnabled(getBooleanProperty(				"view.fracFontMetrics"));				String defaultFont = getProperty("view.font");			int defaultFontSize = getIntegerProperty("view.fontsize",12);			painter.setStyles(SyntaxUtilities.loadStyles(defaultFont,defaultFontSize));				SyntaxStyle[] foldLineStyle = new SyntaxStyle[4];			for(int i = 0; i <= 3; i++)			{				foldLineStyle[i] = SyntaxUtilities.parseStyle(					getProperty("view.style.foldLine." + i),					defaultFont,defaultFontSize,true);			}			painter.setFoldLineStyle(foldLineStyle);		}	
public String getProperty(String name)		{			return propertyManager.getProperty(name);		}	
/**		 * Returns the value of a boolean property.		 * @param name The property		 */		private boolean getBooleanProperty(String name)		{			return getBooleanProperty(name,false);		}	
/**		 * Returns the value of a boolean property.		 * @param name The property		 * @param def The default value		 */		private boolean getBooleanProperty(String name, boolean def)		{			String value = getProperty(name);			if(value == null)				return def;			else if(value.equals("true") || value.equals("yes")				|| value.equals("on"))				return true;			else if(value.equals("false") || value.equals("no")				|| value.equals("off"))				return false;			else				return def;		}	
/**		 * Returns the value of an integer property.		 * @param name The property		 */		private int getIntegerProperty(String name)		{			return getIntegerProperty(name,0);		}	
/**		 * Returns the value of an integer property.		 * @param name The property		 * @param def The default value		 * @since jEdit 4.0pre1		 */		private int getIntegerProperty(String name, int def)		{			String value = getProperty(name);			if(value == null)				return def;			else			{				try				{					return Integer.parseInt(value.trim());				}				catch(NumberFormatException nf)				{					return def;				}			}		}	
/**		 * Returns the value of a font property. The family is stored		 * in the <code><i>name</i></code> property, the font size is stored		 * in the <code><i>name</i>size</code> property, and the font style is		 * stored in <code><i>name</i>style</code>. For example, if		 * <code><i>name</i></code> is <code>view.gutter.font</code>, the		 * properties will be named <code>view.gutter.font</code>,		 * <code>view.gutter.fontsize</code>, and		 * <code>view.gutter.fontstyle</code>.		 *		 * @param name The property		 * @since jEdit 4.0pre1		 */		private Font getFontProperty(String name)		{			return getFontProperty(name,null);		}	
/**		 * Returns the value of a font property. The family is stored		 * in the <code><i>name</i></code> property, the font size is stored		 * in the <code><i>name</i>size</code> property, and the font style is		 * stored in <code><i>name</i>style</code>. For example, if		 * <code><i>name</i></code> is <code>view.gutter.font</code>, the		 * properties will be named <code>view.gutter.font</code>,		 * <code>view.gutter.fontsize</code>, and		 * <code>view.gutter.fontstyle</code>.		 *		 * @param name The property		 * @param def The default value		 * @since jEdit 4.0pre1		 */		private Font getFontProperty(String name, Font def)		{			String family = getProperty(name);			String sizeString = getProperty(name + "size");			String styleString = getProperty(name + "style");				if(family == null || sizeString == null || styleString == null)				return def;			else			{				int size;					try				{					size = Integer.parseInt(sizeString);				}				catch(NumberFormatException nf)				{					return def;				}					int style;				try				{					style = Integer.parseInt(styleString);				}				catch(NumberFormatException nf)				{					return def;				}					return new Font(family,style,size);			}		}	
/**		 * Returns the value of a color property.		 * @param name The property name		 * @since jEdit 4.0pre1		 */		private Color getColorProperty(String name)		{			return getColorProperty(name,Color.black);		}	
/**		 * Returns the value of a color property.		 * @param name The property name		 * @param def The default value		 * @since jEdit 4.0pre1		 */		private Color getColorProperty(String name, Color def)		{			String value = getProperty(name);			if(value == null)				return def;			else				return SyntaxUtilities.parseColor(value, def);		}	
/**		 * Reinitializes the textarea by reading the properties from the property manager		 */		@Override		public void propertiesChanged()		{			getInputHandler().removeAllKeyBindings();			JEditActionSet<JEditBeanShellAction>[] actionSets = getActionContext().getActionSets();			for (JEditActionSet<JEditBeanShellAction> actionSet : actionSets)			{				actionSet.initKeyBindings();			}			initBuffer();			initTextArea();			super.propertiesChanged();		}	
/**		 * Reinitializes the buffer by reading the properties from the property manager		 */		private void initBuffer()		{			String[] bufferProperties = {				"lineSeparator",				"encodingAutodetect",				"tabSize",				"indentSize",				"noTabs",				"defaultMode",				"undoCount",				"wrap",				"maxLineLen",				"wordBreakChars",				"noWordSep",				"camelCasedWords",				"folding",				"collapseFolds"			};			for (int i = 0; i < bufferProperties.length; i++)			{				String value = getProperty("buffer." + bufferProperties[i]);				if (value == null)					buffer.unsetProperty(bufferProperties[i]);				else					buffer.setProperty(bufferProperties[i], value);			}			buffer.propertiesChanged();		}	
/**		 * Creates the popup menu.		 * @since 4.3pre15		 */		@Override		public void createPopupMenu(MouseEvent evt)		{			popup = new JPopupMenu();			addMenuItem("undo", "Undo");			addMenuItem("redo", "Redo");			popup.addSeparator();			addMenuItem("cut", "Cut");			addMenuItem("copy", "Copy");			addMenuItem("paste", "Paste");		}	
/**		 * Adds a menu item from the action context to the popup menu and returns the item.		 * @return the menu item added		 */		public JMenuItem addMenuItem(String action, String label)		{			final JEditBeanShellAction shellAction = getActionContext().getAction(action);			if (shellAction == null)				return null ;			JMenuItem item = new JMenuItem();			item.setAction(new AbstractAction(label)			{				public void actionPerformed(ActionEvent e)				{					shellAction.invoke(StandaloneTextArea.this);				}			});			popup.add(item);			return item;		}	
/**		 * Create a standalone TextArea.		 * If you want to use it in jEdit, please use {@link JEditEmbeddedTextArea#JEditEmbeddedTextArea()}		 *		 * @return a textarea		 * @since 4.3pre13		 */		public static StandaloneTextArea createTextArea()		{			final Properties props = new Properties();			props.putAll(loadProperties("/org/gjt/sp/jedit/jedit_keys.props"));			props.putAll(loadProperties("/org/gjt/sp/jedit/jedit.props"));			StandaloneTextArea textArea = new StandaloneTextArea(new IPropertyManager()			{				public String getProperty(String name)				{					return props.getProperty(name);				}			});			textArea.getBuffer().setProperty("folding", "explicit");			return textArea;		}	
private static Properties loadProperties(String fileName)		{			Properties props = new Properties();			InputStream in = TextArea.class.getResourceAsStream(fileName);			try			{				props.load(in);			}			catch (IOException e)			{				Log.log(Log.ERROR, TextArea.class, e);			}			finally			{				IOUtilities.closeQuietly(in);			}			return props;		}	
public StandaloneActionSet(IPropertyManager iPropertyManager, TextArea textArea, URL url)			{				super(null, url);				this.iPropertyManager = iPropertyManager;				this.textArea = textArea;			}	
@Override			protected JEditBeanShellAction[] getArray(int size)			{				return new JEditBeanShellAction[size];			}	
@Override			protected String getProperty(String name)			{				return iPropertyManager.getProperty(name);			}	
public AbstractInputHandler getInputHandler()			{				return textArea.getInputHandler();			}	
@Override			protected JEditBeanShellAction createBeanShellAction(String actionName,									     String code,									     String selected,									     boolean noRepeat,									     boolean noRecord,									     boolean noRememberLast)			{				return new JEditBeanShellAction(actionName,code,selected,noRepeat,noRecord,noRememberLast);			}	
public static void main(String[] args)		{			JFrame frame = new JFrame();			TextArea text = createTextArea();			Mode mode = new Mode("xml");			mode.setProperty("file","modes/xml.xml");			ModeProvider.instance.addMode(mode);			text.getBuffer().setMode(mode);			frame.getContentPane().add(text);			frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);			frame.pack();			frame.setVisible(true);		}	
/**		 * Escapes newlines, tabs, backslashes, and quotes in the specified		 * string.		 * @param str The string		 * @since jEdit 4.3pre15		 */		public static String charsToEscapes(String str)		{			return charsToEscapes(str,"\n\t\\\"'");		}	
/**		 * Escapes the specified characters in the specified string.		 * @param str The string		 * @param toEscape Any characters that require escaping		 * @since jEdit 4.3pre15		 */		public static String charsToEscapes(String str, String toEscape)		{			StringBuilder buf = new StringBuilder();			for(int i = 0; i < str.length(); i++)			{				char c = str.charAt(i);				if(toEscape.indexOf(c) != -1)				{					if(c == '\n')						buf.append("\\n");					else if(c == '\t')						buf.append("\\t");					else					{						buf.append('\\');						buf.append(c);					}				}				else					buf.append(c);			}			return buf.toString();		}	
/**		 * @param str A java string	  	 * @return the leading whitespace of that string, for indenting subsequent lines.		 * @since jEdit 4.3pre10		 */		public static String getIndentString(String str)		{			StringBuilder indentString = new StringBuilder();			for (int i = 0; i < str.length(); i++)			{				char ch = str.charAt(i);				if (! Character.isWhitespace(ch))					break;				indentString.append(ch);			}			return indentString.toString();			}	
/**		 * Returns the number of leading white space characters in the		 * specified string.		 *		 * @param str The string		 */		public static int getLeadingWhiteSpace(String str)		{			return getLeadingWhiteSpace((CharSequence)str);		}	
/**		 * Returns the number of leading white space characters in the		 * specified string.		 *		 * @param str The string		 * @since jEdit 4.3pre15		 */		public static int getLeadingWhiteSpace(CharSequence str)		{			int whitespace = 0;	loop:		for(;whitespace < str.length();)			{				switch(str.charAt(whitespace))				{				case ' ':				case '\t':					whitespace++;					break;				default:					break loop;				}			}			return whitespace;		}	
/**		 * Returns the number of trailing whitespace characters in the		 * specified string.		 * @param str The string		 */		public static int getTrailingWhiteSpace(String str)		{			int whitespace = 0;	loop:		for(int i = str.length() - 1; i >= 0; i--)			{				switch(str.charAt(i))				{					case ' ':					case '\t':						whitespace++;						break;					default:						break loop;				}			}			return whitespace;		}	
/**		 * Returns the width of the leading white space in the specified		 * string.		 * @param str The string		 * @param tabSize The tab size		 */		public static int getLeadingWhiteSpaceWidth(String str, int tabSize)		{			return getLeadingWhiteSpaceWidth((CharSequence)str, tabSize);		}	
/**		 * Returns the width of the leading white space in the specified		 * string.		 * @param str The string		 * @param tabSize The tab size		 * @since jEdit 4.3pre15		 */		public static int getLeadingWhiteSpaceWidth(CharSequence str, int tabSize)		{			int whitespace = 0;	loop:		for(int i = 0; i < str.length(); i++)			{				switch(str.charAt(i))				{					case ' ':						whitespace++;						break;					case '\t':						whitespace += tabSize -							whitespace % tabSize;						break;					default:						break loop;				}			}			return whitespace;		}	
/**		 * Creates a string of white space with the specified length.<p>		 *		 * To get a whitespace string tuned to the current buffer's		 * settings, call this method as follows:		 *		 * <pre>myWhitespace = MiscUtilities.createWhiteSpace(myLength,		 *     (buffer.getBooleanProperty("noTabs") ? 0		 *     : buffer.getTabSize()));</pre>		 *		 * @param len The length		 * @param tabSize The tab size, or 0 if tabs are not to be used		 */		public static String createWhiteSpace(int len, int tabSize)		{			return createWhiteSpace(len,tabSize,0);		}	
public static String truncateWhiteSpace(int len, int tabSize,			String indentStr)		{			StringBuilder buf = new StringBuilder();			int indent = 0;			for (int i = 0; indent < len && i < indentStr.length(); i++)			{				char c = indentStr.charAt(i);				if (c == ' ')				{					indent++;					buf.append(c);				}				else if (c == '\t')				{					int withTab = indent + tabSize - (indent % tabSize);					if (withTab > len)					{						for (; indent < len; indent++)							buf.append(' ');					}					else					{						indent = withTab;						buf.append(c);					}				}			}			return buf.toString();		}	
/**		 * Creates a string of white space with the specified length.<p>		 *		 * To get a whitespace string tuned to the current buffer's		 * settings, call this method as follows:		 *		 * <pre>myWhitespace = MiscUtilities.createWhiteSpace(myLength,		 *     (buffer.getBooleanProperty("noTabs") ? 0		 *     : buffer.getTabSize()));</pre>		 *		 * @param len The length		 * @param tabSize The tab size, or 0 if tabs are not to be used		 * @param start The start offset, for tab alignment		 */		public static String createWhiteSpace(int len, int tabSize, int start)		{			StringBuilder buf = new StringBuilder();			if(tabSize == 0)			{				while(len-- > 0)					buf.append(' ');			}			else if(len == 1)				buf.append(' ');			else			{				int count = (len + start % tabSize) / tabSize;				if(count != 0)					len += start;				while(count-- > 0)					buf.append('\t');				count = len % tabSize;				while(count-- > 0)					buf.append(' ');			}			return buf.toString();		}	
/**		 * Returns the virtual column number (taking tabs into account) of the		 * specified offset in the segment.		 *		 * @param seg The segment		 * @param tabSize The tab size		 */		public static int getVirtualWidth(Segment seg, int tabSize)		{			int virtualPosition = 0;				for (int i = 0; i < seg.count; i++)			{				char ch = seg.array[seg.offset + i];					if (ch == '\t')				{					virtualPosition += tabSize						- virtualPosition % tabSize;				}				else				{					++virtualPosition;				}			}				return virtualPosition;		}	
/**		 * Returns the array offset of a virtual column number (taking tabs		 * into account) in the segment.		 *		 * @param seg The segment		 * @param tabSize The tab size		 * @param column The virtual column number		 * @param totalVirtualWidth If this array is non-null, the total		 * virtual width will be stored in its first location if this method		 * returns -1.		 *		 * @return -1 if the column is out of bounds		 */		public static int getOffsetOfVirtualColumn(Segment seg, int tabSize,						    int column, int[] totalVirtualWidth)		{			int virtualPosition = 0;				for (int i = 0; i < seg.count; i++)			{				char ch = seg.array[seg.offset + i];					if (ch == '\t')				{					int tabWidth = tabSize						- virtualPosition % tabSize;					if(virtualPosition >= column)						return i;					else						virtualPosition += tabWidth;				}				else				{					if(virtualPosition >= column)						return i;					else						++virtualPosition;				}			}				if(totalVirtualWidth != null)				totalVirtualWidth[0] = virtualPosition;			return -1;		}	
/**		 * Compares two strings.<p>		 *		 * Unlike <function>String.compareTo()</function>,		 * this method correctly recognizes and handles embedded numbers.		 * For example, it places "My file 2" before "My file 10".<p>		 *		 * @param str1 The first string		 * @param str2 The second string		 * @param ignoreCase If true, case will be ignored		 * @return negative If str1 &lt; str2, 0 if both are the same,		 * positive if str1 &gt; str2		 * @since jEdit 4.3pre5		 */		public static int compareStrings(String str1, String str2, boolean ignoreCase)		{			char[] char1 = str1.toCharArray();			char[] char2 = str2.toCharArray();				int len = Math.min(char1.length,char2.length);				for(int i = 0, j = 0; i < len && j < len; i++, j++)			{				char ch1 = char1[i];				char ch2 = char2[j];				if(Character.isDigit(ch1) && Character.isDigit(ch2)					&& ch1 != '0' && ch2 != '0')				{					int _i = i + 1;					int _j = j + 1;						for(; _i < char1.length; _i++)					{						if(!Character.isDigit(char1[_i]))						{							//_i--;							break;						}					}						for(; _j < char2.length; _j++)					{						if(!Character.isDigit(char2[_j]))						{							//_j--;							break;						}					}						int len1 = _i - i;					int len2 = _j - j;					if(len1 > len2)						return 1;					else if(len1 < len2)						return -1;					else					{						for(int k = 0; k < len1; k++)						{							ch1 = char1[i + k];							ch2 = char2[j + k];							if(ch1 != ch2)								return ch1 - ch2;						}					}						i = _i - 1;					j = _j - 1;				}				else				{					if(ignoreCase)					{						ch1 = Character.toLowerCase(ch1);						ch2 = Character.toLowerCase(ch2);					}						if(ch1 != ch2)						return ch1 - ch2;				}			}				return char1.length - char2.length;		}	
public StringCompare(boolean icase)			{				this.icase = icase;			}	
public StringCompare()			{			}	
public int compare(E obj1, E obj2)			{				return compareStrings(obj1.toString(),					obj2.toString(),icase);			}	
/**		 * Returns if two strings are equal. This correctly handles null pointers,		 * as opposed to calling <code>o1.equals(o2)</code>.		 * @since jEdit 4.3pre6		 */		public static boolean objectsEqual(Object o1, Object o2)		{			if(o1 == null)			{				if(o2 == null)					return true;				else					return false;			}			else if(o2 == null)				return false;			else				return o1.equals(o2);		}	
/**		 * Converts a Unix-style glob to a regular expression.<p>		 *		 * ? becomes ., * becomes .*, {aa,bb} becomes (aa|bb).		 * @param glob The glob pattern		 * @since jEdit 4.3pre7		 */		public static String globToRE(String glob)		{			if (glob.startsWith("(re)"))			{				return glob.substring(4);			}				final Object NEG = new Object();			final Object GROUP = new Object();			Stack<Object> state = new Stack<Object>();				StringBuilder buf = new StringBuilder();			boolean backslash = false;				for(int i = 0; i < glob.length(); i++)			{				char c = glob.charAt(i);				if(backslash)				{					buf.append('\\');					buf.append(c);					backslash = false;					continue;				}					switch(c)				{				case '\\':					backslash = true;					break;				case '?':					buf.append('.');					break;				case '.':				case '+':				case '(':				case ')':					buf.append('\\');					buf.append(c);					break;				case '*':					buf.append(".*");					break;				case '|':					if(backslash)						buf.append("\\|");					else						buf.append('|');					break;				case '{':					buf.append('(');					if(i + 1 != glob.length() && glob.charAt(i + 1) == '!')					{						buf.append('?');						state.push(NEG);					}					else						state.push(GROUP);					break;				case ',':					if(!state.isEmpty() && state.peek() == GROUP)						buf.append('|');					else						buf.append(',');					break;				case '}':					if(!state.isEmpty())					{						buf.append(')');						if(state.pop() == NEG)							buf.append(".*");					}					else						buf.append('}');					break;				default:					buf.append(c);				}			}				return buf.toString();		}	
/**		 * Implementation of String.regionMatches() for CharSequence.		 *		 * @param seq The test CharSequence.		 * @param toff Offset for the test sequence.		 * @param other The sequence to compare to.		 * @param ooff Offset of the comparison sequence.		 * @param len How many characters to compare.		 * @return Whether the two subsequences are equal.		 * @see String#regionMatches(int,String,int,int)		 *		 * @since jEdit 4.3pre15		 */		public static boolean regionMatches(CharSequence seq,						    int toff,						    CharSequence other,						    int ooff,						    int len)		{				if (toff < 0 || ooff < 0 || len < 0)				return false;				boolean ret = true;			for (int i = 0; i < len; i++)			{				char c1;					if (i + toff < seq.length())					c1 = seq.charAt(i + toff);				else				{					ret = false;					break;				}					char c2;				if (i + ooff < other.length())					c2 = other.charAt(i + ooff);				else				{					ret = false;					break;				}					if (c1 != c2)				{					ret = false;					break;				}			}				return ret;		}	
/**		 * Implementation of String.startsWith() for CharSequence.		 *		 * @param seq The CharSequence.		 * @param str String to test.		 * @return Whether the sequence starts with the test string.		 *		 * @since jEdit 4.3pre15		 */		public static boolean startsWith(CharSequence seq, String str)		{			boolean ret = true;			for (int i = 0; i < str.length(); i++)			{				if (i >= seq.length() ||				    seq.charAt(i) != str.charAt(i))				{					ret = false;					break;				}			}			return ret;		}	
/**		 * Returns a boolean from a given object.		 * @param obj the object		 * @param def The default value		 * @return the boolean value if obj is a Boolean,		 * true if the value is "true", "yes", "on",		 * false if the value is "false", "no", "off"		 * def if the value is null or anything else		 * @since jEdit 4.3pre17		 */		public static boolean getBoolean(Object obj, boolean def)		{			if(obj == null)				return def;			else if(obj instanceof Boolean)				return ((Boolean)obj).booleanValue();			else if("true".equals(obj) || "yes".equals(obj)				|| "on".equals(obj))				return true;			else if("false".equals(obj) || "no".equals(obj)				|| "off".equals(obj))				return false;				return def;		}	
private StandardUtilities(){}	
public StatusBar(View view)		{			super(new BorderLayout());			setName("StatusBar");			setBorder(new CompoundBorder(new EmptyBorder(4,0,0,				(OperatingSystem.isMacOS() ? 18 : 0)),				UIManager.getBorder("TextField.border")));				this.view = view;				panel = new JPanel(new BorderLayout());			box = new Box(BoxLayout.X_AXIS);			panel.add(BorderLayout.EAST,box);			add(BorderLayout.CENTER,panel);				MouseHandler mouseHandler = new MouseHandler();				caretStatus = new ToolTipLabel();			caretStatus.setName("caretStatus");			caretStatus.setToolTipText(jEdit.getProperty("view.status.caret-tooltip"));			caretStatus.addMouseListener(mouseHandler);				message = new JLabel(" ");			setMessageComponent(message);				modeWidget = _getWidget("mode");			foldWidget = _getWidget("fold");			encodingWidget = _getWidget("encoding");			wrapWidget = _getWidget("wrap");			multiSelectWidget = _getWidget("multiSelect");			rectSelectWidget = _getWidget("rectSelect");			overwriteWidget = _getWidget("overwrite");			lineSepWidget = _getWidget("lineSep");		}	
public void propertiesChanged()		{			Color fg = jEdit.getColorProperty("view.status.foreground");			Color bg = jEdit.getColorProperty("view.status.background");				showCaretStatus = jEdit.getBooleanProperty("view.status.show-caret-status");				panel.setBackground(bg);			panel.setForeground(fg);			caretStatus.setBackground(bg);			caretStatus.setForeground(fg);			message.setBackground(bg);			message.setForeground(fg);				// retarded GTK look and feel!			Font font = new JLabel().getFont();			//UIManager.getFont("Label.font");			FontMetrics fm = getFontMetrics(font);				if (showCaretStatus)			{				panel.add(BorderLayout.WEST,caretStatus);					caretStatus.setFont(font);					Dimension dim = new Dimension(fm.stringWidth(caretTestStr),						fm.getHeight());				caretStatus.setPreferredSize(dim);				updateCaretStatus();			}			else				panel.remove(caretStatus);				String statusBar = jEdit.getProperty("view.status");			if (!StandardUtilities.objectsEqual(currentBar, statusBar))			{				box.removeAll();				StringTokenizer tokenizer = new StringTokenizer(statusBar);				while (tokenizer.hasMoreTokens())				{					String token = tokenizer.nextToken();					if (Character.isLetter(token.charAt(0)))					{						Widget widget = getWidget(token);						if (widget == null)						{							Log.log(Log.WARNING, this, "Widget " + token + " doesn't exist");							continue;						}						Component c = widget.getComponent();						c.setBackground(bg);						c.setForeground(fg);						box.add(c);						widget.update();						widget.propertiesChanged();					}					else					{						JLabel label = new JLabel(token);						label.setBackground(bg);						label.setForeground(fg);						box.add(label);					}				}				currentBar = statusBar;			}			updateBufferStatus();			updateMiscStatus();		}	
@Override		public void addNotify()		{			super.addNotify();			VFSManager.getIOThreadPool().addProgressListener(this);		}	
@Override		public void removeNotify()		{			super.removeNotify();			VFSManager.getIOThreadPool().removeProgressListener(this);		}	
public void statusUpdate(final WorkThreadPool threadPool, int threadIndex)		{			SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					// don't obscure existing message					if(message != null && !"".equals(message.getText().trim())						&& !currentMessageIsIO)						return;						int requestCount = threadPool.getRequestCount();					if(requestCount == 0)					{						setMessageAndClear(jEdit.getProperty(							"view.status.io.done"));						currentMessageIsIO = true;					}					else if(requestCount == 1)					{						setMessage(jEdit.getProperty(							"view.status.io-1"));						currentMessageIsIO = true;					}					else					{						Object[] args = {Integer.valueOf(requestCount)};						setMessage(jEdit.getProperty(							"view.status.io",args));						currentMessageIsIO = true;					}				}			});		}	
public void progressUpdate(WorkThreadPool threadPool, int threadIndex)		{		}	
/**		 * Show a message for a short period of time.		 * @param message The message		 * @since jEdit 3.2pre5		 */		public void setMessageAndClear(String message)		{			setMessage(message);				tempTimer = new Timer(0,new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					// so if view is closed in the meantime...					if(isShowing())						setMessage(null);				}			});				tempTimer.setInitialDelay(10000);			tempTimer.setRepeats(false);			tempTimer.start();		}	
/**		 * Displays a status message.		 * @param message the message to display, it can be null		 */		public void setMessage(String message)		{			if(tempTimer != null)			{				tempTimer.stop();				tempTimer = null;			}				setMessageComponent(this.message);				if(message == null)			{				if(view.getMacroRecorder() != null)					this.message.setText(jEdit.getProperty("view.status.recording"));				else					this.message.setText(" ");			}			else				this.message.setText(message);		}	
public void setMessageComponent(Component comp)		{			currentMessageIsIO = false;				if (comp == null || messageComp == comp)			{				return;			}				messageComp = comp;			panel.add(BorderLayout.CENTER, messageComp);		}	
public void updateCaretStatus()		{			if (showCaretStatus)			{				Buffer buffer = view.getBuffer();					if(!buffer.isLoaded() ||					/* can happen when switching buffers sometimes */					buffer != view.getTextArea().getBuffer())				{					caretStatus.setText(" ");					return;				}					JEditTextArea textArea = view.getTextArea();					int caretPosition = textArea.getCaretPosition();				int currLine = textArea.getCaretLine();					// there must be a better way of fixing this...				// the problem is that this method can sometimes				// be called as a result of a text area scroll				// event, in which case the caret position has				// not been updated yet.				if(currLine >= buffer.getLineCount())					return; // hopefully another caret update will come?					int start = textArea.getLineStartOffset(currLine);				int dot = caretPosition - start;		 			if(dot < 0)	 				return;	 				int bufferLength = buffer.getLength();		 			buffer.getText(start,dot,seg);	 			int virtualPosition = StandardUtilities.getVirtualWidth(seg,	 				buffer.getTabSize());				// for GC				seg.array = null;				seg.count = 0;	 				// per lengthy discussion on dev list, format for caret				// position is lineno,dot-virtual (caret/total) e.g.				// 388,10-31 (8835/13414).  No more "Top" nor "Bottom".				if (jEdit.getBooleanProperty("view.status.show-caret-linenumber", true))				{					buf.append(currLine + 1);					buf.append(',');				}				if (jEdit.getBooleanProperty("view.status.show-caret-dot", true))				{					buf.append(dot + 1);				}				if (jEdit.getBooleanProperty("view.status.show-caret-virtual", true) &&					virtualPosition != dot)				{					buf.append('-');					buf.append(virtualPosition + 1);				}				if (buf.length() > 0) 				{					buf.append(' ');				}				if (jEdit.getBooleanProperty("view.status.show-caret-offset", true) &&					jEdit.getBooleanProperty("view.status.show-caret-bufferlength", true))				{					buf.append('(');					buf.append(caretPosition);					buf.append('/');					buf.append(bufferLength);					buf.append(')');				}				else if (jEdit.getBooleanProperty("view.status.show-caret-offset", true))				{					buf.append('(');					buf.append(caretPosition);					buf.append(')');				}				else if (jEdit.getBooleanProperty("view.status.show-caret-bufferlength", true))				{					buf.append('(');					buf.append(bufferLength);					buf.append(')');				}						 			caretStatus.setText(buf.toString());	 			buf.setLength(0);	 		}					}	
public void updateBufferStatus()		{			wrapWidget.update();			lineSepWidget.update();			modeWidget.update();			foldWidget.update();			encodingWidget.update();		}	
public void updateMiscStatus()		{			multiSelectWidget.update();			rectSelectWidget.update();			overwriteWidget.update();		}	
private Widget getWidget(String name)		{			if ("mode".equals(name))				return modeWidget;			if ("fold".equals(name))				return foldWidget;			if ("encoding".equals(name))				return encodingWidget;			if ("wrap".equals(name))				return wrapWidget;			if ("multiSelect".equals(name))				return multiSelectWidget;			if ("rectSelect".equals(name))				return rectSelectWidget;			if ("overwrite".equals(name))				return overwriteWidget;			if ("lineSep".equals(name))				return lineSepWidget;				return _getWidget(name);		}	
private Widget _getWidget(String name)		{			StatusWidgetFactory widgetFactory =			(StatusWidgetFactory) ServiceManager.getService("org.gjt.sp.jedit.gui.statusbar.StatusWidget", name);			if (widgetFactory == null)			{				Log.log(Log.ERROR, this, "Widget " + name + " doesn't exist");				return null;			}			return widgetFactory.getWidget(view);		}	
@Override			public void mouseClicked(MouseEvent evt)			{				Object source = evt.getSource();				if(source == caretStatus && evt.getClickCount() == 2)				{					view.getTextArea().showGoToLineDialog();				}			}	
public StatusBarOptionPane()		{			super("status");		}	
@Override		protected void _init()		{			setLayout(new BorderLayout());				//{{{ North			JPanel panel = new JPanel(new GridLayout(2,1));			showStatusbar = new JCheckBox(jEdit.getProperty(				"options.status.visible"));			showStatusbar.setSelected(jEdit.getBooleanProperty("view.status.visible"));			panel.add(showStatusbar);			showStatusbarPlain = new JCheckBox(jEdit.getProperty(				"options.status.plainview.visible"));			showStatusbarPlain.setSelected(jEdit.getBooleanProperty("view.status.plainview.visible"));			panel.add(showStatusbarPlain);			panel.add(new JLabel(jEdit.getProperty(				"options.status.caption")));			add(panel, BorderLayout.NORTH);			//}}}				//{{{ Options panel			AbstractOptionPane optionsPanel = new AbstractOptionPane("Status Options");			/* Foreground color */			optionsPanel.addComponent(jEdit.getProperty("options.status.foreground"),				foregroundColor = new ColorWellButton(				jEdit.getColorProperty("view.status.foreground")),				GridBagConstraints.VERTICAL);				/* Background color */			optionsPanel.addComponent(jEdit.getProperty("options.status.background"),				backgroundColor = new ColorWellButton(				jEdit.getColorProperty("view.status.background")),				GridBagConstraints.VERTICAL);				/* Memory foreground color */			optionsPanel.addComponent(jEdit.getProperty("options.status.memory.foreground"),				memForegroundColor = new ColorWellButton(				jEdit.getColorProperty("view.status.memory.foreground")),				GridBagConstraints.VERTICAL);				/* Memory background color */			optionsPanel.addComponent(jEdit.getProperty("options.status.memory.background"),				memBackgroundColor = new ColorWellButton(				jEdit.getColorProperty("view.status.memory.background")),				GridBagConstraints.VERTICAL);				optionsPanel.addSeparator();			optionsPanel.addComponent(new JLabel(jEdit.getProperty("options.status.caret.title", "Caret position display options:")));				/*			Caret position format: lineno,dot-virtual (caretpos/bufferlength)			view.status.show-caret-linenumber -- true shows line number for caret (lineno)			view.status.show-caret-dot -- true shows offset in line for caret (dot)			view.status.show-caret-virtual -- true shows virtual offset in line for caret (virtual)			view.status.show-caret-offset -- true shows caret offset from start of buffer (caretpos)			view.status.show-caret-bufferlength -- true shows length of buffer (bufferlength)			*/			showCaretLineNumber = new JCheckBox(jEdit.getProperty("options.status.caret.linenumber", "Show caret line number"),				jEdit.getBooleanProperty("view.status.show-caret-linenumber", true));			showCaretLineNumber.setName("showCaretLineNumber");			showCaretDot = new JCheckBox(jEdit.getProperty("options.status.caret.dot", "Show caret offset from start of line"),				jEdit.getBooleanProperty("view.status.show-caret-dot", true));			showCaretDot.setName("showCaretDot");			showCaretVirtual = new JCheckBox(jEdit.getProperty("options.status.caret.virtual", "Show caret virtual offset from start of line"),				jEdit.getBooleanProperty("view.status.show-caret-virtual", true));			showCaretVirtual.setName("showCaretVirtual");			showCaretOffset = new JCheckBox(jEdit.getProperty("options.status.caret.offset", "Show caret offset from start of file"),				jEdit.getBooleanProperty("view.status.show-caret-offset", true));			showCaretOffset.setName("showCaretOffset");			showCaretBufferLength = new JCheckBox(jEdit.getProperty("options.status.caret.bufferlength", "Show length of file"),				jEdit.getBooleanProperty("view.status.show-caret-bufferlength", true));			showCaretBufferLength.setName("showCaretBufferLength");			optionsPanel.addComponent(showCaretLineNumber);			optionsPanel.addComponent(showCaretDot);			optionsPanel.addComponent(showCaretVirtual);			optionsPanel.addComponent(showCaretOffset);			optionsPanel.addComponent(showCaretBufferLength);				//}}}					//{{{ widgets panel			String statusbar = jEdit.getProperty("view.status");			StringTokenizer st = new StringTokenizer(statusbar);			listModel = new DefaultListModel();			while (st.hasMoreTokens())			{				String token = st.nextToken();				listModel.addElement(token);			}					list = new JList(listModel);			list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			list.addListSelectionListener(new ListHandler());				JPanel widgetsPanel = new JPanel(new BorderLayout());			widgetsPanel.add(new JScrollPane(list), BorderLayout.CENTER);			//}}}				//{{{ Create buttons			JPanel buttons = new JPanel();			buttons.setBorder(new EmptyBorder(3,0,0,0));			buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));			ActionHandler actionHandler = new ActionHandler();			add = new RolloverButton(GUIUtilities.loadIcon("Plus.png"));			add.setToolTipText(jEdit.getProperty("options.status.add"));			add.addActionListener(actionHandler);			buttons.add(add);			buttons.add(Box.createHorizontalStrut(6));			remove = new RolloverButton(GUIUtilities.loadIcon("Minus.png"));			remove.setToolTipText(jEdit.getProperty("options.status.remove"));			remove.addActionListener(actionHandler);			buttons.add(remove);			buttons.add(Box.createHorizontalStrut(6));			moveUp = new RolloverButton(GUIUtilities.loadIcon("ArrowU.png"));			moveUp.setToolTipText(jEdit.getProperty("options.status.moveUp"));			moveUp.addActionListener(actionHandler);			buttons.add(moveUp);			buttons.add(Box.createHorizontalStrut(6));			moveDown = new RolloverButton(GUIUtilities.loadIcon("ArrowD.png"));			moveDown.setToolTipText(jEdit.getProperty("options.status.moveDown"));			moveDown.addActionListener(actionHandler);			buttons.add(moveDown);			buttons.add(Box.createHorizontalStrut(6));			edit = new RolloverButton(GUIUtilities.loadIcon("ButtonProperties.png"));			edit.setToolTipText(jEdit.getProperty("options.status.edit"));			edit.addActionListener(actionHandler);			buttons.add(edit);			buttons.add(Box.createGlue());			//}}}				updateButtons();			widgetsPanel.add(buttons, BorderLayout.SOUTH);					JTabbedPane tabs = new JTabbedPane();			tabs.addTab("Options",optionsPanel);			tabs.add("Widgets", widgetsPanel);				add(tabs, BorderLayout.CENTER);		}	
@Override		protected void _save()		{			jEdit.setColorProperty("view.status.foreground",foregroundColor				.getSelectedColor());			jEdit.setColorProperty("view.status.background",backgroundColor				.getSelectedColor());			jEdit.setColorProperty("view.status.memory.foreground",memForegroundColor				.getSelectedColor());			jEdit.setColorProperty("view.status.memory.background",memBackgroundColor				.getSelectedColor());				jEdit.setBooleanProperty("view.status.visible",showStatusbar				.isSelected());				jEdit.setBooleanProperty("view.status.plainview.visible",showStatusbarPlain				.isSelected());				StringBuilder buf = new StringBuilder();			for(int i = 0; i < listModel.getSize(); i++)			{				if(i != 0)					buf.append(' ');					String widgetName = (String) listModel.elementAt(i);				buf.append(widgetName);			}			jEdit.setProperty("view.status",buf.toString());				jEdit.setBooleanProperty("view.status.show-caret-linenumber", showCaretLineNumber.isSelected());			jEdit.setBooleanProperty("view.status.show-caret-dot", showCaretDot.isSelected());			jEdit.setBooleanProperty("view.status.show-caret-virtual", showCaretVirtual.isSelected());			jEdit.setBooleanProperty("view.status.show-caret-offset", showCaretOffset.isSelected());			jEdit.setBooleanProperty("view.status.show-caret-bufferlength", showCaretBufferLength.isSelected());			}	
private void updateButtons()		{			int index = list.getSelectedIndex();			remove.setEnabled(index != -1 && listModel.getSize() != 0);			moveUp.setEnabled(index > 0);			moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);			edit.setEnabled(index != -1);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();					if(source == add)				{					String value = selectWidget();					if (value == null)						return;							int index = list.getSelectedIndex();					if(index == -1)						index = listModel.getSize();					else						index++;						listModel.insertElementAt(value,index);					list.setSelectedIndex(index);					list.ensureIndexIsVisible(index);				}				else if(source == remove)				{					int index = list.getSelectedIndex();					listModel.removeElementAt(index);					if(listModel.getSize() != 0)					{						if(listModel.getSize() == index)							list.setSelectedIndex(index-1);						else							list.setSelectedIndex(index);					}					updateButtons();				}				else if(source == moveUp)				{					int index = list.getSelectedIndex();					Object selected = list.getSelectedValue();					listModel.removeElementAt(index);					listModel.insertElementAt(selected,index-1);					list.setSelectedIndex(index-1);					list.ensureIndexIsVisible(index-1);				}				else if(source == moveDown)				{					int index = list.getSelectedIndex();					Object selected = list.getSelectedValue();					listModel.removeElementAt(index);					listModel.insertElementAt(selected,index+1);					list.setSelectedIndex(index+1);					list.ensureIndexIsVisible(index+1);				}				else if(source == edit)				{					String value = selectWidget();					if (value == null)						return;						int index = list.getSelectedIndex();						listModel.insertElementAt(value,index);					list.setSelectedIndex(index);					list.ensureIndexIsVisible(index);				}			}	
private String selectWidget()			{				WidgetSelectionDialog dialog = new WidgetSelectionDialog(StatusBarOptionPane.this);				String value = dialog.getValue();				if (value != null && value.length() == 0)					value = null;				return value;			}	
public void valueChanged(ListSelectionEvent evt)			{				updateButtons();			}	
WidgetSelectionDialog(Component comp)			{				super(GUIUtilities.getParentDialog(comp),				      jEdit.getProperty("options.status.edit.title"),				      true);				ButtonGroup buttonGroup = new ButtonGroup();				labelRadio = new JRadioButton(jEdit.getProperty("options.status.edit.labelRadioButton"));				widgetRadio = new JRadioButton(jEdit.getProperty("options.status.edit.widgetRadioButton"));				buttonGroup.add(labelRadio);				buttonGroup.add(widgetRadio);					labelLabel = new JLabel(jEdit.getProperty("options.status.edit.labelLabel"));				labelField = new JTextField();					widgetLabel = new JLabel(jEdit.getProperty("options.status.edit.widgetLabel"));				widgetCombo = new JComboBox(ServiceManager.getServiceNames("org.gjt.sp.jedit.gui.statusbar.StatusWidget"));					ActionHandler actionHandler = new ActionHandler();				labelRadio.addActionListener(actionHandler);				widgetRadio.addActionListener(actionHandler);				//{{{ south panel				JPanel southPanel = new JPanel();				southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));				southPanel.setBorder(new EmptyBorder(12,0,0,0));				southPanel.add(Box.createGlue());				ok = new JButton(jEdit.getProperty("common.ok"));				ok.addActionListener(actionHandler);				getRootPane().setDefaultButton(ok);				southPanel.add(ok);				southPanel.add(Box.createHorizontalStrut(6));				cancel = new JButton(jEdit.getProperty("common.cancel"));				cancel.addActionListener(actionHandler);				southPanel.add(cancel);				southPanel.add(Box.createGlue());				//}}}					labelField.setEnabled(false);				widgetRadio.setSelected(true);						JPanel content = new JPanel(new BorderLayout());				content.setBorder(new EmptyBorder(12,12,12,12));				setContentPane(content);				JPanel center = new JPanel();				center.setLayout(new BoxLayout(center,BoxLayout.Y_AXIS));					center.add(labelRadio);				JPanel p = new JPanel(new BorderLayout());				p.add(labelLabel, BorderLayout.WEST);				p.add(labelField);				center.add(p);				center.add(widgetRadio);				p = new JPanel(new BorderLayout());				p.add(widgetLabel, BorderLayout.WEST);				p.add(widgetCombo);				center.add(p);							getContentPane().add(center, BorderLayout.CENTER);				getContentPane().add(southPanel, BorderLayout.SOUTH);				pack();				setLocationRelativeTo(GUIUtilities.getParentDialog(comp));				setVisible(true);			}	
@Override			public void ok()			{				if (widgetRadio.isSelected())				{					value = (String) widgetCombo.getSelectedItem();				}				else				{					value = labelField.getText().trim();				}				dispose();			}	
@Override			public void cancel()			{				value = null;				dispose();			}	
public String getValue()			{				return value;			}	
public void actionPerformed(ActionEvent evt)				{					Object source = evt.getSource();					if (source == ok)					{						ok();					}					else if (source == cancel)					{						cancel();					}					else if (source == labelRadio)					{						labelField.setEnabled(true);						widgetCombo.setEnabled(false);						validate();					}					else if (source == widgetRadio)					{						labelField.setEnabled(false);						widgetCombo.setEnabled(true);						validate();					}				}	
public StringList()		{		}	
public StringList(Object[] array)		{			addAll(array);		}	
public void addAll(Object[] array)		{			for (int i = 0; i < array.length; ++i)			{				add(array[i].toString());			}		}	
/**		 * @param orig the original string		 * @param delim a delimiter to use for splitting		 * @return a new StringList containing the split strings.		 */		public static StringList split(String orig, Object delim)		{			if ((orig == null) || (orig.length() == 0))				return new StringList();			return new StringList(orig.split(delim.toString()));		}	
/**		 * Joins each string in the list with a newline.		 * @return a joined string representation of this, 		 * with the newline (\n) as delimiter. 		 */		@Override		public String toString()		{			return join("\n");		}	
/** @return an array of String */		@Override		public String[] toArray() 		{			int siz = size();			String[] result = new String[siz];			System.arraycopy(super.toArray(), 0, result, 0, siz);			return result;		}	
/**		 * The reverse of split - given a collection, takes each element		 * and places it in a string, joined by a delimiter.		 */		public static String join(Collection c, String delim)		{			StringList sl = new StringList();			for (Object o: c) {				String s = o.toString();				sl.add(s);			}			return sl.join(delim);		}	
/**		 *		 * @param arr array of objects		 * @param delim delimiter to separate strings		 * @return a single string with each element in arr converted to a string and concatenated,		 * separated by delim.		 */		public static String join(Object[] arr, String delim) 		{			StringList sl = new StringList();			sl.addAll(arr);			return sl.join(delim);		}	
/**		 * Non-static version, that joins "this" StringList.		 * @param delim the delimiter		 * @return a joined string with delim inbetween each element		 */		public String join(String delim) 		{			int s = size();			if (s < 1)				return "";			if (s == 1)				return get(0);			else			{				StringBuilder retval = new StringBuilder();				retval.append(get(0));				for (int i = 1; i < s; ++i)					retval.append(delim + get(i));				return retval.toString();			}			}	
public static void main(String args[])		{			String teststr = "a,b,c,d,e,f";			StringList.split(teststr, ",");			//String joinstr = sl.join(",");			// assert(teststr.equals(joinstr));			System.out.println("Test Passed");			}	
public static String [] split( String s, String delim) {			Vector v = new Vector();			StringTokenizer st = new StringTokenizer(s, delim);			while ( st.hasMoreTokens() )				v.addElement( st.nextToken() );			String [] sa = new String [ v.size() ];			v.copyInto( sa );			return sa;		}	
public static String [] bubbleSort( String [] in ) {			Vector v = new Vector();			for(int i=0; i<in.length; i++)				v.addElement(in[i]);				int n = v.size();			boolean swap = true;			while ( swap ) {				swap = false;				for(int i=0; i<(n-1); i++)					if ( ((String)v.elementAt(i)).compareTo(							((String)v.elementAt(i+1)) ) > 0 ) {						String tmp = (String)v.elementAt(i+1);						v.removeElementAt( i+1 );						v.insertElementAt( tmp, i );						swap = true;					}			}				String [] out = new String [ n ];			v.copyInto(out);			return out;		}	
public static String maxCommonPrefix( String one, String two ) {			int i=0;			while( one.regionMatches( 0, two, 0, i ) )				i++;			return one.substring(0, i-1);		}	
public static String methodString(String name, Class[] types)	    {	    	StringBuilder sb = new StringBuilder(name + "(");	        if ( types.length > 0 )				sb.append(" ");	        for( int i=0; i<types.length; i++ )	        {	            Class c = types[i];	            sb.append( ( (c == null) ? "null" : c.getName() ) 					+ ( i < (types.length-1) ? ", " : " " ) );	        }	        sb.append(")");	        return sb.toString();	    }	
/**			Hack - The real method is in Reflect.java which is not public.		*/	    public static String normalizeClassName( Class type )		{			return Reflect.normalizeClassName( type );		}	
public Match getMatch(TextArea textArea)			{				int offset = textArea.getCaretPosition()					- textArea.getLineStartOffset(					textArea.getCaretLine());					if(offset != 0)				{					int bracketOffset = TextUtilities.findMatchingBracket(						textArea.getBuffer(),						textArea.getCaretLine(),						offset - 1);					if(bracketOffset != -1)					{						int bracketLine = textArea							.getLineOfOffset(							bracketOffset);						return new Match(this,							bracketLine,							bracketOffset,							bracketLine,							bracketOffset + 1);					}				}					return null;			}	
public void selectMatch(TextArea textArea)			{				textArea.selectToMatchingBracket();			}	
public Match() {}	
public Match(StructureMatcher matcher)			{				this.matcher = matcher;			}	
public Match(StructureMatcher matcher, int startLine,				int start, int endLine, int end)			{				this(matcher);				this.startLine = startLine;				this.start = start;				this.endLine = endLine;				this.end = end;			}	
Highlight(TextArea textArea)			{				this.textArea = textArea;			}	
public void paintValidLine(Graphics2D gfx, int screenLine,				int physicalLine, int start, int end, int y)			{				if(!textArea.getPainter().isStructureHighlightEnabled())					return;					Match match = textArea.getStructureMatch();				if(match != null)				{					paintHighlight(gfx,screenLine,						start,end,y,match);				}			}	
private int[] getOffsets(int screenLine, Match match)			{				int x1, x2;					int matchStartLine = textArea.getScreenLineOfOffset(					match.start);				int matchEndLine = textArea.getScreenLineOfOffset(					match.end);					if(matchStartLine == screenLine)				{					x1 = match.start;				}				else				{					x1 = textArea.getScreenLineStartOffset(						screenLine);				}					if(matchEndLine == screenLine)				{					x2 = match.end;				}				else				{					x2 = textArea.getScreenLineEndOffset(						screenLine) - 1;				}					return new int[] {					textArea.offsetToXY(x1).x,					textArea.offsetToXY(x2).x				};			}	
private void paintHighlight(Graphics gfx, int screenLine,				int start, int end, int y,				Match match)			{				if(!textArea.isStructureHighlightVisible())					return;					if(match.start >= end || match.end < start)				{					return;				}					int matchStartLine = textArea.getScreenLineOfOffset(					match.start);				int matchEndLine = textArea.getScreenLineOfOffset(					match.end);					FontMetrics fm = textArea.getPainter().getFontMetrics();				int height = fm.getHeight();					int[] offsets = getOffsets(screenLine,match);				int x1 = offsets[0];				int x2 = offsets[1];					gfx.setColor(textArea.getPainter().getStructureHighlightColor());					gfx.drawLine(x1,y,x1,y + height - 1);				gfx.drawLine(x2,y,x2,y + height - 1);					if(matchStartLine == screenLine || screenLine == 0)					gfx.drawLine(x1,y,x2,y);				else				{					offsets = getOffsets(screenLine - 1,match);					int prevX1 = offsets[0];					int prevX2 = offsets[1];						gfx.drawLine(Math.min(x1,prevX1),y,						Math.max(x1,prevX1),y);					gfx.drawLine(Math.min(x2,prevX2),y,						Math.max(x2,prevX2),y);				}					if(matchEndLine == screenLine)				{					gfx.drawLine(x1,y + height - 1,						x2,y + height - 1);				}			}	
public StyleEditor(JDialog parent, SyntaxStyle style, String styleName)		{			super(parent, jEdit.getProperty("style-editor.title"),true);			initialize(parent, style, styleName);		}	
public StyleEditor(JFrame parent, SyntaxStyle style, String styleName)		{			super(parent, jEdit.getProperty("style-editor.title"),true);			initialize(parent, style, styleName);		}	
private void initialize(Component comp, SyntaxStyle style, String styleName)		{			JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				JPanel panel = new JPanel(new GridLayout(5,2,12,12));				panel.add(new JLabel(jEdit.getProperty("style-editor.tokenType")));			panel.add(new JLabel(styleName));						italics = new JCheckBox(jEdit.getProperty("style-editor.italics"));			italics.setSelected(style.getFont().isItalic());			panel.add(italics);			panel.add(new JLabel());				bold = new JCheckBox(jEdit.getProperty("style-editor.bold"));			bold.setSelected(style.getFont().isBold());			panel.add(bold);			panel.add(new JLabel());				Color fg = style.getForegroundColor();				fgColorCheckBox = new JCheckBox(jEdit.getProperty("style-editor.fgColor"));			fgColorCheckBox.setSelected(fg != null);			fgColorCheckBox.addActionListener(this);			panel.add(fgColorCheckBox);				fgColor = new ColorWellButton(fg);			fgColor.setEnabled(fg != null);			panel.add(fgColor);				Color bg = style.getBackgroundColor();			bgColorCheckBox = new JCheckBox(jEdit.getProperty("style-editor.bgColor"));			bgColorCheckBox.setSelected(bg != null);			bgColorCheckBox.addActionListener(this);			panel.add(bgColorCheckBox);				bgColor = new ColorWellButton(bg);			bgColor.setEnabled(bg != null);			panel.add(bgColor);				content.add(BorderLayout.CENTER,panel);				Box box = new Box(BoxLayout.X_AXIS);			box.add(Box.createGlue());			box.add(ok = new JButton(jEdit.getProperty("common.ok")));			getRootPane().setDefaultButton(ok);			ok.addActionListener(this);			box.add(Box.createHorizontalStrut(6));			box.add(cancel = new JButton(jEdit.getProperty("common.cancel")));			cancel.addActionListener(this);			box.add(Box.createGlue());				content.add(BorderLayout.SOUTH,box);				pack();			setLocationRelativeTo(comp);				setResizable(false);			setVisible(true);		}	
public void actionPerformed(ActionEvent evt)		{			Object source = evt.getSource();			if(source == ok)				ok();			else if(source == cancel)				cancel();			else if(source == fgColorCheckBox)				fgColor.setEnabled(fgColorCheckBox.isSelected());			else if(source == bgColorCheckBox)				bgColor.setEnabled(bgColorCheckBox.isSelected());		}	
public void ok()		{			okClicked = true;			dispose();		}	
public void cancel()		{			dispose();		}	
public SyntaxStyle getStyle()		{			if(!okClicked)				return null;				Color foreground = (fgColorCheckBox.isSelected()				? fgColor.getSelectedColor()				: null);				Color background = (bgColorCheckBox.isSelected()				? bgColor.getSelectedColor()				: null);				return new SyntaxStyle(foreground,background,					new Font("Dialog",					(italics.isSelected() ? Font.ITALIC : 0)					| (bold.isSelected() ? Font.BOLD : 0),					12));		}	
public SyntaxHiliteOptionPane()		{			super("syntax");		}	
@Override		protected void _init()		{			setLayout(new BorderLayout(6,6));				add(BorderLayout.CENTER,createStyleTableScroller());		}	
@Override		protected void _save()		{			styleModel.save();		}	
private JScrollPane createStyleTableScroller()		{			styleModel = createStyleTableModel();			styleTable = new JTable(styleModel);			styleTable.setRowSelectionAllowed(false);			styleTable.setColumnSelectionAllowed(false);			styleTable.setCellSelectionEnabled(false);			styleTable.getTableHeader().setReorderingAllowed(false);			styleTable.addMouseListener(new MouseHandler());			TableColumnModel tcm = styleTable.getColumnModel();	 		TableColumn styleColumn = tcm.getColumn(1);			styleColumn.setCellRenderer(new StyleTableModel.StyleRenderer());			Dimension d = styleTable.getPreferredSize();			d.height = Math.min(d.height,100);			JScrollPane scroller = new JScrollPane(styleTable);			scroller.setPreferredSize(d);			return scroller;		}	
private static StyleTableModel createStyleTableModel()		{			return new StyleTableModel();		}	
@Override			public void mouseClicked(MouseEvent evt)			{				int row = styleTable.rowAtPoint(evt.getPoint());				if(row == -1)					return;					SyntaxStyle style;				SyntaxStyle current = (SyntaxStyle)styleModel.getValueAt(row,1);				String token = (String) styleModel.getValueAt(row, 0);				JDialog dialog = GUIUtilities.getParentDialog(						SyntaxHiliteOptionPane.this);				if (dialog != null)					style = new StyleEditor(dialog, current, token).getStyle();				else				{					View view = GUIUtilities.getView(SyntaxHiliteOptionPane.this);					style = new StyleEditor(view, current, token).getStyle();				}				if(style != null)					styleModel.setValueAt(style,row,1);			}	
StyleTableModel()			{				styleChoices = new Vector<StyleChoice>(Token.ID_COUNT + 4);				// start at 1 not 0 to skip Token.NULL				for(int i = 1; i < Token.ID_COUNT; i++)				{					String tokenName = Token.tokenToString((byte)i);					addStyleChoice(tokenName,"view.style." + tokenName.toLowerCase());				}					addStyleChoice(jEdit.getProperty("options.syntax.foldLine.1"),				               "view.style.foldLine.1");				addStyleChoice(jEdit.getProperty("options.syntax.foldLine.2"),				               "view.style.foldLine.2");				addStyleChoice(jEdit.getProperty("options.syntax.foldLine.3"),				               "view.style.foldLine.3");				addStyleChoice(jEdit.getProperty("options.syntax.foldLine.0"),				               "view.style.foldLine.0");					Collections.sort(styleChoices,new StandardUtilities.StringCompare<StyleChoice>(true));			}	
public int getColumnCount()			{				return 2;			}	
public int getRowCount()			{				return styleChoices.size();			}	
public Object getValueAt(int row, int col)			{				StyleChoice ch = styleChoices.get(row);				switch(col)				{					case 0:						return ch.label;					case 1:						return ch.style;					default:						return null;				}			}	
@Override			public void setValueAt(Object value, int row, int col)			{				StyleChoice ch = styleChoices.get(row);				if(col == 1)					ch.style = (SyntaxStyle)value;				fireTableRowsUpdated(row,row);			}	
@Override			public String getColumnName(int index)			{				switch(index)				{					case 0:						return jEdit.getProperty("options.syntax.object");					case 1:						return jEdit.getProperty("options.syntax.style");					default:						return null;				}			}	
public void save()			{				for(int i = 0; i < styleChoices.size(); i++)				{					StyleChoice ch = styleChoices						.get(i);					jEdit.setProperty(ch.property,					                  GUIUtilities.getStyleString(ch.style));				}			}	
private void addStyleChoice(String label, String property)			{				styleChoices.add(new StyleChoice(label,				                                 property,				                                 GUIUtilities.parseStyle(jEdit.getProperty(property),				                                                         "Dialog",12)));			}	
StyleChoice(String label, String property, SyntaxStyle style)				{					this.label = label;					this.property = property;					this.style = style;				}	
					// for sorting				@Override				public String toString()				{					return label;				}	
StyleRenderer()				{					setOpaque(true);					setBorder(SyntaxHiliteOptionPane.noFocusBorder);					setText("Hello World");				}	
public Component getTableCellRendererComponent(					JTable table,					Object value,					boolean isSelected,					boolean cellHasFocus,					int row,					int col)				{					if (value != null)					{						SyntaxStyle style = (SyntaxStyle)value;						setForeground(style.getForegroundColor());						if (style.getBackgroundColor() != null)							setBackground(style.getBackgroundColor());						else						{							// this part sucks							setBackground(jEdit.getColorProperty(								"view.bgColor"));						}						setFont(style.getFont());					}						setBorder(cellHasFocus ? UIManager.getBorder(						"Table.focusCellHighlightBorder")					                       : SyntaxHiliteOptionPane.noFocusBorder);					return this;				}	
/**		 * Creates a new SyntaxStyle.		 * @param fgColor The text color		 * @param bgColor The background color		 * @param font The text font		 */		public SyntaxStyle(Color fgColor, Color bgColor, Font font)		{			this.fgColor = fgColor;			this.bgColor = bgColor;			this.font = font;		}	
/**		 * Returns the text color.		 */		public Color getForegroundColor()		{			return fgColor;		}	
/**		 * Returns the background color.		 */		public Color getBackgroundColor()		{			return bgColor;		}	
/**		 * Returns the style font.		 */		public Font getFont()		{			return font;		}	
/**		 * Checks if a subregion of a <code>Segment</code> is equal to a		 * character array.		 * @param ignoreCase True if case should be ignored, false otherwise		 * @param text The segment		 * @param offset The offset into the segment		 * @param match The character array to match		 * @since jEdit 4.2pre1		 */		public static boolean regionMatches(boolean ignoreCase, Segment text,			int offset, char[] match)		{			int length = offset + match.length;			if(length > text.offset + text.count)				return false;			char[] textArray = text.array;			for(int i = offset, j = 0; i < length; i++, j++)			{				char c1 = textArray[i];				char c2 = match[j];				if(ignoreCase)				{					c1 = Character.toUpperCase(c1);					c2 = Character.toUpperCase(c2);				}				if(c1 != c2)					return false;			}			return true;		}	
/**		 * Converts a color object to its hex value. The hex value		 * prefixed is with `#', for example `#ff0088'.		 * @param c The color object		 * @since jEdit 4.3pre13	 		 */		public static String getColorHexString(Color c)		{			String colString = Integer.toHexString(c.getRGB() & 0xffffff);			return "#000000".substring(0,7 - colString.length()).concat(colString);		}	
/**		 * @since jEdit 4.3pre13		 */		public static Color parseColor(String name, Color defaultColor)		{			if(name == null || name.length() == 0)				return defaultColor;			else if(name.charAt(0) == '#')			{				try				{					return Color.decode(name);				}				catch(NumberFormatException nf)				{					return defaultColor;				}			}			else if("red".equals(name))				return Color.red;			else if("green".equals(name))				return Color.green;			else if("blue".equals(name))				return Color.blue;			else if("yellow".equals(name))				return Color.yellow;			else if("orange".equals(name))				return Color.orange;			else if("white".equals(name))				return Color.white;			else if("lightGray".equals(name))				return Color.lightGray;			else if("gray".equals(name))				return Color.gray;			else if("darkGray".equals(name))				return Color.darkGray;			else if("black".equals(name))				return Color.black;			else if("cyan".equals(name))				return Color.cyan;			else if("magenta".equals(name))				return Color.magenta;			else if("pink".equals(name))				return Color.pink;			else				return defaultColor;		}	
/**		 * Converts a style string to a style object.		 * @param str The style string		 * @param family Style strings only specify font style, not font family		 * @param size Style strings only specify font style, not font family		 * @param color If false, the styles will be monochrome		 * @param defaultFgColor Default foreground color (if not specified in style string)		 * @exception IllegalArgumentException if the style is invalid		 * @since jEdit 4.3pre17		 */		public static SyntaxStyle parseStyle(String str, String family, int size,			boolean color, Color defaultFgColor)			throws IllegalArgumentException		{			Color fgColor = defaultFgColor;			Color bgColor = null;			boolean italic = false;			boolean bold = false;			StringTokenizer st = new StringTokenizer(str);			while(st.hasMoreTokens())			{				String s = st.nextToken();				if(s.startsWith("color:"))				{					if(color)						fgColor = parseColor(s.substring(6), Color.black);				}				else if(s.startsWith("bgColor:"))				{					if(color)						bgColor = parseColor(s.substring(8), null);				}				else if(s.startsWith("style:"))				{					for(int i = 6; i < s.length(); i++)					{						if(s.charAt(i) == 'i')							italic = true;						else if(s.charAt(i) == 'b')							bold = true;						else							throw new IllegalArgumentException(									"Invalid style: " + s);					}				}				else					throw new IllegalArgumentException(							"Invalid directive: " + s);			}			return new SyntaxStyle(fgColor,bgColor,					new Font(family,							(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0),							size));		}	
/**		 * Converts a style string to a style object.		 * @param str The style string		 * @param family Style strings only specify font style, not font family		 * @param size Style strings only specify font style, not font family		 * @param color If false, the styles will be monochrome		 * @exception IllegalArgumentException if the style is invalid		 * @since jEdit 4.3pre13		 */		public static SyntaxStyle parseStyle(String str, String family, int size,			boolean color)			throws IllegalArgumentException		{			return parseStyle(str, family, size, color, Color.black);		}	
/**		 * Loads the syntax styles from the properties, giving them the specified		 * base font family and size.		 * @param family The font family		 * @param size The font size		 * @since jEdit 4.3pre13		 */		public static SyntaxStyle[] loadStyles(String family, int size)		{			return loadStyles(family,size,true);		}	
/**		 * Loads the syntax styles from the properties, giving them the specified		 * base font family and size.		 * @param family The font family		 * @param size The font size		 * @param color If false, the styles will be monochrome		 * @since jEdit 4.3pre13		 */		public static SyntaxStyle[] loadStyles(String family, int size, boolean color)		{			SyntaxStyle[] styles = new SyntaxStyle[Token.ID_COUNT];				// start at 1 not 0 to skip Token.NULL			for(int i = 1; i < styles.length; i++)			{				try				{					String styleName = "view.style."						+ Token.tokenToString((byte)i)						.toLowerCase(Locale.ENGLISH);					styles[i] = parseStyle(						propertyManager.getProperty(styleName),						family,size,color);				}				catch(Exception e)				{					Log.log(Log.ERROR,StandardUtilities.class,e);				}			}				return styles;		}	
private SyntaxUtilities(){}	
public TargetError(			String msg, Throwable t, SimpleNode node, CallStack callstack, 			boolean inNativeCode )		{			super( msg, node, callstack );			target = t;			this.inNativeCode = inNativeCode;		}	
public TargetError( Throwable t, SimpleNode node, CallStack callstack )		{			this("TargetError", t, node, callstack, false);		}	
public Throwable getTarget()		{			// check for easy mistake			if(target instanceof InvocationTargetException)				return((InvocationTargetException)target).getTargetException();			else				return target;		}	
public String toString() 		{			return super.toString() 				+ "\nTarget exception: " + 				printTargetError( target );		}	
public void printStackTrace() { 			printStackTrace( false, System.err );		}	
public void printStackTrace( PrintStream out ) { 			printStackTrace( false, out );		}	
public void printStackTrace( boolean debug, PrintStream out ) {			if ( debug ) {				super.printStackTrace( out );				out.println("--- Target Stack Trace ---");			}			target.printStackTrace( out );		}	
/**			Generate a printable string showing the wrapped target exception.			If the proxy mechanism is available, allow the extended print to			check for UndeclaredThrowableException and print that embedded error.		*/		public String printTargetError( Throwable t ) 		{			String s = target.toString();				if ( Capabilities.canGenerateInterfaces() )				s += "\n" + xPrintTargetError( t );				return s;		}	
/**			Extended form of print target error.			This indirection is used to print UndeclaredThrowableExceptions 			which are possible when the proxy mechanism is available.				We are shielded from compile problems by using a bsh script.			This is acceptable here because we're not in a critical path...			Otherwise we'd need yet another dynamically loaded module just for this.		*/		public String xPrintTargetError( Throwable t ) 		{			String getTarget =				"import java.lang.reflect.UndeclaredThrowableException;"+				"String result=\"\";"+				"while ( target instanceof UndeclaredThrowableException ) {"+				"	target=target.getUndeclaredThrowable(); " +				"	result+=\"Nested: \"+target.toString();" +				"}"+				"return result;";			Interpreter i = new Interpreter();			try {				i.set("target", t);				return (String)i.eval( getTarget );			} catch ( EvalError e ) {				throw new InterpreterError("xprintarget: "+e.toString() );			}		}	
/**			Return true if the TargetError was generated from native code.			e.g. if the script called into a compiled java class which threw			the excpetion.  We distinguish so that we can print the stack trace			for the native code case... the stack trace would not be useful if			the exception was generated by the script.  e.g. if the script			explicitly threw an exception... (the stack trace would simply point			to the bsh internals which generated the exception).		*/		public boolean inNativeCode() { 			return inNativeCode; 		}	
/**		 * Creates a new JEditTextArea.		 * @param propertyManager the property manager that contains informations like shortcut bindings		 * @param inputHandlerProvider the inputHandlerProvider		 */		protected TextArea(IPropertyManager propertyManager, InputHandlerProvider inputHandlerProvider)		{			this.inputHandlerProvider = inputHandlerProvider;			enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);				//{{{ Initialize some misc. stuff			selectionManager = new SelectionManager(this);			chunkCache = new ChunkCache(this);			painter = new TextAreaPainter(this);			gutter = new Gutter(this);			gutter.setMouseActionsProvider(new MouseActions(propertyManager, "gutter"));			listenerList = new EventListenerList();			caretEvent = new MutableCaretEvent();			blink = true;			offsetXY = new Point();			structureMatchers = new LinkedList<StructureMatcher>();			structureMatchers.add(new StructureMatcher.BracketMatcher());			//}}}				//{{{ Initialize the GUI			setLayout(new ScrollLayout());			add(ScrollLayout.CENTER,painter);			add(ScrollLayout.LEFT,gutter);				// some plugins add stuff in a "right-hand" gutter			verticalBox = new Box(BoxLayout.X_AXIS);			verticalBox.add(vertical = new JScrollBar(Adjustable.VERTICAL));			vertical.setRequestFocusEnabled(false);			add(ScrollLayout.RIGHT,verticalBox);			add(ScrollLayout.BOTTOM,				horizontal = new JScrollBar(Adjustable.HORIZONTAL));			horizontal.setRequestFocusEnabled(false);				horizontal.setValues(0,0,0,0);			//}}}				//{{{ this ensures that the text area's look is slightly			// more consistent with the rest of the metal l&f.			// while it depends on not-so-well-documented portions			// of Swing, it only affects appearance, so future			// breakage shouldn't matter			if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)			{				setBorder(new TextAreaBorder());				vertical.putClientProperty("JScrollBar.isFreeStanding",					Boolean.FALSE);				horizontal.putClientProperty("JScrollBar.isFreeStanding",					Boolean.FALSE);				//horizontal.setBorder(null);			}			//}}}				//{{{ Add some event listeners			vertical.addAdjustmentListener(new AdjustHandler());			horizontal.addAdjustmentListener(new AdjustHandler());					addFocusListener(new FocusHandler());			addMouseWheelListener(new MouseWheelHandler());				//}}}				// This doesn't seem very correct, but it fixes a problem			// when setting the initial caret position for a buffer			// (eg, from the recent file list)			focusedComponent = this;				popupEnabled = true;		}	
public FoldPainter getFoldPainter()		{			return new TriangleFoldPainter();		}	
/**		 * Creates an actionContext and initializes the input		 * handler for this textarea. Called when creating		 * a standalone textarea from within jEdit.		 */		public void initInputHandler()		{			actionContext = new JEditActionContext<JEditBeanShellAction, JEditActionSet<JEditBeanShellAction>>()			{				@Override				public void invokeAction(EventObject evt, JEditBeanShellAction action)				{					action.invoke(TextArea.this);				}			};				setMouseHandler(new TextAreaMouseHandler(this));			inputHandlerProvider = new DefaultInputHandlerProvider(new TextAreaInputHandler(this)			{				@Override				protected JEditBeanShellAction getAction(String action)				{					return actionContext.getAction(action);				}			});		}	
public JEditActionContext<JEditBeanShellAction,JEditActionSet<JEditBeanShellAction>> getActionContext()		{			return actionContext;		}	
public void setMouseHandler(MouseInputAdapter mouseInputAdapter)		{			mouseHandler = mouseInputAdapter;			painter.addMouseListener(mouseHandler);			painter.addMouseMotionListener(mouseHandler);		}	
@Override		public void setTransferHandler(TransferHandler newHandler)		{			super.setTransferHandler(newHandler);			try			{				getDropTarget().addDropTargetListener(					new TextAreaDropHandler(this));			}			catch(TooManyListenersException e)			{				Log.log(Log.ERROR,this,e);			}		}	
@Override		public String toString()		{			StringBuilder builder = new StringBuilder();			String baseVersion = super.toString();			int len = baseVersion.length() - 1;			builder.append(baseVersion);			builder.setLength(len); // chop off the last ]			builder.append(",caret=").append(caret);			builder.append(",caretLine=").append(caretLine);			builder.append(",caretScreenLine=").append(caretScreenLine);			builder.append(",electricScroll=").append(electricScroll);			builder.append(",horizontalOffset=").append(horizontalOffset);			builder.append(",magicCaret=").append(magicCaret);			builder.append(",offsetXY=").append(offsetXY.toString());			builder.append(",oldCaretLine=").append(oldCaretLine);			builder.append(",screenLastLine=").append(screenLastLine);			builder.append(",visibleLines=").append(visibleLines);			builder.append(",firstPhysicalLine=").append(getFirstPhysicalLine());			builder.append(",physLastLine=").append(physLastLine).append("]");			return builder.toString();		}	
/**		 * Plugins and macros should not call this method.		 * @since jEdit 4.2pre1		 */		public void dispose()		{			DisplayManager.textAreaDisposed(this);			gutter.dispose();		}	
/**		 * @since jEdit 4.3pre1		 */		public AbstractInputHandler getInputHandler()		{				return inputHandlerProvider.getInputHandler();		}	
/**		 * Returns the object responsible for painting this text area.		 */		public final TextAreaPainter getPainter()		{			return painter;		}	
/**		 * Returns the gutter to the left of the text area or null if the gutter		 * is disabled		 */		public final Gutter getGutter()		{			return gutter;		}	
/**		 * @return the display manager used by this text area.		 * @since jEdit 4.2pre1		 */		public DisplayManager getDisplayManager()		{			return displayManager;		}	
/**		 * @return true if the caret is blinking, false otherwise.		 */		public final boolean isCaretBlinkEnabled()		{			return caretBlinks;		}	
/**		 * Toggles caret blinking.		 * @param caretBlinks True if the caret should blink, false otherwise		 */		public void setCaretBlinkEnabled(boolean caretBlinks)		{			this.caretBlinks = caretBlinks;			if(!caretBlinks)				blink = false;				if(buffer != null)				invalidateLine(caretLine);		}	
/**		 * @return the minimum distance (in number of lines)		 * from the caret to the nearest edge of the screen		 * (top or bottom edge).		 */		public final int getElectricScroll()		{			return electricScroll;		}	
/**		 * Sets the number of lines from the top and bottom of the text		 * area that are always visible		 * @param electricScroll The number of lines always visible from		 * the top or bottom		 */		public final void setElectricScroll(int electricScroll)		{			this.electricScroll = electricScroll;		}	
/**		 * Returns if clicking the middle mouse button pastes the most		 * recent selection (% register), and if Control-dragging inserts		 * the selection at the caret.		 */		public final boolean isQuickCopyEnabled()		{			return quickCopy;		}	
/**		 * Sets if clicking the middle mouse button pastes the most		 * recent selection (% register), and if Control-dragging inserts		 * the selection at the caret.		 * @param quickCopy A boolean flag		 */		public final void setQuickCopyEnabled(boolean quickCopy)		{			this.quickCopy = quickCopy;		}	
/**		 * Returns the buffer this text area is editing.		 * @since jedit 4.3pre3		 *		 *  Prior to 4.3pre3, this function returned a "Buffer" type.		 *  If this causes your code to break, try calling view.getBuffer() instead of		 *  view.getTextArea().getBuffer().		 *		 */		public final JEditBuffer getBuffer()		{			return buffer;		}	
/**		 * Sets the buffer this text area is editing.		 * If you don't run a standalone textarea in jEdit please do not call this method -		 * use {@link org.gjt.sp.jedit.EditPane#setBuffer(org.gjt.sp.jedit.Buffer)} instead.		 * @param buffer The buffer		 */		public void setBuffer(JEditBuffer buffer)		{			if(this.buffer == buffer)				return;				try			{				bufferChanging = true;					if(this.buffer != null)				{					// dubious?					//setFirstLine(0);						if(!this.buffer.isLoading())						selectNone();					caretLine = caret = caretScreenLine = 0;					match = null;				}				boolean inCompoundEdit = false;				if (this.buffer != null)					inCompoundEdit = this.buffer.insideCompoundEdit();				if (inCompoundEdit)					this.buffer.endCompoundEdit();				this.buffer = buffer;				if (inCompoundEdit)					this.buffer.beginCompoundEdit();					chunkCache.setBuffer(buffer);				gutter.setBuffer(buffer);				propertiesChanged();					if(displayManager != null)				{					displayManager.release();				}					displayManager = DisplayManager.getDisplayManager(					buffer,this);					displayManager.init();					if(buffer.isLoading())					updateScrollBar();					repaint();					fireScrollEvent(true);			}			finally			{				bufferChanging = false;			}		}	
/**		 * Returns true if this text area is editable, false otherwise.		 */		public final boolean isEditable()		{			return buffer.isEditable();		}	
/**		 * Drag and drop of text in jEdit is implementing using jEdit 1.4 APIs,		 * however since jEdit must run with Java 1.3, this class only has the		 * necessary support to call a hook method via reflection. This method		 * is called by the org.gjt.sp.jedit.Java14 class to signal that		 * a drag is in progress.		 * @since jEdit 4.2pre5		 * @deprecated the org.gjt.jedit.Java14 class no longer exists.		 */		@Deprecated		public boolean isDragInProgress()		{			return dndInProgress;		}	
/**		 * Drag and drop of text in jEdit is implementing using jEdit 1.4 APIs,		 * however since jEdit must run with Java 1.3, this class only has the		 * necessary support to call a hook method via reflection. This method		 * is called by the org.gjt.sp.jedit.Java14 class to signal that		 * a drag is in progress.		 * @since jEdit 4.2pre5		 * @deprecated the org.gjt.jedit.Java14 class no longer exists.		 */		@Deprecated		public void setDragInProgress(boolean dndInProgress)		{			this.dndInProgress = dndInProgress;		}	
/**		 * Returns if drag and drop of text is enabled.		 * @since jEdit 4.2pre5		 */		public boolean isDragEnabled()		{			return dndEnabled;		}	
/**		 * Sets if drag and drop of text is enabled.		 * @since jEdit 4.2pre5		 */		public void setDragEnabled(boolean dndEnabled)		{			this.dndEnabled = dndEnabled;		}	
/**		 * If set, double clicking will join non-word characters to form one "word".		 * @since jEdit 4.3pre2		 */		public boolean getJoinNonWordChars()		{			return joinNonWordChars;		}	
/**		 * If set, double clicking will join non-word characters to form one "word".		 * @since jEdit 4.3pre2		 */		public void setJoinNonWordChars(boolean joinNonWordChars)		{			this.joinNonWordChars = joinNonWordChars;		}	
/**		 * If set, CTRL enables rectangular selection mode while pressed.		 * @since jEdit 4.3pre10		 */		public boolean isCtrlForRectangularSelection()		{			return ctrlForRectangularSelection;		}	
/**		 * If set, CTRL enables rectangular selection mode while pressed.		 * @since jEdit 4.3pre10		 */		public void setCtrlForRectangularSelection(boolean ctrlForRectangularSelection)		{			this.ctrlForRectangularSelection = ctrlForRectangularSelection;		}	
/**		 * Returns the vertical scroll bar position.		 * @since jEdit 4.2pre1		 */		public final int getFirstLine()		{			return displayManager.firstLine.scrollLine				+ displayManager.firstLine.skew;		}	
/**		 * Sets the vertical scroll bar position		 *		 * @param firstLine The scroll bar position		 */		public void setFirstLine(int firstLine)		{			//{{{ ensure we don't have empty space at the bottom or top, etc			int max = displayManager.getScrollLineCount() - visibleLines				+ (lastLinePartial ? 1 : 0);			if(firstLine > max)				firstLine = max;			if(firstLine < 0)				firstLine = 0;			//}}}				if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"setFirstLine() from "					+ getFirstLine() + " to " + firstLine);			}				int oldFirstLine = getFirstLine();			if(firstLine == oldFirstLine)				return;				displayManager.setFirstLine(oldFirstLine,firstLine);				repaint();				fireScrollEvent(true);		}	
/**		 * Returns the first visible physical line index.		 * @since jEdit 4.0pre4		 */		public final int getFirstPhysicalLine()		{			return displayManager.firstLine.physicalLine;		}	
/**		 * Sets the vertical scroll bar position.		 * @param physFirstLine The first physical line to display		 * @since jEdit 4.2pre1		 */		public void setFirstPhysicalLine(int physFirstLine)		{			setFirstPhysicalLine(physFirstLine,0);		}	
/**		 * Sets the vertical scroll bar position.		 * @param physFirstLine The first physical line to display		 * @param skew A local screen line delta		 * @since jEdit 4.2pre1		 */		public void setFirstPhysicalLine(int physFirstLine, int skew)		{			if(Debug.SCROLL_DEBUG)			{				Log.log(Log.DEBUG,this,"setFirstPhysicalLine("					+ physFirstLine + ',' + skew + ')');			}				int amount = physFirstLine - displayManager.firstLine.physicalLine;				displayManager.setFirstPhysicalLine(amount,skew);				repaint();				fireScrollEvent(true);		}	
/**		 * Returns the last visible physical line index.		 * @since jEdit 4.0pre4		 */		public final int getLastPhysicalLine()		{			return physLastLine;		}	
/**		 * Returns the last screen line index, it is different from		 * {@link #getVisibleLines()} because the buffer can have less lines than		 * the visible lines		 * @return the last screen line index.		 * @since jEdit 4.3pre1		 */		public int getLastScreenLine()		{			return screenLastLine;		}	
/**		 * Returns the number of lines visible in this text area.		 * @return the number of visible lines in the textarea		 */		public final int getVisibleLines()		{			return visibleLines;		}	
/**		 * Returns the horizontal offset of drawn lines.		 */		public final int getHorizontalOffset()		{			return horizontalOffset;		}	
/**		 * Sets the horizontal offset of drawn lines. This can be used to		 * implement horizontal scrolling.		 * @param horizontalOffset offset The new horizontal offset		 */		public void setHorizontalOffset(int horizontalOffset)		{			if(horizontalOffset > 0)				horizontalOffset = 0;				if(horizontalOffset == this.horizontalOffset)				return;				this.horizontalOffset = horizontalOffset;			painter.repaint();				fireScrollEvent(false);		}	
/**		 * Scrolls up by one line.		 * @since jEdit 2.7pre2		 */		public void scrollUpLine()		{			setFirstLine(getFirstLine() - 1);		}	
/**		 * Scrolls up by one page.		 * @since jEdit 2.7pre2		 */		public void scrollUpPage()		{			setFirstLine(getFirstLine() - getVisibleLines()				+ (lastLinePartial ? 1 : 0));		}	
/**		 * Scrolls down by one line.		 * @since jEdit 2.7pre2		 */		public void scrollDownLine()		{			setFirstLine(getFirstLine() + 1);		}	
/**		 * Scrolls down by one page.		 * @since jEdit 2.7pre2		 */		public void scrollDownPage()		{			setFirstLine(getFirstLine() + getVisibleLines()				- (lastLinePartial ? 1 : 0));		}	
/**		 * Ensures that the caret is visible by scrolling the text area if		 * necessary.		 * @param doElectricScroll If true, electric scrolling will be performed		 */		public void scrollToCaret(boolean doElectricScroll)		{			scrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),				doElectricScroll);		}	
/**		 * Ensures that the specified location in the buffer is visible.		 * @param offset The offset from the start of the buffer		 * @param doElectricScroll If true, electric scrolling will be performed		 * @since jEdit 4.2pre3		 */		public void scrollTo(int offset, boolean doElectricScroll)		{			int line = buffer.getLineOfOffset(offset);			scrollTo(line,offset - buffer.getLineStartOffset(line),				doElectricScroll);		}	
/**		 * Ensures that the specified location in the buffer is visible.		 * @param line The line number		 * @param offset The offset from the start of the line		 * @param doElectricScroll If true, electric scrolling will be performed		 * @since jEdit 4.0pre6		 */		public void scrollTo(int line, int offset, boolean doElectricScroll)		{			if(Debug.SCROLL_TO_DEBUG)				Log.log(Log.DEBUG,this,"scrollTo(), lineCount="					+ getLineCount());				if(visibleLines <= 1)			{				if(Debug.SCROLL_TO_DEBUG)				Log.log(Log.DEBUG,this,"visibleLines <= 0");				// Fix the case when the line is wrapped				// it was not possible to see the second (or next)				// subregion of a line				ChunkCache.LineInfo[] infos = chunkCache				.getLineInfosForPhysicalLine(line);				int subregion = ChunkCache.getSubregionOfOffset(					offset,infos);				setFirstPhysicalLine(line,subregion);				return;			}				//{{{ Get ready			int extraEndVirt;			int lineLength = buffer.getLineLength(line);			if(offset > lineLength)			{				extraEndVirt = charWidth * (offset - lineLength);				offset = lineLength;			}			else				extraEndVirt = 0;				int _electricScroll = doElectricScroll				&& visibleLines - 1 > (electricScroll << 1)					      ? electricScroll : 0;			//}}}				//{{{ Scroll vertically			int screenLine = chunkCache.getScreenLineOfOffset(line,offset);			int visibleLines = getVisibleLines();			if(screenLine == -1)			{				// We are scrolling to a position that is not on the screen.				if(Debug.SCROLL_TO_DEBUG)					Log.log(Log.DEBUG,this,"screenLine == -1");				ChunkCache.LineInfo[] infos = chunkCache					.getLineInfosForPhysicalLine(line);				int subregion = ChunkCache.getSubregionOfOffset(					offset,infos);				int prevLine = displayManager.getPrevVisibleLine(getFirstPhysicalLine());				int nextLine = displayManager.getNextVisibleLine(getLastPhysicalLine());				if(line == getFirstPhysicalLine())				{					if(Debug.SCROLL_TO_DEBUG)						Log.log(Log.DEBUG,this,line + " == " + getFirstPhysicalLine());					setFirstPhysicalLine(line,subregion						- _electricScroll);				}				else if(line == prevLine)				{					if(Debug.SCROLL_TO_DEBUG)						Log.log(Log.DEBUG,this,line + " == " + prevLine);					setFirstPhysicalLine(prevLine,subregion						- _electricScroll);				}				else if(line == getLastPhysicalLine())				{					if(Debug.SCROLL_TO_DEBUG)						Log.log(Log.DEBUG,this,line + " == " + getLastPhysicalLine());					setFirstPhysicalLine(line,						subregion + _electricScroll						- visibleLines						+ (lastLinePartial ? 2 : 1));				}				else if(line == nextLine)				{					if(Debug.SCROLL_TO_DEBUG)						Log.log(Log.DEBUG,this,line + " == " + nextLine);					setFirstPhysicalLine(nextLine,						subregion + _electricScroll						- visibleLines						+ (lastLinePartial ? 2 : 1));				}				else				{					if(Debug.SCROLL_TO_DEBUG)					{						Log.log(Log.DEBUG,this,"neither");						Log.log(Log.DEBUG,this,"Last physical line is " + getLastPhysicalLine());					}					setFirstPhysicalLine(line,subregion						- (visibleLines >> 1));					if(Debug.SCROLL_TO_DEBUG)					{						Log.log(Log.DEBUG,this,"Last physical line is " + getLastPhysicalLine());					}				}			}			else if(screenLine < _electricScroll)			{				if(Debug.SCROLL_TO_DEBUG)					Log.log(Log.DEBUG,this,"electric up");				setFirstLine(getFirstLine() - _electricScroll + screenLine);			}			else if(screenLine > visibleLines - _electricScroll				- (lastLinePartial ? 2 : 1))			{				if(Debug.SCROLL_TO_DEBUG)					Log.log(Log.DEBUG,this,"electric down");				setFirstLine(getFirstLine() + _electricScroll - visibleLines + screenLine + (lastLinePartial ? 2 : 1));			} //}}}				//{{{ Scroll horizontally			if(!displayManager.isLineVisible(line))				return;				Point point = offsetToXY(line,offset,offsetXY);				point.x += extraEndVirt;				if(point.x < 0)			{				setHorizontalOffset(horizontalOffset					- point.x + charWidth + 5);			}			else if(point.x >= painter.getWidth() - charWidth - 5)			{				setHorizontalOffset(horizontalOffset +					(painter.getWidth() - point.x)					- charWidth - 5);			} //}}}		}	
/**		 * Adds a scroll listener to this text area.		 * @param listener The listener		 * @since jEdit 3.2pre2		 */		public final void addScrollListener(ScrollListener listener)		{			listenerList.add(ScrollListener.class,listener);		}	
/**		 * Removes a scroll listener from this text area.		 * @param listener The listener		 * @since jEdit 3.2pre2		 */		public final void removeScrollListener(ScrollListener listener)		{			listenerList.remove(ScrollListener.class,listener);		}	
/**		 * Returns the physical line number that contains the specified screen		 * line.		 * @param screenLine The screen line		 * @since jEdit 4.0pre6		 */		public int getPhysicalLineOfScreenLine(int screenLine)		{			return chunkCache.getLineInfo(screenLine).physicalLine;		}	
/**		 * Returns the screen (wrapped) line containing the specified offset.		 * Returns -1 if the line is not currently visible on the screen.		 * @param offset The offset		 * @since jEdit 4.0pre4		 */		public int getScreenLineOfOffset(int offset)		{			int line = buffer.getLineOfOffset(offset);			offset -= buffer.getLineStartOffset(line);			return chunkCache.getScreenLineOfOffset(line,offset);		}	
/**		 * Returns the start offset of the specified screen (wrapped) line.		 * @param line The line		 * @since jEdit 4.0pre4		 */		public int getScreenLineStartOffset(int line)		{			ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);			if(lineInfo.physicalLine == -1)				return -1;				return buffer.getLineStartOffset(lineInfo.physicalLine)				+ lineInfo.offset;		}	
/**		 * Returns the end offset of the specified screen (wrapped) line.		 * @param line The line		 * @since jEdit 4.0pre4		 */		public int getScreenLineEndOffset(int line)		{			ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);			if(lineInfo.physicalLine == -1)				return -1;				return buffer.getLineStartOffset(lineInfo.physicalLine)				+ lineInfo.offset + lineInfo.length;		}	
/**		 * Converts a point to an offset.		 * Note that unlike in previous jEdit versions, this method now returns		 * -1 if the y co-ordinate is out of bounds.		 *		 * @param x The x co-ordinate of the point		 * @param y The y co-ordinate of the point		 */		public int xyToOffset(int x, int y)		{			return xyToOffset(x,y,true);		}	
/**		 * Converts a point to an offset.		 * Note that unlike in previous jEdit versions, this method now returns		 * -1 if the y co-ordinate is out of bounds.		 *		 * @param x The x co-ordinate of the point		 * @param y The y co-ordinate of the point		 * @param round Round up to next letter if past the middle of a letter?		 * @since jEdit 3.2pre6		 */		public int xyToOffset(int x, int y, boolean round)		{			FontMetrics fm = painter.getFontMetrics();			int height = fm.getHeight();			int line = y / height;				if(line < 0 || line >= visibleLines)				return -1;				return xToScreenLineOffset(line,x,round);		}	
/**		 * Converts a point in a given screen line to an offset.		 * Note that unlike in previous jEdit versions, this method now returns		 * -1 if the y co-ordinate is out of bounds.		 *		 * @param x The x co-ordinate of the point		 * @param screenLine The screen line		 * @param round Round up to next letter if past the middle of a letter?		 * @since jEdit 3.2pre6		 */		public int xToScreenLineOffset(int screenLine, int x, boolean round)		{			ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(screenLine);			if(lineInfo.physicalLine == -1)			{				return getLineEndOffset(displayManager					.getLastVisibleLine()) - 1;			}			else			{				int offset = Chunk.xToOffset(lineInfo.chunks,					x - horizontalOffset,round);				if(offset == -1 || offset == lineInfo.offset + lineInfo.length)					offset = lineInfo.offset + lineInfo.length - 1;					return getLineStartOffset(lineInfo.physicalLine) + offset;			}		}	
/**		 * Converts an offset into a point in the text area painter's		 * co-ordinate space.		 * @param offset The offset		 * @return The location of the offset on screen, or <code>null</code>		 * if the specified offset is not visible		 */		public Point offsetToXY(int offset)		{			int line = buffer.getLineOfOffset(offset);			offset -= buffer.getLineStartOffset(line);			Point retVal = new Point();			return offsetToXY(line,offset,retVal);		}	
/**		 * Converts an offset into a point in the text area painter's		 * co-ordinate space.		 * @param line The line		 * @param offset The offset		 * @return The location of the offset on screen, or <code>null</code>		 * if the specified offset is not visible		 */		public Point offsetToXY(int line, int offset)		{			return offsetToXY(line,offset,new Point());		}	
/**		 * Converts a line,offset pair into an x,y (pixel) point relative to the		 * upper left corner (0,0) of the text area.		 *		 * @param line The physical line number (from top of document)		 * @param offset The offset in characters, from the start of the line		 * @param retVal The point to store the return value in		 * @return <code>retVal</code> for convenience, or <code>null</code>		 * if the specified offset is not visible		 * @since jEdit 4.0pre4		 */		public Point offsetToXY(int line, int offset, Point retVal)		{			if(!displayManager.isLineVisible(line))				return null;			int screenLine = chunkCache.getScreenLineOfOffset(line,offset);			if(screenLine == -1)				return null;				FontMetrics fm = painter.getFontMetrics();				retVal.y = screenLine * fm.getHeight();				ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);				retVal.x = (int)(horizontalOffset + Chunk.offsetToX(				info.chunks,offset));				return retVal;		}	
/**		 * Marks a range of screen lines as needing a repaint.		 * @param start The first line		 * @param end The last line		 * @since jEdit 4.0pre4		 */		public void invalidateScreenLineRange(int start, int end)		{			if(buffer.isLoading())				return;				if(start > end)			{				int tmp = end;				end = start;				start = tmp;			}				if(chunkCache.needFullRepaint())				end = visibleLines;				FontMetrics fm = painter.getFontMetrics();			int y = start * fm.getHeight();			int height = (end - start + 1) * fm.getHeight();			painter.repaint(0,y,painter.getWidth(),height);			gutter.repaint(0,y,gutter.getWidth(),height);		}	
/**		 * Marks a line as needing a repaint.		 * @param line The physical line to invalidate		 */		public void invalidateLine(int line)		{			if(!isShowing()				|| buffer.isLoading()				|| line < getFirstPhysicalLine()				|| line > physLastLine				|| !displayManager.isLineVisible(line))				return;				int startLine = -1;			int endLine = -1;				for(int i = 0; i < visibleLines; i++)			{				ChunkCache.LineInfo info = chunkCache.getLineInfo(i);					if((info.physicalLine >= line || info.physicalLine == -1)					&& startLine == -1)				{					startLine = i;				}					if((info.physicalLine >= line && info.lastSubregion)					|| info.physicalLine == -1)				{					endLine = i;					break;				}			}				if(chunkCache.needFullRepaint() || endLine == -1)				endLine = visibleLines;				invalidateScreenLineRange(startLine,endLine);		}	
/**		 * Marks a range of physical lines as needing a repaint.		 * @param start The first line to invalidate		 * @param end The last line to invalidate		 */		public void invalidateLineRange(int start, int end)		{			if(!isShowing() || buffer.isLoading())				return;				if(end < start)			{				int tmp = end;				end = start;				start = tmp;			}				if(end < getFirstPhysicalLine() || start > getLastPhysicalLine())				return;				int startScreenLine = -1;			int endScreenLine = -1;				for(int i = 0; i < visibleLines; i++)			{				ChunkCache.LineInfo info = chunkCache.getLineInfo(i);					if((info.physicalLine >= start || info.physicalLine == -1)					&& startScreenLine == -1)				{					startScreenLine = i;				}					if((info.physicalLine >= end && info.lastSubregion)					|| info.physicalLine == -1)				{					endScreenLine = i;					break;				}			}				if(startScreenLine == -1)				startScreenLine = 0;				if(chunkCache.needFullRepaint() || endScreenLine == -1)				endScreenLine = visibleLines;				invalidateScreenLineRange(startScreenLine,endScreenLine);		}	
/**		 * Returns the length of the buffer.		 */		public final int getBufferLength()		{			return buffer.getLength();		}	
/**		 * Returns the number of physical lines in the buffer.		 */		public final int getLineCount()		{			return buffer.getLineCount();		}	
/**		 * Returns the line containing the specified offset.		 * @param offset The offset		 */		public final int getLineOfOffset(int offset)		{			return buffer.getLineOfOffset(offset);		}	
/**		 * Returns the start offset of the specified line.		 * @param line The line (physical line)		 * @return The start offset of the specified line, or -1 if the line is		 * invalid		 */		public int getLineStartOffset(int line)		{			return buffer.getLineStartOffset(line);		}	
/**		 * Returns the end offset of the specified line.		 * @param line The line (physical line)		 * @return The end offset of the specified line, or -1 if the line is		 * invalid.		 */		public int getLineEndOffset(int line)		{			return buffer.getLineEndOffset(line);		}	
/**		 * Returns the length of the specified line.		 * @param line The line		 */		public int getLineLength(int line)		{			return buffer.getLineLength(line);		}	
/**		 * Returns the specified substring of the buffer.		 * @param start The start offset		 * @param len The length of the substring		 * @return The substring		 */		public final String getText(int start, int len)		{			return buffer.getText(start,len);		}	
/**		 * Copies the specified substring of the buffer into a segment.		 * @param start The start offset		 * @param len The length of the substring		 * @param segment The segment		 */		public final void getText(int start, int len, Segment segment)		{			buffer.getText(start,len,segment);		}	
/**		 * Returns the entire text of this text area.		 */		public String getText()		{			return buffer.getText(0,buffer.getLength());		}	
/**		 * Returns the text on the specified line.		 * @param lineIndex the line number		 * @return The text, or null if the lineIndex is invalid		 */		public final String getLineText(int lineIndex)		{			return buffer.getLineText(lineIndex);		}	
/**		 * Copies the text on the specified line into a Segment. If lineIndex		 * is invalid, the segment will contain a null string.		 * @param lineIndex The line number (physical line)		 * @param segment the segment into which the data will be stored.		 */		public final void getLineText(int lineIndex, Segment segment)		{			buffer.getLineText(lineIndex,segment);		}	
/**		 * Sets the entire text of this text area.		 * @param text the new content of the buffer		 */		public void setText(String text)		{			try			{				buffer.beginCompoundEdit();				buffer.remove(0,buffer.getLength());				buffer.insert(0,text);			}			finally			{				buffer.endCompoundEdit();			}		}	
/**		 * Selects all text in the buffer. Preserves the scroll position.		 */		public final void selectAll()		{			int firstLine = getFirstLine();			int horizOffset = getHorizontalOffset();				setSelection(new Selection.Range(0,buffer.getLength()));			moveCaretPosition(buffer.getLength(),true);				setFirstLine(firstLine);			setHorizontalOffset(horizOffset);		}	
/**		 * Selects the current line.		 * @since jEdit 2.7pre2		 */		public void selectLine()		{			int caretLine = getCaretLine();			int start = getLineStartOffset(caretLine);			int end = getLineEndOffset(caretLine) - 1;			Selection s = new Selection.Range(start,end);			if(multi)				addToSelection(s);			else				setSelection(s);			moveCaretPosition(end);		}	
/**		 * Selects the paragraph at the caret position.		 * @since jEdit 2.7pre2		 */		public void selectParagraph()		{			int caretLine = getCaretLine();				if(getLineLength(caretLine) == 0)			{				getToolkit().beep();				return;			}				int start = caretLine;			int end = caretLine;				while(start >= 0)			{				if(getLineLength(start) == 0)					break;				else					start--;			}				while(end < getLineCount())			{				if(getLineLength(end) == 0)					break;				else					end++;			}				int selectionStart = getLineStartOffset(start + 1);			int selectionEnd = getLineEndOffset(end - 1) - 1;			Selection s = new Selection.Range(selectionStart,selectionEnd);			if(multi)				addToSelection(s);			else				setSelection(s);			moveCaretPosition(selectionEnd);		}	
/**		 * Selects the word at the caret position.		 * @since jEdit 2.7pre2		 */		public void selectWord()		{			int line = getCaretLine();			int lineStart = getLineStartOffset(line);			int offset = getCaretPosition() - lineStart;				if(getLineLength(line) == 0)				return;				String lineText = getLineText(line);			String noWordSep = buffer.getStringProperty("noWordSep");				if(offset == getLineLength(line))				offset--;				int wordStart = TextUtilities.findWordStart(lineText,offset,						noWordSep,true,false,false);			int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,						noWordSep,true,false,false);				Selection s = new Selection.Range(lineStart + wordStart,				lineStart + wordEnd);			if(multi)				addToSelection(s);			else				setSelection(s);			moveCaretPosition(lineStart + wordEnd);		}	
/**		 * Selects from the bracket at the specified position to the		 * corresponding bracket.		 * @since jEdit 4.2pre1		 */		public Selection selectToMatchingBracket(int position,			boolean quickCopy)		{			int positionLine = buffer.getLineOfOffset(position);			int lineOffset = position - buffer.getLineStartOffset(positionLine);			if(getLineLength(positionLine) != 0)			{				int bracket = TextUtilities.findMatchingBracket(buffer,					positionLine,Math.max(0,lineOffset - 1));					if(bracket != -1)				{					Selection s;						if(bracket < position)					{						if(!quickCopy)							moveCaretPosition(position,false);						s = new Selection.Range(bracket,position);					}					else					{						if(!quickCopy)							moveCaretPosition(bracket + 1,false);						s = new Selection.Range(position - 1,bracket + 1);					}						if(!multi && !quickCopy)						selectNone();						addToSelection(s);					return s;				}			}				return null;		}	
/**		 * Selects from the bracket at the caret position to the corresponding		 * bracket.		 * @since jEdit 4.0pre2		 */		public void selectToMatchingBracket()		{			selectToMatchingBracket(caret,false);		}	
/**		 * Selects the code block surrounding the caret.		 * @since jEdit 2.7pre2		 */		public void selectBlock()		{				Selection s = getSelectionAtOffset(caret);			int start, end;			if(s == null)				start = end = caret;			else			{				start = s.start;				end = s.end;			}				String text = getText(0,buffer.getLength());				// We can't do the backward scan if start == 0			if(start == 0)			{				getToolkit().beep();				return;			}				// Scan backwards, trying to find a bracket			String openBrackets = "([{";			String closeBrackets = ")]}";			int count = 1;			char openBracket = '\0';			char closeBracket = '\0';		backward_scan:	while(--start > 0)			{				char c = text.charAt(start);				int index = openBrackets.indexOf(c);				if(index != -1)				{					if(--count == 0)					{						openBracket = c;						closeBracket = closeBrackets.charAt(index);						break backward_scan;					}				}				else if(closeBrackets.indexOf(c) != -1)					count++;			}				// Reset count			count = 1;				// Scan forward, matching that bracket			if(openBracket == '\0')			{				getToolkit().beep();				return;			}	forward_scan:	do			{				char c = text.charAt(end);				if(c == closeBracket)				{					if(--count == 0)					{						end++;						break forward_scan;					}				}				else if(c == openBracket)					count++;			}			while(++end < buffer.getLength());				s = new Selection.Range(start,end);			if(multi)				addToSelection(s);			else				setSelection(s);			moveCaretPosition(end);		}	
/**		 * Returns if the specified line is contained in the currently		 * matched structure's scope.		 * @since jEdit 4.2pre3		 */		public boolean lineInStructureScope(int line)		{			if(match == null)				return false;				if(match.startLine < caretLine)				return line >= match.startLine && line <= caretLine;			else				return line <= match.endLine && line >= caretLine;		}	
/**		 * Inverts the selection.		 * @since jEdit 4.0pre1		 */		public final void invertSelection()		{			selectionManager.invertSelection();		}	
/**		 * Returns the number of selections. This can be used to test		 * for the existence of selections.		 * @since jEdit 3.2pre2		 */		public int getSelectionCount()		{			return selectionManager.getSelectionCount();		}	
/**		 * Returns the current selection.		 * @since jEdit 3.2pre1		 */		public Selection[] getSelection()		{			return selectionManager.getSelection();		}	
/**		 * Returns the selection with the specified index. This must be		 * between 0 and the return value of <code>getSelectionCount()</code>.		 * @since jEdit 4.3pre1		 * @param index the index of the selection you want		 */		public Selection getSelection(int index)		{			return selectionManager.selection.get(index);		}	
/**		 * Returns the current selection.		 * @since jEdit 4.3pre1		 */		public Iterator<Selection> getSelectionIterator()		{			return selectionManager.selection.iterator();		}	
/**		 * Deselects everything.		 */		public void selectNone()		{			invalidateSelectedLines();			setSelection((Selection)null);		}	
/**		 * Sets the selection. Nested and overlapping selections are merged		 * where possible. Null elements of the array are ignored.		 * @param selection The new selection		 * since jEdit 3.2pre1		 */		public void setSelection(Selection[] selection)		{			// invalidate the old selection			invalidateSelectedLines();			selectionManager.setSelection(selection);			finishCaretUpdate(caretLine,NO_SCROLL,true);		}	
/**		 * Sets the selection. Nested and overlapping selections are merged		 * where possible.		 * @param selection The new selection		 * since jEdit 3.2pre1		 */		public void setSelection(Selection selection)		{			invalidateSelectedLines();			selectionManager.setSelection(selection);			finishCaretUpdate(caretLine,NO_SCROLL,true);		}	
/**		 * Adds to the selection. Nested and overlapping selections are merged		 * where possible.		 * @param selection The new selection		 * since jEdit 3.2pre1		 */		public void addToSelection(Selection[] selection)		{			invalidateSelectedLines();			selectionManager.addToSelection(selection);			finishCaretUpdate(caretLine,NO_SCROLL,true);		}	
/**		 * Adds to the selection. Nested and overlapping selections are merged		 * where possible.		 * @param selection The new selection		 * since jEdit 3.2pre1		 */		public void addToSelection(Selection selection)		{			invalidateSelectedLines();			selectionManager.addToSelection(selection);			finishCaretUpdate(caretLine,NO_SCROLL,true);		}	
/**		 * Returns the selection containing the specific offset, or <code>null</code>		 * if there is no selection at that offset.		 * @param offset The offset		 * @since jEdit 3.2pre1		 */		public Selection getSelectionAtOffset(int offset)		{			return selectionManager.getSelectionAtOffset(offset);		}	
/**		 * Deactivates the specified selection.		 * @param sel The selection		 * @since jEdit 3.2pre1		 */		public void removeFromSelection(Selection sel)		{			invalidateSelectedLines();			selectionManager.removeFromSelection(sel);			finishCaretUpdate(caretLine,NO_SCROLL,true);		}	
/**		 * Deactivates the selection at the specified offset. If there is		 * no selection at that offset, does nothing.		 * @param offset The offset		 * @since jEdit 3.2pre1		 */		public void removeFromSelection(int offset)		{			Selection sel = getSelectionAtOffset(offset);			if(sel == null)				return;				invalidateSelectedLines();			selectionManager.removeFromSelection(sel);			finishCaretUpdate(caretLine,NO_SCROLL,true);		}	
/**		 * Resizes the selection at the specified offset, or creates a new		 * one if there is no selection at the specified offset. This is a		 * utility method that is mainly useful in the mouse event handler		 * because it handles the case of end being before offset gracefully		 * (unlike the rest of the selection API).		 * @param offset The offset		 * @param end The new selection end		 * @param extraEndVirt Only for rectangular selections - specifies how		 * far it extends into virtual space.		 * @param rect Make the selection rectangular?		 * @since jEdit 3.2pre1		 */		public void resizeSelection(int offset, int end, int extraEndVirt,			boolean rect)		{			Selection s = selectionManager.getSelectionAtOffset(offset);			if(s != null)			{				invalidateLineRange(s.startLine,s.endLine);				selectionManager.removeFromSelection(s);			}				selectionManager.resizeSelection(offset,end,extraEndVirt,rect);			fireCaretEvent();		}	
/**		 * Extends the selection at the specified offset, or creates a new		 * one if there is no selection at the specified offset. This is		 * different from resizing in that the new chunk is added to the		 * selection in question, instead of replacing it.		 * @param offset The offset		 * @param end The new selection end		 * @since jEdit 3.2pre1		 */		public void extendSelection(int offset, int end)		{			extendSelection(offset,end,0,0);		}	
/**		 * Extends the selection at the specified offset, or creates a new		 * one if there is no selection at the specified offset. This is		 * different from resizing in that the new chunk is added to the		 * selection in question, instead of replacing it.		 * @param offset The offset		 * @param end The new selection end		 * @param extraStartVirt Extra virtual space at the start		 * @param extraEndVirt Extra virtual space at the end		 * @since jEdit 4.2pre1		 */		public void extendSelection(int offset, int end,			int extraStartVirt, int extraEndVirt)		{			Selection s = getSelectionAtOffset(offset);			if(s != null)			{				invalidateLineRange(s.startLine,s.endLine);				selectionManager.removeFromSelection(s);					if(offset == s.start)				{					offset = end;					end = s.end;				}				else if(offset == s.end)				{					offset = s.start;				}			}				if(end < offset)			{				int tmp = end;				end = offset;				offset = tmp;			}				if(rectangularSelectionMode)			{				s = new Selection.Rect(offset,end);				((Selection.Rect)s).extraStartVirt = extraStartVirt;				((Selection.Rect)s).extraEndVirt = extraEndVirt;			}			else				s = new Selection.Range(offset,end);				selectionManager.addToSelection(s);			fireCaretEvent();				if(rectangularSelectionMode && extraEndVirt != 0)			{				int line = getLineOfOffset(end);				scrollTo(line,getLineLength(line) + extraEndVirt,false);			}		}	
/**		 * Returns the text in the specified selection.		 * @param s The selection		 * @since jEdit 3.2pre1		 */		public String getSelectedText(Selection s)		{			StringBuilder buf = new StringBuilder(s.end - s.start);			s.getText(buffer,buf);			return buf.toString();		}	
/**		 * Returns the text in all active selections.		 * @param separator The string to insert between each text chunk		 * (for example, a newline)		 * @since jEdit 3.2pre1		 */		public String getSelectedText(String separator)		{			Selection[] sel = selectionManager.getSelection();			if(sel.length == 0)				return null;				StringBuilder buf = new StringBuilder();			for(int i = 0; i < sel.length; i++)			{				if(i != 0)					buf.append(separator);					sel[i].getText(buffer,buf);			}				return buf.toString();		}	
/**		 * Returns the text in all active selections, with a newline		 * between each text chunk.		 */		public String getSelectedText()		{			return getSelectedText("\n");		}	
/**		 * Replaces the selection with the specified text.		 * @param s The selection		 * @param selectedText The new text		 * @since jEdit 3.2pre1		 */		public void setSelectedText(Selection s, String selectedText)		{			if(!isEditable())			{				throw new InternalError("Text component"					+ " read only");			}				try			{				buffer.beginCompoundEdit();					moveCaretPosition(s.setText(buffer,selectedText));			}			// No matter what happends... stops us from leaving buffer			// in a bad state			finally			{				buffer.endCompoundEdit();			}				// no no no!!!!			//selectNone();		}	
/**		 * Replaces the selection at the caret with the specified text.		 * If there is no selection at the caret, the text is inserted at		 * the caret position.		 */		public void setSelectedText(String selectedText)		{			int newCaret = replaceSelection(selectedText);			if(newCaret != -1)				moveCaretPosition(newCaret);			selectNone();		}	
/**		 * Replaces the selection at the caret with the specified text.		 * If there is no selection at the caret, the text is inserted at		 * the caret position.		 * @param selectedText The new selection		 * @param moveCaret Move caret to insertion location if necessary		 * @since jEdit 4.2pre5		 */		public void setSelectedText(String selectedText, boolean moveCaret)		{			int newCaret = replaceSelection(selectedText);			if(moveCaret && newCaret != -1)				moveCaretPosition(newCaret);			selectNone();		}	
/**		 * Set the selection, but does not deactivate it, and does not move the		 * caret.		 *		 * Please use {@link #setSelectedText(String)} instead.		 *		 * @param selectedText The new selection		 * @return The new caret position		 * @since 4.3pre1		 */		public int replaceSelection(String selectedText)		{			if(!isEditable())				throw new RuntimeException("Text component read only");				int newCaret = -1;			if(getSelectionCount() == 0)			{				// for compatibility with older jEdit versions				buffer.insert(caret,selectedText);			}			else			{				try				{					buffer.beginCompoundEdit();						Selection[] selection = getSelection();					for(int i = 0; i < selection.length; i++)						newCaret = selection[i].setText(buffer,selectedText);				}				finally				{					buffer.endCompoundEdit();				}			}				return newCaret;		}	
/**		 * Returns a sorted array of line numbers on which a selection or		 * selections are present.<p>		 *		 * This method is the most convenient way to iterate through selected		 * lines in a buffer. The line numbers in the array returned by this		 * method can be passed as a parameter to such methods as		 * {@link JEditBuffer#getLineText(int)}.		 *		 * @since jEdit 3.2pre1		 */		public int[] getSelectedLines()		{			if(selectionManager.getSelectionCount() == 0)				return new int[] { caretLine };				return selectionManager.getSelectedLines();		}	
/**		 * Return if change in buffer should scroll this text area.		 * @since jEdit 4.3pre2		 */		public boolean caretAutoScroll()		{			return focusedComponent == this;		}	
/**		 * Adds a structure matcher.		 * @since jEdit 4.2pre3		 */		public void addStructureMatcher(StructureMatcher matcher)		{			structureMatchers.add(matcher);		}	
/**		 * Removes a structure matcher.		 * @since jEdit 4.2pre3		 */		public void removeStructureMatcher(StructureMatcher matcher)		{			structureMatchers.remove(matcher);		}	
/**		 * Returns the structure element (bracket, or XML tag, etc) matching the		 * one before the caret.		 * @since jEdit 4.2pre3		 */		public StructureMatcher.Match getStructureMatch()		{			return match;		}	
/**		 * Blinks the caret.		 */		public final void blinkCaret()		{			if(caretBlinks)			{				blink = !blink;				invalidateLine(caretLine);			}			else				blink = true;		}	
/**		 * Centers the caret on the screen.		 * @since jEdit 2.7pre2		 */		public void centerCaret()		{			int offset = getScreenLineStartOffset(visibleLines >> 1);			if(offset == -1)				getToolkit().beep();			else				setCaretPosition(offset);		}	
/**		 * Tries to scroll the textArea so that the caret is centered on the screen.		 * Sometimes gets confused by folds but at least makes the caret visible and		 * guesses better on subsequent attempts.		 *		 * @since jEdit 4.3pre15		 */		public void scrollAndCenterCaret()		{			if (!getDisplayManager().isLineVisible(getCaretLine()))				getDisplayManager().expandFold(getCaretLine(),true);			int physicalLine = getCaretLine();			int midPhysicalLine = getPhysicalLineOfScreenLine(visibleLines >> 1);			int diff = physicalLine -  midPhysicalLine;			setFirstLine(getFirstLine() + diff);			requestFocus();		}	
/**		 * Sets the caret position and deactivates the selection.		 * @param newCaret The caret position		 */		public void setCaretPosition(int newCaret)		{			selectNone();			moveCaretPosition(newCaret,true);		}	
/**		 * Sets the caret position and deactivates the selection.		 * @param newCaret The caret position		 * @param doElectricScroll Do electric scrolling?		 */		public void setCaretPosition(int newCaret, boolean doElectricScroll)		{			selectNone();			moveCaretPosition(newCaret,doElectricScroll);		}	
/**		 * Sets the caret position without deactivating the selection.		 * @param newCaret The caret position		 */		public void moveCaretPosition(int newCaret)		{			moveCaretPosition(newCaret,true);		}	
/**		 * Sets the caret position without deactivating the selection.		 * @param newCaret The caret position		 * @param doElectricScroll Do electric scrolling?		 */		public void moveCaretPosition(int newCaret, boolean doElectricScroll)		{			moveCaretPosition(newCaret,doElectricScroll ? ELECTRIC_SCROLL				: NORMAL_SCROLL);		}	
/**		 * Sets the caret position without deactivating the selection.		 * @param newCaret The caret position		 * @param scrollMode The scroll mode (NO_SCROLL, NORMAL_SCROLL, or		 * ELECTRIC_SCROLL).		 * @since jEdit 4.2pre1		 */		public void moveCaretPosition(int newCaret, int scrollMode)		{			if(newCaret < 0 || newCaret > buffer.getLength())			{				throw new IllegalArgumentException("caret out of bounds: "					+ newCaret);			}			int oldCaretLine = caretLine;				if(caret == newCaret)				finishCaretUpdate(oldCaretLine,scrollMode,false);			else			{				caret = newCaret;				caretLine = getLineOfOffset(newCaret);					magicCaret = -1;					finishCaretUpdate(oldCaretLine,scrollMode,true);			}		}	
/**		 * Returns a zero-based index of the caret position.		 */		public int getCaretPosition()		{			return caret;		}	
/**		 * Returns the line number containing the caret.		 */		public int getCaretLine()		{			return caretLine;		}	
/**		 * Returns an internal position used to keep the caret in one		 * column while moving around lines of varying lengths.		 * @since jEdit 4.2pre1		 */		public int getMagicCaretPosition()		{			if(magicCaret == -1)			{				magicCaret = chunkCache.subregionOffsetToX(					caretLine,caret - getLineStartOffset(caretLine));			}				return magicCaret;		}	
/**		 * Sets the `magic' caret position. This can be used to preserve		 * the column position when moving up and down lines.		 * @param magicCaret The magic caret position		 * @since jEdit 4.2pre1		 */		public void setMagicCaretPosition(int magicCaret)		{			this.magicCaret = magicCaret;		}	
/**		 * Adds a caret change listener to this text area.		 * @param listener The listener		 */		public final void addCaretListener(CaretListener listener)		{			listenerList.add(CaretListener.class,listener);		}	
/**		 * Removes a caret change listener from this text area.		 * @param listener The listener		 */		public final void removeCaretListener(CaretListener listener)		{			listenerList.remove(CaretListener.class,listener);		}	
/**		 * Moves the caret to the next closing bracket.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2.		 */		public void goToNextBracket(boolean select)		{			int newCaret = -1;				if(caret != buffer.getLength())			{				String text = getText(caret,buffer.getLength()					- caret - 1);		loop:			for(int i = 0; i < text.length(); i++)				{					switch(text.charAt(i))					{					case ')': case ']': case '}':						newCaret = caret + i + 1;						break loop;					}				}			}				if(newCaret == -1)				getToolkit().beep();			else			{				if(select)					extendSelection(caret,newCaret);				else if(!multi)					selectNone();				moveCaretPosition(newCaret);			}		}	
/**		 * Moves the caret to the next character.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2.		 */		public void goToNextCharacter(boolean select)		{			Selection s = getSelectionAtOffset(caret);				if(!select && s instanceof Selection.Range)			{				if(multi)				{					if(caret != s.end)					{						moveCaretPosition(s.end);						return;					}				}				else				{					setCaretPosition(s.end);					return;				}			}				int extraStartVirt, extraEndVirt;			if(s instanceof Selection.Rect)			{				extraStartVirt = ((Selection.Rect)s).extraStartVirt;				extraEndVirt = ((Selection.Rect)s).extraEndVirt;			}			else			{				extraStartVirt = 0;				extraEndVirt = 0;			}				int newCaret = caret;				if(caret == buffer.getLength())			{				if(select && (rectangularSelectionMode || s instanceof Selection.Rect))				{					if(s != null && caret == s.start)						extraStartVirt++;					else						extraEndVirt++;				}				else				{					getToolkit().beep();					return;				}			}			else if(caret == getLineEndOffset(caretLine) - 1)			{				if(select && (rectangularSelectionMode || s instanceof Selection.Rect))				{					if(s != null && caret == s.start)						extraStartVirt++;					else						extraEndVirt++;				}				else				{					int line = displayManager.getNextVisibleLine(caretLine);					if(line == -1)					{						getToolkit().beep();						return;					}					else						newCaret = getLineStartOffset(line);				}			}			else				newCaret = caret + 1;				if(select)				extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);			else if(!multi)				selectNone();				moveCaretPosition(newCaret);		}	
/**		 * Move the caret to the next line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToNextLine(boolean select)		{			Selection s = getSelectionAtOffset(caret);			boolean rectSelect = s == null ? rectangularSelectionMode				: s instanceof Selection.Rect;			int magic = getMagicCaretPosition();			int newCaret = chunkCache.getBelowPosition(caretLine,				caret - buffer.getLineStartOffset(caretLine),magic + 1,				rectSelect && select);			if(newCaret == -1)			{				int end = getLineEndOffset(caretLine) - 1;				if(caret == end)				{					getToolkit().beep();					return;				}				else					newCaret = end;			}				_changeLine(select, newCaret);				setMagicCaretPosition(magic);		}	
/**		 * Moves the caret to the next screenful.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2.		 */		public void goToNextPage(boolean select)		{			scrollToCaret(false);			int magic = getMagicCaretPosition();			if(caretLine < displayManager.getFirstVisibleLine())			{				caretLine = displayManager.getNextVisibleLine(					caretLine);			}				int newCaret;				if(getFirstLine() + getVisibleLines() >= displayManager				.getScrollLineCount())			{				int lastVisibleLine = displayManager					.getLastVisibleLine();				newCaret = getLineEndOffset(lastVisibleLine) - 1;			}			else			{				int caretScreenLine = getScreenLineOfOffset(caret);					scrollDownPage();					newCaret = xToScreenLineOffset(caretScreenLine,					magic,true);			}				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();				moveCaretPosition(newCaret,false);				setMagicCaretPosition(magic);		}	
/**		 * Moves the caret to the start of the next paragraph.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToNextParagraph(boolean select)		{			int lineNo = getCaretLine();				int newCaret = getBufferLength();				boolean foundBlank = false;		loop:		for(int i = lineNo + 1; i < getLineCount(); i++)			{				if(!displayManager.isLineVisible(i))					continue;					getLineText(i,lineSegment);					for(int j = 0; j < lineSegment.count; j++)				{					switch(lineSegment.array[lineSegment.offset + j])					{					case ' ':					case '\t':						break;					default:						if(foundBlank)						{							newCaret = getLineStartOffset(i);							break loop;						}						else							continue loop;					}				}					foundBlank = true;			}				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * Moves the caret to the start of the next word.		 * Note that if the "view.eatWhitespace" boolean propery is false,		 * this method moves the caret to the end of the current word instead.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToNextWord(boolean select)		{			goToNextWord(select,false);		}	
/**		 * Moves the caret to the start of the next word.		 * @since jEdit 4.1pre5		 */		public void goToNextWord(boolean select, boolean eatWhitespace)		{			int lineStart = getLineStartOffset(caretLine);			int newCaret = caret - lineStart;			String lineText = getLineText(caretLine);				if(newCaret == lineText.length())			{				int nextLine = displayManager.getNextVisibleLine(caretLine);				if(nextLine == -1)				{					getToolkit().beep();					return;				}					newCaret = getLineStartOffset(nextLine);			}			else			{				String noWordSep = buffer.getStringProperty("noWordSep");				boolean camelCasedWords = buffer.getBooleanProperty("camelCasedWords");				newCaret = TextUtilities.findWordEnd(lineText,					newCaret + 1,noWordSep,true,camelCasedWords,					eatWhitespace);					newCaret += lineStart;			}				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * Moves the caret to the previous bracket.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToPrevBracket(boolean select)		{			String text = getText(0,caret);				int newCaret = -1;		loop:		for(int i = getCaretPosition() - 1; i >= 0; i--)			{				switch(text.charAt(i))				{				case '(': case '[': case '{':					newCaret = i;					break loop;				}			}				if(newCaret == -1)				getToolkit().beep();			else			{				if(select)					extendSelection(caret,newCaret);				else if(!multi)					selectNone();				moveCaretPosition(newCaret);			}		}	
/**		 * Moves the caret to the previous character.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2.		 */		public void goToPrevCharacter(boolean select)		{			Selection s = getSelectionAtOffset(caret);				if(caret == 0)			{				getToolkit().beep();				return;			}				if(!select && s instanceof Selection.Range)			{				if(multi)				{					if(caret != s.start)					{						moveCaretPosition(s.start);						return;					}				}				else				{					setCaretPosition(s.start);					return;				}			}				int extraStartVirt = 0;			int extraEndVirt = 0;			int newCaret = caret;				if(select && caret == getLineEndOffset(caretLine) - 1)			{				if(s instanceof Selection.Rect)				{					extraStartVirt = ((Selection.Rect)s).extraStartVirt;					extraEndVirt = ((Selection.Rect)s).extraEndVirt;					if(caret == s.start)					{						if(extraStartVirt == 0)							newCaret = caret - 1;						else							extraStartVirt--;					}					else					{						if(extraEndVirt == 0)							newCaret = caret - 1;						else							extraEndVirt--;					}				}				else					newCaret = caret - 1;			}			else if(caret == getLineStartOffset(caretLine))			{				int line = displayManager.getPrevVisibleLine(caretLine);				if(line == -1)				{					getToolkit().beep();					return;				}				newCaret = getLineEndOffset(line) - 1;			}			else				newCaret = caret - 1;				if(select)				extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * Moves the caret to the previous line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToPrevLine(boolean select)		{			Selection s = getSelectionAtOffset(caret);			boolean rectSelect = s == null ? rectangularSelectionMode				: s instanceof Selection.Rect;			int magic = getMagicCaretPosition();				int newCaret = chunkCache.getAbovePosition(caretLine,				caret - buffer.getLineStartOffset(caretLine),magic + 1,				rectSelect && select);			if(newCaret == -1)			{				int start = getLineStartOffset(caretLine);				if(caret == start)				{					getToolkit().beep();					return;				}				else					newCaret = start;			}				_changeLine(select, newCaret);				setMagicCaretPosition(magic);		}	
/**		 * Moves the caret to the previous screenful.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToPrevPage(boolean select)		{			scrollToCaret(false);			int magic = getMagicCaretPosition();				if(caretLine < displayManager.getFirstVisibleLine())			{				caretLine = displayManager.getNextVisibleLine(					caretLine);			}				int newCaret;				if(getFirstLine() == 0)			{				int firstVisibleLine = displayManager					.getFirstVisibleLine();				newCaret = getLineStartOffset(firstVisibleLine);			}			else			{				int caretScreenLine = getScreenLineOfOffset(caret);					scrollUpPage();					newCaret = xToScreenLineOffset(caretScreenLine,					magic,true);			}				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret,false);				setMagicCaretPosition(magic);		}	
/**		 * Moves the caret to the start of the previous paragraph.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToPrevParagraph(boolean select)		{			int lineNo = caretLine;			int newCaret = 0;				boolean foundBlank = false;		loop:		for(int i = lineNo - 1; i >= 0; i--)			{				if(!displayManager.isLineVisible(i))					continue;					getLineText(i,lineSegment);					for(int j = 0; j < lineSegment.count; j++)				{					switch(lineSegment.array[lineSegment.offset + j])					{					case ' ':					case '\t':						break;					default:						if(foundBlank)						{							newCaret = getLineEndOffset(i) - 1;							break loop;						}						else							continue loop;					}				}					foundBlank = true;			}				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * Moves the caret to the start of the previous word.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToPrevWord(boolean select)		{			goToPrevWord(select,false);		}	
/**		 * Moves the caret to the start of the previous word.		 * @since jEdit 4.1pre5		 */		public void goToPrevWord(boolean select, boolean eatWhitespace)		{			int lineStart = getLineStartOffset(caretLine);			int newCaret = caret - lineStart;			String lineText = getLineText(caretLine);				if(newCaret == 0)			{				if(lineStart == 0)				{					getToolkit().beep();					return;				}				else				{					int prevLine = displayManager.getPrevVisibleLine(caretLine);					if(prevLine == -1)					{						getToolkit().beep();						return;					}						newCaret = getLineEndOffset(prevLine) - 1;				}			}			else			{				String noWordSep = buffer.getStringProperty("noWordSep");				boolean camelCasedWords = buffer.getBooleanProperty("camelCasedWords");				newCaret = TextUtilities.findWordStart(lineText,					newCaret - 1,noWordSep,true,camelCasedWords,eatWhitespace);					newCaret += lineStart;			}				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * A "dumb home" action which only has 2 states:		 *     start of the whitespace or start of line		 *     @param select true if we also want to select from the cursor		 * @since jedit 4.3pre18		 */		public void home(boolean select)		{			switch(getInputHandler().getLastActionCount() % 2)			{			case 1:				goToStartOfWhiteSpace(select);				break;			default:				goToStartOfLine(select);				break;			}		}	
/**		 * a dumb end action which only has 2 states:		 * 	end of whitespace or end of line		 * @param select true if we also want to select from the cursor		 * @since jedit 4.3pre18		 */		public void end(boolean select)		{			switch(getInputHandler().getLastActionCount() % 2)			{			case 1:				goToEndOfWhiteSpace(select);				break;			default:				goToEndOfLine(select);				break;			}		}	
/**		 * On subsequent invocations, first moves the caret to the first		 * non-whitespace character of the line, then the beginning of the		 * line, then to the first visible line.		 * @param select true if you want to extend selection		 * @since jEdit 4.3pre7		 */		public void smartHome(boolean select)		{			switch(getInputHandler().getLastActionCount())			{			case 1:				goToStartOfWhiteSpace(select);				break;			case 2:				goToStartOfLine(select);				break;			default: //case 3:				goToFirstVisibleLine(select);				break;			}		}	
/**		 * Has 4 states based on # of invocations:		 *   1. last character of code (before inline comment)		 *   2. last non whitespace character of the line		 *   3. end of line		 *   4. end of last visible line		 * @param select true if you want to extend selection		 * @since jEdit 4.3pre18		 */		public void smartEnd(boolean select)		{			int pos = getCaretPosition();			int npos = 0;			switch(getInputHandler().getLastActionCount())			{			case 1:				goToEndOfCode(select);				npos = getCaretPosition();				if (npos == pos) goToEndOfWhiteSpace(select);				break;			case 2:				goToEndOfWhiteSpace(select);				break;			case 3:				goToEndOfLine(select);				break;			default: //case 4:				goToLastVisibleLine(select);				break;			}		}	
/**		 * Moves the caret to the beginning of the current line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToStartOfLine(boolean select)		{			Selection s = getSelectionAtOffset(caret);			int line = select || s == null ? caretLine : s.startLine;			int newCaret = getLineStartOffset(line);			if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * Moves the caret to the end of the current line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToEndOfLine(boolean select)		{			Selection s = getSelectionAtOffset(caret);			int line = select || s == null ? caretLine : s.endLine;			int newCaret = getLineEndOffset(line) - 1;			if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);				// so that end followed by up arrow will always put caret at			// the end of the previous line, for example			//setMagicCaretPosition(Integer.MAX_VALUE);		}	
/**		 * Moves the caret to the end of the code present on the current line, before the comments and whitespace.		 * @param select true if you want to extend selection		 * @since jEdit 4.3pre18		 */		public void goToEndOfCode(boolean select)		{			int line = getCaretLine();				// @todo - Should tokenHandler be an TextArea instance variable?			DefaultTokenHandler tokenHandler = new DefaultTokenHandler();			buffer.markTokens(line,tokenHandler);			Token token = tokenHandler.getTokens();				char[] txt = getLineText(line).toCharArray();				// replace comments with whitespace to find endOfCode:			while(true)			{				if( token.id == Token.COMMENT1 ||					token.id == Token.COMMENT2 ||					token.id == Token.COMMENT3 ||					token.id == Token.COMMENT4)				{					for(int i=token.offset; i<token.offset+token.length; i++)					{						txt[i] = ' ';					}				}					if(token.next == null)					break;				token = token.next;			}				int newCaret = getLineLength(line) - StandardUtilities.getTrailingWhiteSpace( new String(txt) );			newCaret += getLineStartOffset(line);				if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();			moveCaretPosition(newCaret);		}	
/**		 * Moves the caret to the first non-whitespace character of the current		 * line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToStartOfWhiteSpace(boolean select)		{			Selection s = getSelectionAtOffset(caret);			int line, offset;			if(select || s == null)			{				line = caretLine;				offset = caret - buffer.getLineStartOffset(line);			}			else			{				line = s.startLine;				offset = s.start - buffer.getLineStartOffset(line);			}				int firstIndent = chunkCache.getSubregionStartOffset(line,offset);			if(firstIndent == getLineStartOffset(line))			{				firstIndent = StandardUtilities.getLeadingWhiteSpace(getLineText(line));				if(firstIndent == getLineLength(line))					firstIndent = 0;				firstIndent += getLineStartOffset(line);			}				if(select)				extendSelection(caret,firstIndent);			else if(!multi)				selectNone();			moveCaretPosition(firstIndent);		}	
/**		 * Moves the caret to the last non-whitespace character of the current		 * line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToEndOfWhiteSpace(boolean select)		{			Selection s = getSelectionAtOffset(caret);			int line, offset;			if(select || s == null)			{				line = caretLine;				offset = caret - getLineStartOffset(line);			}			else			{				line = s.endLine;				offset = s.end - getLineStartOffset(line);			}				int lastIndent = chunkCache.getSubregionEndOffset(line,offset);				if(lastIndent == getLineEndOffset(line))			{				lastIndent = getLineLength(line) - StandardUtilities.getTrailingWhiteSpace(getLineText(line));				if(lastIndent == 0)					lastIndent = getLineLength(line);				lastIndent += getLineStartOffset(line);			}			else			{				lastIndent--;			}				if(select)				extendSelection(caret,lastIndent);			else if(!multi)				selectNone();			moveCaretPosition(lastIndent);		}	
/**		 * Moves the caret to the first visible line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToFirstVisibleLine(boolean select)		{			int firstVisibleLine = getFirstLine() == 0 ? 0 : electricScroll;			int firstVisible = getScreenLineStartOffset(firstVisibleLine);			if(firstVisible == -1)			{				firstVisible = getLineStartOffset(displayManager					.getFirstVisibleLine());			}				if(select)				extendSelection(caret,firstVisible);			else if(!multi)				selectNone();			moveCaretPosition(firstVisible);		}	
/**		 * Moves the caret to the last visible line.		 * @param select true if you want to extend selection		 * @since jEdit 2.7pre2		 */		public void goToLastVisibleLine(boolean select)		{			int lastVisible;				if(getFirstLine() + visibleLines >=				displayManager.getScrollLineCount())			{				lastVisible = getLineEndOffset(displayManager					.getLastVisibleLine()) - 1;			}			else			{				lastVisible = visibleLines - electricScroll - 1;				if(lastLinePartial)					lastVisible--;				if(lastVisible < 0)					lastVisible = 0;				lastVisible = getScreenLineEndOffset(lastVisible) - 1;				if(lastVisible == -1)				{					lastVisible = getLineEndOffset(displayManager						.getLastVisibleLine()) - 1;				}			}				if(select)				extendSelection(caret,lastVisible);			else if(!multi)				selectNone();			moveCaretPosition(lastVisible);		}	
/**		 * Moves the caret to the beginning of the buffer.		 * @param select true if you want to extend selection		 * @since jEdit 4.0pre3		 */		public void goToBufferStart(boolean select)		{			int start = buffer.getLineStartOffset(				displayManager.getFirstVisibleLine());			if(select)				extendSelection(caret,start);			else if(!multi)				selectNone();			moveCaretPosition(start);		}	
/**		 * Moves the caret to the end of the buffer.		 * @param select true if you want to extend selection		 * @since jEdit 4.0pre3		 */		public void goToBufferEnd(boolean select)		{			int end = buffer.getLineEndOffset(				displayManager.getLastVisibleLine()) - 1;			if(select)				extendSelection(caret,end);			else if(!multi)				selectNone();			moveCaretPosition(end);		}	
/**		 * Moves the caret to the bracket matching the one before the caret.		 * @since jEdit 2.7pre3		 */		public void goToMatchingBracket()		{			if(getLineLength(caretLine) != 0)			{				int dot = caret - getLineStartOffset(caretLine);					int bracket = TextUtilities.findMatchingBracket(					buffer,caretLine,Math.max(0,dot - 1));				if(bracket != -1)				{					selectNone();					moveCaretPosition(bracket + 1,false);					return;				}			}				getToolkit().beep();		}	
/**		 * Handles the insertion of the specified character. It performs the		 * following operations above and beyond simply inserting the text:		 * <ul>		 * <li>Inserting a TAB with a selection will shift to the right		 * <li>Inserting a BACK_SPACE or a DELETE will remove a character		 * <li>Inserting an indent open/close bracket will re-indent the current		 * line as necessary		 * </ul>		 *		 * @param ch The character		 * @see #setSelectedText(String)		 * @see #isOverwriteEnabled()		 * @since jEdit 4.3pre7		 */		public void userInput(char ch)		{			if(!isEditable())			{				getToolkit().beep();				return;			}				/* Null before addNotify() */			if(hiddenCursor != null)				getPainter().setCursor(hiddenCursor);				switch(ch)			{			case '\t':				userInputTab();				break;			case '\b':				backspace();				break;			case '\u007F':				delete();				break;			default:				boolean indent = buffer.isElectricKey(ch, caretLine);				String str = String.valueOf(ch);				if(getSelectionCount() == 0)				{					if(!doWordWrap(ch == ' '))						insert(str,indent);				}				else					replaceSelection(str);				break;			}		}	
/**		 * Returns true if overwrite mode is enabled, false otherwise.		 */		public final boolean isOverwriteEnabled()		{			return overwrite;		}	
/**		 * Sets overwrite mode.		 */		public final void setOverwriteEnabled(boolean overwrite)		{			blink = true;			caretTimer.restart();				this.overwrite = overwrite;			invalidateLine(caretLine);			fireStatusChanged(StatusListener.OVERWRITE_CHANGED,overwrite);		}	
/**		 * Toggles overwrite mode.		 * @since jEdit 2.7pre2		 */		public final void toggleOverwriteEnabled()		{			setOverwriteEnabled(!overwrite);		}	
/**		 * Deletes the character before the caret, or the selection, if one is		 * active.		 * @since jEdit 2.7pre2		 */		public void backspace()		{			delete(false);		}	
/**		 * Deletes the word before the caret.		 * @since jEdit 2.7pre2		 */		public void backspaceWord()		{			backspaceWord(false);		}	
/**		 * Deletes the word before the caret.		 * @param eatWhitespace If true, will eat whitespace		 * @since jEdit 4.2pre5		 */		public void backspaceWord(boolean eatWhitespace)		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				if(getSelectionCount() != 0)			{				setSelectedText("");				return;			}				int lineStart = getLineStartOffset(caretLine);			int _caret = caret - lineStart;				String lineText = getLineText(caretLine);				if(_caret == 0)			{				if(lineStart == 0)				{					getToolkit().beep();					return;				}				_caret--;			}			else			{				String noWordSep = buffer.getStringProperty("noWordSep");				boolean camelCasedWords = buffer.getBooleanProperty("camelCasedWords");				_caret = TextUtilities.findWordStart(lineText,_caret-1,					noWordSep,true,camelCasedWords,eatWhitespace);			}				buffer.remove(_caret + lineStart, caret - (_caret + lineStart));		}	
/**		 * Deletes the character after the caret.		 * @since jEdit 2.7pre2		 */		public void delete()		{			delete(true);		}	
/**		 * Deletes from the caret to the end of the current line.		 * @since jEdit 2.7pre2		 */		public void deleteToEndOfLine()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				buffer.remove(caret,getLineEndOffset(caretLine)				- caret - 1);		}	
/**		 * Deletes the line containing the caret.		 * @since jEdit 2.7pre2		 */		public void deleteLine()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				int x = chunkCache.subregionOffsetToX(caretLine,caret - getLineStartOffset(caretLine));			int[] lines = getSelectedLines();				try			{				buffer.beginCompoundEdit();					for (int i = lines.length - 1; i >= 0; i--)				{					int start = getLineStartOffset(lines[i]);					int end = getLineEndOffset(lines[i]);					if (end > buffer.getLength())					{						if (start != 0)							start--;						end--;					}					buffer.remove(start,end - start);				}			}			finally			{				buffer.endCompoundEdit();			}				int lastLine = displayManager.getLastVisibleLine();				if(caretLine == lastLine)			{				int offset = chunkCache.xToSubregionOffset(lastLine,0,x,true);				setCaretPosition(buffer.getLineStartOffset(lastLine)				+ offset);			}			else			{				int offset = chunkCache.xToSubregionOffset(caretLine,0,x,true);				setCaretPosition(getLineStartOffset(caretLine) + offset);			}		}	
/**		 * Deletes the paragraph containing the caret.		 * @since jEdit 2.7pre2		 */		public void deleteParagraph()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				// find the beginning of the paragraph.			int start = 0;			for(int i = caretLine - 1; i >= 0; i--)			{				if (lineContainsSpaceAndTabs(i))				{					start = getLineStartOffset(i);					break;				}			}				// Find the end of the paragraph			int end = buffer.getLength();			for(int i = caretLine + 1; i < getLineCount(); i++)			{				//if(!displayManager.isLineVisible(i))				//	continue loop;					if (lineContainsSpaceAndTabs(i))				{					end = getLineEndOffset(i) - 1;					break;				}			}				buffer.remove(start,end - start);		}	
/**		 * Deletes from the caret to the beginning of the current line.		 * @since jEdit 2.7pre2		 */		public void deleteToStartOfLine()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				buffer.remove(getLineStartOffset(caretLine),				caret - getLineStartOffset(caretLine));		}	
/**		 * Deletes the word in front of the caret.		 * @since jEdit 2.7pre2		 */		public void deleteWord()		{			deleteWord(false);		}	
/**		 * Deletes the word in front of the caret.		 *	.	 * @param eatWhitespace If true, will eat whitespace		 * @since jEdit 4.2pre5		 */		public void deleteWord(boolean eatWhitespace)		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				if(getSelectionCount() != 0)			{				setSelectedText("");				return;			}				int lineStart = getLineStartOffset(caretLine);			int _caret = caret - lineStart;				String lineText = getLineText(caretLine);				if(_caret == lineText.length())			{				if(lineStart + _caret == buffer.getLength())				{					getToolkit().beep();					return;				}				_caret++;			}			else			{				String noWordSep = buffer.getStringProperty("noWordSep");				boolean camelCasedWords = buffer.getBooleanProperty("camelCasedWords");				_caret = TextUtilities.findWordEnd(lineText,					_caret+1,noWordSep,true,camelCasedWords,eatWhitespace);			}				buffer.remove(caret,(_caret + lineStart) - caret);		}	
/**		 * Returns if multiple selection is enabled.		 * @since jEdit 3.2pre1		 */		public final boolean isMultipleSelectionEnabled()		{			return multi;		}	
/**		 * Toggles multiple selection.		 * @since jEdit 3.2pre1		 */		public final void toggleMultipleSelectionEnabled()		{			setMultipleSelectionEnabled(!multi);		}	
/**		 * Set multiple selection on or off according to the value of		 * <code>multi</code>. This only affects the ability to		 * make multiple selections in the user interface; macros and plugins		 * can manipulate them regardless of the setting of this flag. In fact,		 * in most cases, calling this method should not be necessary.		 *		 * @param multi Should multiple selection be enabled?		 * @since jEdit 3.2pre1		 */		public final void setMultipleSelectionEnabled(boolean multi)		{			this.multi = multi;			fireStatusChanged(StatusListener.MULTI_SELECT_CHANGED,multi);			painter.repaint();		}	
/**		 * Returns if rectangular selection is enabled.		 * @since jEdit 4.2pre1		 */		public final boolean isRectangularSelectionEnabled()		{			return rectangularSelectionMode;		}	
/**		 * Toggles rectangular selection.		 * @since jEdit 4.2pre1		 */		public final void toggleRectangularSelectionEnabled()		{			setRectangularSelectionEnabled(!rectangularSelectionMode);				if(getSelectionCount() == 1)			{				Selection s = getSelection(0);				removeFromSelection(s);				if(rectangularSelectionMode)				{					addToSelection(new Selection.Rect(						s.getStart(),s.getEnd()));				}				else				{					addToSelection(new Selection.Range(						s.getStart(),s.getEnd()));				}			}		}	
/**		 * Set rectangular selection on or off according to the value of		 * <code>rectangularSelectionMode</code>. This only affects the ability		 * to make multiple selections from the keyboard. A rectangular		 * selection can always be created by dragging with the mouse by holding		 * down <b>Control</b>, regardless of the state of this flag.		 *		 * @param rectangularSelectionMode Should rectangular selection be		 * enabled?		 * @since jEdit 4.2pre1		 */		public final void setRectangularSelectionEnabled(			boolean rectangularSelectionMode)		{			this.rectangularSelectionMode = rectangularSelectionMode;			fireStatusChanged(StatusListener.RECT_SELECT_CHANGED,				rectangularSelectionMode);			painter.repaint();		}	
/**		 * Moves the caret to the fold containing the one at the caret		 * position.		 * @since jEdit 4.0pre3		 */		public void goToParentFold()		{			int line = -1;			int level = buffer.getFoldLevel(caretLine);			for(int i = caretLine - 1; i >= 0; i--)			{				if(buffer.getFoldLevel(i) < level)				{					line = i;					break;				}			}				if(line == -1)			{				getToolkit().beep();				return;			}				int magic = getMagicCaretPosition();				int newCaret = buffer.getLineStartOffset(line)				+ chunkCache.xToSubregionOffset(line,0,magic + 1,true);			if(!multi)				selectNone();				moveCaretPosition(newCaret);			setMagicCaretPosition(magic);		}	
/**		 * Moves the caret to the next fold.		 * @param select true if you want to extend selection		 * @since jEdit 4.0pre3		 */		public void goToNextFold(boolean select)		{			int nextFold = -1;			for(int i = caretLine + 1; i < buffer.getLineCount(); i++)			{				if(buffer.isFoldStart(i)					&& displayManager.isLineVisible(i))				{					nextFold = i;					break;				}			}				if(nextFold == -1)			{				getToolkit().beep();				return;			}				int magic = getMagicCaretPosition();				int newCaret = buffer.getLineStartOffset(nextFold)				+ chunkCache.xToSubregionOffset(nextFold,0,magic + 1,true);			if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();				moveCaretPosition(newCaret);			setMagicCaretPosition(magic);		}	
/**		 * Moves the caret to the previous fold.		 * @param select true if you want to extend selection		 * @since jEdit 4.0pre3		 */		public void goToPrevFold(boolean select)		{			int prevFold = -1;			for(int i = caretLine - 1; i >= 0; i--)			{				if(buffer.isFoldStart(i)					&& displayManager.isLineVisible(i))				{					prevFold = i;					break;				}			}				if(prevFold == -1)			{				getToolkit().beep();				return;			}				int magic = getMagicCaretPosition();				int newCaret = buffer.getLineStartOffset(prevFold)				+ chunkCache.xToSubregionOffset(prevFold,0,magic + 1,true);			if(select)				extendSelection(caret,newCaret);			else if(!multi)				selectNone();				moveCaretPosition(newCaret);			setMagicCaretPosition(magic);		}	
/**		 * Like {@link DisplayManager#collapseFold(int)}, but		 * also moves the caret to the first line of the fold.		 * @since jEdit 4.0pre3		 */		public void collapseFold()		{			collapseFold(caretLine);		}	
/**		 * Like {@link DisplayManager#collapseFold(int)}, but		 * also moves the caret to the first line of the fold.		 * @since jEdit 4.3pre7		 */		public void collapseFold(int line)		{			int x = chunkCache.subregionOffsetToX(caretLine,				caret - getLineStartOffset(caretLine));				displayManager.collapseFold(line);				if(displayManager.isLineVisible(caretLine))				return;				line = displayManager.getPrevVisibleLine(caretLine);				if(!multi)			{				// cannot use selectNone() beacause the finishCaretUpdate method will reopen the fold				invalidateSelectedLines();				selectionManager.setSelection((Selection) null);			}			moveCaretPosition(buffer.getLineStartOffset(line)				+ chunkCache.xToSubregionOffset(line,0,x,true));		}	
/**		 * Like {@link DisplayManager#expandFold(int,boolean)}, but		 * also moves the caret to the first sub-fold.		 * @param fully If true, all subfolds will also be expanded		 * @since jEdit 4.0pre3		 */		public void expandFold(boolean fully)		{			int x = chunkCache.subregionOffsetToX(caretLine,				caret - getLineStartOffset(caretLine));				int line = displayManager.expandFold(caretLine,fully);				if(!fully && line != -1)			{				if(!multi)					selectNone();				moveCaretPosition(getLineStartOffset(line)					+ chunkCache.xToSubregionOffset(line,0,x,true));			}		}	
/**		 * Selects the fold that contains the caret line number.		 * @since jEdit 3.1pre3		 */		public void selectFold()		{			selectFold(caretLine);		}	
/**		 * Selects the fold that contains the specified line number.		 * @param line The line number		 * @since jEdit 4.0pre1		 */		public void selectFold(int line)		{			int[] lines = buffer.getFoldAtLine(line);				int newCaret = getLineEndOffset(lines[1]) - 1;			Selection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);			if(multi)				addToSelection(s);			else				setSelection(s);			moveCaretPosition(newCaret);		}	
/**		 * Hides all lines except those in the fold containing the caret.		 * @since jEdit 4.0pre1		 */		public void narrowToFold()		{			int[] lines = buffer.getFoldAtLine(caretLine);			if(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)				getToolkit().beep();			else				displayManager.narrow(lines[0],lines[1]);		}	
/**		 * Hides all lines except those in the selection.		 * @since jEdit 4.0pre1		 */		public void narrowToSelection()		{			if(getSelectionCount() != 1)			{				getToolkit().beep();				return;			}				Selection sel = getSelection(0);			displayManager.narrow(sel.getStartLine(),sel.getEndLine());				selectNone();		}	
/**		 * Surrounds the selection with explicit fold markers.		 * @throws TextAreaException an exception thrown if the folding mode is		 * not explicit		 * @since jEdit 4.0pre3		 */		public void addExplicitFold() throws TextAreaException		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}			if(!buffer.getStringProperty("folding").equals("explicit"))			{				throw new TextAreaException("folding-not-explicit");			}				try			{				buffer.beginCompoundEdit();					if (getSelectionCount() == 0)				{					addExplicitFold(caret, caret, caretLine, caretLine);				}				else				{					Selection[] selections = getSelection();					Selection selection = null;					int caretBack = 0;					for (int i = 0; i < selections.length; i++)					{						selection = selections[i];						caretBack = addExplicitFold(selection.start, selection.end, selection.startLine,selection.endLine);					}					// Selection cannot be null because there is at least 1 selection					assert selection != null;					setCaretPosition(selection.start - caretBack, false);				}			}			finally			{				buffer.endCompoundEdit();			}		}	
/**		 * Prepends each line of the selection with the line comment string.		 * @since jEdit 3.2pre1		 */		public void lineComment()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}			String comment = buffer.getContextSensitiveProperty(caret,"lineComment");			if(comment == null || comment.length() == 0)			{				rangeLineComment();				return;			}				comment += ' ';				buffer.beginCompoundEdit();				int[] lines = getSelectedLines();				try			{				for(int i = 0; i < lines.length; i++)				{					String text = getLineText(lines[i]);					buffer.insert(getLineStartOffset(lines[i])						+ StandardUtilities.getLeadingWhiteSpace(text),						comment);				}			}			finally			{				buffer.endCompoundEdit();			}				selectNone();		}	
/**		 * Adds comment start and end strings to the beginning and end of the		 * selection.		 * @since jEdit 3.2pre1		 */		public void rangeComment()		{			String commentStart = buffer.getContextSensitiveProperty(caret,"commentStart");			String commentEnd = buffer.getContextSensitiveProperty(caret,"commentEnd");			if(!buffer.isEditable() || commentStart == null || commentEnd == null				|| commentStart.length() == 0 || commentEnd.length() == 0)			{				getToolkit().beep();				return;			}				commentStart += ' ';			commentEnd = ' ' + commentEnd;				try			{				buffer.beginCompoundEdit();					Selection[] selection = getSelection();					if(selection.length == 0)				{					int oldCaret = caret;					buffer.insert(caret,commentStart);					buffer.insert(caret,commentEnd);					setCaretPosition(oldCaret + commentStart.length());				}					for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					if(s instanceof Selection.Range)					{						buffer.insert(s.start,commentStart);						buffer.insert(s.end,commentEnd);					}					else if(s instanceof Selection.Rect)					{						Selection.Rect rect = (Selection.Rect)s;						int start = rect.getStartColumn(buffer);						int end = rect.getEndColumn(buffer);							for(int j = s.startLine; j <= s.endLine; j++)						{							buffer.insertAtColumn(j,end,								commentEnd);							buffer.insertAtColumn(j,start,								commentStart);						}					}				}					selectNone();			}			finally			{				buffer.endCompoundEdit();			}		}	
/**		 * Formats the paragraph containing the caret.		 * @since jEdit 2.7pre2		 */		public void formatParagraph() throws TextAreaException		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				if(maxLineLen <= 0)			{				throw new TextAreaException("format-maxlinelen");			}				Selection[] selection = getSelection();			if(selection.length != 0)			{				buffer.beginCompoundEdit();					for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					setSelectedText(s,TextUtilities.format(						getSelectedText(s),maxLineLen,						buffer.getTabSize()));				}					buffer.endCompoundEdit();			}			else			{				int lineNo = getCaretLine();					int start = 0, end = buffer.getLength();					for(int i = lineNo - 1; i >= 0; i--)				{					if (lineContainsSpaceAndTabs(i))					{						start = getLineEndOffset(i);						break;					}				}					for(int i = lineNo + 1; i < getLineCount(); i++)				{					if (lineContainsSpaceAndTabs(i))					{						end = getLineStartOffset(i) - 1;						break;					}				}					try				{					buffer.beginCompoundEdit();						String text = buffer.getText(start,end - start);					int offset = getCaretPosition() - start;					int noSpaceOffset = TextUtilities.indexIgnoringWhitespace(						text,offset);					buffer.remove(start,end - start);					text = TextUtilities.format(						text,maxLineLen,buffer.getTabSize());					buffer.insert(start,text);					int caretPos = start;					if (text.length() != 0)					{						caretPos += Math.min(text.length(),						TextUtilities.ignoringWhitespaceIndex(						text,noSpaceOffset));					}					moveCaretPosition(caretPos);				}				finally				{					buffer.endCompoundEdit();				}			}		}	
/**		 * Converts spaces to tabs in the selection.		 * @since jEdit 2.7pre2		 */		public void spacesToTabs()		{			Selection[] selection = getSelection();				if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				buffer.beginCompoundEdit();				if(selection.length == 0)			{				setText(TextUtilities.spacesToTabs(					getText(), buffer.getTabSize()));			}			else			{				for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					setSelectedText(s,TextUtilities.spacesToTabs(						getSelectedText(s),buffer.getTabSize()));				}			}				buffer.endCompoundEdit();		}	
/**		 * Converts tabs to spaces in the selection.		 * @since jEdit 2.7pre2		 */		public void tabsToSpaces()		{			Selection[] selection = getSelection();				if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				buffer.beginCompoundEdit();				if(selection.length == 0)			{				setText(TextUtilities.tabsToSpaces(					getText(), buffer.getTabSize()));			}			else			{				for(int i = 0; i < selection.length; i++)				{					Selection s = selection[i];					setSelectedText(s, TextUtilities.tabsToSpaces(						getSelectedText(s),buffer.getTabSize()));				}			}				buffer.endCompoundEdit();		}	
/**		 * Converts the selected text to upper case.		 * @since jEdit 2.7pre2		 */		public void toUpperCase()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				Selection[] selection = getSelection();			int caret = -1;			if (selection.length == 0)			{				caret = getCaretPosition();				selectWord();				selection = getSelection();			}			if (selection.length == 0)			{				if (caret != -1)					setCaretPosition(caret);				getToolkit().beep();				return;			}				buffer.beginCompoundEdit();				for(int i = 0; i < selection.length; i++)			{				Selection s = selection[i];				setSelectedText(s,getSelectedText(s).toUpperCase());			}				buffer.endCompoundEdit();			if (caret != -1)				setCaretPosition(caret);		}	
/**		 * Converts the selected text to lower case.		 * @since jEdit 2.7pre2		 */		public void toLowerCase()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				Selection[] selection = getSelection();			int caret = -1;			if (selection.length == 0)			{				caret = getCaretPosition();				selectWord();				selection = getSelection();			}			if (selection.length == 0)			{				if (caret != -1)					setCaretPosition(caret);				getToolkit().beep();				return;			}				buffer.beginCompoundEdit();				for (int i = 0; i < selection.length; i++)			{				Selection s = selection[i];				setSelectedText(s,getSelectedText(s).toLowerCase());			}				buffer.endCompoundEdit();			if (caret != -1)				setCaretPosition(caret);		}	
/**		 * Removes trailing whitespace from all lines in the selection.		 * @since jEdit 2.7pre2		 */		public void removeTrailingWhiteSpace()		{			if(!buffer.isEditable())				getToolkit().beep();			else			{				buffer.removeTrailingWhiteSpace(getSelectedLines());			}		}	
public void insertEnterAndIndent()		{			if(!isEditable())				getToolkit().beep();			else			{				try				{					buffer.beginCompoundEdit();					setSelectedText("\n");					buffer.indentLine(caretLine,true);				}				finally				{					buffer.endCompoundEdit();				}			}		}	
public void insertTabAndIndent()		{			if(!isEditable())			{				getToolkit().beep();				return;			}				if(getSelectionCount() == 0)			{				// if caret is inside leading whitespace, indent.				CharSequence text = buffer.getLineSegment(caretLine);				int start = buffer.getLineStartOffset(caretLine);				int whiteSpace = StandardUtilities.getLeadingWhiteSpace(text);					if(caret - start <= whiteSpace					&& buffer.indentLine(caretLine,false))					return;			}				userInput('\t');		}	
/**		 * Indents all selected lines.		 * @since jEdit 3.1pre3		 */		public void indentSelectedLines()		{			if(!buffer.isEditable())				getToolkit().beep();			else			{				buffer.indentLines(getSelectedLines());				selectNone();			}		}	
/**		 * Shifts the indent to the left.		 * @since jEdit 2.7pre2		 */		public void shiftIndentLeft()		{			if(!buffer.isEditable())				getToolkit().beep();			else			{				buffer.shiftIndentLeft(getSelectedLines());			}		}	
/**		 * Shifts the indent to the right.		 * @since jEdit 2.7pre2		 */		public void shiftIndentRight()		{			if(!buffer.isEditable())				getToolkit().beep();			else				buffer.shiftIndentRight(getSelectedLines());		}	
/**		 * Joins the current and the next line, or joins all lines in		 * selections.		 * @since jEdit 2.7pre2		 */		public void joinLines()		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				try			{				buffer.beginCompoundEdit();				boolean doneForSelection = false;				for (Selection selection: selectionManager.getSelection())				{					while (selection.startLine < selection.endLine)					{						// Edit from end of selection to						// minimize invalidations and						// recaluculations of cached line info						// such as indent level or fold level.						joinLineAt(selection.endLine - 1);						doneForSelection = true;					}				}				// If nothing selected or all selections span only				// one line, join the line at the caret.				if (!doneForSelection)				{					int end = getLineEndOffset(caretLine);						// Nothing to do if the caret is on the last line.					if (end > buffer.getLength())					{						getToolkit().beep();						return;					}						joinLineAt(caretLine);					if(!multi)						selectNone();					moveCaretPosition(end - 1);				}			}			finally			{				buffer.endCompoundEdit();			}		}	
/**		 * Adds a component to the left side of the box left of the vertical		 * scroll bar. The ErrorList plugin uses this to show a global error		 * overview, for example.  It is possible for more than one component		 * to be added, each is added to the left side of the box in turn.		 * Adding to the left ensures the scrollbar is always right of all added		 * components.		 *		 * @param comp The component		 * @since jEdit 4.2pre1		 */		public void addLeftOfScrollBar(Component comp)		{			verticalBox.add(comp, 0);		}	
/**		 * Removes a component from the box left of the vertical scroll bar.		 *		 * @param comp The component		 * @since jEdit 4.2pre1		 */		public void removeLeftOfScrollBar(Component comp)		{			verticalBox.remove(comp);		}	
/**		 * Called by the AWT when this component is added to a parent.		 * Adds document listener.		 */		@Override		public void addNotify()		{			super.addNotify();				ToolTipManager.sharedInstance().registerComponent(painter);			ToolTipManager.sharedInstance().registerComponent(gutter);				recalculateVisibleLines();			if(!buffer.isLoading())				recalculateLastPhysicalLine();			propertiesChanged();				hiddenCursor = getToolkit().createCustomCursor(				getGraphicsConfiguration()				.createCompatibleImage(16,16,				Transparency.BITMASK),				new Point(0,0),"Hidden");		}	
/**		 * Called by the AWT when this component is removed from it's parent.		 * This clears the pointer to the currently focused component.		 * Also removes document listener.		 */		@Override		public void removeNotify()		{			super.removeNotify();				ToolTipManager.sharedInstance().unregisterComponent(painter);			ToolTipManager.sharedInstance().unregisterComponent(gutter);				if(focusedComponent == this)				focusedComponent = null;				caretTimer.stop();		}	
/**		 * Java 1.4 compatibility fix to make Tab key work.		 * @since jEdit 3.2pre4		 */		@Override		public boolean getFocusTraversalKeysEnabled()		{			return false;		}	
/**		 * Java 1.4 compatibility fix to make Tab traversal work in a sane		 * manner.		 * @since jEdit 4.2pre3		 */		public boolean getFocusCycleRoot()		{			return true;		}	
@Override		public void processKeyEvent(KeyEvent evt)		{			getInputHandler().processKeyEvent(evt, 1 /* source=TEXTAREA (1) */, false);			if(!evt.isConsumed())				super.processKeyEvent(evt);			}	
/**		 * Adds a component above the gutter, text area, and vertical scroll bar.		 *		 * @since jEdit 4.2pre3		 */		public void addTopComponent(Component comp)		{			add(ScrollLayout.TOP,comp);		}	
/**		 * Removes a component from above the gutter, text area, and vertical scroll bar.		 *		 * @since jEdit 4.2pre3		 */		public void removeTopComponent(Component comp)		{			remove(comp);		}	
@Override		public InputMethodRequests getInputMethodRequests()		{			if(inputMethodSupport == null)			{				inputMethodSupport = new InputMethodSupport(this);				Log.log(Log.DEBUG, this, "InputMethodSupport is activated");			}			return inputMethodSupport;		}	
/**		 * Adds a scroll listener to this text area.		 * @param listener The listener		 * @since jEdit 4.3pre2		 */		public final void addStatusListener(StatusListener listener)		{			listenerList.add(StatusListener.class,listener);		}	
/**		 * Removes a scroll listener from this text area.		 * @param listener The listener		 * @since jEdit 4.3pre2		 */		public final void removeStatusListener(StatusListener listener)		{			listenerList.remove(StatusListener.class,listener);		}	
/**		 * Called by jEdit when necessary. Plugins should not call this method.		 */		public void propertiesChanged()		{			if(buffer == null)				return;				int _tabSize = buffer.getTabSize();			char[] foo = new char[_tabSize];			for(int i = 0; i < foo.length; i++)				foo[i] = ' ';				tabSize = painter.getStringWidth(new String(foo));				charWidth = (int)Math.round(				painter.getFont().getStringBounds(foo,0,1,				painter.getFontRenderContext()).getWidth());				String oldWrap = wrap;			wrap = buffer.getStringProperty("wrap");			hardWrap = wrap.equals("hard");			softWrap = wrap.equals("soft");			boolean oldWrapToWidth = wrapToWidth;			int oldWrapMargin = wrapMargin;			setMaxLineLength(buffer.getIntegerProperty("maxLineLen",0));				boolean wrapSettingsChanged = !(wrap.equals(oldWrap)				&& oldWrapToWidth == wrapToWidth				&& oldWrapMargin == wrapMargin);				if(displayManager != null && !bufferChanging				&& !buffer.isLoading() && wrapSettingsChanged)			{				displayManager.invalidateScreenLineCounts();				displayManager.notifyScreenLineChanges();			}				chunkCache.invalidateAll();			gutter.repaint();			painter.repaint();		}	
/**		 * Adds a new action set to the textarea's list of ActionSets.		 * Call this only on standalone textarea		 *		 * @param actionSet the actionSet to add		 * @since jEdit 4.3pre13		 */		public void addActionSet(JEditActionSet<JEditBeanShellAction> actionSet)		{			actionContext.addActionSet(actionSet);		}	
/**		 * @deprecated Do not use.		 */		@Deprecated		public final int getMarkPosition()		{			Selection s = getSelectionAtOffset(caret);			if(s == null)				return caret;				if(s.start == caret)				return s.end;			else if(s.end == caret)				return s.start;			else				return caret;		}	
/**		 * @deprecated Do not use.		 */		@Deprecated		public final int getMarkLine()		{			if(getSelectionCount() != 1)				return caretLine;				Selection s = getSelection(0);			if(s.start == caret)				return s.endLine;			else if(s.end == caret)				return s.startLine;			else				return caretLine;		}	
/**		 * Returns true if the caret is visible, false otherwise.		 */		final boolean isCaretVisible()		{			return blink && hasFocus();		}	
/**		 * Returns true if the structure highlight is visible, false otherwise.		 * @since jEdit 4.2pre3		 */		final boolean isStructureHighlightVisible()		{			return match != null				&& hasFocus()				&& displayManager.isLineVisible(match.startLine)				&& displayManager.isLineVisible(match.endLine);		}	
void updateMaxHorizontalScrollWidth()		{			int max = chunkCache.getMaxHorizontalScrollWidth();				if(max != maxHorizontalScrollWidth)			{				maxHorizontalScrollWidth = max;				horizontal.setValues(Math.max(0,					Math.min(maxHorizontalScrollWidth + charWidth					- painter.getWidth(),					-horizontalOffset)),					painter.getWidth(),					0,maxHorizontalScrollWidth					+ charWidth);				horizontal.setUnitIncrement(10);				horizontal.setBlockIncrement(painter.getWidth());			}			else if (horizontal.getValue() != -horizontalOffset)			{				horizontal.setValue(-horizontalOffset);			}		}	
void recalculateVisibleLines()		{			if(painter == null)				return;			int height = painter.getHeight();			int lineHeight = painter.getFontMetrics().getHeight();			if(lineHeight == 0)				visibleLines = 0;			else if(height <= 0)			{				visibleLines = 0;				lastLinePartial = false;			}			else			{				visibleLines = height / lineHeight;				lastLinePartial = height % lineHeight != 0;				if(lastLinePartial)					visibleLines++;			}				chunkCache.recalculateVisibleLines();				// this does the "trick" to eliminate blank space at the end			if(displayManager != null && buffer != null && !buffer.isLoading())				setFirstLine(getFirstLine());				updateScrollBar();		}	
void foldStructureChanged()		{			chunkCache.invalidateAll();			recalculateLastPhysicalLine();			repaint();		}	
/**		 * Updates the state of the scroll bars. This should be called		 * if the number of lines in the buffer changes, or when the		 * size of the text are changes.		 */		void updateScrollBar()		{			if(buffer == null)				return;				if(Debug.SCROLL_DEBUG)				Log.log(Log.DEBUG,this,"updateScrollBar(), slc="					+ displayManager.getScrollLineCount());				if(vertical != null && visibleLines != 0)			{				if(Debug.SCROLL_DEBUG)					Log.log(Log.DEBUG,this,"Vertical ok");				int lineCount = displayManager.getScrollLineCount();				int firstLine = getFirstLine();				int visible = visibleLines - (lastLinePartial ? 1 : 0);					vertical.setValues(firstLine,visible,0,lineCount);				vertical.setUnitIncrement(2);				vertical.setBlockIncrement(visible);			}		}	
void _finishCaretUpdate()		{			if(!queuedCaretUpdate)				return;				try			{				if(match != null)				{					if(oldCaretLine < match.startLine)						invalidateLineRange(oldCaretLine,match.endLine);					else						invalidateLineRange(match.startLine,oldCaretLine);					match = null;				}					int newCaretScreenLine = chunkCache.getScreenLineOfOffset(caretLine,					caret - buffer.getLineStartOffset(caretLine));				if(caretScreenLine == -1)					invalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);				else					invalidateScreenLineRange(caretScreenLine,newCaretScreenLine);				caretScreenLine = newCaretScreenLine;					invalidateSelectedLines();					// When the user is typing, etc, we don't want the caret				// to blink				blink = true;				caretTimer.restart();					if(!displayManager.isLineVisible(caretLine))				{					if(caretLine < displayManager.getFirstVisibleLine()						|| caretLine > displayManager.getLastVisibleLine())					{						int collapseFolds = buffer.getIntegerProperty(							"collapseFolds",0);						if(collapseFolds != 0)						{							displayManager.expandFolds(collapseFolds);							displayManager.expandFold(caretLine,false);						}						else							displayManager.expandAllFolds();					}					else						displayManager.expandFold(caretLine,false);				}					if(queuedScrollMode == ELECTRIC_SCROLL)					scrollToCaret(true);				else if(queuedScrollMode == NORMAL_SCROLL)					scrollToCaret(false);					updateBracketHighlightWithDelay();				if(queuedFireCaretEvent)					fireCaretEvent();			}			// in case one of the above fails, we still want to			// clear these flags.			finally			{				queuedCaretUpdate = queuedFireCaretEvent = false;				queuedScrollMode = NO_SCROLL;			}		}	
void invalidateStructureMatch()		{			if(match != null)				invalidateLineRange(match.startLine,match.endLine);		}	
void startDragAndDrop(InputEvent evt, boolean copy)		{			TransferHandler transferHandler = getTransferHandler();			if (transferHandler != null)			{				Log.log(Log.DEBUG,this,"Drag and drop callback");				transferHandler.exportAsDrag(this,evt,					copy ? TransferHandler.COPY					: TransferHandler.MOVE);			}		}	
void fireNarrowActive()		{			Object[] listeners = listenerList.getListenerList();			for(int i = listeners.length - 2; i >= 0; i--)			{				if(listeners[i] == StatusListener.class)				{					try					{						((StatusListener)listeners[i+1])							.narrowActive(this);					}					catch(Throwable t)					{						Log.log(Log.ERROR,this,t);					}				}			}		}	
/**		 * Sets the horizontal offset of drawn lines. This method will		 * check if the offset do not go too far after the last character		 * @param horizontalOffset offset The new horizontal offset		 */		private void _setHorizontalOffset(int horizontalOffset)		{			if(horizontalOffset > 0)				horizontalOffset = 0;				if(horizontalOffset == this.horizontalOffset)				return;				// Scrolling with trackpad or other device should be kept inside bounds			int min = Math.min(-(maxHorizontalScrollWidth + charWidth - painter.getWidth()), 0);			if(horizontalOffset < min)				horizontalOffset = min;				setHorizontalOffset(horizontalOffset);		}	
/**		 * Repaints the lines containing the selection.		 */		private void invalidateSelectedLines()		{			// to hide line highlight if selections are being added later on			invalidateLine(caretLine);				for (Selection s : selectionManager.selection)				invalidateLineRange(s.startLine,s.endLine);		}	
/**		 * the collapsing of scrolling/event firing inside compound edits		 * greatly speeds up replace-all.		 */		private void finishCaretUpdate(int oldCaretLine,			int scrollMode, boolean fireCaretEvent)		{			queuedFireCaretEvent |= fireCaretEvent;			queuedScrollMode = Math.max(scrollMode,queuedScrollMode);				if(queuedCaretUpdate)				return;				this.oldCaretLine = oldCaretLine;			queuedCaretUpdate = true;				if(!buffer.isTransactionInProgress())				_finishCaretUpdate();			/* otherwise DisplayManager.BufferChangeHandler calls */		}	
private void fireCaretEvent()		{			Object[] listeners = listenerList.getListenerList();			for(int i = listeners.length - 2; i >= 0; i--)			{				if(listeners[i] == CaretListener.class)				{					try					{						((CaretListener)listeners[i+1]).caretUpdate(caretEvent);					}					catch(Throwable t)					{						Log.log(Log.ERROR,this,t);					}				}			}		}	
private void fireScrollEvent(boolean vertical)		{			Object[] listeners = listenerList.getListenerList();			for(int i = listeners.length - 2; i >= 0; i--)			{				if(listeners[i] == ScrollListener.class)				{					try					{						if(vertical)							((ScrollListener)listeners[i+1]).scrolledVertically(this);						else							((ScrollListener)listeners[i+1]).scrolledHorizontally(this);					}					catch(Throwable t)					{						Log.log(Log.ERROR,this,t);					}				}			}		}	
private void fireStatusChanged(int flag, boolean value)		{			Object[] listeners = listenerList.getListenerList();			for(int i = listeners.length - 2; i >= 0; i--)			{				if(listeners[i] == StatusListener.class)				{					try					{						((StatusListener)listeners[i+1])							.statusChanged(this,flag,value);					}					catch(Throwable t)					{						Log.log(Log.ERROR,this,t);					}				}			}		}	
private void fireBracketSelected(int line, String text)		{			Object[] listeners = listenerList.getListenerList();			for(int i = listeners.length - 2; i >= 0; i--)			{				if(listeners[i] == StatusListener.class)				{					try					{						((StatusListener)listeners[i+1])							.bracketSelected(this,line,text);					}					catch(Throwable t)					{						Log.log(Log.ERROR,this,t);					}				}			}		}	
private void _changeLine(boolean select, int newCaret)		{			if(select)			{				RectParams params = getRectParams(caret,newCaret);				int extraStartVirt;				int extraEndVirt;				if(params == null)				{					extraStartVirt = 0;					extraEndVirt = 0;				}				else				{					extraStartVirt = params.extraStartVirt;					extraEndVirt = params.extraEndVirt;					newCaret = params.newCaret;				}				extendSelection(caret,newCaret,extraStartVirt,extraEndVirt);			}			else if(!multi)				selectNone();				moveCaretPosition(newCaret);		}	
/**		 * Check if the line contains only spaces and tabs.		 *		 * @param lineIndex the line index		 * @return <code>true</code> if the line contains only spaces and tabs		 */		private boolean lineContainsSpaceAndTabs(int lineIndex)		{			getLineText(lineIndex,lineSegment);				for(int j = 0; j < lineSegment.count; j++)			{				switch(lineSegment.array[lineSegment.offset + j])				{				case ' ':				case '\t':					break;				default:					return false;				}			}			return true;		}	
protected void insert(String str, boolean indent)		{			try			{				// Don't overstrike if we're on the end of				// the line				if(overwrite || indent)					buffer.beginCompoundEdit();					if(overwrite)				{					int caretLineEnd = getLineEndOffset(caretLine);					if(caretLineEnd - caret > 1)						buffer.remove(caret,1);				}					buffer.insert(caret,str);					if(indent)					buffer.indentLine(caretLine,true);			}			finally			{				if(overwrite || indent)					buffer.endCompoundEdit();			}		}	
private void insertTab()		{			int tabSize = buffer.getTabSize();			if(buffer.getBooleanProperty("noTabs"))			{				int lineStart = getLineStartOffset(caretLine);					String line = getText(lineStart,caret - lineStart);					int pos = 0;					for(int i = 0; i < line.length(); i++)				{					switch(line.charAt(pos))					{					case '\t':						pos = 0;						break;					default:						if(++pos >= tabSize)							pos = 0;						break;					}				}					replaceSelection(StandardUtilities.createWhiteSpace(					tabSize - pos,0));			}			else				replaceSelection("\t");		}	
protected void userInputTab()		{			if(getSelectionCount() == 1)			{				Selection sel = getSelection(0);				if(sel instanceof Selection.Rect ||					(sel.startLine == sel.endLine					&& (sel.start != buffer.getLineStartOffset(sel.startLine)					|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1)))				{					insertTab();				}				else					shiftIndentRight();			}			else if(getSelectionCount() != 0)				shiftIndentRight();			else				insertTab();		}	
/**		 * Does hard wrap.		 */		protected boolean doWordWrap(boolean spaceInserted)		{			if(!hardWrap || maxLineLen <= 0)				return false;				buffer.getLineText(caretLine,lineSegment);				int start = getLineStartOffset(caretLine);			int end = getLineEndOffset(caretLine);			int len = end - start - 1;				int caretPos = caret - start;				// only wrap if we're at the end of a line, or the rest of the			// line text is whitespace			for(int i = caretPos; i < len; i++)			{				char ch = lineSegment.array[lineSegment.offset + i];				if(ch != ' ' && ch != '\t')					return false;			}				int tabSize = buffer.getTabSize();				String wordBreakChars = buffer.getStringProperty("wordBreakChars");				int lastInLine = 0; // last character before wrap			int logicalLength = 0; // length with tabs expanded			int lastWordOffset = -1;			boolean lastWasSpace = true;			for(int i = 0; i < caretPos; i++)			{				char ch = lineSegment.array[lineSegment.offset + i];				if(ch == '\t')				{					logicalLength += tabSize - (logicalLength % tabSize);					if(!lastWasSpace && logicalLength <= maxLineLen)					{						lastInLine = i;						lastWordOffset = i;						lastWasSpace = true;					}				}				else if(ch == ' ')				{					logicalLength++;					if(!lastWasSpace &&						logicalLength <= maxLineLen + 1)					{						lastInLine = i;						lastWordOffset = i;						lastWasSpace = true;					}				}				else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)				{					logicalLength++;					if(!lastWasSpace && logicalLength <= maxLineLen)					{						lastInLine = i;						lastWordOffset = i;						lastWasSpace = true;					}				}				else				{					lastInLine = i;					logicalLength++;					lastWasSpace = false;				}			}				boolean returnValue;				int insertNewLineAt;			if(spaceInserted && logicalLength == maxLineLen				&& lastInLine == caretPos - 1)			{				insertNewLineAt = caretPos;				returnValue = true;			}			else if(logicalLength >= maxLineLen && lastWordOffset != -1)			{				insertNewLineAt = lastWordOffset;				returnValue = false;			}			else				return false;				try			{				buffer.beginCompoundEdit();				buffer.insert(start + insertNewLineAt,"\n");				// caretLine would have been incremented				// since insertNewLineAt <= caretPos				buffer.indentLine(caretLine,true);			}			finally			{				buffer.endCompoundEdit();			}				/* only ever return true if space was pressed			 * with logicalLength == maxLineLen */			return returnValue;		}	
private static void updateBracketHighlightWithDelay()		{			structureTimer.stop();			structureTimer.start();		}	
private void updateStructureHighlight()		{			if(!painter.isStructureHighlightEnabled()				&& !gutter.isStructureHighlightEnabled())				return;				for (StructureMatcher matcher : structureMatchers)			{				match = matcher.getMatch(this);				if(match != null)					break;			}				if(match != null)			{				if(caretLine < match.startLine)					invalidateLineRange(caretLine,match.endLine);				else					invalidateLineRange(match.startLine,caretLine);					if(!displayManager.isLineVisible(match.startLine)					|| chunkCache.getScreenLineOfOffset(					match.startLine,match.start - getLineStartOffset(match.startLine))					== -1)				{					showStructureStatusMessage(match.startLine < caretLine);				}			}		}	
private void showStructureStatusMessage(boolean backward)		{			String text = buffer.getLineText(match.startLine).trim();			if(backward && match.startLine != 0 && text.length() == 1)			{				switch(text.charAt(0))				{				case '{': case '}':				case '[': case ']':				case '(': case ')':					text = buffer.getLineText(match.startLine - 1)						.trim() + ' ' + text;					break;				}			}				// get rid of embedded tabs not removed by trim()			fireBracketSelected(match.startLine + 1,text.replace('\t',' '));		}	
void recalculateLastPhysicalLine()		{			int oldScreenLastLine = screenLastLine;			for(int i = visibleLines - 1; i >= 0; i--)			{				ChunkCache.LineInfo info = chunkCache.getLineInfo(i);				if(info.physicalLine != -1)				{					physLastLine = info.physicalLine;					screenLastLine = i;					break;				}			}			invalidateScreenLineRange(oldScreenLastLine,screenLastLine);		}	
RectParams(int extraStartVirt, int extraEndVirt, int newCaret)			{				this.extraStartVirt = extraStartVirt;				this.extraEndVirt = extraEndVirt;				this.newCaret = newCaret;			}	
/**		 * Used when doing S+UP/DOWN to simplify dealing with virtual space.		 */		private RectParams getRectParams(int caret, int newCaret)		{			Selection s = getSelectionAtOffset(caret);			int virtualWidth;			if(s instanceof Selection.Rect)			{				if(caret == s.end)				{					virtualWidth = buffer.getVirtualWidth(						s.endLine,s.end - getLineStartOffset(						s.endLine)) + ((Selection.Rect)s).extraEndVirt;				}				else				{					virtualWidth = buffer.getVirtualWidth(						s.startLine,s.start - getLineStartOffset(						s.startLine)) + ((Selection.Rect)s).extraStartVirt;				}			}			else if(rectangularSelectionMode)			{				virtualWidth = buffer.getVirtualWidth(					caretLine,caret - buffer.getLineStartOffset(caretLine));			}			else				return null;				int newLine = getLineOfOffset(newCaret);			int[] totalVirtualWidth = new int[1];			int newOffset = buffer.getOffsetOfVirtualColumn(newLine,				virtualWidth,totalVirtualWidth);			if(newOffset == -1)			{				int extraVirt = virtualWidth - totalVirtualWidth[0];				newCaret = getLineEndOffset(newLine) - 1;					boolean bias;				if(s == null)					bias = newCaret < caret;				else if(s.start == caret)					bias = newCaret <= s.end;				else if(s.end == caret)					bias = newCaret <= s.start;				else					bias = false;					RectParams returnValue;				if(bias)					returnValue = new RectParams(extraVirt,0,newCaret);				else					returnValue = new RectParams(0,extraVirt,newCaret);				return returnValue;			}			else			{				return new RectParams(0,0,getLineStartOffset(newLine)					+ newOffset);			}		}	
private void delete(boolean forward)		{			if(!buffer.isEditable())			{				getToolkit().beep();				return;			}				if(getSelectionCount() != 0)			{				Selection[] selections = getSelection();				for(int i = 0; i < selections.length; i++)				{					Selection s = selections[i];					if(s instanceof Selection.Rect)					{						Selection.Rect r = (Selection.Rect)s;						int startColumn = r.getStartColumn(buffer);						if(startColumn == r.getEndColumn(buffer))						{							if(!forward && startColumn == 0)								getToolkit().beep();							else								tallCaretDelete(r,forward);						}						else							setSelectedText(s,null);					}					else						setSelectedText(s,null);				}			}			else if(forward)			{				if(caret == buffer.getLength())				{					getToolkit().beep();					return;				}					buffer.remove(caret,1);			}			else			{				if(caret == 0)				{					getToolkit().beep();					return;				}					buffer.remove(caret - 1,1);			}		}	
private void tallCaretDelete(Selection.Rect s, boolean forward)		{			try			{				buffer.beginCompoundEdit();					int[] width = new int[1];					int startCol = s.getStartColumn(buffer);				int startLine = s.startLine;				int endLine = s.endLine;				for(int i = startLine; i <= endLine; i++)				{					int offset = buffer.getOffsetOfVirtualColumn(						i,startCol,width);					if(offset == -1)					{						if(width[0] == startCol)							offset = getLineLength(i);						else						{							if(i == startLine && !forward)								shiftTallCaretLeft(s);							continue;						}					}					offset += buffer.getLineStartOffset(i);					if(forward)					{						if(offset != buffer.getLineEndOffset(i) - 1)							buffer.remove(offset,1);					}					else						buffer.remove(offset-1,1);				}			}			finally			{				buffer.endCompoundEdit();			}		}	
private void shiftTallCaretLeft(Selection.Rect s)		{			removeFromSelection(s);			addToSelection(new Selection.Rect(				buffer,				s.getStartLine(),s.getStartColumn(buffer) - 1,				s.getEndLine(),s.getEndColumn(buffer) - 1));		}	
private void setMaxLineLength(int maxLineLen)		{			this.maxLineLen = maxLineLen;				if(maxLineLen <= 0)			{				if(softWrap)				{					wrapToWidth = true;					wrapMargin = painter.getWidth() - charWidth * 3;				}				else				{					wrapToWidth = false;					wrapMargin = 0;				}			}			else			{				// stupidity				char[] foo = new char[maxLineLen];				for(int i = 0; i < foo.length; i++)				{					foo[i] = ' ';				}				wrapToWidth = false;				wrapMargin = (int)painter.getFont().getStringBounds(					foo,0,foo.length,					painter.getFontRenderContext())					.getWidth();			}		}	
/**		 * Add an explicit fold.		 * You should call this method inside a compoundEdit in the buffer.		 * You must also check if the buffer fold mode is explicit before		 * calling this method.		 *		 * @param caretStart the starting offset		 * @param caretEnd   the end offset		 * @param lineStart  the start line		 * @param lineEnd    the end line		 * @since jEdit 4.3pre3		 */		protected int addExplicitFold(int caretStart, int caretEnd, int lineStart, int lineEnd)		{			// need to "fix" the caret position so that we get the right rule.			// taking the start offset one char ahead and the end offset one char			// behing makes sure we get the right rule for the text being			// wrapped (tricky around mode boundaries, e.g., php code embedded			// in HTML code)			int startCaret = caretStart < buffer.getLength() ? caretStart + 1 : caretStart;			int endCaret = caretEnd > 0 ? caretEnd - 1 : caretEnd;				String startLineComment = buffer.getContextSensitiveProperty(startCaret,"lineComment");			String startCommentStart = buffer.getContextSensitiveProperty(startCaret,"commentStart");			String startCommentEnd = buffer.getContextSensitiveProperty(startCaret,"commentEnd");			String endLineComment = buffer.getContextSensitiveProperty(endCaret,"lineComment");			String endCommentStart = buffer.getContextSensitiveProperty(endCaret,"commentStart");			String endCommentEnd = buffer.getContextSensitiveProperty(endCaret,"commentEnd");				String start;			int caretBack = 1;			if(startLineComment != null)				start = startLineComment + "{{{ ";			else if(startCommentStart != null && startCommentEnd != null)			{				start = startCommentStart + "{{{  " + startCommentEnd;				caretBack = 1 + startCommentStart.length();			}			else				start = "{{{ ";				if (startLineComment != null)			{				// add a new line if there's text after the comment				// we're inserting				if (buffer.getLineLength(lineStart) != caretStart)				{					start += '\n';				}			}			else			{				// always insert a new line if there's no comment character.				start += "\n";			}				String end;			if(endLineComment != null)				end = endLineComment + "}}}";			else if(endCommentStart != null && endCommentEnd != null)				end = endCommentStart + "}}}" + endCommentEnd;			else				end = "}}}";				String line = buffer.getLineText(lineStart);			String whitespace = line.substring(0,				StandardUtilities.getLeadingWhiteSpace(line));				if (endLineComment != null)			{				// if we're inserting a line comment into a non-empty				// line, we'll need to add a line break so we don't				// comment out existing code.				if (buffer.getLineLength(lineEnd) != caretEnd)				{					end += '\n';				}			}			else			{				// always insert a new line if there's no comment character.				end += "\n";			}				if(caretEnd == buffer.getLineStartOffset(lineEnd))				buffer.insert(caretEnd,end);			else			{				CharSequence lineText = buffer.getSegment(caretEnd - 1, 1);				if (Character.isWhitespace(lineText.charAt(0)))					buffer.insert(caretEnd, end);				else					buffer.insert(caretEnd,' ' + end);			}				buffer.insert(caretStart,start + whitespace);				return caretBack;		}	
/**		 * This method will surround each selected line with a range comment.		 * This is used when calling line comment if the edit mode doesn't have		 * a line comment property		 * @since jEdit 4.3pre10		 */		private void rangeLineComment()		{			String commentStart = buffer.getContextSensitiveProperty(caret,"commentStart");			String commentEnd = buffer.getContextSensitiveProperty(caret,"commentEnd");			if(!buffer.isEditable() || commentStart == null || commentEnd == null				|| commentStart.length() == 0 || commentEnd.length() == 0)			{				getToolkit().beep();				return;			}				commentStart += ' ';			commentEnd = ' ' + commentEnd;					try			{				buffer.beginCompoundEdit();				int[] lines = getSelectedLines();				for(int i = 0; i < lines.length; i++)				{					String text = getLineText(lines[i]);					if (text.trim().length() == 0)						continue;					buffer.insert(getLineEndOffset(lines[i]) - 1,						commentEnd);					buffer.insert(getLineStartOffset(lines[i])						+ StandardUtilities.getLeadingWhiteSpace(text),						commentStart);				}			}			finally			{				buffer.endCompoundEdit();			}		}	
/**		 * Join a line with the next line.		 * If you use this method you have to lock the buffer in compound edit mode.		 * @param line the line number that will be joined with the next line		 */		private void joinLineAt(int line)		{			if (line >= buffer.getLineCount() - 1)				return;			int end = getLineEndOffset(line);			CharSequence nextLineText = buffer.getLineSegment(line + 1);			buffer.remove(end - 1,StandardUtilities.getLeadingWhiteSpace(				nextLineText) + 1);			if (nextLineText.length() != 0)				buffer.insert(end - 1, " ");		}	
/**		 * Returns if the right click popup menu is enabled. The Gestures		 * plugin uses this API.		 * @since jEdit 4.2pre13		 */		public boolean isRightClickPopupEnabled()		{			return popupEnabled;		}	
/**		 * Sets if the right click popup menu is enabled. The Gestures		 * plugin uses this API.		 * @since jEdit 4.2pre13		 */		public void setRightClickPopupEnabled(boolean popupEnabled)		{			this.popupEnabled = popupEnabled;		}	
/**		 * Returns the right click popup menu.		 */		public final JPopupMenu getRightClickPopup()		{			return popup;		}	
/**		 * Sets the right click popup menu.		 * @param popup The popup		 */		public final void setRightClickPopup(JPopupMenu popup)		{			this.popup = popup;		}	
/**		 * Do the same thing as right-clicking on the text area. The Gestures		 * plugin uses this API.		 * @since jEdit 4.2pre13		 */		public void handlePopupTrigger(MouseEvent evt)		{			// Rebuild popup menu every time the menu is requested.			createPopupMenu(evt);				int x = evt.getX();			int y = evt.getY();				int dragStart = xyToOffset(x,y,				!(painter.isBlockCaretEnabled()				|| isOverwriteEnabled()));				if(getSelectionCount() == 0 || multi)				moveCaretPosition(dragStart,false);			showPopupMenu(popup,this,x,y,false);		}	
/**		 * Creates the popup menu.		 * @since 4.3pre15		 */		public void createPopupMenu(MouseEvent evt)		{			if (popup == null)				popup = new JPopupMenu();		}	
/**		 * Shows the popup menu below the current caret position.		 * @since 4.3pre10		 */		public void showPopupMenu()		{			if (!popup.isVisible() && hasFocus())			{				Point caretPos = offsetToXY(getCaretPosition());				if (caretPos != null)				{					// Open the context menu below the caret					int charHeight = getPainter().getFontMetrics().getHeight();					showPopupMenu(popup,						painter,caretPos.x,caretPos.y + charHeight,true);				}			}		}	
/**		 * Shows the specified popup menu, ensuring it is displayed within		 * the bounds of the screen.		 * @param popup The popup menu		 * @param comp The component to show it for		 * @param x The x co-ordinate		 * @param y The y co-ordinate		 * @param point If true, then the popup originates from a single point;		 * otherwise it will originate from the component itself. This affects		 * positioning in the case where the popup does not fit onscreen.		 *		 * @since jEdit 4.1pre1		 */		private static void showPopupMenu(JPopupMenu popup, Component comp,			int x, int y, boolean point)		{			int offsetX = 0;			int offsetY = 0;				int extraOffset = point ? 1 : 0;				Component win = comp;			while(!(win instanceof Window || win == null))			{				offsetX += win.getX();				offsetY += win.getY();				win = win.getParent();			}				if(win != null)			{				Dimension size = popup.getPreferredSize();					Rectangle screenSize = GraphicsEnvironment					.getLocalGraphicsEnvironment().getMaximumWindowBounds();					if(x + offsetX + size.width + win.getX() > screenSize.width					&& x + offsetX + win.getX() >= size.width)				{					//System.err.println("x overflow");					if(point)						x -= size.width + extraOffset;					else						x = win.getWidth() - size.width - offsetX + extraOffset;				}				else				{					x += extraOffset;				}					//System.err.println("y=" + y + ",offsetY=" + offsetY				//	+ ",size.height=" + size.height				//	+ ",win.height=" + win.getHeight());				if(y + offsetY + size.height + win.getY() > screenSize.height					&& y + offsetY + win.getY() >= size.height)				{					if(point)						y = win.getHeight() - size.height - offsetY + extraOffset;					else						y = -size.height - 1;				}				else				{					y += extraOffset;				}					popup.show(comp,x,y);			}			else				popup.show(comp,x + extraOffset,y + extraOffset);			}	
public void actionPerformed(ActionEvent evt)			{				if(focusedComponent != null && focusedComponent.hasFocus())					focusedComponent.blinkCaret();			}	
MutableCaretEvent()			{				super(TextArea.this);			}	
@Override			public int getDot()			{				return getCaretPosition();			}	
@Override			public int getMark()			{				return getMarkPosition();			}	
public void adjustmentValueChanged(AdjustmentEvent evt)			{				if(!scrollBarsInitialized)					return;					if(evt.getAdjustable() == vertical)					setFirstLine(vertical.getValue());				else					setHorizontalOffset(-horizontal.getValue());			}	
public void focusGained(FocusEvent evt)			{				if(bufferChanging)					return;					if(match != null)				{					if(caretLine < match.startLine)						invalidateLineRange(caretLine,match.endLine);					else						invalidateLineRange(match.startLine,caretLine);				}				else					invalidateLine(caretLine);					focusedComponent = TextArea.this;			}	
public void focusLost(FocusEvent evt)			{				if(!isShowing())					return;					if(match != null)				{					if(caretLine < match.startLine)						invalidateLineRange(caretLine,match.endLine);					else						invalidateLineRange(match.startLine,caretLine);				}				else					invalidateLine(caretLine);			}	
public void mouseWheelMoved(MouseWheelEvent e)			{				/****************************************************				 * move caret depending on pressed control-keys:				 * - Alt: move cursor, do not select				 * - Alt+(shift or control): move cursor, select				 * - shift: scroll horizontally				 * - control: scroll single line				 * - <else>: scroll 3 lines				 ****************************************************/				if(e.isAltDown())				{					boolean select = e.isShiftDown()						|| e.isControlDown();					if(e.getWheelRotation() < 0)						goToPrevLine(select);					else						goToNextLine(select);				}				else if(e.getScrollType()					== MouseWheelEvent.WHEEL_BLOCK_SCROLL)				{					if(e.isShiftDown())					{						// Wheel orientation is reversed so we negate the charwidth						_setHorizontalOffset(getHorizontalOffset()							+ (e.getWheelRotation() > 0 ? 1 : -1) * painter.getWidth());					}					else					{						if(e.getWheelRotation() > 0)							scrollDownPage();						else							scrollUpPage();					}				}				else if(e.isControlDown() && e.isShiftDown())				{					if(e.getWheelRotation() > 0)						scrollDownPage();					else						scrollUpPage();				}				else if(e.isControlDown())				{					setFirstLine(getFirstLine()						+ e.getWheelRotation());				}				else if(e.getScrollType()					== MouseWheelEvent.WHEEL_UNIT_SCROLL)				{					if(e.isShiftDown())					{						_setHorizontalOffset(getHorizontalOffset()							+ (-charWidth * e.getUnitsToScroll()));					}					else					{						setFirstLine(getFirstLine()							+ e.getUnitsToScroll());					}				}				else				{					if(e.isShiftDown())					{						_setHorizontalOffset(getHorizontalOffset()							+ (-charWidth * e.getWheelRotation()));					}					else					{						setFirstLine(getFirstLine()							+ 3 * e.getWheelRotation());					}				}			}	
public void paintBorder(Component c, Graphics g, int x, int y,			int width, int height)		{			g.translate(x,y);				g.setColor(MetalLookAndFeel.getControlDarkShadow());			g.drawRect(0,0,width-2,height-2);				g.setColor(MetalLookAndFeel.getControlHighlight());			g.drawLine(width-1,1,width-1,height-1);			g.drawLine(1,height-1,width-1,height-1);				g.setColor(MetalLookAndFeel.getControl());			g.drawLine(width-2,2,width-2,2);			g.drawLine(1,height-2,1,height-2);				g.translate(-x,-y);		}	
public Insets getBorderInsets(Component c)		{			return new Insets(1,1,2,2);		}	
public TextAreaDialog(Frame frame, String title, String caption,			Icon icon, String text)		{			super(frame,title,true);				init(caption,icon,text);		}	
public TextAreaDialog(Frame frame, String name, Throwable t)		{			this(frame,jEdit.getProperty(name + ".title"),				jEdit.getProperty(name + ".message"),				UIManager.getIcon("OptionPane.errorIcon"),				MiscUtilities.throwableToString(t));		}	
public TextAreaDialog(Dialog frame, String title, String caption,			Icon icon, String text)		{			super(frame,title,true);				init(caption,icon,text);		}	
public TextAreaDialog(Dialog frame, String name, Throwable t)		{			this(frame,jEdit.getProperty(name + ".title"),				jEdit.getProperty(name + ".message"),				UIManager.getIcon("OptionPane.errorIcon"),				MiscUtilities.throwableToString(t));		}	
private void init(String caption,			Icon icon, String text)		{			JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				Box iconBox = new Box(BoxLayout.Y_AXIS);			iconBox.add(new JLabel(icon));			iconBox.add(Box.createGlue());			content.add(BorderLayout.WEST,iconBox);				JPanel centerPanel = new JPanel(new BorderLayout(6,6));				centerPanel.add(BorderLayout.NORTH,				GUIUtilities.createMultilineLabel(caption));				JTextArea textArea = new JTextArea(10,80);				textArea.setText(text);			textArea.setLineWrap(true);			textArea.setCaretPosition(0);			centerPanel.add(BorderLayout.CENTER,new JScrollPane(textArea));				content.add(BorderLayout.CENTER,centerPanel);				Box buttons = new Box(BoxLayout.X_AXIS);			buttons.add(Box.createGlue());			JButton ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(new ActionHandler());			buttons.add(ok);			buttons.add(Box.createGlue());			content.add(BorderLayout.SOUTH,buttons);				getRootPane().setDefaultButton(ok);				pack();			setLocationRelativeTo(getParent());			setVisible(true);		}	
public void ok()		{			dispose();		}	
public void cancel()		{			dispose();		}	
public void actionPerformed(ActionEvent evt)			{				dispose();			}	
TextAreaDropHandler(TextArea textArea)		{			this.textArea = textArea;		}	
@Override		public void dragEnter(DropTargetDragEvent dtde)		{			Log.log(Log.DEBUG,this,"Drag enter");			savedBuffer = textArea.getBuffer();			textArea.setDragInProgress(true);			//textArea.getBuffer().beginCompoundEdit();			savedCaret = textArea.getCaretPosition();		}	
@Override		public void dragOver(DropTargetDragEvent dtde)		{			Point p = dtde.getLocation();			p = SwingUtilities.convertPoint(textArea,p,				textArea.getPainter());			int pos = textArea.xyToOffset(p.x,p.y,				!(textArea.getPainter().isBlockCaretEnabled()				|| textArea.isOverwriteEnabled()));			if(pos != -1)			{				textArea.moveCaretPosition(pos,					TextArea.ELECTRIC_SCROLL);			}		}	
@Override		public void dragExit(DropTargetEvent dtde)		{			Log.log(Log.DEBUG,this,"Drag exit");			textArea.setDragInProgress(false);			//textArea.getBuffer().endCompoundEdit();			if(textArea.getBuffer() == savedBuffer)			{				textArea.moveCaretPosition(savedCaret,					TextArea.ELECTRIC_SCROLL);			}			savedBuffer = null;		}	
public void drop(DropTargetDropEvent dtde)		{			Log.log(Log.DEBUG,this,"Drop");			textArea.setDragInProgress(false);			//textArea.getBuffer().endCompoundEdit();			savedBuffer = null;		}	
public TextAreaException(String msg)		{			super(msg);		}	
/**		 * Paints a range of screen lines. The default implementation calls		 * {@link #paintValidLine(Graphics2D,int,int,int,int,int)} and		 * {@link #paintInvalidLine(Graphics2D,int,int)}.		 * @param gfx A graphics context		 * @param firstLine The first screen line		 * @param lastLine The last screen line		 * @param physicalLines The list of physical line numbers. Entries are		 * -1 if the screen line is out of range.		 * @param start An array of screen line start offsets.		 * @param end An array of screen line end offsets		 * @param y The y co-ordinate		 * @param lineHeight The line height		 * @since jEdit 4.2pre2		 */		public void paintScreenLineRange(Graphics2D gfx, int firstLine,			int lastLine, int[] physicalLines, int[] start, int[] end,			int y, int lineHeight)		{			for(int i = 0; i < physicalLines.length; i++)			{				int screenLine = i + firstLine;				if(physicalLines[i] == -1)					paintInvalidLine(gfx,screenLine,y);				else				{					paintValidLine(gfx,screenLine,physicalLines[i],						start[i],end[i],y);				}					y += lineHeight;			}		}	
/**		 * Called by the text area when the extension is to paint a		 * screen line which has an associated physical line number in		 * the buffer. Note that since one physical line may consist of		 * several screen lines due to soft wrap, the start and end		 * offsets of the screen line are passed in as well.		 *		 * @param gfx The graphics context		 * @param screenLine The screen line number		 * @param physicalLine The physical line number		 * @param start The offset where the screen line begins, from		 * the start of the buffer		 * @param end The offset where the screen line ends, from the		 * start of the buffer		 * @param y The y co-ordinate of the top of the line's		 * bounding box		 * @since jEdit 4.0pre4		 */		public void paintValidLine(Graphics2D gfx, int screenLine,			int physicalLine, int start, int end, int y) {}	
/**		 * Called by the text area when the extension is to paint a		 * screen line which is not part of the buffer. This can happen		 * if the buffer is shorter than the height of the text area,		 * for example.		 *		 * @param gfx The graphics context		 * @param screenLine The screen line number		 * @param y The y co-ordinate of the top of the line's		 * bounding box		 * @since jEdit 4.0pre4		 */		public void paintInvalidLine(Graphics2D gfx, int screenLine,			int y) {}	
/**		 * Called by the text area when the mouse hovers over the		 * location specified in the mouse event.		 *		 * @param x The x co-ordinate		 * @param y The y co-ordinate		 * @since jEdit 4.0pre4		 */		public String getToolTipText(int x, int y)		{			return null;		}	
protected TextAreaInputHandler(TextArea textArea)		{			this.textArea = textArea;			bindings = currentBindings = new Hashtable();		}	
/**		 * Forwards key events directly to the input handler.		 * This is slightly faster than using a KeyListener		 * because some Swing overhead is avoided.		 * @param evt the keyboard event		 * @param from the source of the event. Since this is the input handler of the textarea, it should always be 1		 * @param global it is only true if the event comes from the DefaultKeyboardFocusManager		 * @since 4.3pre7		 */		@Override		public void processKeyEvent(KeyEvent evt, int from, boolean global)		{			if(Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,this,"Key event                 : "					+ toString(evt) + " from " + from);			//	Log.log(Log.DEBUG,this,view+".isFocused()="+view.isFocused()+'.',new Exception());			}				evt = _preprocessKeyEvent(evt);			if(evt == null)				return;				if(Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,this,"Key event after workaround: "					+ toString(evt) + " from " + from);			}				boolean focusOnTextArea = false;			switch(evt.getID())			{			case KeyEvent.KEY_TYPED:				// if the user pressed eg C+e n n in the				// search bar we want focus to go back there				// after the prefix is done						if(keyEventInterceptor != null)					keyEventInterceptor.keyTyped(evt);				else if(isPrefixActive() || textArea.hasFocus())				{					processKeyEventKeyStrokeHandling(evt,from,"type ",global);				}						processKeyEventSub(focusOnTextArea);					break;			case KeyEvent.KEY_PRESSED:				if(keyEventInterceptor != null)					keyEventInterceptor.keyPressed(evt);				else if(KeyEventWorkaround.isBindable(evt.getKeyCode()))				{					processKeyEventKeyStrokeHandling(evt,from,"press",global);						processKeyEventSub(focusOnTextArea);					}				break;			case KeyEvent.KEY_RELEASED:				if(keyEventInterceptor != null)					keyEventInterceptor.keyReleased(evt);				break;			}		}	
/**		 * This method returns if the keyboard event can be handled or not.		 *		 * @param evt the keyboard event		 * @return null if the keyboard event cannot be handled, or the keyboard event itself		 * otherwise		 */		private KeyEvent _preprocessKeyEvent(KeyEvent evt)		{			if(evt.isConsumed())				return null;				if(Debug.DUMP_KEY_EVENTS)			{				Log.log(Log.DEBUG,this,"Key event (preprocessing) : "						+ toString(evt));			}				return KeyEventWorkaround.processKeyEvent(evt);		}	
private void processKeyEventSub(boolean focusOnTextArea)		{			// this is a weird hack.			// we don't want C+e a to insert 'a' in the			// search bar if the search bar has focus...			if (isPrefixActive() && focusOnTextArea)			{				textArea.requestFocus();			}		}	
/**		 * Invokes the specified action, repeating and recording it as		 * necessary.		 * @param action The action		 * @since jEdit 4.2pre1		 */		@Override		public void invokeAction(String action)		{			invokeAction(getAction(action));		}	
/**		 * Invokes the specified action, repeating and recording it as		 * necessary.		 * @param action The action		 */		@Override		public void invokeAction(JEditBeanShellAction action)		{			JEditBuffer buffer = textArea.getBuffer();				/* if(buffer.insideCompoundEdit())				buffer.endCompoundEdit(); */				// remember the last executed action			if(!action.noRememberLast())			{				if(lastAction == action)					lastActionCount++;				else				{					lastAction = action;					lastActionCount = 1;				}			}				// remember old values, in case action changes them			int _repeatCount = repeatCount;				// execute the action			if(action.noRepeat() || _repeatCount == 1)				action.invoke(textArea);			else			{				try				{					buffer.beginCompoundEdit();						for(int i = 0; i < _repeatCount; i++)						action.invoke(textArea);				}				finally				{					buffer.endCompoundEdit();				}			}				// If repeat was true originally, clear it			// Otherwise it might have been set by the action, etc			if(_repeatCount != 1)			{				// first of all, if this action set a				// readNextChar, do not clear the repeat				if(readNextChar != null)					return;					repeatCount = 1;			}		}	
/**		 * Handles the given keystroke.		 * @param keyStroke The key stroke		 * @param dryRun only calculate the return value, do not have any other effect		 * @since jEdit 4.2pre5		 */		@Override		public boolean handleKey(KeyEventTranslator.Key keyStroke,boolean dryRun)		{			char input = '\0';			if(keyStroke.modifiers == null				|| keyStroke.modifiers.equals("S"))			{				switch(keyStroke.key)				{				case '\n':				case '\t':					input = (char)keyStroke.key;					break;				default:					input = keyStroke.input;					break;				}			}				if(readNextChar != null)			{				if(input != '\0')				{					if (!dryRun)					{						setCurrentBindings(bindings);						invokeReadNextChar(input);						repeatCount = 1;					}					return true;				}				else				{					if (!dryRun)					{						readNextChar = null;					}				}			}				Object o = currentBindings.get(keyStroke);			if(o == null)			{				if (!dryRun)				{					// Don't beep if the user presses some					// key we don't know about unless a					// prefix is active. Otherwise it will					// beep when caps lock is pressed, etc.					if(currentBindings != bindings)					{						Toolkit.getDefaultToolkit().beep();						// F10 should be passed on, but C+e F10						// shouldn't						repeatCount = 1;						setCurrentBindings(bindings);					}					else if(input != '\0')					{						if (!keyStroke.isFromGlobalContext())						{ // let user input be only local							userInput(input);						}					}					else					{						// this is retarded. excuse me while I drool						// and make stupid noises						if(KeyEventWorkaround.isNumericKeypad(keyStroke.key))							KeyEventWorkaround.numericKeypadKey();					}					sendShortcutPrefixOff();				}			}			else if(o instanceof Hashtable)			{				if (!dryRun)				{					setCurrentBindings((Hashtable)o);					ShortcutPrefixActiveEvent.firePrefixStateChange(currentBindings, true);					shortcutOn = true;				}				return true;			}			else if(o instanceof String)			{				if (!dryRun)				{					setCurrentBindings(bindings);					sendShortcutPrefixOff();					invokeAction((String)o);				}				return true;			}			else if(o instanceof JEditBeanShellAction)			{				if (!dryRun)				{					setCurrentBindings(bindings);					sendShortcutPrefixOff();					invokeAction((JEditBeanShellAction)o);				}				return true;			}			if (!dryRun)			{				sendShortcutPrefixOff();			}			return false;		}	
protected void userInput(char ch)		{			lastActionCount = 0;					if(repeatCount == 1)				textArea.userInput(ch);				repeatCount = 1;		}	
protected void invokeReadNextChar(char ch)		{			String charStr = StandardUtilities.charsToEscapes(String.valueOf(ch));				// this might be a bit slow if __char__ occurs a lot			int index;			while((index = readNextChar.indexOf("__char__")) != -1)			{				readNextChar = readNextChar.substring(0,index)					+ '\'' + charStr + '\''					+ readNextChar.substring(index + 8);			}			readNextChar = null;		}	
TextAreaMouseHandler(TextArea textArea)		{			this.textArea = textArea;		}	
@Override		public void mousePressed(MouseEvent evt)		{			showCursor();				control = (OperatingSystem.isMacOS() && evt.isMetaDown())				|| (!OperatingSystem.isMacOS() && evt.isControlDown());				ctrlForRectangularSelection = true;				// so that Home <mouse click> Home is not the same			// as pressing Home twice in a row			textArea.getInputHandler().resetLastActionCount();				quickCopyDrag = (textArea.isQuickCopyEnabled() &&				isMiddleButton(evt.getModifiers()));				if(!quickCopyDrag)			{				textArea.requestFocus();				TextArea.focusedComponent = textArea;			}				if(textArea.getBuffer().isLoading())				return;				int x = evt.getX();			int y = evt.getY();				dragStart = textArea.xyToOffset(x,y,				!(textArea.getPainter().isBlockCaretEnabled()				|| textArea.isOverwriteEnabled()));			dragStartLine = textArea.getLineOfOffset(dragStart);			dragStartOffset = dragStart - textArea.getLineStartOffset(				dragStartLine);				if(isPopupTrigger(evt) && textArea.isRightClickPopupEnabled())			{					textArea.handlePopupTrigger(evt);					return;			}				dragged = false;				textArea.blink = true;			textArea.invalidateLine(textArea.getCaretLine());				clickCount = evt.getClickCount();				if(textArea.isDragEnabled()				&& textArea.selectionManager.insideSelection(x,y)				&& clickCount == 1 && !evt.isShiftDown())			{				maybeDragAndDrop = true;				textArea.moveCaretPosition(dragStart,false);				return;			}			maybeDragAndDrop = false;				if(quickCopyDrag)			{				// ignore double clicks of middle button				doSingleClick(evt);			}			else			{				switch(clickCount)				{				case 1:					doSingleClick(evt);					break;				case 2:					doDoubleClick();					break;				default: //case 3:					doTripleClick();					break;				}			}		}	
protected void doSingleClick(MouseEvent evt)		{			int x = evt.getX();				int extraEndVirt = 0;			if(textArea.chunkCache.getLineInfo(				textArea.getLastScreenLine()).lastSubregion)			{				int dragStart = textArea.xyToOffset(x,evt.getY(),					!textArea.getPainter().isBlockCaretEnabled()					&& !textArea.isOverwriteEnabled());				int screenLine = textArea.getScreenLineOfOffset(dragStart);				ChunkCache.LineInfo lineInfo = textArea.chunkCache.getLineInfo(screenLine);				int offset = textArea.getScreenLineEndOffset(screenLine);				if ((1 != offset - dragStart) || (lineInfo.lastSubregion))				{					offset--;				}				float dragStartLineWidth = textArea.offsetToXY(offset).x;				if(x > dragStartLineWidth)				{					extraEndVirt = (int)(						(x - dragStartLineWidth)						/ textArea.charWidth);					if(!textArea.getPainter().isBlockCaretEnabled()						&& !textArea.isOverwriteEnabled()						&& (x - textArea.getHorizontalOffset())						% textArea.charWidth > textArea.charWidth / 2)					{						extraEndVirt++;					}				}			}				if(((control && ctrlForRectangularSelection) ||			    textArea.isRectangularSelectionEnabled())				&& textArea.isEditable())			{				int screenLine = (evt.getY() / textArea.getPainter()					.getFontMetrics().getHeight());				if(screenLine > textArea.getLastScreenLine())					screenLine = textArea.getLastScreenLine();				ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(screenLine);				if(info.lastSubregion && extraEndVirt != 0)				{					// control-click in virtual space inserts					// whitespace and moves caret					String whitespace = StandardUtilities						.createWhiteSpace(extraEndVirt,0);					textArea.getBuffer().insert(dragStart,whitespace);						dragStart += whitespace.length();				}			}				if(evt.isShiftDown())			{				// XXX: getMarkPosition() deprecated!				textArea.resizeSelection(					textArea.getMarkPosition(),dragStart,extraEndVirt,					textArea.isRectangularSelectionEnabled()					|| (control && ctrlForRectangularSelection));					if(!quickCopyDrag)					textArea.moveCaretPosition(dragStart,false);					// so that shift-click-drag works				dragStartLine = textArea.getMarkLine();				dragStart = textArea.getMarkPosition();				dragStartOffset = dragStart					- textArea.getLineStartOffset(dragStartLine);					// so that quick copy works				dragged = true;					return;			}				if(!quickCopyDrag)				textArea.moveCaretPosition(dragStart,false);				if(!(textArea.isMultipleSelectionEnabled()				|| quickCopyDrag))				textArea.selectNone();		}	
protected void doDoubleClick()		{			// Ignore empty lines			if(textArea.getLineLength(dragStartLine) == 0)				return;				String lineText = textArea.getLineText(dragStartLine);			String noWordSep = textArea.getBuffer()				.getStringProperty("noWordSep");			if(dragStartOffset == textArea.getLineLength(dragStartLine))				dragStartOffset--;				boolean joinNonWordChars = textArea.getJoinNonWordChars();			int wordStart = TextUtilities.findWordStart(lineText,dragStartOffset,				noWordSep,joinNonWordChars,false,false);			int wordEnd = TextUtilities.findWordEnd(lineText,				dragStartOffset+1,noWordSep,				joinNonWordChars,false,false);				int lineStart = textArea.getLineStartOffset(dragStartLine);			Selection sel = new Selection.Range(				lineStart + wordStart,				lineStart + wordEnd);			if(textArea.isMultipleSelectionEnabled())				textArea.addToSelection(sel);			else				textArea.setSelection(sel);				if(quickCopyDrag)				quickCopyDrag = false;				textArea.moveCaretPosition(lineStart + wordEnd,false);				dragged = true;		}	
protected void doTripleClick()		{			int newCaret = textArea.getLineEndOffset(dragStartLine);			if(dragStartLine == textArea.getLineCount() - 1)				newCaret--;				Selection sel = new Selection.Range(				textArea.getLineStartOffset(dragStartLine),				newCaret);			if(textArea.isMultipleSelectionEnabled())				textArea.addToSelection(sel);			else				textArea.setSelection(sel);				if(quickCopyDrag)				quickCopyDrag = false;				textArea.moveCaretPosition(newCaret,false);				dragged = true;		}	
@Override		public void mouseMoved(MouseEvent evt)		{			showCursor();		}	
@Override		public void mouseDragged(MouseEvent evt)		{			if (isPopupTrigger(evt))				return;				if(maybeDragAndDrop)			{				textArea.startDragAndDrop(evt,control);				return;			}				if(textArea.isDragInProgress())				return;				if(textArea.getBuffer().isLoading())				return;				TextAreaPainter painter = textArea.getPainter();			if(evt.getY() < 0)			{				int delta = Math.min(-1,evt.getY()					/ painter.getFontMetrics()					.getHeight());				textArea.setFirstLine(textArea.getFirstLine() + delta);			}			else if(evt.getY() >= painter.getHeight())			{				int delta = Math.max(1,(evt.getY()					- painter.getHeight()) /					painter.getFontMetrics()					.getHeight());				if(textArea.lastLinePartial)					delta--;				textArea.setFirstLine(textArea.getFirstLine() + delta);			}				switch(clickCount)			{			case 1:				doSingleDrag(evt);				break;			case 2:				doDoubleDrag(evt);				break;			default: //case 3:				doTripleDrag(evt);				break;			}		}	
private void doSingleDrag(MouseEvent evt)		{			dragged = true;				TextAreaPainter painter = textArea.getPainter();				int x = evt.getX();			int y = evt.getY();			if(y < 0)				y = 0;			else if(y >= painter.getHeight())				y = painter.getHeight() - 1;				int dot = textArea.xyToOffset(x,y,				(!painter.isBlockCaretEnabled()				&& !textArea.isOverwriteEnabled())				|| quickCopyDrag);			int dotLine = textArea.getLineOfOffset(dot);			int extraEndVirt = 0;				if(textArea.chunkCache.getLineInfo(				textArea.getLastScreenLine())				.lastSubregion)			{				int screenLine = textArea.getScreenLineOfOffset(dot);				ChunkCache.LineInfo lineInfo = textArea.chunkCache.getLineInfo(screenLine);				int offset = textArea.getScreenLineEndOffset(screenLine);				if ((1 != offset - dot) || (lineInfo.lastSubregion))				{					offset--;				}				float dotLineWidth = textArea.offsetToXY(offset).x;				if(x > dotLineWidth)				{					extraEndVirt = (int)((x - dotLineWidth) / textArea.charWidth);					if(!painter.isBlockCaretEnabled()						&& !textArea.isOverwriteEnabled()						&& (x - textArea.getHorizontalOffset()) % textArea.charWidth > textArea.charWidth / 2)						extraEndVirt++;				}			}				textArea.resizeSelection(dragStart,dot,extraEndVirt,				textArea.isRectangularSelectionEnabled()				|| (control && ctrlForRectangularSelection));				if(quickCopyDrag)			{				// just scroll to the dragged location				textArea.scrollTo(dotLine,dot - textArea.getLineStartOffset(dotLine),false);			}			else			{				if(dot != textArea.getCaretPosition())					textArea.moveCaretPosition(dot,false);				if(textArea.isRectangularSelectionEnabled()					&& extraEndVirt != 0)				{					textArea.scrollTo(dotLine,dot - textArea.getLineStartOffset(dotLine)						+ extraEndVirt,false);				}			}		}	
private void doDoubleDrag(MouseEvent evt)		{			int markLineStart = textArea.getLineStartOffset(dragStartLine);			int markLineLength = textArea.getLineLength(dragStartLine);			int mark = dragStartOffset;				TextAreaPainter painter = textArea.getPainter();				int pos = textArea.xyToOffset(evt.getX(),				Math.max(0,Math.min(painter.getHeight(),evt.getY())),				!(painter.isBlockCaretEnabled()				|| textArea.isOverwriteEnabled()));			int line = textArea.getLineOfOffset(pos);			int lineStart = textArea.getLineStartOffset(line);			int lineLength = textArea.getLineLength(line);			int offset = pos - lineStart;				String lineText = textArea.getLineText(line);			String markLineText = textArea.getLineText(dragStartLine);			String noWordSep = textArea.getBuffer()				.getStringProperty("noWordSep");			boolean joinNonWordChars = textArea.getJoinNonWordChars();				if(markLineStart + dragStartOffset > lineStart + offset)			{				if(offset != 0 && offset != lineLength)				{					offset = TextUtilities.findWordStart(						lineText,offset,noWordSep,						joinNonWordChars);				}					if(markLineLength != 0)				{					mark = TextUtilities.findWordEnd(						markLineText,mark,noWordSep,						joinNonWordChars);				}			}			else			{				if(offset != 0 && lineLength != 0)				{					offset = TextUtilities.findWordEnd(						lineText,offset,noWordSep,						joinNonWordChars);				}					if(mark != 0 && mark != markLineLength)				{					mark = TextUtilities.findWordStart(						markLineText,mark,noWordSep,						joinNonWordChars);				}			}				if(lineStart + offset == textArea.getCaretPosition())				return;				textArea.resizeSelection(markLineStart + mark,				lineStart + offset,0,false);			textArea.moveCaretPosition(lineStart + offset,false);				dragged = true;		}	
private void doTripleDrag(MouseEvent evt)		{			TextAreaPainter painter = textArea.getPainter();				int offset = textArea.xyToOffset(evt.getX(),				Math.max(0,Math.min(painter.getHeight(),evt.getY())),				false);			int mouseLine = textArea.getLineOfOffset(offset);			int mark;			int mouse;			if(dragStartLine > mouseLine)			{				mark = textArea.getLineEndOffset(dragStartLine) - 1;				if(offset == textArea.getLineEndOffset(mouseLine) - 1)					mouse = offset;				else					mouse = textArea.getLineStartOffset(mouseLine);			}			else			{				mark = textArea.getLineStartOffset(dragStartLine);				if(offset == textArea.getLineStartOffset(mouseLine))					mouse = offset;				else if(offset == textArea.getLineEndOffset(mouseLine) - 1					&& mouseLine != textArea.getLineCount() - 1)					mouse = textArea.getLineEndOffset(mouseLine);				else					mouse = textArea.getLineEndOffset(mouseLine) - 1;			}				mouse = Math.min(textArea.getBuffer().getLength(),mouse);				if(mouse == textArea.getCaretPosition())				return;				textArea.resizeSelection(mark,mouse,0,false);			textArea.moveCaretPosition(mouse,false);				dragged = true;		}	
@Override		public void mouseReleased(MouseEvent evt)		{			if(!dragged && textArea.isQuickCopyEnabled() &&				isMiddleButton(evt.getModifiers()))			{				textArea.requestFocus();				TextArea.focusedComponent = textArea;					textArea.setCaretPosition(dragStart,false);			}			else if(maybeDragAndDrop				&& !textArea.isMultipleSelectionEnabled())			{				textArea.selectNone();			}				dragged = false;		}	
/**		 * Returns if the specified event is the popup trigger event.		 * This implements precisely defined behavior, as opposed to		 * MouseEvent.isPopupTrigger().		 * @param evt The event		 * @since jEdit 4.3pre7		 */		public static boolean isPopupTrigger(MouseEvent evt)		{			return isRightButton(evt.getModifiers());		}	
/**		 * @param modifiers The modifiers flag from a mouse event		 * @return true if the modifier match the middle button		 * @since jEdit 4.3pre7		 */		public static boolean isMiddleButton(int modifiers)		{			if (OperatingSystem.isMacOS())			{				if((modifiers & InputEvent.BUTTON1_MASK) != 0)					return (modifiers & InputEvent.ALT_MASK) != 0;				else					return (modifiers & InputEvent.BUTTON2_MASK) != 0;			}			else				return (modifiers & InputEvent.BUTTON2_MASK) != 0;		}	
/**		 * @param modifiers The modifiers flag from a mouse event		 * @return true if the modifier match the right button		 * @since jEdit 4.3pre7		 */		public static boolean isRightButton(int modifiers)		{			if (OperatingSystem.isMacOS())			{				if((modifiers & InputEvent.BUTTON1_MASK) != 0)					return (modifiers & InputEvent.CTRL_MASK) != 0;				else					return (modifiers & InputEvent.BUTTON3_MASK) != 0;			}			else				return (modifiers & InputEvent.BUTTON3_MASK) != 0;		}	
protected void showCursor()		{			textArea.getPainter().setCursor(				Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));		}	
public TextAreaOptionPane()		{			super("textarea");		}	
public void _init()		{			/* Font */			font = new FontSelector(jEdit.getFontProperty("view.font"));				addComponent(jEdit.getProperty("options.textarea.font"),font);				/* Text color */			addComponent(jEdit.getProperty("options.textarea.foreground"),				foregroundColor = new ColorWellButton(				jEdit.getColorProperty("view.fgColor")),				GridBagConstraints.VERTICAL);				/* Background color */			addComponent(jEdit.getProperty("options.textarea.background"),				backgroundColor = new ColorWellButton(				jEdit.getColorProperty("view.bgColor")),				GridBagConstraints.VERTICAL);				/* Caret color, caret blink, block caret */			blinkCaret = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".blinkCaret"));			blinkCaret.setSelected(jEdit.getBooleanProperty("view.caretBlink"));				blockCaret = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".blockCaret"));			blockCaret.setSelected(jEdit.getBooleanProperty("view.blockCaret"));				thickCaret = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".thickCaret"));			thickCaret.setSelected(jEdit.getBooleanProperty("view.thickCaret"));				Box caretSettings = new Box(BoxLayout.X_AXIS);			caretSettings.add(new JLabel(jEdit.getProperty(				"options.textarea.caret")));			caretSettings.add(Box.createHorizontalStrut(6));			caretSettings.add(blinkCaret);			caretSettings.add(blockCaret);			caretSettings.add(thickCaret);				addComponent(caretSettings,caretColor = new ColorWellButton(				jEdit.getColorProperty("view.caretColor")),				GridBagConstraints.VERTICAL);				/* Selection color */			addComponent(jEdit.getProperty("options.textarea.selection"),				selectionColor = new ColorWellButton(				jEdit.getColorProperty("view.selectionColor")),				GridBagConstraints.VERTICAL);				/* Multiple selection color */			addComponent(jEdit.getProperty("options.textarea.multipleSelection"),				multipleSelectionColor = new ColorWellButton(				jEdit.getColorProperty("view.multipleSelectionColor")),				GridBagConstraints.VERTICAL);				/* Line highlight */			lineHighlight = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".lineHighlight"));			lineHighlight.setSelected(jEdit.getBooleanProperty("view.lineHighlight"));			addComponent(lineHighlight,lineHighlightColor = new ColorWellButton(				jEdit.getColorProperty("view.lineHighlightColor")),				GridBagConstraints.VERTICAL);				/* Structure highlight */			structureHighlight = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".structureHighlight"));			structureHighlight.setSelected(jEdit.getBooleanProperty(				"view.structureHighlight"));			addComponent(structureHighlight,structureHighlightColor = new ColorWellButton(				jEdit.getColorProperty("view.structureHighlightColor")),				GridBagConstraints.VERTICAL);				/* EOL markers */			eolMarkers = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".eolMarkers"));			eolMarkers.setSelected(jEdit.getBooleanProperty("view.eolMarkers"));			addComponent(eolMarkers,eolMarkerColor =new ColorWellButton(				jEdit.getColorProperty("view.eolMarkerColor")),				GridBagConstraints.VERTICAL);				/* Wrap guide */			wrapGuide = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".wrapGuide"));			wrapGuide.setSelected(jEdit.getBooleanProperty("view.wrapGuide"));			addComponent(wrapGuide,wrapGuideColor = new ColorWellButton(				jEdit.getColorProperty("view.wrapGuideColor")),				GridBagConstraints.VERTICAL);				/* Electric borders */			electricBorders = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".electricBorders"));			electricBorders.setSelected(!"0".equals(jEdit.getProperty(				"view.electricBorders")));			addComponent(electricBorders);				/* Anti-aliasing */				antiAlias = new JComboBox(AntiAlias.comboChoices);			antiAlias.setToolTipText(jEdit.getProperty("options.textarea.antiAlias.tooltip"));			AntiAlias antiAliasValue = new AntiAlias(jEdit.getProperty("view.antiAlias"));			font.setAntiAliasEnabled(antiAliasValue.val()>0);			antiAlias.addActionListener(new ActionListener()				{					public void actionPerformed(ActionEvent evt)					{						int idx = antiAlias.getSelectedIndex();						font.setAntiAliasEnabled(idx > 0);						font.repaint();					}				});			antiAlias.setSelectedIndex(antiAliasValue.val());			addComponent(jEdit.getProperty("options.textarea"+ ".antiAlias"), antiAlias);				/* Fractional font metrics */			fracFontMetrics = new JCheckBox(jEdit.getProperty("options.textarea"				+ ".fracFontMetrics"));			fracFontMetrics.setSelected(jEdit.getBooleanProperty("view.fracFontMetrics"));			addComponent(fracFontMetrics);				/* Strip trailing EOL */			stripTrailingEOL = new JCheckBox(jEdit.getProperty(				"options.textArea.stripTrailingEOL"));			stripTrailingEOL.setSelected(jEdit.getBooleanProperty("stripTrailingEOL"));			addComponent(stripTrailingEOL);				completeFromAllBuffers = new JCheckBox(jEdit.getProperty(				"options.textArea.completeFromAllBuffers"));			completeFromAllBuffers.setSelected(jEdit.getBooleanProperty("completeFromAllBuffers"));			addComponent(completeFromAllBuffers);			}	
public void _save()		{			jEdit.setFontProperty("view.font",font.getFont());				jEdit.setColorProperty("view.fgColor",foregroundColor				.getSelectedColor());			jEdit.setColorProperty("view.bgColor",backgroundColor				.getSelectedColor());			jEdit.setBooleanProperty("view.caretBlink",blinkCaret.isSelected());			jEdit.setBooleanProperty("view.blockCaret",blockCaret.isSelected());			jEdit.setBooleanProperty("view.thickCaret",thickCaret.isSelected());			jEdit.setColorProperty("view.caretColor",caretColor				.getSelectedColor());			jEdit.setColorProperty("view.selectionColor",selectionColor				.getSelectedColor());			jEdit.setColorProperty("view.multipleSelectionColor",multipleSelectionColor				.getSelectedColor());			jEdit.setBooleanProperty("view.lineHighlight",lineHighlight				.isSelected());			jEdit.setColorProperty("view.lineHighlightColor",				lineHighlightColor.getSelectedColor());			jEdit.setBooleanProperty("view.structureHighlight",structureHighlight				.isSelected());			jEdit.setColorProperty("view.structureHighlightColor",				structureHighlightColor.getSelectedColor());			jEdit.setBooleanProperty("view.eolMarkers",eolMarkers				.isSelected());			jEdit.setColorProperty("view.eolMarkerColor",				eolMarkerColor.getSelectedColor());			jEdit.setBooleanProperty("view.wrapGuide",wrapGuide				.isSelected());			jEdit.setColorProperty("view.wrapGuideColor",				wrapGuideColor.getSelectedColor());			jEdit.setIntegerProperty("view.electricBorders",electricBorders				.isSelected() ? 3 : 0);			AntiAlias nv = new AntiAlias(jEdit.getProperty("view.antiAlias"));			nv.set(antiAlias.getSelectedIndex());			jEdit.setProperty("view.antiAlias", nv.toString());			jEdit.setBooleanProperty("view.fracFontMetrics",fracFontMetrics.isSelected());			jEdit.setBooleanProperty("stripTrailingEOL", stripTrailingEOL.isSelected());			jEdit.setBooleanProperty("completeFromAllBuffers", completeFromAllBuffers.isSelected());		}	
/**		 * It is a bad idea to override this, but we need to get the component		 * event before the first repaint.		 */		@Override		public void setBounds(int x, int y, int width, int height)		{			if(x == getX() && y == getY() && width == getWidth()				&& height == getHeight())			{				return;			}				super.setBounds(x,y,width,height);				textArea.recalculateVisibleLines();			if(!textArea.getBuffer().isLoading())				textArea.recalculateLastPhysicalLine();			textArea.propertiesChanged();			textArea.updateMaxHorizontalScrollWidth();			textArea.scrollBarsInitialized = true;		}	
/**		 * Makes the tab key work in Java 1.4.		 * @since jEdit 3.2pre4		 */		@Override		public boolean getFocusTraversalKeysEnabled()		{			return false;		}	
/**		 * Returns the syntax styles used to paint colorized text. Entry <i>n</i>		 * will be used to paint tokens with id = <i>n</i>.		 * @return an array of SyntaxStyles		 * @see org.gjt.sp.jedit.syntax.Token		 */		public final SyntaxStyle[] getStyles()		{			return styles;		}	
/**		 * Sets the syntax styles used to paint colorized text. Entry <i>n</i>		 * will be used to paint tokens with id = <i>n</i>.		 * @param styles The syntax styles		 * @see org.gjt.sp.jedit.syntax.Token		 */		public final void setStyles(SyntaxStyle[] styles)		{			// assumed this is called after a font render context is set up.			// changing font render context settings without a setStyles()			// call will not reset cached monospaced font info.			fonts.clear();				this.styles = styles;			styles[Token.NULL] = new SyntaxStyle(getForeground(),null,getFont());			repaint();		}	
/**		 * Returns the caret color.		 */		public final Color getCaretColor()		{			return caretColor;		}	
/**		 * Sets the caret color.		 * @param caretColor The caret color		 */		public final void setCaretColor(Color caretColor)		{			this.caretColor = caretColor;			if(textArea.getBuffer() != null)				textArea.invalidateLine(textArea.getCaretLine());		}	
/**		 * Returns the selection color.		 */		public final Color getSelectionColor()		{			return selectionColor;		}	
/**		 * Sets the selection color.		 * @param selectionColor The selection color		 */		public final void setSelectionColor(Color selectionColor)		{			this.selectionColor = selectionColor;			textArea.repaint();		}	
/**		 * Returns the multiple selection color.		 * @since jEdit 4.2pre1		 */		public final Color getMultipleSelectionColor()		{			return multipleSelectionColor;		}	
/**		 * Sets the multiple selection color.		 * @param multipleSelectionColor The multiple selection color		 * @since jEdit 4.2pre1		 */		public final void setMultipleSelectionColor(Color multipleSelectionColor)		{			this.multipleSelectionColor = multipleSelectionColor;			textArea.repaint();		}	
/**		 * Returns the line highlight color.		 */		public final Color getLineHighlightColor()		{			return lineHighlightColor;		}	
/**		 * Sets the line highlight color.		 * @param lineHighlightColor The line highlight color		 */		public final void setLineHighlightColor(Color lineHighlightColor)		{			this.lineHighlightColor = lineHighlightColor;			if(textArea.getBuffer() != null)				textArea.invalidateLine(textArea.getCaretLine());		}	
/**		 * Returns true if line highlight is enabled, false otherwise.		 */		public final boolean isLineHighlightEnabled()		{			return lineHighlight;		}	
/**		 * Enables or disables current line highlighting.		 * @param lineHighlight True if current line highlight should be enabled,		 * false otherwise		 */		public final void setLineHighlightEnabled(boolean lineHighlight)		{			this.lineHighlight = lineHighlight;			textArea.repaint();		}	
/**		 * Returns the structure highlight color.		 * @since jEdit 4.2pre3		 */		public final Color getStructureHighlightColor()		{			return structureHighlightColor;		}	
/**		 * Sets the structure highlight color.		 * @param structureHighlightColor The bracket highlight color		 * @since jEdit 4.2pre3		 */		public final void setStructureHighlightColor(			Color structureHighlightColor)		{			this.structureHighlightColor = structureHighlightColor;			textArea.invalidateStructureMatch();		}	
/**		 * Returns true if structure highlighting is enabled, false otherwise.		 * @since jEdit 4.2pre3		 */		public final boolean isStructureHighlightEnabled()		{			return structureHighlight;		}	
/**		 * Enables or disables structure highlighting.		 * @param structureHighlight True if structure highlighting should be		 * enabled, false otherwise		 * @since jEdit 4.2pre3		 */		public final void setStructureHighlightEnabled(boolean structureHighlight)		{			this.structureHighlight = structureHighlight;			textArea.invalidateStructureMatch();		}	
/**		 * Returns true if the caret should be drawn as a block, false otherwise.		 */		public final boolean isBlockCaretEnabled()		{			return blockCaret;		}	
/**		 * Sets if the caret should be drawn as a block, false otherwise.		 * @param blockCaret True if the caret should be drawn as a block,		 * false otherwise.		 */		public final void setBlockCaretEnabled(boolean blockCaret)		{			this.blockCaret = blockCaret;			extensionMgr.removeExtension(caretExtension);			if(blockCaret)				addExtension(BLOCK_CARET_LAYER,caretExtension);			else				addExtension(CARET_LAYER,caretExtension);			if(textArea.getBuffer() != null)				textArea.invalidateLine(textArea.getCaretLine());		}	
/**		 * Returns true if the caret should be drawn with a thick line, false otherwise.		 * @since jEdit 4.3pre15		 */		public final boolean isThickCaretEnabled()		{			return thickCaret;		}	
/**		 * Sets if the caret should be drawn with a thick line.		 * @param thickCaret		 *     True if the caret should be drawn as a block, false otherwise.		 * @since jEdit 4.3pre15		 */		public final void setThickCaretEnabled(boolean thickCaret)		{			this.thickCaret = thickCaret;			if(textArea.getBuffer() != null)				textArea.invalidateLine(textArea.getCaretLine());		}	
/**		 * Returns the EOL marker color.		 */		public final Color getEOLMarkerColor()		{			return eolMarkerColor;		}	
/**		 * Sets the EOL marker color.		 * @param eolMarkerColor The EOL marker color		 */		public final void setEOLMarkerColor(Color eolMarkerColor)		{			this.eolMarkerColor = eolMarkerColor;			repaint();		}	
/**		 * Returns true if EOL markers are drawn, false otherwise.		 */		public final boolean getEOLMarkersPainted()		{			return eolMarkers;		}	
/**		 * Sets if EOL markers are to be drawn.		 * @param eolMarkers True if EOL markers should be drawn, false otherwise		 */		public final void setEOLMarkersPainted(boolean eolMarkers)		{			this.eolMarkers = eolMarkers;			repaint();		}	
/**		 * Returns the wrap guide color.		 */		public final Color getWrapGuideColor()		{			return wrapGuideColor;		}	
/**		 * Sets the wrap guide color.		 * @param wrapGuideColor The wrap guide color		 */		public final void setWrapGuideColor(Color wrapGuideColor)		{			this.wrapGuideColor = wrapGuideColor;			repaint();		}	
/**		 * Returns true if the wrap guide is drawn, false otherwise.		 * @since jEdit 4.0pre4		 */		public final boolean isWrapGuidePainted()		{			return wrapGuide;		}	
/**		 * Sets if the wrap guide is to be drawn.		 * @param wrapGuide True if the wrap guide should be drawn, false otherwise		 */		public final void setWrapGuidePainted(boolean wrapGuide)		{			this.wrapGuide = wrapGuide;			repaint();		}	
/**		 * Returns the fold line style. The first element is the style for		 * lines with a fold level greater than 3. The remaining elements		 * are for fold levels 1 to 3.		 */		public final SyntaxStyle[] getFoldLineStyle()		{			return foldLineStyle;		}	
/**		 * Sets the fold line style. The first element is the style for		 * lines with a fold level greater than 3. The remaining elements		 * are for fold levels 1 to 3.		 * @param foldLineStyle The fold line style		 */		public final void setFoldLineStyle(SyntaxStyle[] foldLineStyle)		{			this.foldLineStyle = foldLineStyle;			repaint();		}	
/**		 * @deprecated use setAntiAlias(AntiAlias newMode)		 */		@Deprecated		public void setAntiAliasEnabled(boolean isEnabled)		{			setAntiAlias(new AntiAlias(isEnabled));		}	
/**		 * As of jEdit 4.3pre4, a new JDK 1.6 subpixel antialias mode is supported.		 *		 * @since jEdit 4.2pre4		 */		public void setAntiAlias(AntiAlias newValue)		{			antiAlias = newValue;			updateRenderingHints();		}	
/**		 * @return the AntiAlias value that is currently used for TextAreas.		 * @since jedit 4.3pre4		 */		public AntiAlias getAntiAlias()		{			return antiAlias;		}	
/**		 * Returns if anti-aliasing is enabled.		 * @since jEdit 3.2pre6		 * @deprecated - use @ref getAntiAlias()		 */		@Deprecated		public boolean isAntiAliasEnabled()		{			return antiAlias.val() > 0;		}	
/**		 * Sets if fractional font metrics should be enabled. Has no effect when		 * running on Java 1.1.		 * @since jEdit 3.2pre6		 */		public void setFractionalFontMetricsEnabled(boolean fracFontMetrics)		{			this.fracFontMetrics = fracFontMetrics;			updateRenderingHints();		}	
/**		 * Returns if fractional font metrics are enabled.		 * @since jEdit 3.2pre6		 */		public boolean isFractionalFontMetricsEnabled()		{			return fracFontMetrics;		}	
/**		 * Returns the font render context.		 * @since jEdit 4.0pre4		 */		public FontRenderContext getFontRenderContext()		{			return fontRenderContext;		}	
/**		 * Adds a text area extension, which can perform custom painting and		 * tool tip handling.		 * @param extension The extension		 * @since jEdit 4.0pre4		 */		public void addExtension(TextAreaExtension extension)		{			extensionMgr.addExtension(DEFAULT_LAYER,extension);			repaint();		}	
/**		 * Adds a text area extension, which can perform custom painting and		 * tool tip handling.		 * @param layer The layer to add the extension to. Note that more than		 * extension can share the same layer.		 * @param extension The extension		 * @since jEdit 4.0pre4		 */		public void addExtension(int layer, TextAreaExtension extension)		{			extensionMgr.addExtension(layer,extension);			repaint();		}	
/**		 * Removes a text area extension. It will no longer be asked to		 * perform custom painting and tool tip handling.		 * @param extension The extension		 * @since jEdit 4.0pre4		 */		public void removeExtension(TextAreaExtension extension)		{			extensionMgr.removeExtension(extension);			repaint();		}	
/**		 * Returns an array of registered text area extensions. Useful for		 * debugging purposes.		 * @since jEdit 4.1pre5		 */		public TextAreaExtension[] getExtensions()		{			return extensionMgr.getExtensions();		}	
/**		 * Returns the tool tip to display at the specified location.		 * @param evt The mouse event		 */		@Override		public String getToolTipText(MouseEvent evt)		{			if(textArea.getBuffer().isLoading())				return null;				return extensionMgr.getToolTipText(evt.getX(),evt.getY());		}	
/**		 * Returns the font metrics used by this component.		 */		public FontMetrics getFontMetrics()		{			return fm;		}	
/**		 * Sets the font for this component. This is overridden to update the		 * cached font metrics and to recalculate which lines are visible.		 * @param font The font		 */		@Override		public void setFont(Font font)		{			super.setFont(font);			fm = getFontMetrics(font);			textArea.recalculateVisibleLines();			if(textArea.getBuffer() != null				&& !textArea.getBuffer().isLoading())				textArea.recalculateLastPhysicalLine();			//textArea.propertiesChanged();		}	
/**		 * Returns the width of the given string, in pixels, using the text		 * area's current font.		 *		 * @since jEdit 4.2final		 */		public float getStringWidth(String str)		{			if(textArea.charWidth != 0)				return textArea.charWidth * str.length();			else			{				return (float)getFont().getStringBounds(					str,getFontRenderContext()).getWidth();			}		}	
/**		 * Repaints the text.		 * @param _gfx The graphics context		 */		@Override		public void update(Graphics _gfx)		{			paint(_gfx);		}	
/**		 * Repaints the text.		 * @param _gfx The graphics context		 */		@Override		public void paint(Graphics _gfx)		{			assert _gfx instanceof Graphics2D;			Graphics2D gfx = (Graphics2D)_gfx;			gfx.setRenderingHints(renderingHints);			fontRenderContext = gfx.getFontRenderContext();				Rectangle clipRect = gfx.getClipBounds();			int lineHeight = fm.getHeight();			if(lineHeight == 0 || textArea.getBuffer().isLoading())			{				gfx.setColor(getBackground());				gfx.fillRect(clipRect.x,clipRect.y,clipRect.width,clipRect.height);			}			else			{				long prepareTime = System.nanoTime();				// Because the clipRect's height is usually an even multiple				// of the font height, we subtract 1 from it, otherwise one				// too many lines will always be painted.				int firstLine = clipRect.y / lineHeight;				int lastLine = (clipRect.y + clipRect.height - 1) / lineHeight;				gfx.setColor(getBackground());				gfx.setFont(getFont());				prepareTime = System.nanoTime() - prepareTime;					long linesTime = System.nanoTime();				int numLines = lastLine - firstLine + 1;				int y = firstLine * lineHeight;				gfx.fillRect(0,y,getWidth(),numLines * lineHeight);				extensionMgr.paintScreenLineRange(textArea,gfx,					firstLine,lastLine,y,lineHeight);				linesTime = System.nanoTime() - linesTime;					if(Debug.PAINT_TIMER && numLines >= 1)					Log.log(Log.DEBUG,this,"repainting " + numLines + " lines took " + prepareTime + "/" + linesTime + " ns");			}				textArea.updateMaxHorizontalScrollWidth();		}	
/**		 * Implementation of TabExpander interface. Returns next tab stop after		 * a specified point.		 * @param x The x co-ordinate		 * @param tabOffset Ignored		 * @return The next tab stop after <i>x</i>		 */		public float nextTabStop(float x, int tabOffset)		{			int ntabs = (int)(x / textArea.tabSize);			return (ntabs + 1) * textArea.tabSize;		}	
/**		 * Returns the painter's preferred size.		 */		@Override		public Dimension getPreferredSize()		{			Dimension dim = new Dimension();				char[] foo = new char[80];			for(int i = 0; i < foo.length; i++)				foo[i] = ' ';			dim.width = (int)getStringWidth(new String(foo));			dim.height = fm.getHeight() * 25;			return dim;		}	
/**		 * Returns the painter's minimum size.		 */		@Override		public Dimension getMinimumSize()		{			return getPreferredSize();		}	
/**		 * Creates a new painter. Do not create instances of this class		 * directly.		 */		TextAreaPainter(TextArea textArea)		{			enableEvents(AWTEvent.FOCUS_EVENT_MASK				| AWTEvent.KEY_EVENT_MASK				| AWTEvent.MOUSE_EVENT_MASK);				this.textArea = textArea;			antiAlias = new AntiAlias(0);			fonts = new HashMap();			extensionMgr = new ExtensionManager();				setAutoscrolls(true);			setOpaque(true);			setRequestFocusEnabled(false);			setDoubleBuffered(false);				setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));				fontRenderContext = new FontRenderContext(null,false,false);				addExtension(LINE_BACKGROUND_LAYER,new PaintLineBackground());			addExtension(SELECTION_LAYER,new PaintSelection());			addExtension(WRAP_GUIDE_LAYER,new PaintWrapGuide());			addExtension(BRACKET_HIGHLIGHT_LAYER,new StructureMatcher				.Highlight(textArea));			addExtension(TEXT_LAYER,new PaintText());			caretExtension = new PaintCaret();		}	
private void updateRenderingHints()		{			Map<RenderingHints.Key,Object> hints = new HashMap<RenderingHints.Key,Object>();				hints.put(RenderingHints.KEY_FRACTIONALMETRICS,				fracFontMetrics ? RenderingHints.VALUE_FRACTIONALMETRICS_ON					: RenderingHints.VALUE_FRACTIONALMETRICS_OFF);				if (antiAlias.val() == 0)			{				hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);				hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);				fontRenderContext = new FontRenderContext(null, antiAlias.val() > 0, fracFontMetrics);			}			/** LCD HRGB mode - works with JRE 1.6 only, which is why we use reflection */			else if (antiAlias.val() == 2 && sm_hrgbRender != null )			{				hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, sm_hrgbRender);				Object fontRenderHint = fracFontMetrics ?					RenderingHints.VALUE_FRACTIONALMETRICS_ON :					RenderingHints.VALUE_FRACTIONALMETRICS_OFF;				Object[] paramList = {null, sm_hrgbRender, fontRenderHint};				try				{					fontRenderContext = sm_frcConstructor.newInstance(paramList);				}				catch (Exception e)				{					fontRenderContext = new FontRenderContext(null, antiAlias.val() > 0, fracFontMetrics);				}			}			else /** Standard Antialias Version */			{				hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);				hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);				hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);				fontRenderContext = new FontRenderContext(null, antiAlias.val() > 0, fracFontMetrics);			}				renderingHints = new RenderingHints(hints);				}	
private boolean shouldPaintLineHighlight(int caret, int start, int end)			{				if(!isLineHighlightEnabled()					|| caret < start || caret >= end)				{					return false;				}					int count = textArea.getSelectionCount();				if(count == 1)				{					Selection s = textArea.getSelection(0);					return s.getStartLine() == s.getEndLine();				}				else					return count == 0;			}	
@Override			public void paintValidLine(Graphics2D gfx, int screenLine,				int physicalLine, int start, int end, int y)			{				// minimise access$ methods				TextArea textArea = TextAreaPainter.this.textArea;				JEditBuffer buffer = textArea.getBuffer();					//{{{ Paint line highlight and collapsed fold highlight				boolean collapsedFold =					physicalLine < buffer.getLineCount() - 1					&& buffer.isFoldStart(physicalLine)					&& !textArea.displayManager					.isLineVisible(physicalLine + 1);					SyntaxStyle foldLineStyle = null;				if(collapsedFold)				{					int level = buffer.getFoldLevel(physicalLine + 1);					if(buffer.getFoldHandler() instanceof IndentFoldHandler)						level = Math.max(1,level / buffer.getIndentSize());					if(level > 3)						level = 0;					foldLineStyle = TextAreaPainter.this.foldLineStyle[level];				}					int caret = textArea.getCaretPosition();				boolean paintLineHighlight = shouldPaintLineHighlight(					caret,start,end);					Color bgColor;				if(paintLineHighlight)					bgColor = lineHighlightColor;				else if(collapsedFold)				{					bgColor = foldLineStyle.getBackgroundColor();					if(bgColor == null)						bgColor = getBackground();				}				else					bgColor = getBackground();					if(paintLineHighlight || collapsedFold)				{					gfx.setColor(bgColor);					gfx.fillRect(0,y,getWidth(),fm.getHeight());				} //}}}					//{{{ Paint token backgrounds				ChunkCache.LineInfo lineInfo = textArea.chunkCache					.getLineInfo(screenLine);					if(lineInfo.chunks != null)				{					float baseLine = y + fm.getHeight()						- (fm.getLeading()+1) - fm.getDescent();					Chunk.paintChunkBackgrounds(						lineInfo.chunks,gfx,						textArea.getHorizontalOffset(),						baseLine);				} //}}}			}	
@Override			public void paintValidLine(Graphics2D gfx, int screenLine,				int physicalLine, int start, int end, int y)			{				if(textArea.getSelectionCount() == 0)					return;					gfx.setColor(textArea.isMultipleSelectionEnabled()					? getMultipleSelectionColor()					: getSelectionColor());					Iterator<Selection> iter = textArea.getSelectionIterator();				while(iter.hasNext())				{					Selection s = iter.next();					paintSelection(gfx,screenLine,physicalLine,y,s);				}			}	
private void paintSelection(Graphics2D gfx, int screenLine,				int physicalLine, int y, Selection s)			{				int[] selectionStartAndEnd					= textArea.selectionManager					.getSelectionStartAndEnd(					screenLine,physicalLine,s);				if(selectionStartAndEnd == null)					return;					int x1 = selectionStartAndEnd[0];				int x2 = selectionStartAndEnd[1];					gfx.fillRect(x1,y,x2 - x1,fm.getHeight());			}	
@Override			public void paintScreenLineRange(Graphics2D gfx, int firstLine,				int lastLine, int[] physicalLines, int[] start,				int[] end, int y, int lineHeight)			{				if(textArea.wrapMargin != 0					&& !textArea.wrapToWidth					&& isWrapGuidePainted())				{					gfx.setColor(getWrapGuideColor());					int x = textArea.getHorizontalOffset()						+ textArea.wrapMargin;					gfx.drawLine(x,y,x,y + (lastLine - firstLine						+ 1) * lineHeight);				}			}	
@Override			public String getToolTipText(int x, int y)			{				if(textArea.wrapMargin != 0					&& !textArea.wrapToWidth					&& isWrapGuidePainted())				{					int wrapGuidePos = textArea.wrapMargin						+ textArea.getHorizontalOffset();					if(Math.abs(x - wrapGuidePos) < 5)					{						return String.valueOf(textArea.getBuffer()							.getProperty("maxLineLen"));					}				}					return null;			}	
@Override			public void paintValidLine(Graphics2D gfx, int screenLine,				int physicalLine, int start, int end, int y)			{				ChunkCache.LineInfo lineInfo = textArea.chunkCache					.getLineInfo(screenLine);					Font defaultFont = getFont();				Color defaultColor = getForeground();					gfx.setFont(defaultFont);				gfx.setColor(defaultColor);					int x = textArea.getHorizontalOffset();				int originalX = x;					float baseLine = y + fm.getHeight()					- (fm.getLeading()+1) - fm.getDescent();					if(lineInfo.chunks != null)				{					x += Chunk.paintChunkList(lineInfo.chunks,						gfx,textArea.getHorizontalOffset(),						baseLine,!Debug.DISABLE_GLYPH_VECTOR);				}					JEditBuffer buffer = textArea.getBuffer();					if(!lineInfo.lastSubregion)				{					gfx.setFont(defaultFont);					gfx.setColor(eolMarkerColor);					gfx.drawString(":",Math.max(x,						textArea.getHorizontalOffset()						+ textArea.wrapMargin + textArea.charWidth),						baseLine);					x += textArea.charWidth;				}				else if(physicalLine < buffer.getLineCount() - 1					&& buffer.isFoldStart(physicalLine)					&& !textArea.displayManager					.isLineVisible(physicalLine + 1))				{					int level = buffer.getFoldLevel(physicalLine + 1);					if(buffer.getFoldHandler() instanceof IndentFoldHandler)						level = Math.max(1,level / buffer.getIndentSize());					if(level > 3)						level = 0;					SyntaxStyle foldLineStyle = TextAreaPainter.this.foldLineStyle[level];						Font font = foldLineStyle.getFont();					gfx.setFont(font);					gfx.setColor(foldLineStyle.getForegroundColor());						int nextLine;					int nextScreenLine = screenLine + 1;					if(nextScreenLine < textArea.getVisibleLines())					{						nextLine = textArea.chunkCache.getLineInfo(nextScreenLine)							.physicalLine;					}					else					{						nextLine = textArea.displayManager							.getNextVisibleLine(physicalLine);					}						if(nextLine == -1)						nextLine = textArea.getLineCount();						int count = nextLine - physicalLine - 1;					String str = " [" + count + " lines]";						float width = getStringWidth(str);						gfx.drawString(str,x,baseLine);					x += width;				}				else if(eolMarkers)				{					gfx.setFont(defaultFont);					gfx.setColor(eolMarkerColor);					gfx.drawString(".",x,baseLine);					x += textArea.charWidth;				}					lineInfo.width = x - originalX;			}	
@Override			public void paintValidLine(Graphics2D gfx, int screenLine,				int physicalLine, int start, int end, int y)			{				if(!textArea.isCaretVisible())					return;					int caret = textArea.getCaretPosition();				if(caret < start || caret >= end)					return;					int offset = caret - textArea.getLineStartOffset(physicalLine);				textArea.offsetToXY(physicalLine,						    offset, textArea.offsetXY);				int caretX = textArea.offsetXY.x;				int lineHeight = fm.getHeight();					gfx.setColor(caretColor);					if(textArea.isOverwriteEnabled())				{					gfx.drawLine(caretX,y + lineHeight - 1,						     caretX + textArea.charWidth,						     y + lineHeight - 1);				}				else if(blockCaret)					gfx.drawRect(caretX,y,textArea.charWidth - 1,						     lineHeight - 1);				else				{					if (thickCaret)						gfx.drawRect(caretX, y,							1, lineHeight - 1);					else						gfx.drawLine(caretX,y,							caretX,y + lineHeight - 1);				}			}	
@Override		protected Transferable createTransferable(JComponent c)		{			Log.log(Log.DEBUG,this,"createTransferable()");			JEditTextArea textArea = (JEditTextArea)c;			if(textArea.getSelectionCount() == 0)				return null;			else			{				dragSource = textArea;				return new TextAreaSelection(textArea);			}		}	
@Override		public int getSourceActions(JComponent c)		{			return COPY_OR_MOVE;		}	
@Override		public boolean importData(JComponent c, Transferable t)		{			Log.log(Log.DEBUG,this,"Import data");	//		Log.log(Log.DEBUG,this,"Import data: t.isDataFlavorSupported("+textURIlistDataFlavor+")="+t.isDataFlavorSupported(textURIlistDataFlavor)+".");			if(!canImport(c,t.getTransferDataFlavors()))				return false;				boolean returnValue;				try			{				if(t.isDataFlavorSupported(DataFlavor.javaFileListFlavor))				{					returnValue = importFile(c,t);				}				else				{					DataFlavor uriListStringDataFlavor = null;					DataFlavor[] dataFlavors = t.getTransferDataFlavors();										for (int i = 0;i<dataFlavors.length;i++)					{						DataFlavor dataFlavor = dataFlavors[i];						if ("text".equals(dataFlavor.getPrimaryType()) &&						    "uri-list".equals(dataFlavor.getSubType()) &&						    dataFlavor.getRepresentationClass() == String.class)						{							uriListStringDataFlavor = dataFlavor;							break;						}	 				}										if (uriListStringDataFlavor != null &&t.isDataFlavorSupported(uriListStringDataFlavor))					{						returnValue = importURIList(c,t,uriListStringDataFlavor);					}					else					{						returnValue = importText(c,t);					}				}			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);				returnValue = false;			}				GUIUtilities.getView(c).toFront();			GUIUtilities.getView(c).requestFocus();			c.requestFocus();				return returnValue;		}	
private boolean importFile(JComponent c, Transferable t)			throws Exception		{			Log.log(Log.DEBUG,this,"=> File list");			EditPane editPane = (EditPane)				GUIUtilities.getComponentParent(				c,EditPane.class);			View view = editPane.getView();			Buffer buffer = null;				List<File> data = (List<File>) t.getTransferData(DataFlavor.javaFileListFlavor);				boolean browsedDirectory = false;			BufferSetManager bufferSetManager = jEdit.getBufferSetManager();			for (File file : data)			{				if (file.isDirectory())				{					if (!browsedDirectory)					{						VFSBrowser.browseDirectory(view, file.getPath());						browsedDirectory = true;					}					continue;				}				Buffer _buffer = jEdit.openFile(editPane, file.getPath());				if (_buffer != null)				{					buffer = _buffer;					bufferSetManager.addBuffer(editPane, buffer);				}			}				if(buffer != null)				editPane.setBuffer(buffer);			view.toFront();			view.requestFocus();			editPane.requestFocus();				return true;		}	
private boolean importURIList(JComponent c, Transferable t,DataFlavor uriListStringDataFlavor)			throws Exception		{			String str = (String) t.getTransferData(uriListStringDataFlavor);				Log.log(Log.DEBUG,this,"=> URIList \""+str+ '\"');			EditPane editPane = (EditPane) GUIUtilities.getComponentParent(c, EditPane.class);			View view = editPane.getView();			JEditTextArea textArea = (JEditTextArea) c;			if (dragSource == null)			{				boolean found = false;				String[] components = str.split("\r\n");					boolean browsedDirectory = false;				for (int i = 0;i<components.length;i++)				{					String str0 = components[i];										if (str0.length() > 0)					{						URI uri = new URI(str0); // this handles the URI-decoding												if ("file".equals(uri.getScheme()))						{							File file = new File(uri.getPath());							if (file.isDirectory())							{								if (!browsedDirectory)								{									VFSBrowser.browseDirectory(view, file.getPath());									browsedDirectory = true;								}							}							else							{								VFSManager.runInWorkThread(new DraggedURLLoader(textArea,uri.getPath()));							}							found = true;						}						else						{							Log.log(Log.DEBUG,this,"I do not know how to handle this URI "+uri+", ignoring.");						}					}					else					{						// This should be the last component, because every URI in the list is terminated with a "\r\n", even the last one.						if (i!=components.length-1)						{							Log.log(Log.DEBUG,this,"Odd: there is an empty line in the uri list which is not the last line.");						}					}				}								if (found)				{					return true;				}			}						return true;		}	
private boolean importText(JComponent c, Transferable t)			throws Exception		{			String str = (String)t.getTransferData(				DataFlavor.stringFlavor);			str = str.trim();			Log.log(Log.DEBUG,this,"=> String \""+str+ '\"');						JEditTextArea textArea = (JEditTextArea)c;			if (dragSource == null)			{				boolean found = false;				String[] components = str.split("\n");					for (int i = 0;i<components.length;i++)				{					String str0 = components[i];					// Only examine the string for a URL if it came from					// outside of jEdit.					VFS vfs = VFSManager.getVFSForPath(str0);					if (!(vfs instanceof FileVFS) || str.startsWith("file://"))					{	//					str = str.replace('\n',' ').replace('\r',' ').trim();						if (str0.startsWith("file://"))						{							str0 = str0.substring(7);						}							VFSManager.runInWorkThread(new DraggedURLLoader(textArea,str0));					}					found = true;									}								if (found)					return true;			}				if(dragSource != null				&& textArea.getBuffer()				== dragSource.getBuffer())			{				compoundEdit = true;				textArea.getBuffer().beginCompoundEdit();			}									sameTextArea = textArea == dragSource;				int caret = textArea.getCaretPosition();			Selection s = textArea.getSelectionAtOffset(caret);				/* if user drops into the same			selection where they started, do			nothing. */			if(s != null)			{				if(sameTextArea)					return false;				/* if user drops into a selection,				replace selection */				int startPos = s.start;				textArea.setSelectedText(s,str);				textArea.setSelection(new Selection.Range(startPos,startPos+str.length()));			}			/* otherwise just insert the text */			else			{				if (sameTextArea)				{					insertPos = caret;					insertOffset = 0;					Selection[] selections = textArea.getSelection();					for (int i=0;i<selections.length;i++)					{						if (selections[i].end < insertPos + insertOffset)							insertOffset -= selections[i].end - selections[i].start;					}				}				else				{					textArea.getBuffer().insert(caret,str);					textArea.setSelection(new Selection.Range(caret,caret+str.length()));				}			}			textArea.scrollToCaret(true);				return true;		}	
@Override		protected void exportDone(JComponent c, Transferable t,			int action)		{			Log.log(Log.DEBUG,this,"Export done");				JEditTextArea textArea = (JEditTextArea)c;				try			{				// This happens if importData returns false. For example if you drop into the Selection				if (action == NONE)				{					Log.log(Log.DEBUG,this,"Export impossible");					return;				}					if(t == null)				{					Log.log(Log.DEBUG,this,"=> Null transferrable");					textArea.selectNone();				}				else if(t.isDataFlavorSupported(					DataFlavor.stringFlavor))				{					Log.log(Log.DEBUG,this,"=> String");					if (sameTextArea)					{						if(action == MOVE)						{							textArea.setSelectedText(null,false);							insertPos += insertOffset;						} 						try						{							String str = (String)t.getTransferData(DataFlavor.stringFlavor);							textArea.getBuffer().insert(insertPos,str);							textArea.setSelection(new Selection.Range(insertPos,insertPos+str.length()));						}						catch(Exception e)						{							Log.log(Log.DEBUG,this,"exportDone in sameTextArea");							Log.log(Log.DEBUG,this,e);						}					}					else					{						if(action == MOVE)							textArea.setSelectedText(null,false);						else							textArea.selectNone();					}				}			}			finally			{				if(compoundEdit)				{					compoundEdit = false;					textArea.getBuffer().endCompoundEdit();				}			}				dragSource = null;		}	
@Override		public boolean canImport(JComponent c, DataFlavor[] flavors)		{			JEditTextArea textArea = (JEditTextArea)c;				// correctly handle text flavor + file list flavor			// + text area read only, do an or of all flags			boolean returnValue = false;				for(int i = 0; i < flavors.length; i++)			{				if(flavors[i].equals(					DataFlavor.javaFileListFlavor))				{					returnValue = true;				}				else if(flavors[i].equals(					DataFlavor.stringFlavor))				{					if(textArea.isEditable())						returnValue = true;				}				else if (flavors[i].getRepresentationClass().equals(java.io.InputStream.class))				{					//workaround for Ubuntu/Gnome/Nautilus import flavors, otherwise					//doesn't work on all Ubuntu installations					returnValue = true;					break;				}			}				Log.log(Log.DEBUG,this,"canImport() returning "				+ returnValue);			return returnValue;		}	
TextAreaSelection(JEditTextArea textArea)			{				super(textArea.getSelectedText());				this.textArea = textArea;			}	
DraggedURLLoader(JEditTextArea textArea, String url)			{				this.textArea = textArea;				this.url = url;			}	
public void run()			{				EditPane editPane = EditPane.get(textArea);				jEdit.openFile(editPane,url);			}	
/**		 * Returns the token that contains the specified offset.		 * @param tokens The token list		 * @param offset The offset		 * @since jEdit 4.0pre3		 */		public static Token getTokenAtOffset(Token tokens, int offset)		{			if(offset == 0 && tokens.id == Token.END)				return tokens;				for(;;)			{				if(tokens.id == Token.END)					throw new ArrayIndexOutOfBoundsException("offset > line length");					if(tokens.offset + tokens.length > offset)					return tokens;				else					tokens = tokens.next;			}		}	
/**		 * Given an opening bracket, return the corresponding closing bracket		 * and store true in <code>direction[0]</code>. Given a closing bracket,		 * return the corresponding opening bracket and store false in		 * <code>direction[0]</code>. Otherwise, return <code>\0</code>.		 * @since jEdit 4.3pre2		 */		public static char getComplementaryBracket(char ch, boolean[] direction)		{			switch(ch)			{			case '(': if (direction != null) direction[0] = true;  return ')';			case ')': if (direction != null) direction[0] = false; return '(';			case '[': if (direction != null) direction[0] = true;  return ']';			case ']': if (direction != null) direction[0] = false; return '[';			case '{': if (direction != null) direction[0] = true;  return '}';			case '}': if (direction != null) direction[0] = false; return '{';			case '<': if (direction != null) direction[0] = true;  return '>';			case '>': if (direction != null) direction[0] = false; return '<';			default:  return '\0';			}		}	
/**		 * Returns the offset of the bracket matching the one at the		 * specified offset of the buffer, or -1 if the bracket is		 * unmatched (or if the character is not a bracket).		 * @param buffer The buffer		 * @param line The line		 * @param offset The offset within that line		 * @since jEdit 2.6pre1		 */		public static int findMatchingBracket(JEditBuffer buffer, int line, int offset)		{			if(offset < 0 || offset >= buffer.getLineLength(line))			{				throw new ArrayIndexOutOfBoundsException(offset + ":"					+ buffer.getLineLength(line));			}				Segment lineText = new Segment();			buffer.getLineText(line,lineText);				char c = lineText.array[lineText.offset + offset];			// false - backwards, true - forwards			boolean[] direction = new boolean[1];				// corresponding character			char cprime = getComplementaryBracket(c,direction);				if( cprime == '\0' )			{ // c is no bracket				return -1;			}				// 1 because we've already 'seen' the first bracket			int count = 1;				DefaultTokenHandler tokenHandler = new DefaultTokenHandler();			buffer.markTokens(line,tokenHandler);				// Get the syntax token at 'offset'			// only tokens with the same type will be checked for			// the corresponding bracket			byte idOfBracket = getTokenAtOffset(tokenHandler.getTokens(),offset).id;				boolean haveTokens = true;				int startLine = line;				//{{{ Forward search			if(direction[0])			{				offset++;					for(;;)				{					for(int i = offset; i < lineText.count; i++)					{						char ch = lineText.array[lineText.offset + i];						if(ch == c)						{							if(!haveTokens)							{								tokenHandler.init();								buffer.markTokens(line,tokenHandler);								haveTokens = true;							}							if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)								count++;						}						else if(ch == cprime)						{							if(!haveTokens)							{								tokenHandler.init();								buffer.markTokens(line,tokenHandler);								haveTokens = true;							}							if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)							{								count--;								if(count == 0)									return buffer.getLineStartOffset(line) + i;							}						}					}						//{{{ Go on to next line					line++;					if(line >= buffer.getLineCount() || (line - startLine) > BRACKET_MATCH_LIMIT)						break;					buffer.getLineText(line,lineText);					offset = 0;					haveTokens = false;					//}}}				}			} //}}}			//{{{ Backward search			else			{				offset--;					for(;;)				{					for(int i = offset; i >= 0; i--)					{						char ch = lineText.array[lineText.offset + i];						if(ch == c)						{							if(!haveTokens)							{								tokenHandler.init();								buffer.markTokens(line,tokenHandler);								haveTokens = true;							}							if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)								count++;						}						else if(ch == cprime)						{							if(!haveTokens)							{								tokenHandler.init();								buffer.markTokens(line,tokenHandler);								haveTokens = true;							}							if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)							{								count--;								if(count == 0)									return buffer.getLineStartOffset(line) + i;							}						}					}						//{{{ Go on to previous line					line--;					if(line < 0 || (startLine - line) > BRACKET_MATCH_LIMIT)						break;					buffer.getLineText(line,lineText);					offset = lineText.count - 1;					haveTokens = false;					//}}}				}			} //}}}				// Nothing found			return -1;		}	
/**		 * Locates the start of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 */		public static int findWordStart(String line, int pos, String noWordSep)		{			return findWordStart(line, pos, noWordSep, true, false);		}	
/**		 * Locates the start of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @since jEdit 4.3pre15		 */		public static int findWordStart(CharSequence line,						int pos,						String noWordSep)		{			return findWordStart(line, pos, noWordSep, true, false, false);		}	
/** Similar to perl's join() method on lists,		 *    but works with all collections.		 *		 * @param c An iterable collection of Objects		 * @param delim a string to put between each object		 * @return a joined toString() representation of the collection		 *		 * @since jedit 4.3pre3		 */		public static String join(Collection<String> c, String delim)		{			StringBuilder retval = new StringBuilder();			Iterator<String> itr = c.iterator();			if (itr.hasNext())				retval.append( itr.next() );			else 				return "";			while (itr.hasNext())			{				retval.append(delim);				retval.append(itr.next());			}			return retval.toString();		}	
/**		 * Locates the start of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @since jEdit 4.2pre5		 */		public static int findWordStart(String line, int pos, String noWordSep,			boolean joinNonWordChars)		{			return findWordStart(line,pos,noWordSep,joinNonWordChars,false);		}	
/**		 * Locates the start of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @param eatWhitespace Include whitespace at start of word		 * @since jEdit 4.1pre2		 */		public static int findWordStart(String line, int pos, String noWordSep,			boolean joinNonWordChars, boolean eatWhitespace)		{			return findWordStart(line, pos, noWordSep, joinNonWordChars, false, eatWhitespace);		}	
/**		 * Locates the start of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @param camelCasedWords Treat "camelCased" parts as words		 * @param eatWhitespace Include whitespace at start of word		 * @since jEdit 4.3pre10		 */		public static int findWordStart(String line, int pos, String noWordSep,			boolean joinNonWordChars, boolean camelCasedWords,			boolean eatWhitespace)		{			return findWordStart((CharSequence) line, pos, noWordSep,					     joinNonWordChars, camelCasedWords,					     eatWhitespace);		}	
/**		 * Locates the start of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @param camelCasedWords Treat "camelCased" parts as words		 * @param eatWhitespace Include whitespace at start of word		 * @since jEdit 4.3pre15		 */		public static int findWordStart(CharSequence line,						int pos,						String noWordSep,						boolean joinNonWordChars,						boolean camelCasedWords,						boolean eatWhitespace)		{			char ch = line.charAt(pos);				if(noWordSep == null)				noWordSep = "";				//{{{ the character under the cursor changes how we behave.			int type = getCharType(ch, noWordSep);			//}}}				for(int i = pos; i >= 0; i--)			{				char lastCh = ch;				ch = line.charAt(i);				switch(type)				{				//{{{ Whitespace...				case WHITESPACE:					// only select other whitespace in this case					if(Character.isWhitespace(ch))						break;					// word char or symbol; stop					else						return i + 1; //}}}				//{{{ Word character...				case WORD_CHAR:					// stop at next last (in writing direction) upper case char if camel cased					// (don't stop at every upper case char, don't treat noWordSep as word chars)					if (camelCasedWords && Character.isUpperCase(ch) && !Character.isUpperCase(lastCh)							&& Character.isLetterOrDigit(lastCh))					{						return i;					}					// stop at next first (in writing direction) upper case char if camel cased					// (don't stop at every upper case char)					else if (camelCasedWords && !Character.isUpperCase(ch) && Character.isUpperCase(lastCh))					{						return i + 1;					}					// word char; keep going					else if(Character.isLetterOrDigit(ch) ||						noWordSep.indexOf(ch) != -1)					{						break;					}					// whitespace; include in word if eating					else if(Character.isWhitespace(ch)						&& eatWhitespace)					{						type = WHITESPACE;						break;					}					else						return i + 1; //}}}				//{{{ Symbol...				case SYMBOL:					if(!joinNonWordChars && pos != i)						return i + 1;						// whitespace; include in word if eating					if(Character.isWhitespace(ch))					{						if(eatWhitespace)						{							type = WHITESPACE;							break;						}						else							return i + 1;					}					else if(Character.isLetterOrDigit(ch) ||						noWordSep.indexOf(ch) != -1)					{						return i + 1;					}					else					{						break;					} //}}}				}			}				return 0;		}	
/**		 * Locates the end of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 */		public static int findWordEnd(String line, int pos, String noWordSep)		{			return findWordEnd(line, pos, noWordSep, true);		}	
/**		 * Locates the end of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @since jEdit 4.3pre15		 */		public static int findWordEnd(CharSequence line,					      int pos,					      String noWordSep)		{			return findWordEnd(line, pos, noWordSep, true, false, false);		}	
/**		 * Locates the end of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @since jEdit 4.1pre2		 */		public static int findWordEnd(String line, int pos, String noWordSep,			boolean joinNonWordChars)		{			return findWordEnd(line,pos,noWordSep,joinNonWordChars,false);		}	
/**		 * Locates the end of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @param eatWhitespace Include whitespace at end of word		 * @since jEdit 4.2pre5		 */		public static int findWordEnd(String line, int pos, String noWordSep,			boolean joinNonWordChars, boolean eatWhitespace)		{			return findWordEnd(line, pos, noWordSep, joinNonWordChars, false, eatWhitespace);		}	
/**		 * Locates the end of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @param camelCasedWords Treat "camelCased" parts as words		 * @param eatWhitespace Include whitespace at end of word		 * @since jEdit 4.3pre10		 */		public static int findWordEnd(String line, int pos, String noWordSep,			boolean joinNonWordChars, boolean camelCasedWords,			boolean eatWhitespace)		{			return findWordEnd((CharSequence)line, pos, noWordSep,					   joinNonWordChars, camelCasedWords,					   eatWhitespace);		}	
/**		 * Locates the end of the word at the specified position.		 * @param line The text		 * @param pos The position		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @param joinNonWordChars Treat consecutive non-alphanumeric		 * characters as one word		 * @param camelCasedWords Treat "camelCased" parts as words		 * @param eatWhitespace Include whitespace at end of word		 * @since jEdit 4.3pre15		 */		public static int findWordEnd(CharSequence line,					      int pos,					      String noWordSep,					      boolean joinNonWordChars,					      boolean camelCasedWords,					      boolean eatWhitespace)		{			if(pos != 0)				pos--;				char ch = line.charAt(pos);				if(noWordSep == null)				noWordSep = "";				//{{{ the character under the cursor changes how we behave.			int type = getCharType(ch, noWordSep);			//}}}				for(int i = pos; i < line.length(); i++)			{				char lastCh = ch;				ch = line.charAt(i);				switch(type)				{				//{{{ Whitespace...				case WHITESPACE:					// only select other whitespace in this case					if(Character.isWhitespace(ch))						break;					else						return i; //}}}				//{{{ Word character...				case WORD_CHAR:					// stop at next last upper case char if camel cased					// (don't stop at every upper case char, don't treat noWordSep as word chars)					if (camelCasedWords && i > pos + 1 && !Character.isUpperCase(ch) && Character.isLetterOrDigit(ch)							&& Character.isUpperCase(lastCh))					{						return i - 1;					}					// stop at next first upper case char if camel caseg (don't stop at every upper case char)					else if (camelCasedWords && Character.isUpperCase(ch) && !Character.isUpperCase(lastCh))					{						return i;					}					else if(Character.isLetterOrDigit(ch) ||						noWordSep.indexOf(ch) != -1)					{						break;					}					// whitespace; include in word if eating					else if(Character.isWhitespace(ch)						&& eatWhitespace)					{						type = WHITESPACE;						break;					}					else						return i; //}}}				//{{{ Symbol...				case SYMBOL:					if(!joinNonWordChars && i != pos)						return i;						// if we see whitespace, set flag.					if(Character.isWhitespace(ch))					{						if(eatWhitespace)						{							type = WHITESPACE;							break;						}						else							return i;					}					else if(Character.isLetterOrDigit(ch) ||						noWordSep.indexOf(ch) != -1)					{						return i;					}					else					{						break;					} //}}}				}			}				return line.length();		}	
/**		 * Returns the type of the char.		 *		 * @param ch the character		 * @param noWordSep Characters that are non-alphanumeric, but		 * should be treated as word characters anyway		 * @return the type of the char : {@link #WHITESPACE}, {@link #WORD_CHAR}, {@link #SYMBOL}		 */		private static int getCharType(char ch, String noWordSep)		{			int type;			if(Character.isWhitespace(ch))				type = WHITESPACE;			else if(Character.isLetterOrDigit(ch)				|| noWordSep.indexOf(ch) != -1)				type = WORD_CHAR;			else				type = SYMBOL;			return type;		}	
/**		 * Converts consecutive spaces to tabs in the specified string.		 * @param in The string		 * @param tabSize The tab size		 */		public static String spacesToTabs(String in, int tabSize)		{			StringBuilder buf = new StringBuilder();			int width = 0;			int whitespace = 0;			for(int i = 0; i < in.length(); i++)			{				switch(in.charAt(i))				{				case ' ':					whitespace++;					width++;					break;				case '\t':					int tab = tabSize - (width % tabSize);					width += tab;					whitespace += tab;					break;				case '\n':					if(whitespace != 0)					{						buf.append(StandardUtilities							.createWhiteSpace(whitespace,tabSize,							width - whitespace));					}					whitespace = 0;					width = 0;					buf.append('\n');					break;				default:					if(whitespace != 0)					{						buf.append(StandardUtilities							.createWhiteSpace(whitespace,tabSize,							width - whitespace));						whitespace = 0;					}					buf.append(in.charAt(i));					width++;					break;				}			}				if(whitespace != 0)			{				buf.append(StandardUtilities.createWhiteSpace(whitespace,tabSize,					width - whitespace));			}				return buf.toString();		}	
/**		 * Converts tabs to consecutive spaces in the specified string.		 * @param in The string		 * @param tabSize The tab size		 */		public static String tabsToSpaces(String in, int tabSize)		{			StringBuilder buf = new StringBuilder();			int width = 0;			for(int i = 0; i < in.length(); i++)			{				switch(in.charAt(i))				{				case '\t':					int count = tabSize - (width % tabSize);					width += count;					while(--count >= 0)						buf.append(' ');					break;				case '\n':					width = 0;					buf.append(in.charAt(i));					break;				default:					width++;					buf.append(in.charAt(i));					break;				}			}			return buf.toString();		}	
/**		 * Formats the specified text by merging and breaking lines to the		 * specified width.		 * @param text The text		 * @param maxLineLength The maximum line length		 * @param tabSize The tab size		 */		public static String format(String text, int maxLineLength, int tabSize)		{			StringBuilder buf = new StringBuilder();				int index = 0;				for(;;)			{				int newIndex = text.indexOf("\n\n",index);				if(newIndex == -1)					break;					formatParagraph(text.substring(index,newIndex),					maxLineLength,tabSize,buf);				buf.append("\n\n");				index = newIndex + 2;			}				if(index != text.length())			{				formatParagraph(text.substring(index),					maxLineLength,tabSize,buf);			}				return buf.toString();		}	
/**		 * Inverse of <code>ignoringWhitespaceIndex()</code>.		 * @param str a string (not an empty string)		 * @param index The index		 * @return The number of non-whitespace characters that precede the index.		 * @since jEdit 4.3pre2		 */		public static int indexIgnoringWhitespace(String str, int index)		{			int j = 0;			for(int i = 0; i < index; i++)				if(!Character.isWhitespace(str.charAt(i))) j++;			return j;		}	
/**		 * Inverse of <code>indexIgnoringWhitespace()</code>.		 * @param str a string (not an empty string)		 * @param index The index		 * @return The index into the string where the number of non-whitespace		 * characters that precede the index is count.		 * @since jEdit 4.3pre2		 */		public static int ignoringWhitespaceIndex(String str, int index)		{			int j = 0;			for(int i = 0;;i++)			{				if(!Character.isWhitespace(str.charAt(i))) j++;					if(j > index)					return i;				if(i == str.length() - 1)					return i + 1;			}		}	
/**		 * Returns if the specified string is all upper case, all lower case,		 * or title case (first letter upper case, rest lower case).		 * @param str The string		 * @since jEdit 4.0pre1		 */		public static int getStringCase(String str)		{			if(str.length() == 0)				return MIXED;				int state = -1;				char ch = str.charAt(0);			if(Character.isLetter(ch))			{				if(Character.isUpperCase(ch))					state = UPPER_CASE;				else					state = LOWER_CASE;			}				for(int i = 1; i < str.length(); i++)			{				ch = str.charAt(i);				if(!Character.isLetter(ch))					continue;					switch(state)				{				case UPPER_CASE:					if(Character.isLowerCase(ch))					{						if(i == 1)							state = TITLE_CASE;						else							return MIXED;					}					break;				case LOWER_CASE:				case TITLE_CASE:					if(Character.isUpperCase(ch))						return MIXED;					break;				}			}				return state;		}	
/**		 * Converts the specified string to title case, by capitalizing the		 * first letter.		 * @param str The string		 * @since jEdit 4.0pre1		 */		public static String toTitleCase(String str)		{			if(str.length() == 0)				return str;			else			{				return Character.toUpperCase(str.charAt(0))					+ str.substring(1).toLowerCase();			}		}	
private static void formatParagraph(String text, int maxLineLength,			int tabSize, StringBuilder buf)		{			// align everything to paragraph's leading indent			int leadingWhitespaceCount = StandardUtilities.getLeadingWhiteSpace(text);			String leadingWhitespace = text.substring(0,leadingWhitespaceCount);			int leadingWhitespaceWidth = StandardUtilities.getLeadingWhiteSpaceWidth(text,tabSize);				buf.append(leadingWhitespace);				int lineLength = leadingWhitespaceWidth;			StringTokenizer st = new StringTokenizer(text);			while(st.hasMoreTokens())			{				String word = st.nextToken();				if(lineLength == leadingWhitespaceWidth)				{					// do nothing				}				else if(lineLength + word.length() + 1 > maxLineLength)				{					buf.append('\n');					buf.append(leadingWhitespace);					lineLength = leadingWhitespaceWidth;				}				else				{					buf.append(' ');					lineLength++;				}				buf.append(word);				lineLength += word.length();			}		}	
public static void indexIgnoringWhitespace(String text, int maxLineLength,			int tabSize, StringBuffer buf)		{			// align everything to paragraph's leading indent			int leadingWhitespaceCount = StandardUtilities.getLeadingWhiteSpace(text);			String leadingWhitespace = text.substring(0,leadingWhitespaceCount);			int leadingWhitespaceWidth = StandardUtilities.getLeadingWhiteSpaceWidth(text,tabSize);				buf.append(leadingWhitespace);				int lineLength = leadingWhitespaceWidth;			StringTokenizer st = new StringTokenizer(text);			while(st.hasMoreTokens())			{				String word = st.nextToken();				if(lineLength == leadingWhitespaceWidth)				{					// do nothing				}				else if(lineLength + word.length() + 1 > maxLineLength)				{					buf.append('\n');					buf.append(leadingWhitespace);					lineLength = leadingWhitespaceWidth;				}				else				{					buf.append(' ');					lineLength++;				}				buf.append(word);				lineLength += word.length();			}		}	
/**	        getThis() is a factory for bsh.This type references.  The capabilities	        of ".this" references in bsh are version dependent up until jdk1.3.	        The version dependence was to support different default interface	        implementations.  i.e. different sets of listener interfaces which	        scripted objects were capable of implementing.  In jdk1.3 the	        reflection proxy mechanism was introduced which allowed us to	        implement arbitrary interfaces.  This is fantastic.		        A This object is a thin layer over a namespace, comprising a bsh object	        context.  We create it here only if needed for the namespace.		        Note: this method could be considered slow because of the way it	        dynamically factories objects.  However I've also done tests where	        I hard-code the factory to return JThis and see no change in the	        rough test suite time.  This references are also cached in NameSpace.	    */	    static This getThis(	        NameSpace namespace, Interpreter declaringInterpreter )	    {	        try {	            Class c;	            if ( Capabilities.canGenerateInterfaces() )	                c = Class.forName( "org.gjt.sp.jedit.bsh.XThis" );	            else if ( Capabilities.haveSwing() )	                c = Class.forName( "org.gjt.sp.jedit.bsh.JThis" );	            else	                return new This( namespace, declaringInterpreter );		            return (This)Reflect.constructObject( c,	                new Object [] { namespace, declaringInterpreter } );		        } catch ( Exception e ) {	            throw new InterpreterError("internal error 1 in This: "+e);	        }	    }	
/**	        Get a version of this scripted object implementing the specified	        interface.	    */	    /*	        If this type of This implements it directly return this,	        else try complain that we don't have the proxy mechanism.	    */	    public Object getInterface( Class clas )	        throws UtilEvalError	    {	        if ( clas.isInstance( this ) )	            return this;	        else	            throw new UtilEvalError( "Dynamic proxy mechanism not available. "	            + "Cannot construct interface type: "+clas );	    }	
/**	        Get a version of this scripted object implementing the specified	        interfaces.	    */	    public Object getInterface( Class [] ca )	        throws UtilEvalError	    {	        for(int i=0; i<ca.length; i++)	            if ( !(ca[i].isInstance( this )) )	                throw new UtilEvalError(	                    "Dynamic proxy mechanism not available. "	                    + "Cannot construct interface type: "+ca[i] );		        return this;	    }	
protected This( NameSpace namespace, Interpreter declaringInterpreter ) {	        this.namespace = namespace;	        this.declaringInterpreter = declaringInterpreter;	        //initCallStack( namespace );	    }	
public NameSpace getNameSpace() {	        return namespace;	    }	
public String toString() {	        return "'this' reference to Bsh object: " + namespace;	    }	
public void run() {	        try {	            invokeMethod( "run", new Object[0] );	        } catch( EvalError e ) {	            declaringInterpreter.error(	                "Exception in runnable:" + e );	        }	    }	
/**	        Invoke specified method as from outside java code, using the	        declaring interpreter and current namespace.	        The call stack will indicate that the method is being invoked from	        outside of bsh in native java code.	        Note: you must still wrap/unwrap args/return values using	        Primitive/Primitive.unwrap() for use outside of BeanShell.	        @see org.gjt.sp.jedit.bsh.Primitive	    */	    public Object invokeMethod( String name, Object [] args )	        throws EvalError	    {	        // null callstack, one will be created for us	        return invokeMethod(	            name, args, null/*declaringInterpreter*/, null, null,	            false/*declaredOnly*/ );	    }	
/**	        Invoke a method in this namespace with the specified args,	        interpreter reference, callstack, and caller info.	        <p>		        Note: If you use this method outside of the bsh package and wish to	        use variables with primitive values you will have to wrap them using	        bsh.Primitive.  Consider using This getInterface() to make a true Java	        interface for invoking your scripted methods.	        <p>		        This method also implements the default object protocol of toString(),	        hashCode() and equals() and the invoke() meta-method handling as a	        last resort.	        <p>		        Note: The invoke() meta-method will not catch the Object protocol	        methods (toString(), hashCode()...).  If you want to override them you	        have to script them directly.	        <p>		        @see org.gjt.sp.jedit.bsh.This#invokeMethod(String methodName, Object [] args, Interpreter interpreter, CallStack callstack, SimpleNode callerInfo, boolean declaredOnly ) invokeMethod	        @param callstack if callStack is null a new CallStack will be created and	            initialized with this namespace.	        @param declaredOnly if true then only methods declared directly in the	            namespace will be visible - no inherited or imported methods will	            be visible.	        @see org.gjt.sp.jedit.bsh.Primitive Primitive	    */	    /*	        invokeMethod() here is generally used by outside code to callback	        into the bsh interpreter. e.g. when we are acting as an interface	        for a scripted listener, etc.  In this case there is no real call stack	        so we make a default one starting with the special JAVACODE namespace	        and our namespace as the next.	    */	    public Object invokeMethod(	        String methodName, Object [] args,	        Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,	        boolean declaredOnly  )	        throws EvalError	    {	        /*	            Wrap nulls.	            This is a bit of a cludge to address a deficiency in the class	            generator whereby it does not wrap nulls on method delegate.  See	            Class Generator.java.  If we fix that then we can remove this.	            (just have to generate the code there.)	        */	        if ( args != null )	        {	            Object [] oa = new Object [args.length];	            for(int i=0; i<args.length; i++)	                oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );	            args = oa;	        }		        if ( interpreter == null )	            interpreter = declaringInterpreter;	        if ( callstack == null )	            callstack = new CallStack( namespace );	        if ( callerInfo == null )	            callerInfo = SimpleNode.JAVACODE;		        // Find the bsh method	        Class [] types = Types.getTypes( args );	        BshMethod bshMethod = null;	        try {	            bshMethod = namespace.getMethod( methodName, types, declaredOnly );	        } catch ( UtilEvalError e ) {	            // leave null	        }		        if ( bshMethod != null )	            return bshMethod.invoke( args, interpreter, callstack, callerInfo );		        /*	            No scripted method of that name.	            Implement the required part of the Object protocol:	                public int hashCode();	                public boolean equals(java.lang.Object);	                public java.lang.String toString();	            if these were not handled by scripted methods we must provide	            a default impl.	        */	        // a default toString() that shows the interfaces we implement	        if ( methodName.equals("toString" ) )	            return toString();		        // a default hashCode()	        if ( methodName.equals("hashCode" ) )	            return new Integer(this.hashCode());		        // a default equals() testing for equality with the This reference	        if ( methodName.equals("equals" ) ) {	            Object obj = args[0];	            return new Boolean( this == obj );	        }		        // Look for a default invoke() handler method in the namespace	        // Note: this code duplicates that in NameSpace getCommand()	        // is that ok?	        try {	            bshMethod = namespace.getMethod(	                "invoke", new Class [] { null, null } );	        } catch ( UtilEvalError e ) { /*leave null*/ }		        // Call script "invoke( String methodName, Object [] args );	        if ( bshMethod != null )	            return bshMethod.invoke( new Object [] { methodName, args },	                interpreter, callstack, callerInfo );		        throw new EvalError("Method " +	            StringUtil.methodString( methodName, types ) +	            " not found in bsh scripted object: "+ namespace.getName(),	            callerInfo, callstack );	    }	
/**	        Bind a This reference to a parent's namespace with the specified	        declaring interpreter.  Also re-init the callstack.  It's necessary	        to bind a This reference before it can be used after deserialization.	        This is used by the bsh load() command.	        <p>		        This is a static utility method because it's used by a bsh command	        bind() and the interpreter doesn't currently allow access to direct	        methods of This objects (small hack)	    */	    public static void bind(	        This ths, NameSpace namespace, Interpreter declaringInterpreter )	    {	        ths.namespace.setParent( namespace );	        ths.declaringInterpreter = declaringInterpreter;	    }	
/**	        Allow invocations of these method names on This type objects.	        Don't give bsh.This a chance to override their behavior.	        <p>		        If the method is passed here the invocation will actually happen on	        the bsh.This object via the regular reflective method invocation	        mechanism.  If not, then the method is evaluated by bsh.This itself	        as a scripted method call.	    */	    static boolean isExposedThisMethod( String name )	    {	        return	            name.equals("getClass")	            || name.equals("invokeMethod")	            || name.equals("getInterface")	            // These are necessary to let us test synchronization from scripts	            || name.equals("wait")	            || name.equals("notify")	            || name.equals("notifyAll");	    }	
public TipOfTheDay(View view)		{			super(view,jEdit.getProperty("tip.title"),false);				JPanel content = new JPanel(new BorderLayout(12,12));			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				JLabel label = new JLabel(jEdit.getProperty("tip.caption"));			label.setFont(new Font("SansSerif",Font.PLAIN,24));			label.setForeground(UIManager.getColor("Button.foreground"));			content.add(BorderLayout.NORTH,label);				tipText = new JEditorPane();			tipText.setEditable(false);			tipText.setContentType("text/html");				nextTip();				JScrollPane scroller = new JScrollPane(tipText);			scroller.setPreferredSize(new Dimension(150,150));			content.add(BorderLayout.CENTER,scroller);				ActionHandler actionHandler = new ActionHandler();				Box buttons = new Box(BoxLayout.X_AXIS);				showNextTime = new JCheckBox(jEdit.getProperty("tip.show-next-time"),				jEdit.getBooleanProperty("tip.show"));			showNextTime.addActionListener(actionHandler);			buttons.add(showNextTime);				buttons.add(Box.createHorizontalStrut(6));			buttons.add(Box.createGlue());				nextTip = new JButton(jEdit.getProperty("tip.next-tip"));			nextTip.addActionListener(actionHandler);			buttons.add(nextTip);				buttons.add(Box.createHorizontalStrut(6));				close = new JButton(jEdit.getProperty("common.close"));			close.addActionListener(actionHandler);			buttons.add(close);			content.getRootPane().setDefaultButton(close);				Dimension dim = nextTip.getPreferredSize();			dim.width = Math.max(dim.width,close.getPreferredSize().width);			nextTip.setPreferredSize(dim);			close.setPreferredSize(dim);				content.add(BorderLayout.SOUTH,buttons);				setDefaultCloseOperation(DISPOSE_ON_CLOSE);			pack();			setLocationRelativeTo(view);			setVisible(true);		}	
public void ok()		{			dispose();		}	
public void cancel()		{			dispose();		}	
private void nextTip()		{			File[] tips = new File(MiscUtilities.constructPath(				jEdit.getJEditHome(),"doc","tips")).listFiles();			if(tips == null || tips.length == 0)			{				tipText.setText(jEdit.getProperty("tip.not-found"));				return;			}				int count = tips.length;				// so that we don't see the same tip again if the user			// clicks 'Next Tip'			int tipToShow = currentTip;			while(tipToShow == currentTip || !tips[tipToShow].getName().endsWith(".html"))				tipToShow = (new Random().nextInt(Integer.MAX_VALUE)) % count;			try			{				tipText.setPage(tips[tipToShow].toURI().toURL());			}			catch(Exception e)			{				Log.log(Log.ERROR,this,e);			}		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == showNextTime)				{					jEdit.setBooleanProperty("tip.show",showNextTime						.isSelected());				}				else if(source == nextTip)					nextTip();				else if(source == close)					dispose();			}	
/**	   * Returns the image.	   */	  public String toString()	  {	     return image;	  }	
/**	   * Returns a new Token object, by default. However, if you want, you	   * can create and return subclass objects based on the value of ofKind.	   * Simply add the cases to the switch for all those special cases.	   * For example, if you have a subclass of Token called IDToken that	   * you want to create if ofKind is ID, simlpy add something like :	   *	   *    case MyParserConstants.ID : return new IDToken();	   *	   * to the following switch statement. Then you can cast matchedToken	   * variable to the appropriate type and use it in your lexical actions.	   */	  public static final Token newToken(int ofKind)	  {	     switch(ofKind)	     {	       default : return new Token();	     }	  }	
/**		 * Converts a token type string to a token type constant.		 * @param value The token type		 * @since jEdit 4.1pre1		 */		public static byte stringToToken(String value)		{			try			{				Field f = Token.class.getField(value);				return f.getByte(null);			}			catch(Exception e)			{				return -1;			}		}	
/**		 * Converts a token type constant to a token type string.		 * @since jEdit 4.2pre1		 */		public static String tokenToString(byte token)		{			return (token == Token.END) ? "END" : TOKEN_TYPES[token];		}	
/**		 * Creates a new token.		 * @param id The id of the token		 * @param offset The start offset of the token		 * @param length The length of the token		 * @param rules The parser rule set that generated this token		 */		public Token(byte id, int offset, int length, ParserRuleSet rules)		{			this.id = id;			this.offset = offset;			this.length = length;			this.rules = rules;		}	
/**		 * Returns a string representation of this token.		 */		public String toString()		{			return "[id=" + id + ",offset=" + offset + ",length=" + length + "]";		}	
public TokenMarker()		{}	
public void addRuleSet(ParserRuleSet rules)		{			ruleSets.put(rules.getSetName(), rules);				if (rules.getSetName().equals("MAIN"))				mainRuleSet = rules;		}	
public ParserRuleSet getMainRuleSet()		{			return mainRuleSet;		}	
public ParserRuleSet getRuleSet(String setName)		{			return ruleSets.get(setName);		}	
/**		 * @since jEdit 4.2pre3		 */		public ParserRuleSet[] getRuleSets()		{			return ruleSets.values().toArray(new ParserRuleSet[ruleSets.size()]);		}	
/**		 * Do not call this method directly; call Buffer.markTokens() instead.		 *		 * @param prevContext the context of the previous line, it can be null		 * @param tokenHandler the token handler		 * @param line a segment containing the content of the line		 */		public synchronized LineContext markTokens(LineContext prevContext,			TokenHandler tokenHandler, Segment line)		{			//{{{ Set up some instance variables			// this is to avoid having to pass around lots and lots of			// parameters.			this.tokenHandler = tokenHandler;			this.line = line;				lastOffset = line.offset;			lineLength = line.count + line.offset;				context = new LineContext();				if(prevContext == null)			{				context.rules = getMainRuleSet();				context.escapeRule = context.rules.getEscapeRule();			}			else			{				context.parent = prevContext.parent;				context.setInRule(prevContext.inRule);				context.rules = prevContext.rules;				context.spanEndSubst = prevContext.spanEndSubst;			}				keywords = context.rules.getKeywords();				seenWhitespaceEnd = false;			whitespaceEnd = line.offset;			//}}}				//{{{ Main parser loop			int terminateChar = context.rules.getTerminateChar();			boolean terminated = false;	main_loop:	for(pos = line.offset; pos < lineLength; pos++)			{				//{{{ check if we have to stop parsing (happens if the terminateChar has been exceeded)				if(terminateChar >= 0 && pos - line.offset >= terminateChar					&& !terminated)				{					terminated = true;					context = new LineContext(ParserRuleSet						.getStandardRuleSet(context.rules						.getDefault()),context);					keywords = context.rules.getKeywords();				} //}}}					//{{{ Check for the escape rule before anything else.				if (context.escapeRule != null &&					handleRule(context.escapeRule,false))				{					continue main_loop;				} //}}}					//{{{ check for end of delegate				if (context.parent != null				    && context.parent.inRule != null				    && checkDelegateEnd(context.parent.inRule))				{					seenWhitespaceEnd = true;					continue main_loop;				} //}}}					//{{{ check every rule				Character ch = Character.valueOf(line.array[pos]);				List<ParserRule> rules = context.rules.getRules(ch);				for (ParserRule rule : rules)				{					// stop checking rules if there was a match					if (handleRule(rule,false))					{						seenWhitespaceEnd = true;						continue main_loop;					}				} //}}}					//{{{ check if current character is a word separator				if(Character.isWhitespace(ch))				{					if(!seenWhitespaceEnd)						whitespaceEnd = pos + 1;						if(context.inRule != null)						handleRule(context.inRule,true);						handleNoWordBreak();						markKeyword(false);						if(lastOffset != pos)					{						tokenHandler.handleToken(line,							context.rules.getDefault(),							lastOffset - line.offset,							pos - lastOffset,							context);					}						tokenHandler.handleToken(line,						context.rules.getDefault(),						pos - line.offset,1,context);					lastOffset = pos + 1;				}				else				{					if(keywords != null || context.rules.getRuleCount() != 0)					{						String noWordSep = context.rules.getNoWordSep();							if(!Character.isLetterOrDigit(ch)							&& noWordSep.indexOf(ch) == -1)						{							if(context.inRule != null)								handleRule(context.inRule,true);								handleNoWordBreak();								markKeyword(true);								tokenHandler.handleToken(line,								context.rules.getDefault(),								lastOffset - line.offset,1,								context);							lastOffset = pos + 1;						}					}						seenWhitespaceEnd = true;				} //}}}			} //}}}				//{{{ Mark all remaining characters			pos = lineLength;				if(context.inRule != null)				handleRule(context.inRule,true);				handleNoWordBreak();			markKeyword(true);			//}}}				//{{{ Unwind any NO_LINE_BREAK parent delegates	unwind:		while(context.parent != null)			{				ParserRule rule = context.parent.inRule;				if((rule != null && (rule.action					& ParserRule.NO_LINE_BREAK) == ParserRule.NO_LINE_BREAK)					|| terminated)				{					context = context.parent;					keywords = context.rules.getKeywords();					context.setInRule(null);				}				else					break unwind;			} //}}}				tokenHandler.handleToken(line,Token.END,				pos - line.offset,0,context);				context = context.intern();			tokenHandler.setLineContext(context);				/* for GC. */			this.tokenHandler = null;			this.line = null;				return context;		}	
private boolean checkDelegateEnd(ParserRule rule)		{			if(rule.end == null)				return false;				LineContext tempContext = context;			context = context.parent;			keywords = context.rules.getKeywords();			boolean handled = handleRule(rule,true);			context = tempContext;			keywords = context.rules.getKeywords();				if (handled)			{				if(context.inRule != null)					handleRule(context.inRule,true);					markKeyword(true);					context = (LineContext)context.parent.clone();					tokenHandler.handleToken(line,					matchToken(context.inRule, context.inRule, context),					pos - line.offset,pattern.count,context);					keywords = context.rules.getKeywords();				context.setInRule(null);				lastOffset = pos + pattern.count;					// move pos to last character of match sequence				pos += pattern.count - 1;					return true;			}				return false;		}	
/**		 * Checks if the rule matches the line at the current position		 * and handles the rule if it does match		 */		private boolean handleRule(ParserRule checkRule, boolean end)		{			//{{{ Some rules can only match in certain locations			if(!end)			{				if (null == checkRule.upHashChars)				{					if (checkRule.upHashChar != null &&					    (pos + checkRule.upHashChar.length() < line.array.length) &&					    !checkHashString(checkRule))					{						return false;					}				}				else				{					if (-1 == Arrays.binarySearch(							checkRule.upHashChars,							Character.toUpperCase(line.array[pos])))					{						return false;					}				}			}				int offset = (checkRule.action & ParserRule.MARK_PREVIOUS) != 0 ? lastOffset : pos;			int posMatch = end ? checkRule.endPosMatch : checkRule.startPosMatch;				if((posMatch & ParserRule.AT_LINE_START)				== ParserRule.AT_LINE_START)			{				if(offset != line.offset)				{					return false;				}			}			else if((posMatch & ParserRule.AT_WHITESPACE_END)				== ParserRule.AT_WHITESPACE_END)			{				if(offset != whitespaceEnd)				{					return false;				}			}			else if((posMatch & ParserRule.AT_WORD_START)				== ParserRule.AT_WORD_START)			{				if(offset != lastOffset)				{					return false;				}			} //}}}				int matchedChars = 1;			CharSequence charSeq = null;			Matcher match = null;				//{{{ See if the rule's start or end sequence matches here			if(!end || (checkRule.action & ParserRule.MARK_FOLLOWING) == 0)			{				// the end cannot be a regular expression				if((checkRule.action & ParserRule.REGEXP) == 0 || end)				{					if(end)					{						if(context.spanEndSubst != null)							pattern.array = context.spanEndSubst;						else							pattern.array = checkRule.end;					}					else						pattern.array = checkRule.start;					pattern.offset = 0;					pattern.count = pattern.array.length;					matchedChars = pattern.count;						if(!SyntaxUtilities.regionMatches(context.rules						.getIgnoreCase(),line,pos,pattern.array))					{						return false;					}				}				else				{					// note that all regexps start with \A so they only					// match the start of the string					//int matchStart = pos - line.offset;					charSeq = new SegmentCharSequence(line, pos - line.offset,									  line.count - (pos - line.offset));					match = checkRule.startRegexp.matcher(charSeq);					if(!match.lookingAt())					{						return false;					}					else if(match.start() != 0)					{						throw new InternalError("Can't happen");					}					else					{						matchedChars = match.end();						/* workaround for hang if match was						 * zero-width. not sure if there is						 * a better way to handle this */						if(matchedChars == 0)							matchedChars = 1;					}				}			} //}}}			//{{{ Check for an escape sequence			if((checkRule.action & ParserRule.IS_ESCAPE) == ParserRule.IS_ESCAPE)			{				pos += pattern.count;			} //}}}			//{{{ Handle start of rule			else if(!end)			{				if(context.inRule != null)					handleRule(context.inRule,true);					markKeyword((checkRule.action & ParserRule.MARK_PREVIOUS)					!= ParserRule.MARK_PREVIOUS);					switch(checkRule.action & ParserRule.MAJOR_ACTIONS)				{				//{{{ SEQ				case ParserRule.SEQ:					context.spanEndSubst = null;						if((checkRule.action & ParserRule.REGEXP) != 0)					{						handleTokenWithSpaces(tokenHandler,							checkRule.token,							pos - line.offset,							matchedChars,							context);					}					else					{						tokenHandler.handleToken(line,							checkRule.token,							pos - line.offset,							matchedChars,context);					}						// a DELEGATE attribute on a SEQ changes the					// ruleset from the end of the SEQ onwards					if(checkRule.delegate != null)					{						context = new LineContext(							checkRule.delegate,							context.parent);						keywords = context.rules.getKeywords();					}					break;				//}}}				//{{{ SPAN, EOL_SPAN				case ParserRule.SPAN:				case ParserRule.EOL_SPAN:					context.setInRule(checkRule);						byte tokenType = matchToken(checkRule,								context.inRule, context);						if((checkRule.action & ParserRule.REGEXP) != 0)					{						handleTokenWithSpaces(tokenHandler,							tokenType,							pos - line.offset,							matchedChars,							context);					}					else					{						tokenHandler.handleToken(line,tokenType,							pos - line.offset,							matchedChars,context);					}						char[] spanEndSubst = null;					/* substitute result of matching the rule start					 * into the end string.					 *					 * eg, in shell script mode, <<\s*(\w+) is					 * matched into \<$1\> to construct rules for					 * highlighting read-ins like this <<EOF					 * ...					 * EOF					 */					if(charSeq != null && checkRule.end != null)					{						spanEndSubst = substitute(match,							checkRule.end);					}						context.spanEndSubst = spanEndSubst;					context = new LineContext(						checkRule.delegate,						context);					keywords = context.rules.getKeywords();						break;				//}}}				//{{{ MARK_FOLLOWING				case ParserRule.MARK_FOLLOWING:					tokenHandler.handleToken(line,						matchToken(checkRule, checkRule, context),						pos - line.offset,						pattern.count,context);						context.spanEndSubst = null;					context.setInRule(checkRule);					break;				//}}}				//{{{ MARK_PREVIOUS				case ParserRule.MARK_PREVIOUS:					context.spanEndSubst = null;						if(pos != lastOffset)					{						tokenHandler.handleToken(line,							checkRule.token,							lastOffset - line.offset,							pos - lastOffset,							context);					}						tokenHandler.handleToken(line,						matchToken(checkRule, checkRule, context),						pos - line.offset,pattern.count,						context);						break;				//}}}				default:					throw new InternalError("Unhandled major action");				}					// move pos to last character of match sequence				pos += matchedChars - 1;				lastOffset = pos + 1;					// break out of inner for loop to check next char			} //}}}			//{{{ Handle end of MARK_FOLLOWING			else if((context.inRule.action & ParserRule.MARK_FOLLOWING) != 0)			{				if(pos != lastOffset)				{					tokenHandler.handleToken(line,						context.inRule.token,						lastOffset - line.offset,						pos - lastOffset,context);				}					lastOffset = pos;				context.setInRule(null);			} //}}}				return true;		}	
private void handleNoWordBreak()		{			if(context.parent != null)			{				ParserRule rule = context.parent.inRule;				if(rule != null && (context.parent.inRule.action					& ParserRule.NO_WORD_BREAK) != 0)				{					if(pos != lastOffset)					{						tokenHandler.handleToken(line,							rule.token,							lastOffset - line.offset,							pos - lastOffset,context);					}						lastOffset = pos;					context = context.parent;					keywords = context.rules.getKeywords();					context.setInRule(null);				}			}		}	
private void handleTokenWithSpaces(TokenHandler tokenHandler,			byte tokenType, int start, int len, LineContext context)		{			int last = start;			int end = start + len;				for(int i = start; i < end; i++)			{				if(Character.isWhitespace(line.array[i + line.offset]))				{					if(last != i)					{						tokenHandler.handleToken(line,						tokenType,last,i - last,context);					}					tokenHandler.handleToken(line,tokenType,i,1,context);					last = i + 1;				}			}				if(last != end)			{				tokenHandler.handleToken(line,tokenType,last,					end - last,context);			}		}	
private void markKeyword(boolean addRemaining)		{			int len = pos - lastOffset;			if(len == 0)				return;				//{{{ Do digits			if(context.rules.getHighlightDigits())			{				boolean digit = false;				boolean mixed = false;					for(int i = lastOffset; i < pos; i++)				{					char ch = line.array[i];					if(Character.isDigit(ch))						digit = true;					else						mixed = true;				}					if(mixed)				{					Pattern digitRE = context.rules.getDigitRegexp();						// only match against regexp if its not all					// digits; if all digits, no point matching					if(digit)					{						if(digitRE == null)						{							// mixed digit/alpha keyword,							// and no regexp... don't							// highlight as DIGIT							digit = false;						}						else						{							int oldCount = line.count;							int oldOffset = line.offset;							line.offset = lastOffset;							line.count = len;							CharSequence seq = new SegmentCharSequence(line);							digit = digitRE.matcher(seq).matches();							line.offset = oldOffset;							line.count = oldCount;						}					}				}					if(digit)				{					tokenHandler.handleToken(line,Token.DIGIT,						lastOffset - line.offset,						len,context);					lastOffset = pos;						return;				}			} //}}}				//{{{ Do keywords			if(keywords != null)			{				byte id = keywords.lookup(line, lastOffset, len);					if(id != Token.NULL)				{					tokenHandler.handleToken(line,id,						lastOffset - line.offset,						len,context);					lastOffset = pos;					return;				}			} //}}}				//{{{ Handle any remaining crud			if(addRemaining)			{				tokenHandler.handleToken(line,context.rules.getDefault(),					lastOffset - line.offset,len,context);				lastOffset = pos;			} //}}}		}	
private static char[] substitute(Matcher match, char[] end)		{			StringBuilder buf = new StringBuilder();			for(int i = 0; i < end.length; i++)			{				char ch = end[i];				if(ch == '$' || ch == '~')				{					if(i == end.length - 1)						buf.append(ch);					else					{						char digit = end[i + 1];						if(!Character.isDigit(digit))							buf.append(ch);						else if (ch == '$')						{							buf.append(match.group(								digit - '0'));							i++;						}						else						{							String s = match.group(digit - '0');							if (s.length() == 1)							{								char b = TextUtilities.getComplementaryBracket(s.charAt(0), null);								if (b == '\0')									b = s.charAt(0);								buf.append(b);							}							else								buf.append(ch);							i++;						}					}				}				else					buf.append(ch);			}				char[] returnValue = new char[buf.length()];			buf.getChars(0,buf.length(),returnValue,0);			return returnValue;		}	
private byte matchToken(ParserRule rule, ParserRule base, LineContext ctx)		{			switch (rule.matchType)			{				case ParserRule.MATCH_TYPE_RULE:					return base.token;					case ParserRule.MATCH_TYPE_CONTEXT:					return context.rules.getDefault();					default:					return rule.matchType;			}		}	
private boolean checkHashString(ParserRule rule)		{			for (int i = 0; i < rule.upHashChar.length(); i++)			{				if (Character.toUpperCase(line.array[pos+i]) != rule.upHashChar.charAt(i))				{					return false;				}			}			return true;		}	
public LineContext(ParserRuleSet rs, LineContext lc)			{				rules = rs;				parent = (lc == null ? null : (LineContext)lc.clone());				/*				 * SPANs with no delegate need to propagate the				 * escape rule to the child context, so this is				 * needed.				 */				if (rs.getModeName() != null)					escapeRule = rules.getEscapeRule();				else					escapeRule = lc.escapeRule;			}	
public LineContext()			{			}	
public LineContext intern()			{				LineContext obj = intern.get(this);				if(obj == null)				{					intern.put(this,this);					return this;				}				else					return obj;			}	
public int hashCode()			{				if(inRule != null)					return inRule.hashCode();				else if(rules != null)					return rules.hashCode();				else					return 0;			}	
public boolean equals(Object obj)			{				if(obj instanceof LineContext)				{					LineContext lc = (LineContext)obj;					return lc.inRule == inRule && lc.rules == rules						&& StandardUtilities.objectsEqual(parent,lc.parent)						&& charArraysEqual(spanEndSubst,lc.spanEndSubst);				}				else					return false;			}	
public Object clone()			{				LineContext lc = new LineContext();				lc.inRule = inRule;				lc.rules = rules;				lc.parent = (parent == null) ? null : (LineContext) parent.clone();				lc.spanEndSubst = spanEndSubst;				lc.escapeRule = escapeRule;					return lc;			}	
private static boolean charArraysEqual(char[] c1, char[] c2)			{				if(c1 == null)					return c2 == null;					// c1 is not null				if(c2 == null)					return false;					if(c1.length != c2.length)					return false;					for(int i = 0; i < c1.length; i++)				{					if(c1[i] != c2[i])						return false;				}					return true;			}	
/**			 * Sets the current rule being processed and adjusts the			 * escape rule for the context based on the rule.			 */			public void setInRule(ParserRule rule)			{				inRule = rule;				if (rule != null && rule.escapeRule != null)					escapeRule = rule.escapeRule;				else if (rules != null && rules.getModeName() != null)					escapeRule = rules.getEscapeRule();				else if (parent != null)					escapeRule = parent.escapeRule;				else					escapeRule = null;			}	
/**	    * Replaces unprintable characters by their espaced (or unicode escaped)	    * equivalents in the given string	    */	   protected static final String addEscapes(String str) {		  StringBuilder retval = new StringBuilder();	      char ch;	      for (int i = 0; i < str.length(); i++) {	        switch (str.charAt(i))	        {	           case 0 :	              continue;	           case '\b':	              retval.append("\\b");	              continue;	           case '\t':	              retval.append("\\t");	              continue;	           case '\n':	              retval.append("\\n");	              continue;	           case '\f':	              retval.append("\\f");	              continue;	           case '\r':	              retval.append("\\r");	              continue;	           case '\"':	              retval.append("\\\"");	              continue;	           case '\'':	              retval.append("\\\'");	              continue;	           case '\\':	              retval.append("\\\\");	              continue;	           default:	              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {	                 String s = "0000" + Integer.toString(ch, 16);	                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));	              } else {	                 retval.append(ch);	              }	              continue;	        }	      }	      return retval.toString();	   }	
/**	    * Returns a detailed message for the Error when it is thrown by the	    * token manager to indicate a lexical error.	    * Parameters : 	    *    EOFSeen     : indicates if EOF caused the lexicl error	    *    curLexState : lexical state in which this error occured	    *    errorLine   : line number when the error occured	    *    errorColumn : column number when the error occured	    *    errorAfter  : prefix that was seen before this error occured	    *    curchar     : the offending character	    * Note: You can customize the lexical error message by modifying this method.	    */	   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {	      return("Lexical error at line " +	           errorLine + ", column " +	           errorColumn + ".  Encountered: " +	           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +	           "after : \"" + addEscapes(errorAfter) + "\"");	   }	
/**	    * You can also modify the body of this method to customize your error messages.	    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not	    * of end-users concern, so you can return something like : 	    *	    *     "Internal Error : Please file a bug report .... "	    *	    * from this method for such cases in the release version of your parser.	    */	   public String getMessage() {	      return super.getMessage();	   }	
public TokenMgrError() {	   }	
public TokenMgrError(String message, int reason) {	      super(message);	      errorCode = reason;	   }	
public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {	      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);	   }	
public ToolBarManager(Container top, Container bottom)		{			this.top = top;			this.bottom = bottom;		}	
public void addToolBar(int group, int layer, Component toolbar)		{			Entry entry = new Entry(layer, toolbar);				if (group == View.TOP_GROUP)				addToolBar(top, topToolBars, entry);			else if (group == View.BOTTOM_GROUP)				addToolBar(bottom, bottomToolBars, entry);			else				throw new InternalError("Invalid tool bar group");		}	
public void removeToolBar(Component toolbar)		{			removeToolBar(top, topToolBars, toolbar);			removeToolBar(bottom, bottomToolBars, toolbar);		}	
private static void addToolBar(Container group, List<Entry> toolbars,			Entry entry)		{			// See if we should place this toolbar before any others			for(int i = 0; i < toolbars.size(); i++)			{				if(entry.layer > toolbars.get(i).layer)				{					toolbars.add(i,entry);					group.add(entry.toolbar,i);					return;				}			}				// Place the toolbar at the bottom of the group			toolbars.add(entry);			group.add(entry.toolbar);		}	
private static void removeToolBar(Container group, List<Entry> toolbars,			Component toolbar)		{			for(int i = 0; i < toolbars.size(); i++)			{				if(toolbar == toolbars.get(i).toolbar)				{					group.remove(toolbar);					toolbars.remove(i);						return;				}			}		}	
Entry(int layer, Component toolbar)			{				this.layer = layer;				this.toolbar = toolbar;			}	
public ToolBarOptionPane()		{			super("toolbar");		}	
protected void _init()		{			setLayout(new BorderLayout());				JPanel panel = new JPanel(new GridLayout(2,1));				/* Show toolbar */			showToolbar = new JCheckBox(jEdit.getProperty(				"options.toolbar.showToolbar"));			showToolbar.setSelected(jEdit.getBooleanProperty("view.showToolbar"));			panel.add(showToolbar);				panel.add(new JLabel(jEdit.getProperty(				"options.toolbar.caption")));				add(BorderLayout.NORTH,panel);				listModel = new DefaultListModel();			reloadButtonList(jEdit.getProperty("view.toolbar"));						list = new JList(listModel);			list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			list.addListSelectionListener(new ListHandler());			list.setCellRenderer(new ButtonCellRenderer());				add(BorderLayout.CENTER,new JScrollPane(list));				//{{{ Create buttons			JPanel buttons = new JPanel();			buttons.setBorder(new EmptyBorder(3,0,0,0));			buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));			ActionHandler actionHandler = new ActionHandler();			add = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.toolbar.add.icon")));			add.setToolTipText(jEdit.getProperty("options.toolbar.add"));			add.addActionListener(actionHandler);			buttons.add(add);			buttons.add(Box.createHorizontalStrut(6));			remove = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.toolbar.remove.icon")));			remove.setToolTipText(jEdit.getProperty("options.toolbar.remove"));			remove.addActionListener(actionHandler);			buttons.add(remove);			buttons.add(Box.createHorizontalStrut(6));			moveUp = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.toolbar.moveUp.icon")));			moveUp.setToolTipText(jEdit.getProperty("options.toolbar.moveUp"));			moveUp.addActionListener(actionHandler);			buttons.add(moveUp);			buttons.add(Box.createHorizontalStrut(6));			moveDown = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.toolbar.moveDown.icon")));			moveDown.setToolTipText(jEdit.getProperty("options.toolbar.moveDown"));			moveDown.addActionListener(actionHandler);			buttons.add(moveDown);			buttons.add(Box.createHorizontalStrut(6));			edit = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.toolbar.edit.icon")));			edit.setToolTipText(jEdit.getProperty("options.toolbar.edit"));			edit.addActionListener(actionHandler);			buttons.add(edit);			buttons.add(Box.createGlue());						// add "reset to defaults" button			reset = new RolloverButton(GUIUtilities.loadIcon(jEdit.getProperty("options.toolbar.reset.icon")));			reset.setToolTipText(jEdit.getProperty("options.toolbar.reset"));			reset.addActionListener(actionHandler);			buttons.add(reset);			//}}}				updateButtons();			add(BorderLayout.SOUTH,buttons);				//{{{ Ceate icons list			iconList = new DefaultComboBoxModel();			StringTokenizer st = new StringTokenizer(jEdit.getProperty("icons"));			while(st.hasMoreElements())			{				String icon = st.nextToken();				iconList.addElement(new IconListEntry(					GUIUtilities.loadIcon(icon),icon));			} //}}}		}	
protected void _save()		{			jEdit.setBooleanProperty("view.showToolbar",showToolbar				.isSelected());				StringBuilder buf = new StringBuilder();			for(int i = 0; i < listModel.getSize(); i++)			{				if(i != 0)					buf.append(' ');				Button button = (Button)listModel.elementAt(i);				buf.append(button.actionName);				jEdit.setProperty(button.actionName + ".icon",button.iconName);			}			jEdit.setProperty("view.toolbar",buf.toString());		}	
private void updateButtons()		{			int index = list.getSelectedIndex();			remove.setEnabled(index != -1 && listModel.getSize() != 0);			moveUp.setEnabled(index > 0);			moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);			edit.setEnabled(index != -1);		}	
private void reloadButtonList(String toolbar)		{			StringTokenizer st = new StringTokenizer(toolbar);			listModel.clear();						while(st.hasMoreTokens())			{				String actionName = st.nextToken();				if(actionName.equals("-"))					listModel.addElement(new ToolBarOptionPane.Button("-",null,null,"-"));				else				{					EditAction action = jEdit.getAction(actionName);					if(action == null)						continue;					String label = action.getLabel();					if(label == null)						continue;						Icon icon;					String iconName;					if(actionName.equals("-"))					{						iconName = null;						icon = null;					}					else					{						iconName = jEdit.getProperty(actionName + ".icon");						if(iconName == null)							icon = GUIUtilities.loadIcon(jEdit.getProperty("broken-image.icon"));						else						{							icon = GUIUtilities.loadIcon(iconName);							if(icon == null)								icon = GUIUtilities.loadIcon(jEdit.getProperty("broken-image.icon"));						}					}					listModel.addElement(new Button(actionName,iconName,icon,label));				}			}		}	
public int compare(Button button1, Button button2)			{				return StandardUtilities.compareStrings(					button1.label,					button2.label,					true);			}	
Button(String actionName, String iconName, Icon icon, String label)			{				this.actionName = actionName;				this.iconName = iconName;				this.icon = icon;				this.label = GUIUtilities.prettifyMenuLabel(label);			}	
public String toString()			{				return label;			}	
public boolean equals(Object o)			{				if(o instanceof Button)					return ((Button)o).actionName.equals(actionName);				else					return false;			}	
IconListEntry(Icon icon, String name)			{				this.icon = icon;				this.name = name;			}	
public String toString()			{				return name;			}	
public Component getListCellRendererComponent(JList list,				Object value, int index, boolean isSelected,				boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,index,					isSelected,cellHasFocus);					Button button = (Button)value;				setIcon(button.icon);					return this;			}	
public Component getListCellRendererComponent(JList list,				Object value, int index, boolean isSelected,				boolean cellHasFocus)			{				super.getListCellRendererComponent(list,value,index,					isSelected,cellHasFocus);					IconListEntry icon = (IconListEntry)value;				setIcon(icon.icon);					return this;			}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();					if(source == add)				{					ToolBarEditDialog dialog = new ToolBarEditDialog(						ToolBarOptionPane.this,iconList,null);					Button selection = dialog.getSelection();					if(selection == null)						return;						int index = list.getSelectedIndex();					if(index == -1)						index = listModel.getSize();					else						index++;						listModel.insertElementAt(selection,index);					list.setSelectedIndex(index);					list.ensureIndexIsVisible(index);				}				else if(source == remove)				{					int index = list.getSelectedIndex();					listModel.removeElementAt(index);					if(listModel.getSize() != 0)					{						if(listModel.getSize() == index)							list.setSelectedIndex(index-1);						else							list.setSelectedIndex(index);					}					updateButtons();				}				else if(source == moveUp)				{					int index = list.getSelectedIndex();					Object selected = list.getSelectedValue();					listModel.removeElementAt(index);					listModel.insertElementAt(selected,index-1);					list.setSelectedIndex(index-1);					list.ensureIndexIsVisible(index-1);				}				else if(source == moveDown)				{					int index = list.getSelectedIndex();					Object selected = list.getSelectedValue();					listModel.removeElementAt(index);					listModel.insertElementAt(selected,index+1);					list.setSelectedIndex(index+1);					list.ensureIndexIsVisible(index+1);				}				else if(source == edit)				{					ToolBarEditDialog dialog = new ToolBarEditDialog(						ToolBarOptionPane.this,iconList,						(Button)list.getSelectedValue());					Button selection = dialog.getSelection();					if(selection == null)						return;						int index = list.getSelectedIndex();						listModel.setElementAt(selection,index);					list.setSelectedIndex(index);					list.ensureIndexIsVisible(index);				}				else if(source == reset)				{					String dialogType = "options.toolbar.reset.dialog";					int result = GUIUtilities.confirm(list,dialogType,null,						JOptionPane.YES_NO_OPTION,						JOptionPane.WARNING_MESSAGE);										if(result == JOptionPane.YES_OPTION)					{						// the user should be able to cancel the options dialog 						// so we need to modify the list, not the actual property						// since the default value is not available, 						// we reset, fetch default value and re-set to original						String orgToolbar = jEdit.getProperty("view.toolbar");						jEdit.resetProperty("view.toolbar");						String defaultToolbar = jEdit.getProperty("view.toolbar");						jEdit.setProperty("view.toolbar", orgToolbar);						reloadButtonList(defaultToolbar);												// reset selection if user had more buttons than default						list.setSelectedIndex(0);						list.ensureIndexIsVisible(0);						updateButtons();					}				}			}	
public void valueChanged(ListSelectionEvent evt)			{				updateButtons();			}	
public ToolBarEditDialog(Component comp,			DefaultComboBoxModel iconListModel,			ToolBarOptionPane.Button current)		{			super(GUIUtilities.getParentDialog(comp),				jEdit.getProperty("options.toolbar.edit.title"),				true);				JPanel content = new JPanel(new BorderLayout());			content.setBorder(new EmptyBorder(12,12,12,12));			setContentPane(content);				ActionHandler actionHandler = new ActionHandler();			ButtonGroup grp = new ButtonGroup();				JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));			typePanel.setBorder(new EmptyBorder(0,0,6,0));			typePanel.add(new JLabel(				jEdit.getProperty("options.toolbar.edit.caption")));				separator = new JRadioButton(jEdit.getProperty("options.toolbar"				+ ".edit.separator"));			separator.addActionListener(actionHandler);			grp.add(separator);			typePanel.add(separator);				action = new JRadioButton(jEdit.getProperty("options.toolbar"				+ ".edit.action"));			action.addActionListener(actionHandler);			grp.add(action);			typePanel.add(action);				content.add(BorderLayout.NORTH,typePanel);				JPanel actionPanel = new JPanel(new BorderLayout(6,6));				ActionSet[] actionsList = jEdit.getActionSets();			String selectedActionSet = jEdit.getProperty("options.toolbar.selectedActionSet");			ActionSet selectedItem = null;			Vector<ActionSet> vec = new Vector<ActionSet>(actionsList.length);			for(int i = 0; i < actionsList.length; i++)			{				ActionSet actionSet = actionsList[i];				if(actionSet.getActionCount() != 0)				{					vec.add(actionSet);					if (actionSet.getLabel().equals(selectedActionSet))					{						selectedItem = actionSet;					}				}			}			combo = new JComboBox(vec);			if (selectedItem != null)				combo.setSelectedItem(selectedItem);			else				jEdit.unsetProperty("options.toolbar.selectedActionSet");			combo.addActionListener(actionHandler);				actionPanel.add(BorderLayout.NORTH,combo);				list = new JList();			list.setVisibleRowCount(8);			list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);			actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));				// Icon selection			JPanel iconPanel = new JPanel(new BorderLayout(0,3));			JPanel labelPanel = new JPanel(new GridLayout(2,1));			labelPanel.setBorder(new EmptyBorder(0,0,0,12));			JPanel compPanel = new JPanel(new GridLayout(2,1));			grp = new ButtonGroup();			labelPanel.add(builtin = new JRadioButton(jEdit.getProperty(				"options.toolbar.edit.builtin")));			builtin.addActionListener(actionHandler);			grp.add(builtin);			labelPanel.add(file = new JRadioButton(jEdit.getProperty(				"options.toolbar.edit.file")));			grp.add(file);			file.addActionListener(actionHandler);			iconPanel.add(BorderLayout.WEST,labelPanel);			builtinCombo = new JComboBox(iconListModel);			builtinCombo.setRenderer(new ToolBarOptionPane.IconCellRenderer());			compPanel.add(builtinCombo);				fileButton = new JButton(jEdit.getProperty("options.toolbar.edit.no-icon"));			fileButton.setMargin(new Insets(1,1,1,1));			fileButton.setIcon(GUIUtilities.loadIcon("Blank24.gif"));			fileButton.setHorizontalAlignment(SwingConstants.LEFT);			fileButton.addActionListener(actionHandler);			compPanel.add(fileButton);			iconPanel.add(BorderLayout.CENTER,compPanel);			actionPanel.add(BorderLayout.SOUTH,iconPanel);				content.add(BorderLayout.CENTER,actionPanel);				JPanel southPanel = new JPanel();			southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));			southPanel.setBorder(new EmptyBorder(12,0,0,0));			southPanel.add(Box.createGlue());			ok = new JButton(jEdit.getProperty("common.ok"));			ok.addActionListener(actionHandler);			getRootPane().setDefaultButton(ok);			southPanel.add(ok);			southPanel.add(Box.createHorizontalStrut(6));			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.addActionListener(actionHandler);			southPanel.add(cancel);			southPanel.add(Box.createGlue());				content.add(BorderLayout.SOUTH,southPanel);				if(current == null)			{				action.setSelected(true);				builtin.setSelected(true);				updateList();			}			else			{				if(current.actionName.equals("-"))				{					separator.setSelected(true);					builtin.setSelected(true);				}				else				{					action.setSelected(true);					ActionSet set = jEdit.getActionSetForAction(						current.actionName);					combo.setSelectedItem(set);					updateList();					list.setSelectedValue(current,true);						if(MiscUtilities.isURL(current.iconName))					{						file.setSelected(true);						fileIcon = current.iconName;						try						{							fileButton.setIcon(new ImageIcon(new URL(								fileIcon)));						}						catch(MalformedURLException mf)						{							Log.log(Log.ERROR,this,mf);						}						fileButton.setText(MiscUtilities.getFileName(fileIcon));					}					else					{						builtin.setSelected(true);						ListModel model = builtinCombo.getModel();						for(int i = 0; i < model.getSize(); i++)						{							ToolBarOptionPane.IconListEntry entry								= (ToolBarOptionPane.IconListEntry)								model.getElementAt(i);							if(entry.name.equals(current.iconName))							{								builtinCombo.setSelectedIndex(i);								break;							}						}					}				}			}				updateEnabled();				pack();			setLocationRelativeTo(GUIUtilities.getParentDialog(comp));			setVisible(true);		}	
public void ok()		{			isOK = true;			dispose();		}	
public void cancel()		{			dispose();		}	
public ToolBarOptionPane.Button getSelection()		{			if(!isOK)				return null;				if(separator.isSelected())				return new ToolBarOptionPane.Button("-",null,null,"-");			else			{				Icon icon;				String iconName;				if(builtin.isSelected())				{					ToolBarOptionPane.IconListEntry selectedIcon =						(ToolBarOptionPane.IconListEntry)						builtinCombo.getSelectedItem();					icon = selectedIcon.icon;					iconName = selectedIcon.name;				}				else				{					icon = fileButton.getIcon();					iconName = fileIcon;					if(iconName == null)						iconName = "Blank24.gif";				}					String label;				String actionName;				if(action.isSelected())				{					ToolBarOptionPane.Button button =						(ToolBarOptionPane.Button)list						.getSelectedValue();					label = button.label;					actionName = button.actionName;				}				else					throw new InternalError();					return new ToolBarOptionPane.Button(actionName,					iconName,icon,label);			}		}	
private void updateEnabled()		{			combo.setEnabled(action.isSelected());			list.setEnabled(action.isSelected());				boolean iconControlsEnabled = !separator.isSelected();			builtin.setEnabled(iconControlsEnabled);			file.setEnabled(iconControlsEnabled);			builtinCombo.setEnabled(iconControlsEnabled && builtin.isSelected());			fileButton.setEnabled(iconControlsEnabled && file.isSelected());		}	
private void updateList()		{			ActionSet actionSet = (ActionSet)combo.getSelectedItem();			String actionSetLabel = actionSet.getLabel();			jEdit.setProperty("options.toolbar.selectedActionSet", actionSetLabel);			EditAction[] actions = actionSet.getActions();			Vector<ToolBarOptionPane.Button> listModel = new Vector<ToolBarOptionPane.Button>(actions.length);				for(int i = 0; i < actions.length; i++)			{				EditAction action = actions[i];				String label = action.getLabel();				if(label == null)					continue;					listModel.add(new ToolBarOptionPane.Button(					action.getName(),null,null,label));			}				Collections.sort(listModel,new ToolBarOptionPane.ButtonCompare());			list.setListData(listModel);		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source instanceof JRadioButton)					updateEnabled();				if(source == ok)					ok();				else if(source == cancel)					cancel();				else if(source == combo)					updateList();				else if(source == fileButton)				{					String directory;					if(fileIcon == null)						directory = null;					else						directory = MiscUtilities.getParentOfPath(fileIcon);					String[] paths = GUIUtilities.showVFSFileDialog(null,directory,						VFSBrowser.OPEN_DIALOG,false);					if(paths == null)						return;						fileIcon = "file:" + paths[0];						try					{						fileButton.setIcon(new ImageIcon(new URL(							fileIcon)));					}					catch(MalformedURLException mf)					{						Log.log(Log.ERROR,this,mf);					}					fileButton.setText(MiscUtilities.getFileName(fileIcon));				}			}	
@Override		public Point getToolTipLocation(MouseEvent event)		{			return new Point(event.getX(),-20);		}	
public void paintFoldStart(Gutter gutter, Graphics2D gfx, int screenLine,				int physicalLine, boolean nextLineVisible, int y, int lineHeight,				JEditBuffer buffer)		{			int _y = y + lineHeight / 2;			gfx.setColor(gutter.getFoldColor());			if (nextLineVisible)			{				gfx.drawLine(1,_y - 3,10,_y - 3);				gfx.drawLine(2,_y - 2,9,_y - 2);				gfx.drawLine(3,_y - 1,8,_y - 1);				gfx.drawLine(4,_y,7,_y);				gfx.drawLine(5,_y + 1,6,_y + 1);			}			else			{				gfx.drawLine(4,_y - 5,4,_y + 4);				gfx.drawLine(5,_y - 4,5,_y + 3);				gfx.drawLine(6,_y - 3,6,_y + 2);				gfx.drawLine(7,_y - 2,7,_y + 1);				gfx.drawLine(8,_y - 1,8,_y);			}		}	
public void paintFoldEnd(Gutter gutter, Graphics2D gfx, int screenLine,				int physicalLine, int y, int lineHeight, JEditBuffer buffer)		{			gfx.setColor(gutter.getFoldColor());			int _y = y + lineHeight / 2;			gfx.drawLine(4,_y,4,_y + 3);			gfx.drawLine(4,_y + 3,7,_y + 3);		}	
public void paintFoldMiddle(Gutter gutter, Graphics2D gfx, int screenLine,				int physicalLine, int y, int lineHeight, JEditBuffer buffer)		{		}	
/**	   * Constructs a primitive type.	   *	   * @param sort the sort of the primitive type to be constructed.	   */		  private Type (final int sort) {	    this.sort = sort;	    this.len = 1;	  }	
/**	   * Constructs a reference type.	   *	   * @param sort the sort of the reference type to be constructed.	   * @param buf a buffer containing the descriptor of the previous type.	   * @param off the offset of this descriptor in the previous buffer.	   * @param len the length of this descriptor.	   */		  private Type (	    final int sort,	    final char[] buf,	    final int off,	    final int len)	  {	    this.sort = sort;	    this.buf = buf;	    this.off = off;	    this.len = len;	  }	
/**	   * Returns the Java type corresponding to the given type descriptor.	   *	   * @param typeDescriptor a type descriptor.	   * @return the Java type corresponding to the given type descriptor.	   */		  public static Type getType (final String typeDescriptor) {	    return getType(typeDescriptor.toCharArray(), 0);	  }	
/**	   * Returns the Java type corresponding to the given class.	   *	   * @param c a class.	   * @return the Java type corresponding to the given class.	   */		  public static Type getType (final Class c) {	    if (c.isPrimitive()) {	      if (c == Integer.TYPE) {	        return INT_TYPE;	      } else if (c == Void.TYPE) {	        return VOID_TYPE;	      } else if (c == Boolean.TYPE) {	        return BOOLEAN_TYPE;	      } else if (c == Byte.TYPE) {	        return BYTE_TYPE;	      } else if (c == Character.TYPE) {	        return CHAR_TYPE;	      } else if (c == Short.TYPE) {	        return SHORT_TYPE;	      } else if (c == Double.TYPE) {	        return DOUBLE_TYPE;	      } else if (c == Float.TYPE) {	        return FLOAT_TYPE;	      } else /*if (c == Long.TYPE)*/ {	        return LONG_TYPE;	      }	    } else {	      return getType(getDescriptor(c));	    }	  }	
/**	   * Returns the Java types corresponding to the argument types of the given	   * method descriptor.	   *	   * @param methodDescriptor a method descriptor.	   * @return the Java types corresponding to the argument types of the given	   *      method descriptor.	   */		  public static Type[] getArgumentTypes (final String methodDescriptor) {	    char[] buf = methodDescriptor.toCharArray();	    int off = 1;	    int size = 0;	    while (true) {	      char car = buf[off++];	      if (car == ')') {	        break;	      } else if (car == 'L') {	        while (buf[off++] != ';') {	        }	        ++size;	      } else if (car != '[') {	        ++size;	      }	    }	    Type[] args = new Type[size];	    off = 1;	    size = 0;	    while (buf[off] != ')') {	      args[size] = getType(buf, off);	      off += args[size].len;	      size += 1;	    }	    return args;	  }	
/**	   * Returns the Java types corresponding to the argument types of the given	   * method.	   *	   * @param method a method.	   * @return the Java types corresponding to the argument types of the given	   *      method.	   */		  public static Type[] getArgumentTypes (final Method method) {	    Class[] classes = method.getParameterTypes();	    Type[] types = new Type[classes.length];	    for (int i = classes.length - 1; i >= 0; --i) {	      types[i] = getType(classes[i]);	    }	    return types;	  }	
/**	   * Returns the Java type corresponding to the return type of the given	   * method descriptor.	   *	   * @param methodDescriptor a method descriptor.	   * @return the Java type corresponding to the return type of the given	   *      method descriptor.	   */		  public static Type getReturnType (final String methodDescriptor) {	    char[] buf = methodDescriptor.toCharArray();	    return getType(buf, methodDescriptor.indexOf(')') + 1);	  }	
/**	   * Returns the Java type corresponding to the return type of the given	   * method.	   *	   * @param method a method.	   * @return the Java type corresponding to the return type of the given	   *      method.	   */		  public static Type getReturnType (final Method method) {	    return getType(method.getReturnType());	  }	
/**	   * Returns the Java type corresponding to the given type descriptor.	   *	   * @param buf a buffer containing a type descriptor.	   * @param off the offset of this descriptor in the previous buffer.	   * @return the Java type corresponding to the given type descriptor.	   */		  private static Type getType (final char[] buf, final int off) {	    int len;	    switch (buf[off]) {	      case 'V': return VOID_TYPE;	      case 'Z': return BOOLEAN_TYPE;	      case 'C': return CHAR_TYPE;	      case 'B': return BYTE_TYPE;	      case 'S': return SHORT_TYPE;	      case 'I': return INT_TYPE;	      case 'F': return FLOAT_TYPE;	      case 'J': return LONG_TYPE;	      case 'D': return DOUBLE_TYPE;	      case '[':	        len = 1;	        while (buf[off + len] == '[') {	          ++len;	        }	        if (buf[off + len] == 'L') {	          ++len;	          while (buf[off + len] != ';') {	            ++len;	          }	        }	        return new Type(ARRAY, buf, off, len + 1);	      //case 'L':	      default:	        len = 1;	        while (buf[off + len] != ';') {	          ++len;	        }	        return new Type(OBJECT, buf, off, len + 1);	    }	  }	
/**	   * Returns the sort of this Java type.	   *	   * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN}, {@link #CHAR CHAR},	   *      {@link #BYTE BYTE}, {@link #SHORT SHORT}, {@link #INT INT}, {@link	   *      #FLOAT FLOAT}, {@link #LONG LONG}, {@link #DOUBLE DOUBLE}, {@link	   *      #ARRAY ARRAY} or {@link #OBJECT OBJECT}.	   */		  public int getSort () {	    return sort;	  }	
/**	   * Returns the number of dimensions of this array type.	   * This method should only be used for an array type.	   *	   * @return the number of dimensions of this array type.	   */		  public int getDimensions () {	    int i = 1;	    while (buf[off + i] == '[') {	      ++i;	    }	    return i;	  }	
/**	   * Returns the type of the elements of this array type.	   * This method should only be used for an array type.	   *	   * @return Returns the type of the elements of this array type.	   */		  public Type getElementType () {	    return getType(buf, off + getDimensions());	  }	
/**	   * Returns the name of the class corresponding to this object type.	   * This method should only be used for an object type.	   *	   * @return the fully qualified name of the class corresponding to this object	   *      type.	   */		  public String getClassName () {	    return new String(buf, off + 1, len - 2).replace('/', '.');	  }	
/**	   * Returns the internal name of the class corresponding to this object type.	   * The internal name of a class is its fully qualified name, where '.' are	   * replaced by '/'.   * This method should only be used for an object type.	   *	   * @return the internal name of the class corresponding to this object type.	   */		  public String getInternalName () {	    return new String(buf, off + 1, len - 2);	  }	
/**	   * Returns the descriptor corresponding to this Java type.	   *	   * @return the descriptor corresponding to this Java type.	   */		  public String getDescriptor () {	    StringBuilder buf = new StringBuilder();	    getDescriptor(buf);	    return buf.toString();	  }	
/**	   * Returns the descriptor corresponding to the given argument and return	   * types.	   *	   * @param returnType the return type of the method.	   * @param argumentTypes the argument types of the method.	   * @return the descriptor corresponding to the given argument and return	   *      types.	   */		  public static String getMethodDescriptor (	    final Type returnType,	    final Type[] argumentTypes)	  {	    StringBuilder buf = new StringBuilder();	    buf.append('(');	    for (int i = 0; i < argumentTypes.length; ++i) {	      argumentTypes[i].getDescriptor(buf);	    }	    buf.append(')');	    returnType.getDescriptor(buf);	    return buf.toString();	  }	
/**	   * Appends the descriptor corresponding to this Java type to the given string	   * buffer.	   *	   * @param buf the string buffer to which the descriptor must be appended.	   */		  private void getDescriptor(final StringBuilder buf) {	    switch (sort) {	      case VOID:    buf.append('V'); return;	      case BOOLEAN: buf.append('Z'); return;	      case CHAR:    buf.append('C'); return;	      case BYTE:    buf.append('B'); return;	      case SHORT:   buf.append('S'); return;	      case INT:     buf.append('I'); return;	      case FLOAT:   buf.append('F'); return;	      case LONG:    buf.append('J'); return;	      case DOUBLE:  buf.append('D'); return;	      //case ARRAY:	      //case OBJECT:	      default:      buf.append(this.buf, off, len);	    }	  }	
/**	   * Returns the internal name of the given class. The internal name of a class	   * is its fully qualified name, where '.' are replaced by '/'.	   *	   * @param c an object class.	   * @return the internal name of the given class.	   */		  public static String getInternalName (final Class c) {	    return c.getName().replace('.', '/');	  }	
/**	   * Returns the descriptor corresponding to the given Java type.	   *	   * @param c an object class, a primitive class or an array class.	   * @return the descriptor corresponding to the given class.	   */		  public static String getDescriptor (final Class c) {	    StringBuilder buf = new StringBuilder();	    getDescriptor(buf, c);	    return buf.toString();	  }	
/**	   * Returns the descriptor corresponding to the given method.	   *	   * @param m a {@link Method Method} object.	   * @return the descriptor of the given method.	   */		  public static String getMethodDescriptor (final Method m) {	    Class[] parameters = m.getParameterTypes();	    StringBuilder buf = new StringBuilder();	    buf.append('(');	    for (int i = 0; i < parameters.length; ++i) {	      getDescriptor(buf, parameters[i]);	    }	    buf.append(')');	    getDescriptor(buf, m.getReturnType());	    return buf.toString();	  }	
/**	   * Appends the descriptor of the given class to the given string buffer.	   *	   * @param buf the string buffer to which the descriptor must be appended.	   * @param c the class whose descriptor must be computed.	   */		  private static void getDescriptor (final StringBuilder buf, final Class c) {	    Class d = c;	    while (true) {	      if (d.isPrimitive()) {	        char car;	        if (d == Integer.TYPE) {	          car = 'I';	        } else if (d == Void.TYPE) {	          car = 'V';	        } else if (d == Boolean.TYPE) {	          car = 'Z';	        } else if (d == Byte.TYPE) {	          car = 'B';	        } else if (d == Character.TYPE) {	          car = 'C';	        } else if (d == Short.TYPE) {	          car = 'S';	        } else if (d == Double.TYPE) {	          car = 'D';	        } else if (d == Float.TYPE) {	          car = 'F';	        } else /*if (d == Long.TYPE)*/ {	          car = 'J';	        }	        buf.append(car);	        return;	      } else if (d.isArray()) {	        buf.append('[');	        d = d.getComponentType();	      } else {	        buf.append('L');	        String name = d.getName();	        int len = name.length();	        for (int i = 0; i < len; ++i) {	          char car = name.charAt(i);	          buf.append(car == '.' ? '/' : car);	        }	        buf.append(';');	        return;	      }	    }	  }	
/**	   * Returns the size of values of this type.	   *	   * @return the size of values of this type, i.e., 2 for <tt>long</tt> and	   *      <tt>double</tt>, and 1 otherwise.	   */		  public int getSize () {	    return (sort == LONG || sort == DOUBLE ? 2 : 1);	  }	
/**	   * Returns a JVM instruction opcode adapted to this Java type.	   *	   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,	   *      ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,	   *      ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.	   * @return an opcode that is similar to the given opcode, but adapted to this	   *      Java type. For example, if this type is <tt>float</tt> and	   *      <tt>opcode</tt> is IRETURN, this method returns FRETURN.	   */		  public int getOpcode (final int opcode) {	    if (opcode == Constants.IALOAD || opcode == Constants.IASTORE) {	      switch (sort) {	        case VOID:	          return opcode + 5;	        case BOOLEAN:	        case BYTE:	          return opcode + 6;	        case CHAR:	          return opcode + 7;	        case SHORT:	          return opcode + 8;	        case INT:	          return opcode;	        case FLOAT:	          return opcode + 2;	        case LONG:	          return opcode + 1;	        case DOUBLE:	          return opcode + 3;	        //case ARRAY:	        //case OBJECT:	        default:	          return opcode + 4;	      }	    } else {	      switch (sort) {	        case VOID:	          return opcode + 5;	        case BOOLEAN:	        case CHAR:	        case BYTE:	        case SHORT:	        case INT:	          return opcode;	        case FLOAT:	          return opcode + 2;	        case LONG:	          return opcode + 1;	        case DOUBLE:	          return opcode + 3;	        //case ARRAY:	        //case OBJECT:	        default:	          return opcode + 4;	      }	    }	  }	
/**			Get the Java types of the arguments.		*/	    public static Class[] getTypes( Object[] args )	    {	        if ( args == null )	            return new Class[0];		        Class[] types = new Class[ args.length ];		        for( int i=0; i<args.length; i++ )	        {				if ( args[i] == null )					types[i] = null;	            else				if ( args[i] instanceof Primitive )	                types[i] = ((Primitive)args[i]).getType();	            else	                types[i] = args[i].getClass();	        }		        return types;	    }	
/**		 Is the 'from' signature (argument types) assignable to the 'to'		 signature (candidate method types)		 This method handles the special case of null values in 'to' types		 indicating a loose type and matching anything.		 */		/* Should check for strict java here and limit to isJavaAssignable() */		static boolean isSignatureAssignable( Class[] from, Class[] to, int round )		{			if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )				return false;				switch ( round )			{				case JAVA_BASE_ASSIGNABLE:					for( int i=0; i<from.length; i++ )						if ( !isJavaBaseAssignable( to[i], from[i] ) )							return false;					return true;				case JAVA_BOX_TYPES_ASSIGABLE:					for( int i=0; i<from.length; i++ )						if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )							return false;					return true;				case JAVA_VARARGS_ASSIGNABLE:					return isSignatureVarargsAssignable( from, to );				case BSH_ASSIGNABLE:					for( int i=0; i<from.length; i++ )						if ( !isBshAssignable( to[i], from[i] ) )							return false;					return true;				default:					throw new InterpreterError("bad case");			}		}	
private static boolean isSignatureVarargsAssignable(			Class[] from, Class[] to )		{			return false;		}	
/**			Test if a conversion of the rhsType type to the lhsType type is legal via		 standard Java assignment conversion rules (i.e. without a cast).		 The rules include Java 5 autoboxing/unboxing.			<p/>				For Java primitive TYPE classes this method takes primitive promotion			into account.  The ordinary Class.isAssignableFrom() does not take			primitive promotion conversions into account.  Note that Java allows			additional assignments without a cast in combination with variable			declarations and array allocations.  Those are handled elsewhere		 	(maybe should be here with a flag?)			<p/>			This class accepts a null rhsType type indicating that the rhsType was the			value Primitive.NULL and allows it to be assigned to any reference lhsType			type (non primitive).			<p/>				Note that the getAssignableForm() method is the primary bsh method for			checking assignability.  It adds additional bsh conversions, etc.				@see #isBshAssignable( Class, Class )			@param lhsType assigning from rhsType to lhsType			@param rhsType assigning from rhsType to lhsType		*/		static boolean isJavaAssignable( Class lhsType, Class rhsType ) {			return isJavaBaseAssignable( lhsType, rhsType )				|| isJavaBoxTypesAssignable( lhsType, rhsType );		}	
/**			Is the assignment legal via original Java (up to version 1.4)			assignment rules, not including auto-boxing/unboxing.		 @param rhsType may be null to indicate primitive null value		*/		static boolean isJavaBaseAssignable( Class lhsType, Class rhsType )		{			/*				Assignment to loose type, defer to bsh extensions				Note: we could shortcut this here:				if ( lhsType == null ) return true;				rather than forcing another round.  It's not strictly a Java issue,				so does it belong here?			*/			if ( lhsType == null )				return false;				// null rhs type corresponds to type of Primitive.NULL			// assignable to any object type			if ( rhsType == null )				return !lhsType.isPrimitive();				if ( lhsType.isPrimitive() && rhsType.isPrimitive() )			{				if ( lhsType == rhsType )					return true;					// handle primitive widening conversions - JLS 5.1.2				if ( (rhsType == Byte.TYPE) &&					(lhsType == Short.TYPE || lhsType == Integer.TYPE					|| lhsType == Long.TYPE || lhsType == Float.TYPE					|| lhsType == Double.TYPE))	                    return true;		            if ( (rhsType == Short.TYPE) &&					(lhsType == Integer.TYPE || lhsType == Long.TYPE ||	                lhsType == Float.TYPE || lhsType == Double.TYPE))	                    return true;		            if ((rhsType == Character.TYPE) &&					(lhsType == Integer.TYPE || lhsType == Long.TYPE ||	                lhsType == Float.TYPE || lhsType == Double.TYPE))	                    return true;		            if ((rhsType == Integer.TYPE) &&					(lhsType == Long.TYPE || lhsType == Float.TYPE ||	                lhsType == Double.TYPE))	                    return true;		            if ((rhsType == Long.TYPE) &&					(lhsType == Float.TYPE || lhsType == Double.TYPE))	                return true;		            if ((rhsType == Float.TYPE) && (lhsType == Double.TYPE))	                return true;	        }	        else	            if ( lhsType.isAssignableFrom(rhsType) )	                return true;		        return false;	    }	
/**			Determine if the type is assignable via Java boxing/unboxing rules.		*/		static boolean isJavaBoxTypesAssignable(			Class lhsType, Class rhsType )		{			// Assignment to loose type... defer to bsh extensions			if ( lhsType == null )				return false;				// prim can be boxed and assigned to Object			if ( lhsType == Object.class )				return true;				// prim numeric type can be boxed and assigned to number			if ( lhsType == Number.class				&& rhsType != Character.TYPE				&& rhsType != Boolean.TYPE			)				return true;				// General case prim type to wrapper or vice versa.			// I don't know if this is faster than a flat list of 'if's like above.			// wrapperMap maps both prim to wrapper and wrapper to prim types,			// so this test is symmetric			if ( Primitive.wrapperMap.get( lhsType ) == rhsType )				return true;				return false;		}	
/**		 Test if a type can be converted to another type via BeanShell		 extended syntax rules (a superset of Java conversion rules).		 */		static boolean isBshAssignable( Class toType, Class fromType )		{			try {				return castObject(					toType, fromType, null/*fromValue*/,					ASSIGNMENT, true/*checkOnly*/				) == VALID_CAST;			} catch ( UtilEvalError e ) {				// This should not happen with checkOnly true				throw new InterpreterError("err in cast check: "+e);			}		}	
/**			Attempt to cast an object instance to a new type if possible via		 BeanShell extended syntax rules.  These rules are always a superset of		 Java conversion rules.  If you wish to impose context sensitive		 conversion rules then you must test before calling this method.		 <p/>				This method can handle fromValue Primitive types (representing			primitive casts) as well as fromValue object casts requiring interface			generation, etc.				@param toType the class type of the cast result, which may include			primitive types, e.g. Byte.TYPE				@param fromValue an Object or bsh.Primitive primitive value (including				Primitive.NULL or Primitive.VOID )				@see #isBshAssignable( Class, Class )		*/		public static Object castObject(			Object fromValue, Class toType, int operation )			throws UtilEvalError		{			if ( fromValue == null )				throw new InterpreterError("null fromValue");				Class fromType =				fromValue instanceof Primitive ?					((Primitive)fromValue).getType()					: fromValue.getClass();				return castObject(				toType, fromType, fromValue, operation, false/*checkonly*/ );		}	
/**		 Perform a type conversion or test if a type conversion is possible with		 respect to BeanShell extended rules.  These rules are always a superset of		 the Java language rules, so this method can also perform (but not test)		 any Java language assignment or cast conversion.		 <p/>			 This method can perform the functionality of testing if an assignment		 or cast is ultimately possible (with respect to BeanShell) as well as the		 functionality of performing the necessary conversion of a value based		 on the specified target type.  This combined functionality is done for		 expediency and could be separated later.		 <p/>			 Other methods such as isJavaAssignable() should be used to determine the		 suitability of an assignment in a fine grained or restrictive way based		 on context before calling this method		 <p/>			 A CAST is stronger than an ASSIGNMENT operation in that it will attempt to		 perform primtive operations that cast to a smaller type. e.g. (byte)myLong;		 These are used in explicit primitive casts, primitive delclarations and		 array declarations. I don't believe there are any object conversions which are		 different between  ASSIGNMENT and CAST (e.g. scripted object to interface proxy		 in bsh is done on assignment as well as cast).		 <p/>			 This method does not obey strictJava(), you must test first before		 using this method if you care. (See #isJavaAssignable()).		 <p/>				@param toType the class type of the cast result, which may include				primitive types, e.g. Byte.TYPE.  toType may be null to indicate a				loose type assignment (which matches any fromType).				@param fromType is the class type of the value to be cast including				java primitive TYPE classes for primitives.				If fromValue is (or would be) Primitive.NULL then fromType should be null.				@param fromValue an Object or bsh.Primitive primitive value (including				Primitive.NULL or Primitive.VOID )				@param checkOnly If checkOnly is true then fromValue must be null.				FromType is checked for the cast to toType...				If checkOnly is false then fromValue must be non-null				(Primitive.NULL is ok) and the actual cast is performed.				@throws UtilEvalError on invalid assignment (when operation is				assignment ).				@throws UtilTargetError wrapping ClassCastException on cast error				(when operation is cast)				@param operation is Types.CAST or Types.ASSIGNMENT				@see org.gjt.sp.jedit.bsh.Primitive.getType()		*/		/*			Notes: This method is currently responsible for auto-boxing/unboxing			conversions...  Where does that need to go?		*/		private static Object castObject(			Class toType, Class fromType, Object fromValue,			int operation, boolean checkOnly )			throws UtilEvalError		{			/*				Lots of preconditions checked here...				Once things are running smoothly we might comment these out				(That's what assertions are for).			*/			if ( checkOnly && fromValue != null )				throw new InterpreterError("bad cast params 1");			if ( !checkOnly && fromValue == null )				throw new InterpreterError("bad cast params 2");			if ( fromType == Primitive.class )				throw new InterpreterError("bad from Type, need to unwrap");			if ( fromValue == Primitive.NULL && fromType != null )				throw new InterpreterError("inconsistent args 1");			if ( fromValue == Primitive.VOID && fromType != Void.TYPE )				throw new InterpreterError("inconsistent args 2");			if ( toType == Void.TYPE )				throw new InterpreterError("loose toType should be null");						// assignment to loose type, void type, or exactly same type			if ( toType == null || toType == fromType )				return checkOnly ? VALID_CAST :					fromValue;				// Casting to primitive type	        if ( toType.isPrimitive() )			{				if ( fromType == Void.TYPE || fromType == null 					|| fromType.isPrimitive() )				{					// Both primitives, do primitive cast					return Primitive.castPrimitive( 						toType, fromType, (Primitive)fromValue, 						checkOnly, operation );				} else				{					if ( Primitive.isWrapperType( fromType ) )					{						// wrapper to primitive						// Convert value to Primitive and check/cast it.							//Object r = checkOnly ? VALID_CAST :						Class unboxedFromType = Primitive.unboxType( fromType );						Primitive primFromValue;						if ( checkOnly ) 							primFromValue = null; // must be null in checkOnly						else							primFromValue = (Primitive)Primitive.wrap( 								fromValue, unboxedFromType );							return Primitive.castPrimitive( 							toType, unboxedFromType, primFromValue, 							checkOnly, operation );					} else					{						// Cannot cast from arbitrary object to primitive						if ( checkOnly )							return INVALID_CAST;						else							throw castError( toType, fromType, operation );					}				}	        }				// Else, casting to reference type				// Casting from primitive or void (to reference type)			if ( fromType == Void.TYPE || fromType == null				|| fromType.isPrimitive() )			{				// cast from primitive to wrapper type				if ( Primitive.isWrapperType( toType )					&& fromType != Void.TYPE && fromType != null )				{					// primitive to wrapper type					return checkOnly ? VALID_CAST :						Primitive.castWrapper( 							Primitive.unboxType(toType), 							((Primitive)fromValue).getValue() );				}					// Primitive (not null or void) to Object.class type				if ( toType == Object.class 					&& fromType != Void.TYPE && fromType != null )				{					// box it					return checkOnly ? VALID_CAST :						((Primitive)fromValue).getValue();				}					// Primitive to arbitrary object type. 				// Allow Primitive.castToType() to handle it as well as cases of 				// Primitive.NULL and Primitive.VOID				return Primitive.castPrimitive( 					toType, fromType, (Primitive)fromValue, checkOnly, operation );			}				// If type already assignable no cast necessary			// We do this last to allow various errors above to be caught.			// e.g cast Primitive.Void to Object would pass this			if ( toType.isAssignableFrom( fromType ) )				return checkOnly ? VALID_CAST : 					fromValue;				// Can we use the proxy mechanism to cast a bsh.This to 			// the correct interface?			if ( toType.isInterface() 				&& org.gjt.sp.jedit.bsh.This.class.isAssignableFrom( fromType )				&& Capabilities.canGenerateInterfaces() 			)				return checkOnly ? VALID_CAST : 					((org.gjt.sp.jedit.bsh.This)fromValue).getInterface( toType );				// Both numeric wrapper types? 			// Try numeric style promotion wrapper cast			if ( Primitive.isWrapperType( toType ) 				&& Primitive.isWrapperType( fromType ) 			)				return checkOnly ? VALID_CAST :					Primitive.castWrapper( toType, fromValue );						if ( checkOnly )				return INVALID_CAST;			else				throw castError( toType, fromType , operation  );		}	
/**			Return a UtilEvalError or UtilTargetError wrapping a ClassCastException			describing an illegal assignment or illegal cast, respectively.			*/	    static UtilEvalError castError( 			Class lhsType, Class rhsType, int operation   ) 	    {			return castError( 				Reflect.normalizeClassName(lhsType),				Reflect.normalizeClassName(rhsType), operation  );	    }	
static UtilEvalError castError( 			String lhs, String rhs, int operation   ) 	    {			if ( operation == ASSIGNMENT )				return new UtilEvalError (					"Can't assign " + rhs + " to "+ lhs );				Exception cce = new ClassCastException(				"Cannot cast " + rhs + " to " + lhs );			return new UtilTargetError( cce );	    }	
public UndoManager(JEditBuffer buffer)		{			this.buffer = buffer;		}	
public void setLimit(int limit)		{			this.limit = limit;		}	
public void clear()		{			undosFirst = undosLast = redosFirst = redosLast = null;			undoCount = 0;		}	
public boolean canUndo()		{			return (undosLast != null);		}	
public int undo()		{			if(insideCompoundEdit())				throw new InternalError("Unbalanced begin/endCompoundEdit()");				if(undosLast == null)				return -1;			else			{				reviseUndoId();				undoCount--;					int caret = undosLast.undo();				redosFirst = undosLast;				undosLast = undosLast.prev;				if(undosLast == null)					undosFirst = null;				return caret;			}		}	
public boolean canRedo()		{			return (redosFirst != null);		}	
public int redo()		{			if(insideCompoundEdit())				throw new InternalError("Unbalanced begin/endCompoundEdit()");				if(redosFirst == null)				return -1;			else			{				reviseUndoId();				undoCount++;					int caret = redosFirst.redo();				undosLast = redosFirst;				if(undosFirst == null)					undosFirst = undosLast;				redosFirst = redosFirst.next;				return caret;			}		}	
public void beginCompoundEdit()		{			if(compoundEditCount == 0)			{				compoundEdit = new CompoundEdit();				reviseUndoId();			}				compoundEditCount++;		}	
public void endCompoundEdit()		{			if(compoundEditCount == 0)			{				Log.log(Log.WARNING,this,new Exception("Unbalanced begin/endCompoundEdit()"));				return;			}			else if(compoundEditCount == 1)			{				if(compoundEdit.first == null)					/* nothing done between begin/end calls */;				else if(compoundEdit.first == compoundEdit.last)					addEdit(compoundEdit.first);				else					addEdit(compoundEdit);					compoundEdit = null;			}				compoundEditCount--;		}	
public boolean insideCompoundEdit()		{			return compoundEditCount != 0;		}	
public Object getUndoId()		{			return undoId;		}	
public void contentInserted(int offset, int length, String text, boolean clearDirty)		{			Edit last = getLastEdit();			Edit toMerge = getMergeEdit();				if(!clearDirty && toMerge instanceof Insert				&& redosFirst == null)			{				Insert ins = (Insert)toMerge;				if(ins.offset == offset)				{					ins.str = text.concat(ins.str);					ins.length += length;					return;				}				else if(ins.offset + ins.length == offset)				{					ins.str = ins.str.concat(text);					ins.length += length;					return;				}			}				Insert ins = new Insert(this,offset,length,text);				if(clearDirty)			{				redoClearDirty = last;				undoClearDirty = ins;			}				if(compoundEdit != null)				compoundEdit.add(ins);			else			{				reviseUndoId();				addEdit(ins);			}		}	
public void contentRemoved(int offset, int length, String text, boolean clearDirty)		{			Edit last = getLastEdit();			Edit toMerge = getMergeEdit();				if(!clearDirty && toMerge instanceof Remove				&& redosFirst == null)			{				Remove rem = (Remove)toMerge;				if(rem.offset == offset)				{					rem.content.str = rem.content.str.concat(text);					rem.content.hashcode = rem.content.str.hashCode();					rem.length += length;					KillRing.getInstance().changed(rem.content);					return;				}				else if(offset + length == rem.offset)				{					rem.content.str = text.concat(rem.content.str);					rem.content.hashcode = rem.content.str.hashCode();					rem.length += length;					rem.offset = offset;					KillRing.getInstance().changed(rem.content);					return;				}			}				Remove rem = new Remove(this,offset,length,text);			if(clearDirty)			{				redoClearDirty = last;				undoClearDirty = rem;			}				if(compoundEdit != null)				compoundEdit.add(rem);			else			{				reviseUndoId();				addEdit(rem);			}				KillRing.getInstance().add(rem.content);		}	
public void resetClearDirty()		{			redoClearDirty = getLastEdit();			if(redosFirst instanceof CompoundEdit)				undoClearDirty = ((CompoundEdit)redosFirst).first;			else				undoClearDirty = redosFirst;		}	
private void addEdit(Edit edit)		{			if(undosFirst == null)				undosFirst = undosLast = edit;			else			{				undosLast.next = edit;				edit.prev = undosLast;				undosLast = edit;			}				redosFirst = redosLast = null;				undoCount++;				while(undoCount > limit)			{				undoCount--;					if(undosFirst == undosLast)					undosFirst = undosLast = null;				else				{					undosFirst.next.prev = null;					undosFirst = undosFirst.next;				}			}		}	
private Edit getMergeEdit()		{			Edit last = getLastEdit();			return (compoundEdit != null ? compoundEdit.last : last);		}	
private Edit getLastEdit()		{			if(undosLast instanceof CompoundEdit)				return ((CompoundEdit)undosLast).last;			else				return undosLast;		}	
private void reviseUndoId()		{			undoId = new Object();		}	
Insert(UndoManager mgr, int offset, int length, String str)			{				this.mgr = mgr;				this.offset = offset;				this.length = length;				this.str = str;			}	
int undo()			{				mgr.buffer.remove(offset,length);				if(mgr.undoClearDirty == this)					mgr.buffer.setDirty(false);				return offset;			}	
int redo()			{				mgr.buffer.insert(offset,str);				if(mgr.redoClearDirty == this)					mgr.buffer.setDirty(false);				return offset + length;			}	
public RemovedContent(String str)			{				this.str = str;				this.hashcode = str.hashCode();			}	
public String toString()			{				return str;			}	
Remove(UndoManager mgr, int offset, int length, String str)			{				this.mgr = mgr;				this.offset = offset;				this.length = length;				this.content = new RemovedContent(str);			}	
int undo()			{				mgr.buffer.insert(offset,content.str);				if(mgr.undoClearDirty == this)					mgr.buffer.setDirty(false);				return offset + length;			}	
int redo()			{				mgr.buffer.remove(offset,length);				if(mgr.redoClearDirty == this)					mgr.buffer.setDirty(false);				return offset;			}	
public int undo()			{				int retVal = -1;				Edit edit = last;				while(edit != null)				{					retVal = edit.undo();					edit = edit.prev;				}				return retVal;			}	
public int redo()			{				int retVal = -1;				Edit edit = first;				while(edit != null)				{					retVal = edit.redo();					edit = edit.next;				}				return retVal;			}	
public void add(Edit edit)			{				if(first == null)					first = last = edit;				else				{					edit.prev = last;					last.next = edit;					last = edit;				}			}	
public UrlVFS()		{			super("url",READ_CAP | WRITE_CAP);		}	
public String constructPath(String parent, String path)		{			if(parent.endsWith("/"))				return parent + path;			else				return parent + '/' + path;		}	
public InputStream _createInputStream(Object session,			String path, boolean ignoreErrors, Component comp)			throws IOException		{			try			{				return new URL(path).openStream();			}			catch(MalformedURLException mu)			{				Log.log(Log.ERROR,this,mu);				String[] args = { mu.getMessage() };				VFSManager.error(comp,path,"ioerror.badurl",args);				return null;			}		}	
public OutputStream _createOutputStream(Object session, String path,			Component comp) throws IOException		{			try			{				return new URL(path).openConnection()					.getOutputStream();			}			catch(MalformedURLException mu)			{				Log.log(Log.ERROR,this,mu);				String[] args = { mu.getMessage() };				VFSManager.error(comp,path,"ioerror.badurl",args);				return null;			}		}	
protected UtilEvalError() {	    }	
public UtilEvalError( String s ) {	        super(s);	    }	
/**	        Re-throw as an eval error, prefixing msg to the message and specifying	        the node.  If a node already exists the addNode is ignored.	        <p>	        @param msg may be null for no additional message.	    */	    public EvalError toEvalError(	        String msg, SimpleNode node, CallStack callstack  )	    {	        if ( Interpreter.DEBUG )	            printStackTrace();		        if ( msg == null )	            msg = "";	        else	            msg = msg + ": ";	        return new EvalError( msg+getMessage(), node, callstack );	    }	
public EvalError toEvalError ( SimpleNode node, CallStack callstack )	    {	        return toEvalError( null, node, callstack );	    }	
public UtilTargetError( String message, Throwable t ) {			super( message );			this.t = t;		}	
public UtilTargetError( Throwable t ) {			this( null, t );		}	
/**			Override toEvalError to throw TargetError type.		*/		public EvalError toEvalError( 			String msg, SimpleNode node, CallStack callstack  ) 		{			if ( msg == null )				msg = getMessage();			else				msg = msg + ": " + getMessage();				return new TargetError( msg, t, node, callstack, false );		}	
Variable( String name, Class type, LHS lhs ) 		{			this.name = name;			this.lhs = lhs;			this.type = type;		}	
Variable( String name, Object value, Modifiers modifiers )			throws UtilEvalError		{			this( name, (Class)null/*type*/, value, modifiers );		}	
/**			This constructor is used in class generation.		*/		Variable( 			String name, String typeDescriptor, Object value, Modifiers modifiers 		)			throws UtilEvalError		{			this( name, (Class)null/*type*/, value, modifiers );			this.typeDescriptor = typeDescriptor;		}	
/**			@param value may be null if this 		*/		Variable( String name, Class type, Object value, Modifiers modifiers )			throws UtilEvalError		{				this.name=name;			this.type =	type;			this.modifiers = modifiers;			setValue( value, DECLARATION );		}	
/**			Set the value of the typed variable.			@param value should be an object or wrapped bsh Primitive type.			if value is null the appropriate default value will be set for the			type: e.g. false for boolean, zero for integer types.		*/		public void setValue( Object value, int context ) 			throws UtilEvalError		{				// check this.value			if ( hasModifier("final") && this.value != null )				throw new UtilEvalError ("Final variable, can't re-assign.");				if ( value == null )				value = Primitive.getDefaultValue( type );				if ( lhs != null )			{				lhs.assign( value, false/*strictjava*/ );				return;			}				// TODO: should add isJavaCastable() test for strictJava			// (as opposed to isJavaAssignable())			if ( type != null )				value = Types.castObject( value, type, 					context == DECLARATION ? Types.CAST : Types.ASSIGNMENT				);				this.value= value;		}	
Object getValue() 			throws UtilEvalError		{ 			if ( lhs != null )				return lhs.getValue();				return value; 		}	
/** A type of null means loosely typed variable */		public Class getType() { return type;	}	
public String getTypeDescriptor() { return typeDescriptor; }	
public Modifiers getModifiers() { return modifiers; }	
public String getName() { return name; }	
public boolean hasModifier( String name ) {			return modifiers != null && modifiers.hasModifier(name);		}	
public String toString() { 			return "Variable: "+super.toString()+" "+name+", type:"+type				+", value:"+value +", lhs = "+lhs;		}	
/**		 * Creates a variable grid layout manager with the specified mode,		 * size, horizontal and vertical gap, eventually taking minimum and maximum		 * sizes into account when distributing free space, depending on takeSizesIntoAccount		 * and the specified distance to the borders.		 *		 * @param mode The mode in which to operate. Either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS		 * @param size The amount of rows for mode FIXED_NUM_ROWS or the amount of columns for mode FIXED_NUM_COLUMNS (>0)		 * @param hgap The horizontal space between cells (>=0)		 * @param vgap The vertical space between cells (>=0)		 * @param takeSizesIntoAccount Whether to take minimum and maximum sizes into account when distributing free space		 * @param distanceToBorders The distances to the borders		 * @throws IllegalArgumentException if mode is not either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS or size is <= 0 or hgap or vgap is < 0		 */		public VariableGridLayout(int mode, int size, int hgap, int vgap, boolean takeSizesIntoAccount, Insets distanceToBorders)		{			if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS)			{				throw new IllegalArgumentException("illegal mode; value is " + mode);			}			if (size <= 0)			{				throw new IllegalArgumentException("size cannot be zero or less; value is " + size);			}			if (hgap < 0)			{				throw new IllegalArgumentException("hgap cannot be negative; value is " + hgap);			}			if (vgap < 0)			{				throw new IllegalArgumentException("vgap cannot be negative; value is " + vgap);			}			this.mode = mode;			this.size = size;			this.hgap = hgap;			this.vgap = vgap;			this.takeSizesIntoAccount = takeSizesIntoAccount;			this.distanceToBorders = (Insets)distanceToBorders.clone();		}	
/**		 * Creates a variable grid layout manager with the specified mode,		 * size, horizontal and vertical gap, eventually taking minimum and maximum		 * sizes into account when distributing free space, depending on takeSizesIntoAccount		 * and zero distance to borders.		 *		 * @param mode The mode in which to operate. Either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS		 * @param size The amount of rows for mode FIXED_NUM_ROWS or the amount of columns for mode FIXED_NUM_COLUMNS (>0)		 * @param hgap The horizontal space between cells (>=0)		 * @param vgap The vertical space between cells (>=0)		 * @param takeSizesIntoAccount Whether to take minimum and maximum sizes into account when distributing free space		 * @throws IllegalArgumentException if mode is not either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS or size is <= 0 or hgap or vgap is < 0		 */		public VariableGridLayout(int mode, int size, int hgap, int vgap, boolean takeSizesIntoAccount)		{			this(mode, size, hgap, vgap, takeSizesIntoAccount, new Insets(0,0,0,0));		}	
/**		 * Creates a variable grid layout manager with the specified mode,		 * size, horizontal and vertical gap, and zero distance to borders.		 * The minimum and maximum Component sizes are not taken into account		 * when distributing free space.		 *		 * @param mode The mode in which to operate. Either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS		 * @param size The amount of rows for mode FIXED_NUM_ROWS or the amount of columns for mode FIXED_NUM_COLUMNS		 * @param hgap The horizontal space between cells		 * @param vgap The vertical space between cells		 * @throws IllegalArgumentException if mode is not either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS or size is <= 0 or hgap or vgap is < 0		 */		public VariableGridLayout(int mode, int size, int hgap, int vgap)		{			this(mode, size, hgap, vgap, false, new Insets(0,0,0,0));		}	
/**		 * Creates a variable grid layout manager with the specified mode		 * and size, zero horizontal and vertical gap, and zero distance to borders. 		 * Does not take minimum and maximum Component sizes into account when distributing		 * free space.		 *		 * @param mode The mode in which to operate. Either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS		 * @param size The amount of rows for mode FIXED_NUM_ROWS or the amount of columns for mode FIXED_NUM_COLUMNS		 * @throws IllegalArgumentException if mode is not either FIXED_NUM_ROWS or FIXED_NUM_COLUMNS or size is <= 0		 */		public VariableGridLayout(int mode, int size)		{			this(mode, size, 0, 0, false, new Insets(0,0,0,0));		}	
/**		 * Creates a variable grid layout manager with mode FIXED_NUM_ROWS,		 * number of rows == 1, zero horizontal and vertical gap, and zero distance to borders.		 * Does not take minimum and maximum Component sizes into account when		 * distributing free space.		 */		public VariableGridLayout()		{			this(FIXED_NUM_ROWS, 1, 0, 0, false, new Insets(0,0,0,0));		}	
/**		 * Not used in this class.		 */		public void addLayoutComponent(String name, Component component)		{		}	
/**		 * Not used in this class.		 */		public void addLayoutComponent(Component component, Object constraints)		{		}	
/**		 * Not used in this class.		 */		public void removeLayoutComponent(Component component)		{		}	
/**		 * Always returns 0.5.		 */		public float getLayoutAlignmentX(Container container)		{			return 0.5f;		}	
/**		 * Always returns 0.5.		 */		public float getLayoutAlignmentY(Container container)		{			return 0.5f;		}	
public Dimension preferredLayoutSize(Container parent)		{			return getLayoutSize(parent,LayoutSize.PREFERRED);		}	
public Dimension minimumLayoutSize(Container parent)		{			return getLayoutSize(parent,LayoutSize.MINIMUM);		}	
public Dimension maximumLayoutSize(Container parent)		{			return getLayoutSize(parent,LayoutSize.MAXIMUM);		}	
public void layoutContainer(Container parent)		{			synchronized (parent.getTreeLock())			{				update(parent);					int ncomponents = parent.getComponentCount();					if (ncomponents == 0)				{					return;				}					// Pass 1: compute minimum, preferred and maximum row heights / column widths				int total_height = 0;				Arrays.fill(row_heights,0);				Arrays.fill(col_widths,0);				if (takeSizesIntoAccount)				{					Arrays.fill(minimum_row_heights,0);					Arrays.fill(minimum_col_widths,0);					Arrays.fill(maximum_row_heights,Integer.MAX_VALUE);					Arrays.fill(maximum_col_widths,Integer.MAX_VALUE);				}				for (int r = 0, i = 0; r < nrows; r++)				{					for (int c = 0; c < ncols; c++, i++)					{						if (i < ncomponents)						{							Component comp = parent.getComponent(i);							Dimension d = comp.getPreferredSize();							row_heights[r] = Math.max(row_heights[r], d.height);							col_widths[c] = Math.max(col_widths[c], d.width);							if (takeSizesIntoAccount)							{								d = comp.getMinimumSize();								minimum_row_heights[r] = Math.max(minimum_row_heights[r], d.height);								minimum_col_widths[c] = Math.max(minimum_col_widths[c], d.width);								d = comp.getMaximumSize();								maximum_row_heights[r] = Math.min(maximum_row_heights[r], d.height);								maximum_col_widths[c] = Math.min(maximum_col_widths[c], d.width);							}						}						else						{							break;						}					}					if (takeSizesIntoAccount)					{						// correct cases where						// minimum_row_heights[row] <= row_heights[row] <= maximum_row_heights[row]						// is not true by clipping to the minimum_row_heights and maximum_row_heights						if (minimum_row_heights[r] >= maximum_row_heights[r])						{							maximum_row_heights[r] = minimum_row_heights[r];							row_heights[r] = minimum_row_heights[r];						}						else if (row_heights[r] < minimum_row_heights[r])						{							row_heights[r] = minimum_row_heights[r];						}						else if (row_heights[r] > maximum_row_heights[r])						{							row_heights[r] = maximum_row_heights[r];						}					}					total_height += row_heights[r];				}					int total_width = 0;				for (int c = 0; c < ncols; c++)				{					if (takeSizesIntoAccount)					{						// correct cases where						// minimum_col_widths[col] <= col_widths[col] <= maximum_col_widths[col]						// is not true by clipping to the minimum_col_widths and maximum_col_widths						if (minimum_col_widths[c] >= maximum_col_widths[c])						{							maximum_col_widths[c] = minimum_col_widths[c];							col_widths[c] = minimum_col_widths[c];						}						else if (col_widths[c] < minimum_col_widths[c])						{							col_widths[c] = minimum_col_widths[c];						}						else if (col_widths[c] > maximum_col_widths[c])						{							col_widths[c] = maximum_col_widths[c];						}					}					total_width += col_widths[c];				}					// Pass 2: redistribute free space				Dimension parent_size = parent.getSize();				Insets insets = parent.getInsets();				int free_height = parent_size.height						  - insets.top - insets.bottom						  - (nrows - 1) * vgap						  - distanceToBorders.top - distanceToBorders.bottom;				int free_width = parent_size.width						 - insets.left - insets.right						 - (ncols - 1) * hgap						 - distanceToBorders.left - distanceToBorders.right;					redistributeSpace(total_height,free_height,						  takeSizesIntoAccount,						  nrows,row_heights,						  minimum_row_heights,						  maximum_row_heights);					redistributeSpace(total_width,free_width,						  takeSizesIntoAccount,						  ncols,col_widths,						  minimum_col_widths,						  maximum_col_widths);					// Pass 3: layout components				for (int r = 0, y = insets.top + distanceToBorders.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++)				{					for (int c = 0, x = insets.left + distanceToBorders.left; c < ncols; x += col_widths[c] + hgap, c++, i++)					{						if (i < ncomponents)						{							Component comp = parent.getComponent(i);							Dimension d = comp.getMaximumSize();							int width = col_widths[c];							int height = row_heights[r];							int xCorrection = 0;							int yCorrection = 0;							if (width > d.width)							{								xCorrection = (int)((width - d.width) * comp.getAlignmentX());								width = d.width;							}							if (height > d.height)							{								yCorrection = (int)((height-d.height) * comp.getAlignmentY());								height = d.height;							}														comp.setBounds(x + xCorrection, y + yCorrection, width, height);						}					}				}			} // synchronized		}	
public void invalidateLayout(Container container)		{		}	
/**		 * Returns the string representation of this variable grid layout's values.		 * @return  a string representation of this variable grid layout.		 */		public String toString()		{			return getClass().getName() + "[mode="				+ ((FIXED_NUM_ROWS == mode) ? "FIXED_NUM_ROWS"				   : ((FIXED_NUM_COLUMNS == mode) ? "FIXED_NUM_COLUMNS"				      : "UNKNOWN(" + mode + ")")) + ",size=" + size				+ ",hgap=" + hgap + ",vgap=" + vgap				+ ",takeSizesIntoAccount=" + takeSizesIntoAccount				+ ",distanceToBorders=" + distanceToBorders + "]";		}	
/**		 * @param  which  if LayoutSize.MINIMUM compute minimum layout size,		 *                if LayoutSize.MAXIMUM compute maximum layout size,		 *                if LayoutSize.PREFERRED compute preferred layout size.		 */		private Dimension getLayoutSize(Container parent, LayoutSize which)		{			synchronized (parent.getTreeLock())			{				update(parent);					int ncomponents = parent.getComponentCount();				long h = 0;				long w = 0;					for (int r = 0, i = 0; r < nrows; r++)				{					int row_height = 0;					for (int c = 0; c < ncols; c++, i++)					{						if (i < ncomponents)						{							switch (which)							{								case MINIMUM:									row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);									break;																case MAXIMUM:									row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);									break;																case PREFERRED:									row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);									break;																default:									throw new InternalError("Missing case branch for LayoutSize: " + which);							}						}					}					h += row_height;				}					for (int c = 0; c < ncols; c++)				{					int col_width = 0;					for (int r = 0; r < nrows; r++)					{						int i = r * ncols + c;						if (i < ncomponents)						{							switch (which)							{								case MINIMUM:									col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);									break;																case MAXIMUM:									col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);									break;																case PREFERRED:									col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);									break;																default:									throw new InternalError("Missing case branch for LayoutSize: " + which);							}						}					}					w += col_width;				}					Insets insets = parent.getInsets();				w += insets.left + insets.right + ((ncols - 1) * hgap) + distanceToBorders.left + distanceToBorders.right;				h += insets.top + insets.bottom + ((nrows - 1) * vgap) + distanceToBorders.top + distanceToBorders.bottom;				if (w > Integer.MAX_VALUE)				{					w = Integer.MAX_VALUE;				}				if (h > Integer.MAX_VALUE)				{					h = Integer.MAX_VALUE;				}				return new Dimension((int)w,(int)h);			}		}	
private void update(Container container)		{			int ncomponents = container.getComponentCount();			int old_nrows = nrows;			int old_ncols = ncols;			if (this.mode == FIXED_NUM_ROWS)			{				nrows = this.size;				ncols = (ncomponents + nrows - 1) / nrows;			}			else			{				ncols = this.size;				nrows = (ncomponents + ncols - 1) / ncols;			}			if (old_nrows != nrows)			{				row_heights = new int[nrows];				if (takeSizesIntoAccount)				{					minimum_row_heights = new int[nrows];					maximum_row_heights = new int[nrows];				}			}			if (old_ncols != ncols)			{				col_widths = new int[ncols];				if (takeSizesIntoAccount)				{					minimum_col_widths = new int[ncols];					maximum_col_widths = new int[ncols];				}			}		}	
private void redistributeSpace(int total_size, int free_size, boolean takeSizesIntoAccount,					       int nelements, int[] element_sizes,					       int[] minimum_element_sizes, int[] maximum_element_sizes)		{			if (total_size != free_size)			{				if (takeSizesIntoAccount)				{					boolean grow = total_size < free_size;					// calculate the size that is available for redistribution					free_size = (free_size - total_size) * (grow ? 1 : -1);					while (free_size != 0)					{						// calculate the amount of elements that can be resized without violating						// the minimum and maximum sizes and their current cumulated size						int modifyableAmount = 0;						int modifySize = 0;						for (int i = 0 ; i < nelements ; i++)						{							if ((grow && (element_sizes[i] < maximum_element_sizes[i])) ||							    (!grow && (element_sizes[i] > minimum_element_sizes[i])))							{								modifyableAmount++;								modifySize += element_sizes[i];							}						}						boolean checkBounds = true;						// if all elements are at their minimum or maximum size, resize all elements						if (0 == modifyableAmount)						{							for (int i = 0 ; i < nelements ; i++)							{								modifySize += element_sizes[i];							}							checkBounds = false;							modifyableAmount = nelements;						}						// to prevent an endless loop if the container gets resized to a very small amount						if (modifySize == 0)						{							break;						}						// resize the elements						if (free_size < modifyableAmount)						{							for (int i = 0 ; i < nelements ; i++)							{								if ((free_size != 0) &&								    (!checkBounds ||								     (checkBounds &&								      (grow && (element_sizes[i] < maximum_element_sizes[i])) ||								      (!grow && (element_sizes[i] > minimum_element_sizes[i])))))								{									element_sizes[i] += (grow ? 1 : -1);									if (0 > element_sizes[i])									{										element_sizes[i] = 0;									}									free_size--;								}							}						}						else						{							int modifySizeAddition = 0;							for (int i = 0 ; i < nelements ; i++)							{								int modifyableSize = (checkBounds ? (grow ? maximum_element_sizes[i] - element_sizes[i] : element_sizes[i] - minimum_element_sizes[i]) : Integer.MAX_VALUE - element_sizes[i]);								int elementModifySize = (int)((double)free_size / (double)modifySize * (double)element_sizes[i]);								if (elementModifySize <= modifyableSize)								{									element_sizes[i] += (grow ? elementModifySize : -elementModifySize);									modifySizeAddition += (grow ? elementModifySize : -elementModifySize);									free_size -= elementModifySize;								}								else								{									element_sizes[i] += (grow ? modifyableSize : -modifyableSize);									modifySizeAddition += (grow ? modifyableSize : -modifyableSize);									free_size -= modifyableSize;								}								if (0 > element_sizes[i])								{									element_sizes[i] = 0;								}							}							modifySize += modifySizeAddition;						}					}				}				else				{					double d = (double)free_size / (double)total_size;					for (int i = 0; i < nelements; i++)					{						element_sizes[i] = (int)(element_sizes[i] * d);					}				}			}		}	
/**		 * @deprecated Use the form where the constructor takes a capability		 * list.		 */		@Deprecated		protected VFS(String name)		{			this(name,0);		}	
/**		 * Creates a new virtual filesystem.		 * @param name The name		 * @param caps The capabilities		 */		protected VFS(String name, int caps)		{			this.name = name;			this.caps = caps;			// reasonable defaults (?)			this.extAttrs = new String[] { EA_SIZE, EA_TYPE };		}	
/**		 * Creates a new virtual filesystem.		 * @param name The name		 * @param caps The capabilities		 * @param extAttrs The extended attributes		 * @since jEdit 4.2pre1		 */		protected VFS(String name, int caps, String[] extAttrs)		{			this.name = name;			this.caps = caps;			this.extAttrs = extAttrs;		}	
/**		 * Returns this VFS's name. The name is used to obtain the		 * label stored in the <code>vfs.<i>name</i>.label</code>		 * property.		 */		public String getName()		{			return name;		}	
/**		 * Returns the capabilities of this VFS.		 * @since jEdit 2.6pre2		 */		public int getCapabilities()		{			return caps;		}	
/**		 * Returns if an additional markers file can be saved by this VFS.		 * Default is {@code true}.		 *		 * @since jEdit 4.3pre10		 */		public boolean isMarkersFileSupported()		{			return true;		}	
/**		 * Returns the extended attributes supported by this VFS.		 * @since jEdit 4.2pre1		 */		public String[] getExtendedAttributes()		{			return extAttrs;		}	
/**		 * Displays a dialog box that should set up a session and return		 * the initial URL to browse.		 * @param session Where the VFS session will be stored		 * @param comp The component that will parent error dialog boxes		 * @return The URL		 * @since jEdit 2.7pre1		 * @deprecated This function is not used in the jEdit core anymore,		 *             so it doesn't have to be provided anymore. If you want		 *             to use it for another purpose like in the FTP plugin,		 *             feel free to do so.		 */		@Deprecated		public String showBrowseDialog(Object[] session, Component comp)		{			return null;		}	
/**		 * Returns the file name component of the specified path.		 * @param path The path		 * @since jEdit 3.1pre4		 */		public String getFileName(String path)		{			if(path.equals("/"))				return path;				while(path.endsWith("/") || path.endsWith(File.separator))				path = path.substring(0,path.length() - 1);				int index = Math.max(path.lastIndexOf('/'),				path.lastIndexOf(File.separatorChar));			if(index == -1)				index = path.indexOf(':');				// don't want getFileName("roots:") to return ""			if(index == -1 || index == path.length() - 1)				return path;				return path.substring(index + 1);		}	
/**		 * Returns the parent of the specified path. This must be		 * overridden to return a non-null value for browsing of this		 * filesystem to work.		 * @param path The path		 * @since jEdit 2.6pre5		 */		public String getParentOfPath(String path)		{			// ignore last character of path to properly handle			// paths like /foo/bar/			int lastIndex = path.length() - 1;			while(lastIndex > 0				&& (path.charAt(lastIndex) == File.separatorChar				|| path.charAt(lastIndex) == '/'))			{				lastIndex--;			}				int count = Math.max(0,lastIndex);			int index = path.lastIndexOf(File.separatorChar,count);			if(index == -1)				index = path.lastIndexOf('/',count);			if(index == -1)			{				// this ensures that getFileParent("protocol:"), for				// example, is "protocol:" and not "".				index = path.lastIndexOf(':');			}				return path.substring(0,index + 1);		}	
/**		 * Constructs a path from the specified directory and		 * file name component. This must be overridden to return a		 * non-null value, otherwise browsing this filesystem will		 * not work.<p>		 *		 * Unless you are writing a VFS, this method should not be called		 * directly. To ensure correct behavior, you <b>must</b> call		 * {@link org.gjt.sp.jedit.MiscUtilities#constructPath(String,String)}		 * instead.		 *		 * @param parent The parent directory		 * @param path The path		 * @since jEdit 2.6pre2		 */		public String constructPath(String parent, String path)		{			return parent + path;		}	
/**		 * Returns the file separator used by this VFS.		 * @since jEdit 2.6pre9		 */		public char getFileSeparator()		{			return '/';		}	
/**		 * Returns a temporary file name based on the given path.		 *		 * By default jEdit first saves a file to <code>#<i>name</i>#save#</code>		 * and then renames it to the original file. However some virtual file		 * systems might not support the <code>#</code> character in filenames,		 * so this method permits the VFS to override this behavior.		 *		 * If this method returns <code>null</code>, two stage save will not		 * be used for that particular file (introduced in jEdit 4.3pre1).		 *		 * @param path The path name		 * @since jEdit 4.1pre7		 */		public String getTwoStageSaveName(String path)		{			return MiscUtilities.constructPath(getParentOfPath(path),				'#' + getFileName(path) + "#save#");		}	
/**		 * Called before a directory is reloaded by the file system browser.		 * Can be used to flush a cache, etc.		 * @since jEdit 4.0pre3		 */		public void reloadDirectory(String path) {}	
/**		 * Creates a VFS session. This method is called from the AWT thread,		 * so it should not do any I/O. It could, however, prompt for		 * a login name and password, for example.		 * @param path The path in question		 * @param comp The component that will parent any dialog boxes shown		 * @return The session. The session can be null if there were errors		 * @since jEdit 2.6pre3		 */		public Object createVFSSession(String path, Component comp)		{			return new Object();		}	
/**		 * Loads the specified buffer. The default implementation posts		 * an I/O request to the I/O thread.		 * @param view The view		 * @param buffer The buffer		 * @param path The path		 */		public boolean load(View view, Buffer buffer, String path)		{			if((getCapabilities() & READ_CAP) == 0)			{				VFSManager.error(view,path,"vfs.not-supported.load",new String[] { name });				return false;			}				Object session = createVFSSession(path,view);			if(session == null)				return false;				if((getCapabilities() & WRITE_CAP) == 0)				buffer.setReadOnly(true);				BufferIORequest request = new BufferLoadRequest(				view,buffer,session,this,path);			if(buffer.isTemporary())				// this makes HyperSearch much faster				request.run();			else				VFSManager.runInWorkThread(request);				return true;		}	
/**		 * Saves the specifies buffer. The default implementation posts		 * an I/O request to the I/O thread.		 * @param view The view		 * @param buffer The buffer		 * @param path The path		 */		public boolean save(View view, Buffer buffer, String path)		{			if((getCapabilities() & WRITE_CAP) == 0)			{				VFSManager.error(view,path,"vfs.not-supported.save",new String[] { name });				return false;			}				Object session = createVFSSession(path,view);			if(session == null)				return false;				/* When doing a 'save as', the path to save to (path)			 * will not be the same as the buffer's previous path			 * (buffer.getPath()). In that case, we want to create			 * a backup of the new path, even if the old path was			 * backed up as well (BACKED_UP property set) */			if(!path.equals(buffer.getPath()))				buffer.unsetProperty(Buffer.BACKED_UP);				VFSManager.runInWorkThread(new BufferSaveRequest(				view,buffer,session,this,path));			return true;		}	
/**		 * Copy a file to another using VFS.		 *		 * @param progress the progress observer. It could be null if you don't want to monitor progress. If not null		 *                  you should probably launch this command in a WorkThread		 * @param sourceVFS the source VFS		 * @param sourceSession the VFS session		 * @param sourcePath the source path		 * @param targetVFS the target VFS		 * @param targetSession the target session		 * @param targetPath the target path		 * @param comp comp The component that will parent error dialog boxes		 * @param canStop could this copy be stopped ?		 * @return true if the copy was successful		 * @throws IOException  IOException If an I/O error occurs		 * @since jEdit 4.3pre3		 */		public static boolean copy(ProgressObserver progress, VFS sourceVFS, Object sourceSession,String sourcePath,			VFS targetVFS, Object targetSession,String targetPath, Component comp, boolean canStop)		throws IOException		{			if (progress != null)				progress.setStatus("Initializing");				InputStream in = null;			OutputStream out = null;			try			{				VFSFile sourceVFSFile = sourceVFS._getFile(sourceSession, sourcePath, comp);				if (sourceVFSFile == null)					throw new FileNotFoundException(sourcePath);				if (progress != null)				{					progress.setMaximum(sourceVFSFile.getLength());				}				VFSFile targetVFSFile = targetVFS._getFile(targetSession, targetPath, comp);				if (targetVFSFile.getType() == VFSFile.DIRECTORY)				{					if (targetVFSFile.getPath().equals(sourceVFSFile.getPath()))						return false;					targetPath = MiscUtilities.constructPath(targetPath, sourceVFSFile.getName());				}				in = new BufferedInputStream(sourceVFS._createInputStream(sourceSession, sourcePath, false, comp));				out = new BufferedOutputStream(targetVFS._createOutputStream(targetSession, targetPath, comp));				boolean copyResult = IOUtilities.copyStream(IOBUFSIZE, progress, in, out, canStop);				VFSManager.sendVFSUpdate(targetVFS, targetPath, true);				return copyResult;			}			finally			{				IOUtilities.closeQuietly(in);				IOUtilities.closeQuietly(out);			}		}	
/**		 * Copy a file to another using VFS.		 *		 * @param progress the progress observer. It could be null if you don't want to monitor progress. If not null		 *                  you should probably launch this command in a WorkThread		 * @param sourcePath the source path		 * @param targetPath the target path		 * @param comp comp The component that will parent error dialog boxes		 * @param canStop if true the copy can be stopped		 * @return true if the copy was successful		 * @throws IOException IOException If an I/O error occurs		 * @since jEdit 4.3pre3		 */		public static boolean copy(ProgressObserver progress, String sourcePath,String targetPath, Component comp, boolean canStop)		throws IOException		{			VFS sourceVFS = VFSManager.getVFSForPath(sourcePath);			Object sourceSession = sourceVFS.createVFSSession(sourcePath, comp);			if (sourceSession == null)			{				Log.log(Log.WARNING, VFS.class, "Unable to get a valid session from " + sourceVFS + " for path " + sourcePath);				return false;			}			VFS targetVFS = VFSManager.getVFSForPath(targetPath);			Object targetSession = targetVFS.createVFSSession(targetPath, comp);			if (targetSession == null)			{				Log.log(Log.WARNING, VFS.class, "Unable to get a valid session from " + targetVFS + " for path " + targetPath);				return false;			}			return copy(progress, sourceVFS, sourceSession, sourcePath, targetVFS, targetSession, targetPath, comp,canStop);		}	
/**		 * Inserts a file into the specified buffer. The default implementation		 * posts an I/O request to the I/O thread.		 * @param view The view		 * @param buffer The buffer		 * @param path The path		 */		public boolean insert(View view, Buffer buffer, String path)		{			if((getCapabilities() & READ_CAP) == 0)			{				VFSManager.error(view,path,"vfs.not-supported.load",new String[] { name });				return false;			}				Object session = createVFSSession(path,view);			if(session == null)				return false;				VFSManager.runInWorkThread(new BufferInsertRequest(				view,buffer,session,this,path));			return true;		}	
/**		 * Returns the canonical form of the specified path name. For example,		 * <code>~</code> might be expanded to the user's home directory.		 * @param session The session		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @since jEdit 4.0pre2		 */		public String _canonPath(Object session, String path, Component comp)			throws IOException		{			return path;		}	
/**		 * A convinience method that matches file names against globs, and can		 * optionally list the directory recursively.		 * @param session The session		 * @param directory The directory. Note that this must be a full		 * URL, including the host name, path name, and so on. The		 * username and password (if needed by the VFS) is obtained from the		 * session instance.		 * @param glob Only file names matching this glob will be returned		 * @param recursive If true, subdirectories will also be listed.		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @since jEdit 4.1pre1		 */		public String[] _listDirectory(Object session, String directory,			String glob, boolean recursive, Component comp )			throws IOException		{			String[] retval = _listDirectory(session, directory, glob, recursive, comp, true, false);			return retval;		}	
/**		 * A convenience method that matches file names against globs, and can		 * optionally list the directory recursively.		 * @param session The session		 * @param directory The directory. Note that this must be a full		 * URL, including the host name, path name, and so on. The		 * username and password (if needed by the VFS) is obtained from the		 * session instance.		 * @param glob Only file names matching this glob will be returned		 * @param recursive If true, subdirectories will also be listed.		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @param skipBinary ignore binary files (do not return them).		 *    This will slow down the process since it will open the files		 * @param skipHidden skips hidden files, directories, and		 *        backup files. Ignores any file beginning with . or #, or ending with ~		 *        or .bak		 *		 *		 * @since jEdit 4.3pre5		 */		public String[] _listDirectory(Object session, String directory,			String glob, boolean recursive, Component comp,			boolean skipBinary, boolean skipHidden)			throws IOException		{			VFSFileFilter filter = new GlobVFSFileFilter(glob);			return _listDirectory(session, directory, filter,					      recursive, comp, skipBinary,					      skipHidden);		}	
/**		 * A convenience method that filters the directory listing		 * according to a filter, and can optionally list the directory		 * recursively.		 * @param session The session		 * @param directory The directory. Note that this must be a full		 * URL, including the host name, path name, and so on. The		 * username and password (if needed by the VFS) is obtained from the		 * session instance.		 * @param filter The {@link VFSFileFilter} to use for filtering.		 * @param recursive If true, subdirectories will also be listed.		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @param skipBinary ignore binary files (do not return them).		 *    This will slow down the process since it will open the files		 * @param skipHidden skips hidden files, directories, and		 *        backup files. Ignores any file beginning with . or #, or ending with ~		 *        or .bak		 *		 * @since jEdit 4.3pre7		 */		public String[] _listDirectory(Object session, String directory,			VFSFileFilter filter, boolean recursive, Component comp,			boolean skipBinary, boolean skipHidden)			throws IOException		{			List<String> files = new ArrayList<String>(100);				listFiles(session,new HashSet<String>(), files,directory,filter,				recursive, comp, skipBinary, skipHidden);				String[] retVal = files.toArray(new String[files.size()]);				Arrays.sort(retVal,new StandardUtilities.StringCompare<String>(true));				return retVal;		}	
/**		 * Lists the specified directory.		 * @param session The session		 * @param directory The directory. Note that this must be a full		 * URL, including the host name, path name, and so on. The		 * username and password (if needed by the VFS) is obtained from the		 * session instance.		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @since jEdit 4.3pre2		 */		public VFSFile[] _listFiles(Object session, String directory,			Component comp)			throws IOException		{			return _listDirectory(session,directory,comp);		}	
/**		 * @deprecated Use <code>_listFiles()</code> instead.		 */		@Deprecated		public DirectoryEntry[] _listDirectory(Object session, String directory,			Component comp)			throws IOException		{			VFSManager.error(comp,directory,"vfs.not-supported.list",new String[] { name });			return null;		}	
/**		 * Returns the specified directory entry.		 * @param session The session get it with {@link VFS#createVFSSession(String, Component)}		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @return The specified directory entry, or null if it doesn't exist.		 * @since jEdit 4.3pre2		 */		public VFSFile _getFile(Object session, String path,			Component comp)			throws IOException		{			return _getDirectoryEntry(session,path,comp);		}	
/**		 * Returns the specified directory entry.		 * @param session The session get it with {@link VFS#createVFSSession(String, Component)}		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @return The specified directory entry, or null if it doesn't exist.		 * @since jEdit 2.7pre1		 * @deprecated Use <code>_getFile()</code> instead.		 */		@Deprecated		public DirectoryEntry _getDirectoryEntry(Object session, String path,			Component comp)			throws IOException		{			return null;		}	
/**			 * @since jEdit 4.2pre2			 */			public DirectoryEntry()			{			}	
public DirectoryEntry(String name, String path, String deletePath,				int type, long length, boolean hidden)			{				this.name = name;				this.path = path;				this.deletePath = deletePath;				this.symlinkPath = path;				this.type = type;				this.length = length;				this.hidden = hidden;				if(path != null)				{					// maintain backwards compatibility					VFS vfs = VFSManager.getVFSForPath(path);					canRead = ((vfs.getCapabilities() & READ_CAP) != 0);					canWrite = ((vfs.getCapabilities() & WRITE_CAP) != 0);				}			}	
/**		 * Deletes the specified URL.		 * @param session The VFS session		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurs		 * @since jEdit 2.7pre1		 */		public boolean _delete(Object session, String path, Component comp)			throws IOException		{			return false;		}	
/**		 * Renames the specified URL. Some filesystems might support moving		 * URLs between directories, however others may not. Do not rely on		 * this behavior.		 * @param session The VFS session		 * @param from The old path		 * @param to The new path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurs		 * @since jEdit 2.7pre1		 */		public boolean _rename(Object session, String from, String to,			Component comp) throws IOException		{			return false;		}	
/**		 * Creates a new directory with the specified URL.		 * @param session The VFS session		 * @param directory The directory		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurs		 * @since jEdit 2.7pre1		 */		public boolean _mkdir(Object session, String directory, Component comp)			throws IOException		{			return false;		}	
/**		 * Backs up the specified file. This should only be overriden by		 * the local filesystem VFS.		 * @param session The VFS session		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurs		 * @since jEdit 3.2pre2		 */		public void _backup(Object session, String path, Component comp)			throws IOException		{		}	
/**		 * Creates an input stream. This method is called from the I/O		 * thread.		 * @param session the VFS session		 * @param path The path		 * @param ignoreErrors If true, file not found errors should be		 * ignored		 * @param comp The component that will parent error dialog boxes		 * @return an inputstream or <code>null</code> if there was a problem		 * @exception IOException If an I/O error occurs		 * @since jEdit 2.7pre1		 */		public InputStream _createInputStream(Object session,			String path, boolean ignoreErrors, Component comp)			throws IOException		{			VFSManager.error(comp,path,"vfs.not-supported.load",new String[] { name });			return null;		}	
/**		 * Creates an output stream. This method is called from the I/O		 * thread.		 * @param session the VFS session		 * @param path The path		 * @param comp The component that will parent error dialog boxes		 * @exception IOException If an I/O error occurs		 * @since jEdit 2.7pre1		 */		public OutputStream _createOutputStream(Object session,			String path, Component comp)			throws IOException		{			VFSManager.error(comp,path,"vfs.not-supported.save",new String[] { name });			return null;		}	
/**		 * Called after a file has been saved.		 * @param session The VFS session		 * @param buffer The buffer		 * @param path The path the buffer was saved to (can be different from		 * {@link org.gjt.sp.jedit.Buffer#getPath()} if the user invoked the		 * <b>Save a Copy As</b> command, for example).		 * @param comp The component that will parent error dialog boxes		 * @exception IOException If an I/O error occurs		 * @since jEdit 4.1pre9		 */		public void _saveComplete(Object session, Buffer buffer, String path,			Component comp) throws IOException {}	
/**		 * Called after a file has been saved and we use twoStageSave (first saving to		 * another file). This should re-apply permissions for example.			 * @param session The VFS session		 * @param buffer The buffer		 * @param path The path the buffer was saved to (can be different from		 * {@link org.gjt.sp.jedit.Buffer#getPath()} if the user invoked the		 * <b>Save a Copy As</b> command, for example).		 * @param comp The component that will parent error dialog boxes		 * @exception IOException If an I/O error occurs		 * @since jEdit 4.3pre4		 */		public void _finishTwoStageSave(Object session, Buffer buffer, String path,			Component comp) throws IOException		{		}	
/**		 * Finishes the specified VFS session. This must be called		 * after all I/O with this VFS is complete, to avoid leaving		 * stale network connections and such.		 * @param session The VFS session		 * @param comp The component that will parent error dialog boxes		 * @exception IOException if an I/O error occurred		 * @since jEdit 2.7pre1		 */		public void _endVFSSession(Object session, Component comp)			throws IOException		{		}	
/**		 * Returns color of the specified file name, by matching it against		 * user-specified regular expressions.		 * @since jEdit 4.0pre1		 */		public static Color getDefaultColorFor(String name)		{			synchronized(lock)			{				if(colors == null)					loadColors();					for(int i = 0; i < colors.size(); i++)				{					ColorEntry entry = colors.get(i);					if(entry.re.matcher(name).matches())						return entry.color;				}					return null;			}		}	
/**			 * Creates a new <code>DirectoryEntryCompare</code>.			 * @param sortMixFilesAndDirs If false, directories are			 * put at the top of the listing.			 * @param sortIgnoreCase If false, upper case comes before			 * lower case.			 */			public DirectoryEntryCompare(boolean sortMixFilesAndDirs,				boolean sortIgnoreCase)			{				this.sortMixFilesAndDirs = sortMixFilesAndDirs;				this.sortIgnoreCase = sortIgnoreCase;			}	
public int compare(VFSFile file1, VFSFile file2)			{				if(!sortMixFilesAndDirs)				{					if(file1.getType() != file2.getType())						return file2.getType() - file1.getType();				}					return StandardUtilities.compareStrings(file1.getName(),					file2.getName(),sortIgnoreCase);			}	
private void listFiles(Object session, Collection<String> stack,			List<String> files, String directory, VFSFileFilter filter, boolean recursive,			Component comp, boolean skipBinary, boolean skipHidden) throws IOException		{			String resolvedPath = directory;			if (recursive && !MiscUtilities.isURL(directory))			{				resolvedPath = MiscUtilities.resolveSymlinks(directory);				/*				 * If looking at a symlink, do not traverse the				 * resolved path more than once.				 */				if (!directory.equals(resolvedPath))				{					if (stack.contains(resolvedPath))					{						Log.log(Log.ERROR,this,							"Recursion in listFiles(): "							+ directory);						return;					}					stack.add(resolvedPath);				}			}				Thread ct = Thread.currentThread();			WorkThread wt = null;			if (ct instanceof WorkThread) {				wt = (WorkThread) ct;			}					VFSFile[] _files = _listFiles(session,directory,				comp);			if(_files == null || _files.length == 0)				return;				for(int i = 0; i < _files.length; i++)			{				if (wt != null && wt.isAborted()) break;				VFSFile file = _files[i];				if (skipHidden && (file.isHidden() || MiscUtilities.isBackup(file.getName())))					continue;				if(!filter.accept(file))					continue;				if(file.getType() == VFSFile.DIRECTORY					|| file.getType() == VFSFile.FILESYSTEM)				{					if(recursive)					{						String canonPath = _canonPath(session,							file.getPath(),comp);						listFiles(session,stack,files,							canonPath,filter,recursive,							comp, skipBinary, skipHidden);					}				}				else // It's a regular file				{					if (skipBinary)					{						try						{							if (file.isBinary(session))							{								Log.log(Log.NOTICE,this									,file.getPath() + ": skipped as a binary file");								continue;							}						}						catch(IOException e)						{							Log.log(Log.ERROR,this,e);							// may be not binary...						}					}					files.add(file.getPath());				}			}		}	
private static void loadColors()		{			synchronized(lock)			{				colors = new ArrayList<ColorEntry>();					if(!jEdit.getBooleanProperty("vfs.browser.colorize"))					return;					String glob;				int i = 0;				while((glob = jEdit.getProperty("vfs.browser.colors." + i + ".glob")) != null)				{					try					{						colors.add(new ColorEntry(							Pattern.compile(StandardUtilities.globToRE(glob)),							jEdit.getColorProperty(							"vfs.browser.colors." + i + ".color",							Color.black)));					}					catch(PatternSyntaxException e)					{						Log.log(Log.ERROR,VFS.class,"Invalid regular expression: "							+ glob);						Log.log(Log.ERROR,VFS.class,e);					}						i++;				}			}		}	
ColorEntry(Pattern re, Color color)			{				this.re = re;				this.color = color;			}	
/**		 * Opens the specified directory in a new, floating, file system browser.		 * @param view The view		 * @param path The directory's path		 * @since jEdit 4.1pre2		 */		public static void browseDirectoryInNewWindow(View view, String path)		{			DockableWindowManager wm = view.getDockableWindowManager();			if(path != null)			{				// this is such a bad way of doing it, but oh well...				jEdit.setTemporaryProperty("vfs.browser.path.tmp",path);			}			wm.floatDockableWindow("vfs.browser");			jEdit.unsetProperty("vfs.browser.path.tmp");		}	
/**		 * Opens the specified directory in a file system browser.		 * @param view The view		 * @param path The directory's path		 * @since jEdit 4.0pre3		 */		public static void browseDirectory(View view, String path)		{			DockableWindowManager wm = view.getDockableWindowManager();			VFSBrowser browser = (VFSBrowser)wm.getDockable(NAME);			if(browser != null)			{				wm.showDockableWindow(NAME);				browser.setDirectory(path);			}			else			{				if(path != null)				{					// this is such a bad way of doing it, but oh well...					jEdit.setTemporaryProperty("vfs.browser.path.tmp",path);				}				wm.addDockableWindow("vfs.browser");				jEdit.unsetProperty("vfs.browser.path.tmp");			}		}	
/**		 * Returns the browser action context.		 * @since jEdit 4.2pre1		 */		public static ActionContext getActionContext()		{			return actionContext;		}	
/**		 * Creates a new VFS browser.		 * @param view The view to open buffers in by default		 */		public VFSBrowser(View view, String position)		{			this(view,null,BROWSER,true,position);		}	
/**		 * Creates a new VFS browser.		 * @param view The view to open buffers in by default		 * @param path The path to display		 * @param mode The browser mode		 * @param multipleSelection True if multiple selection should be allowed		 * @param position Where the browser is located		 * @since jEdit 4.2pre1		 */		public VFSBrowser(View view, String path, int mode,			boolean multipleSelection, String position)		{			super(new BorderLayout());				listenerList = new EventListenerList();				this.mode = mode;			this.multipleSelection = multipleSelection;			this.view = view;				DockableWindowManager dwm = view.getDockableWindowManager();			KeyListener keyListener = dwm.closeListener(NAME);			addKeyListener(keyListener);						currentEncoding = jEdit.getProperty("buffer.encoding",				System.getProperty("file.encoding"));			autoDetectEncoding = jEdit.getBooleanProperty(				"buffer.encodingAutodetect");				ActionHandler actionHandler = new ActionHandler();				topBox = new Box(BoxLayout.Y_AXIS);			horizontalLayout = (mode != BROWSER				|| DockableWindowManager.TOP.equals(position)				|| DockableWindowManager.BOTTOM.equals(position));				toolbarBox = new Box(horizontalLayout				? BoxLayout.X_AXIS				: BoxLayout.Y_AXIS);				topBox.add(toolbarBox);				GridBagLayout layout = new GridBagLayout();			pathAndFilterPanel = new JPanel(layout);			if(isHorizontalLayout())				pathAndFilterPanel.setBorder(new EmptyBorder(12,12,12,12));				GridBagConstraints cons = new GridBagConstraints();			cons.gridwidth = cons.gridheight = 1;			cons.gridx = cons.gridy = 0;			cons.fill = GridBagConstraints.BOTH;			cons.anchor = GridBagConstraints.EAST;			JLabel label = new JLabel(jEdit.getProperty("vfs.browser.path"),				SwingConstants.RIGHT);			label.setBorder(new EmptyBorder(0,0,0,12));			layout.setConstraints(label,cons);			pathAndFilterPanel.add(label);				pathField = new HistoryTextField("vfs.browser.path");			pathField.setName("path");			pathField.addKeyListener(keyListener);			pathField.setInstantPopups(true);			pathField.setEnterAddsToHistory(false);			pathField.setSelectAllOnFocus(true);						if (mode == BROWSER)			{				pathField.addKeyListener(new KeyAdapter()				{					public void keyReleased(KeyEvent e)					{						if (e.getKeyCode() == KeyEvent.VK_ESCAPE)						{							pathField.setText(VFSBrowser.this.path);						}					}				});			}				// because its preferred size can be quite wide, we			// don't want it to make the browser way too big,			// so set the preferred width to 0.			Dimension prefSize = pathField.getPreferredSize();			prefSize.width = 0;			pathField.setPreferredSize(prefSize);			pathField.addActionListener(actionHandler);			cons.gridx = 1;			cons.weightx = 1.0;			cons.gridwidth = GridBagConstraints.REMAINDER;				layout.setConstraints(pathField,cons);			pathAndFilterPanel.add(pathField);				filterCheckbox = new JCheckBox(jEdit.getProperty("vfs.browser.filter"));			filterCheckbox.setMargin(new Insets(0,0,0,0));	//		filterCheckbox.setRequestFocusEnabled(false);			filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));			filterCheckbox.setSelected(jEdit.getBooleanProperty(				"vfs.browser.filter-enabled"));				filterCheckbox.addActionListener(actionHandler);			filterCheckbox.addKeyListener(keyListener);			filterCheckbox.setName("filter-checkbox");			if(mode != CHOOSE_DIRECTORY_DIALOG)			{				cons.gridwidth = 1;				cons.gridx = 0;				cons.weightx = 0.0;				cons.gridy = 1;				layout.setConstraints(filterCheckbox,cons);				pathAndFilterPanel.add(filterCheckbox);			}				filterField = new JComboBox();			filterEditor = new HistoryComboBoxEditor("vfs.browser.filter");			filterEditor.setToolTipText(jEdit.getProperty("glob.tooltip"));			filterEditor.setInstantPopups(true);			filterEditor.setSelectAllOnFocus(true);			filterEditor.addActionListener(actionHandler);			filterEditor.addKeyListener(keyListener);			filterField.setName("filter-field");			String filter;			if(mode == BROWSER || !jEdit.getBooleanProperty(				"vfs.browser.currentBufferFilter"))			{				filter = jEdit.getProperty("vfs.browser.last-filter");				if(filter == null)					filter = jEdit.getProperty("vfs.browser.default-filter");			}			else			{				String ext = MiscUtilities.getFileExtension(					view.getBuffer().getName());				if(ext.length() == 0)					filter = jEdit.getProperty("vfs.browser.default-filter");				else					filter = '*' + ext;			}				// filterField.getEditor().setItem(new GlobVFSFileFilter(filter));			// filterField.addItem(filterField.getEditor().getItem());			filterEditor.setItem(new GlobVFSFileFilter(filter));			filterField.addItem(filterEditor.getItem());			filterField.addItemListener(actionHandler);			filterField.setRenderer(new VFSFileFilterRenderer());				// loads the registered VFSFileFilter services.			String[] _filters = ServiceManager.getServiceNames(VFSFileFilter.SERVICE_NAME);			for (int i = 0; i < _filters.length; i++)			{				VFSFileFilter _filter = (VFSFileFilter)					ServiceManager.getService(VFSFileFilter.SERVICE_NAME, _filters[i]);				filterField.addItem(_filter);			}				if(mode != CHOOSE_DIRECTORY_DIALOG)			{				cons.gridwidth = GridBagConstraints.REMAINDER;				cons.fill = GridBagConstraints.HORIZONTAL;				cons.gridx = 1;				cons.weightx = 1.0;				if (filterField.getItemCount() > 1)				{					filterField.setEditor(filterEditor);					filterField.setEditable(true);					layout.setConstraints(filterField,cons);					pathAndFilterPanel.add(filterField);				}				else				{					layout.setConstraints(filterEditor,cons);					pathAndFilterPanel.add(filterEditor);				}			}				topBox.add(pathAndFilterPanel);			add(BorderLayout.NORTH,topBox);				add(BorderLayout.CENTER,browserView = new BrowserView(this));			if(isHorizontalLayout())				browserView.setBorder(new EmptyBorder(0,12,0,12));			defaultFocusComponent = browserView.getTable();			propertiesChanged();				updateFilterEnabled();				setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());			// see VFSBrowser.browseDirectory()			if(path == null)				path = jEdit.getProperty("vfs.browser.path.tmp");				if(path == null || path.length() == 0)			{				String userHome = System.getProperty("user.home");				String defaultPath = jEdit.getProperty("vfs.browser.defaultPath");				if("home".equals(defaultPath))					path = userHome;				else if("working".equals(defaultPath))					path = System.getProperty("user.dir");				else if("buffer".equals(defaultPath))				{					Buffer buffer = view.getBuffer();					path = buffer.getDirectory();				}				else if("last".equals(defaultPath))				{					HistoryModel pathModel = HistoryModel.getModel("vfs.browser.path");					if(pathModel.getSize() == 0)						path = "~";					else						path = pathModel.getItem(0);				}				else if("favorites".equals(defaultPath))					path = "favorites:";				else				{					// unknown value??!!!					path = userHome;				}			}				final String _path = path;				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					setDirectory(_path);				}			});		}	
public void focusOnDefaultComponent()		{			// pathField.requestFocus();					defaultFocusComponent.requestFocus();		}	
/** Only used by VFSFileChooserDialog, since it embeds this in a dialog		 */		void setDefaultFocusComponent(JComponent c) 		{			defaultFocusComponent = c;		}	
@Override		public void addNotify()		{			super.addNotify();			EditBus.addToBus(this);		}	
@Override		public void removeNotify()		{			super.removeNotify();			jEdit.setBooleanProperty("vfs.browser.filter-enabled",				filterCheckbox.isSelected());			if(mode == BROWSER || !jEdit.getBooleanProperty(				"vfs.browser.currentBufferFilter"))			{				VFSFileFilter selectedFilter =					(VFSFileFilter) filterField.getSelectedItem();				if (selectedFilter instanceof GlobVFSFileFilter)					jEdit.setProperty("vfs.browser.last-filter",						((GlobVFSFileFilter)selectedFilter).getGlob());			}			EditBus.removeFromBus(this);		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof PropertiesChanged)				propertiesChanged();			else if(msg instanceof BufferUpdate)			{				BufferUpdate bmsg = (BufferUpdate)msg;				if(bmsg.getWhat() == BufferUpdate.CREATED					|| bmsg.getWhat() == BufferUpdate.CLOSED)					browserView.updateFileView();			}			else if(msg instanceof PluginUpdate)			{				PluginUpdate pmsg = (PluginUpdate)msg;				if((pmsg.getWhat() == PluginUpdate.LOADED ||				   pmsg.getWhat() == PluginUpdate.UNLOADED) &&					plugins != null /* plugins can be null if the VFSBrowser menu bar is hidden */)				{					plugins.updatePopupMenu();				}			}			else if(msg instanceof VFSUpdate)			{				maybeReloadDirectory(((VFSUpdate)msg).getPath());			}		}	
public View getView()		{			return view;		}	
public int getMode()		{			return mode;		}	
public boolean isMultipleSelectionEnabled()		{			return multipleSelection;		}	
public boolean isHorizontalLayout()		{			return horizontalLayout;		}	
public boolean getShowHiddenFiles()		{			return showHiddenFiles;		}	
public void setShowHiddenFiles(boolean showHiddenFiles)		{			this.showHiddenFiles = showHiddenFiles;		}	
/**		 * Returns the file name filter glob.		 * @since jEdit 3.2pre2		 * @deprecated Use {@link #getVFSFileFilter()} instead. This method		 *             might return wrong information since jEdit 4.3pre6.		 */		@Deprecated		public String getFilenameFilter()		{			if(filterCheckbox.isSelected())			{				String filter = filterField.getSelectedItem().toString();				if(filter.length() == 0)					return "*";				else					return filter;			}			else				return "*";		}	
/**		 * Returns the currently active VFSFileFilter.		 *		 * @since jEdit 4.3pre7		 */		public VFSFileFilter getVFSFileFilter()		{			if (mode == CHOOSE_DIRECTORY_DIALOG)				return new DirectoriesOnlyFilter();			return 	(VFSFileFilter) filterField.getSelectedItem();		}	
/**		 * Adds a file filter to the browser.		 *		 * @since jEdit 4.3pre7		 */		public void addVFSFileFilter(VFSFileFilter filter)		{			filterField.addItem(filter);			if (filterField.getItemCount() == 2)			{				filterField.setEditor(filterEditor);				filterField.setEditable(true);					GridBagLayout layout = (GridBagLayout) pathAndFilterPanel.getLayout();				GridBagConstraints cons =layout.getConstraints(filterEditor);				cons.gridwidth = GridBagConstraints.REMAINDER;				cons.fill = GridBagConstraints.HORIZONTAL;				cons.gridx = 1;				cons.weightx = 1;					pathAndFilterPanel.remove(filterEditor);				layout.setConstraints(filterField, cons);				pathAndFilterPanel.add(filterField);				pathAndFilterPanel.validate();				pathAndFilterPanel.repaint();			}		}	
public void setFilenameFilter(String filter)		{			if(filter == null || filter.length() == 0 || "*".equals(filter))				filterCheckbox.setSelected(false);			else			{				filterCheckbox.setSelected(true);				filterEditor.setItem(new GlobVFSFileFilter(filter));			}		}	
public HistoryTextField getDirectoryField()		{			return pathField;		}	
public String getDirectory()		{			return path;		}	
/**		 * @since jedit 4.3pre15		 */		public void previousDirectory() 		{			if (historyStack.size() > 1)			{				historyStack.pop();				nextDirectoryStack.push(path);				setDirectory(historyStack.peek());				historyStack.pop();			}		}	
/**		 * @since jEdit 4.3pre15		 */		public void nextDirectory() 		{			if (!nextDirectoryStack.isEmpty())			{				setDirectory(nextDirectoryStack.pop());			}		}	
public void setDirectory(String path)		{			if(path.startsWith("file:"))				path = path.substring(5);			path = MiscUtilities.expandVariables(path);			pathField.setText(path);				if(!startRequest())				return;				historyStack.push(path);			browserView.saveExpansionState();			browserView.loadDirectory(null,path,true);			this.path = path;				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					endRequest();				}			});		}	
public static String getRootDirectory()		{			if(OperatingSystem.isMacOS() || OperatingSystem.isDOSDerived())				return FileRootsVFS.PROTOCOL + ':';			else				return "/";		}	
/**		 * Goes to the local drives directory.		 * @since jEdit 4.0pre4		 */		public void rootDirectory()		{			setDirectory(getRootDirectory());		}	
public void reloadDirectory()		{			// used by FTP plugin to clear directory cache			VFSManager.getVFSForPath(path).reloadDirectory(path);				browserView.saveExpansionState();			browserView.loadDirectory(null,path,false);		}	
/**		 * Note that all files must be on the same VFS.		 * @since jEdit 4.3pre2		 */		public void delete(VFSFile[] files)		{			String dialogType;				if(MiscUtilities.isURL(files[0].getDeletePath())				&& FavoritesVFS.PROTOCOL.equals(				MiscUtilities.getProtocolOfURL(files[0].getDeletePath())))			{				dialogType = "vfs.browser.delete-favorites";			}			else			{				dialogType = "vfs.browser.delete-confirm";			}				StringBuilder buf = new StringBuilder();			String typeStr = "files";			for(int i = 0; i < files.length; i++)			{				buf.append(files[i].getPath());				buf.append('\n');				if (files[i].getType() == VFSFile.DIRECTORY)					typeStr = "directories and their contents";			}				Object[] args = { buf.toString(), typeStr};						int result = GUIUtilities.confirm(this,dialogType,args,				JOptionPane.YES_NO_OPTION,				JOptionPane.WARNING_MESSAGE);			if(result != JOptionPane.YES_OPTION)				return;				VFS vfs = VFSManager.getVFSForPath(files[0].getDeletePath());				if(!startRequest())				return;				for(int i = 0; i < files.length; i++)			{				Object session = vfs.createVFSSession(files[i].getDeletePath(),this);				if(session == null)					continue;					VFSManager.runInWorkThread(new BrowserIORequest(					BrowserIORequest.DELETE,this,					session,vfs,files[i].getDeletePath(),					null,null));			}				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					endRequest();				}			});		}	
public void rename(String from)		{			VFS vfs = VFSManager.getVFSForPath(from);				String filename = vfs.getFileName(from);			String[] args = { filename };			String to = GUIUtilities.input(this,"vfs.browser.rename",				args,filename);			if(to == null)				return;				to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);				Object session = vfs.createVFSSession(from,this);			if(session == null)				return;				if(!startRequest())				return;				VFSManager.runInWorkThread(new BrowserIORequest(				BrowserIORequest.RENAME,this,				session,vfs,from,to,null));				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					endRequest();				}			});		}	
public void rename(String from, String newname)		{			VFS vfs = VFSManager.getVFSForPath(from);				String filename = vfs.getFileName(from);			String[] args = { filename };			String to = newname;						if(to == null || filename.equals(newname))				return;				to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);				Object session = vfs.createVFSSession(from,this);			if(session == null)				return;				if(!startRequest())				return;				VFSManager.runInWorkThread(new BrowserIORequest(				BrowserIORequest.RENAME,this,				session,vfs,from,to,null));				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					endRequest();				}			});		}	
public void mkdir()		{			String newDirectory = GUIUtilities.input(this,"vfs.browser.mkdir",null);			if(newDirectory == null)				return;				// if a directory is selected, create new dir in there.			// if a file is selected, create new dir inside its parent.			final VFSFile[] selected = getSelectedFiles();			String parent;			if(selected.length == 0)				parent = path;			else if(selected[0].getType() == VFSFile.FILE)			{				parent = selected[0].getPath();				parent = VFSManager.getVFSForPath(parent)					.getParentOfPath(parent);			}			else				parent = selected[0].getPath();				VFS vfs = VFSManager.getVFSForPath(parent);				// path is the currently viewed directory in the browser			newDirectory = MiscUtilities.constructPath(parent,newDirectory);				Object session = vfs.createVFSSession(newDirectory,this);			if(session == null)				return;				if(!startRequest())				return;				VFSManager.runInWorkThread(new BrowserIORequest(				BrowserIORequest.MKDIR,this,				session,vfs,newDirectory,null,null));				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					endRequest();					if (selected.length != 0 && selected[0].getType() != VFSFile.FILE)					{						VFSDirectoryEntryTable directoryEntryTable = browserView.getTable();						int selectedRow = directoryEntryTable.getSelectedRow();						VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel) directoryEntryTable.getModel();						VFSDirectoryEntryTableModel.Entry entry = model.files[selectedRow];						if (!entry.expanded)						{							browserView.clearExpansionState();							browserView.loadDirectory(entry,entry.dirEntry.getPath(),								false);						}					}				}			});		}	
/**		 * Creates a new file in the current directory.		 * @since jEdit 4.0pre2		 */		public void newFile()		{			VFSFile[] selected = getSelectedFiles();			if(selected.length >= 1)			{				VFSFile file = selected[0];				if(file.getType() == VFSFile.DIRECTORY)					jEdit.newFile(view,file.getPath());				else				{					VFS vfs = VFSManager.getVFSForPath(file.getPath());					jEdit.newFile(view,vfs.getParentOfPath(file.getPath()));				}			}			else				jEdit.newFile(view,path);		}	
/**		 * Show selected file's properties.		 */		public void fileProperties(VFSFile[] files)		{			new FilePropertiesDialog(view, this, files);		}	
/**		 * Opens a directory search in the current directory.		 * @since jEdit 4.0pre2		 */		public void searchInDirectory()		{			VFSFile[] selected = getSelectedFiles();			if(selected.length >= 1)			{				VFSFile file = selected[0];				searchInDirectory(file.getPath(),file.getType() != VFSFile.FILE);			}			else			{				searchInDirectory(path,true);			}		}	
/**		 * Opens a directory search in the specified directory.		 * @param path The path name		 * @param directory True if the path is a directory, false if it is a file		 * @since jEdit 4.2pre1		 */		public void searchInDirectory(String path, boolean directory)		{			String filter;			VFSFileFilter vfsff = getVFSFileFilter();			if (vfsff instanceof GlobVFSFileFilter)				filter = ((GlobVFSFileFilter)vfsff).getGlob();			else				filter = "*";				if (!directory)			{				String name = MiscUtilities.getFileName(path);				String ext = MiscUtilities.getFileExtension(name);				filter = (ext == null || ext.length() == 0					? filter : '*' + ext);				path = MiscUtilities.getParentOfPath(path);			}				SearchAndReplace.setSearchFileSet(new DirectoryListSet(				path,filter,true));			SearchDialog.showSearchDialog(view,null,SearchDialog.DIRECTORY);		}	
BrowserView getBrowserView()		{			return browserView;		}	
/**		 * @since jEdit 4.3pre2		 */		public VFSFile[] getSelectedFiles()		{			return browserView.getSelectedFiles();		}	
/**		 * Goes to the given file's directory and selects the file in the list.		 * @param path The file		 * @since jEdit 4.2pre2		 */		public void locateFile(final String path)		{			VFSFileFilter filter = getVFSFileFilter();			if(!filter.accept(MiscUtilities.getFileName(path)))				setFilenameFilter(null);				setDirectory(MiscUtilities.getParentOfPath(path));			VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					browserView.getTable().selectFile(path);				}			});		}	
public JComponent createPluginsMenu(JComponent pluginMenu, boolean showManagerOptions)		{			ActionHandler actionHandler = new ActionHandler();			if(showManagerOptions && getMode() == BROWSER)			{				pluginMenu.add(GUIUtilities.loadMenuItem("plugin-manager",false));				pluginMenu.add(GUIUtilities.loadMenuItem("plugin-options",false));				if (pluginMenu instanceof JMenu)					((JMenu)pluginMenu).addSeparator();				else if (pluginMenu instanceof JPopupMenu)					((JPopupMenu)pluginMenu).addSeparator();				}			else				/* we're in a modal dialog */;				List<JMenuItem> vec = new ArrayList<JMenuItem>();				//{{{ old API			Enumeration<VFS> e = VFSManager.getFilesystems();				while(e.hasMoreElements())			{				VFS vfs = e.nextElement();				if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)					continue;						JMenuItem menuItem = new JMenuItem(jEdit.getProperty(							"vfs." + vfs.getName() + ".label"));					menuItem.setActionCommand(vfs.getName());					menuItem.addActionListener(actionHandler);					vec.add(menuItem);			} //}}}				//{{{ new API			EditPlugin[] plugins = jEdit.getPlugins();			for (int i = 0; i < plugins.length; i++)			{				JMenuItem menuItem = plugins[i].createBrowserMenuItems();				if(menuItem != null)					vec.add(menuItem);			} //}}}				if (!vec.isEmpty())			{				Collections.sort(vec,new MenuItemTextComparator());				for(int i = 0; i < vec.size(); i++)					pluginMenu.add(vec.get(i));			}			else			{				JMenuItem mi = new JMenuItem(jEdit.getProperty(						"vfs.browser.plugins.no-plugins.label"));				mi.setEnabled(false);				pluginMenu.add(mi);			}				return pluginMenu;		}	
public void addBrowserListener(BrowserListener l)		{			listenerList.add(BrowserListener.class,l);		}	
public void removeBrowserListener(BrowserListener l)		{			listenerList.remove(BrowserListener.class,l);		}	
/**		 * This method does the "double-click" handling. It is public so that		 * <code>browser.actions.xml</code> can bind to it.		 * @since jEdit 4.2pre2		 */		public void filesActivated(int mode, boolean canDoubleClickClose)		{			VFSFile[] selectedFiles = browserView.getSelectedFiles();				Buffer buffer = null;		check_selected: for(int i = 0; i < selectedFiles.length; i++)			{				VFSFile file = selectedFiles[i];					if(file.getType() == VFSFile.DIRECTORY					|| file.getType() == VFSFile.FILESYSTEM)				{					if(mode == M_OPEN_NEW_VIEW && this.mode == BROWSER)						browseDirectoryInNewWindow(view,file.getPath());					else						setDirectory(file.getPath());				}				else if(this.mode == BROWSER || this.mode == BROWSER_DIALOG)				{					if(mode == M_INSERT)					{						view.getBuffer().insertFile(view,							file.getPath());						continue check_selected;					}						Buffer _buffer = jEdit.getBuffer(file.getPath());					if(_buffer == null)					{						Hashtable<String, Object> props = new Hashtable<String, Object>();						props.put(JEditBuffer.ENCODING,currentEncoding);						props.put(Buffer.ENCODING_AUTODETECT,							  Boolean.valueOf(autoDetectEncoding));						_buffer = jEdit.openFile(view, null,							file.getPath(),false,props);					}					else if(doubleClickClose && canDoubleClickClose						&& this.mode != BROWSER_DIALOG						&& selectedFiles.length == 1)					{						// close if this buffer is currently						// visible in the view.						EditPane[] editPanes = view.getEditPanes();						for(int j = 0; j < editPanes.length; j++)						{							if(editPanes[j].getBuffer() == _buffer)							{								jEdit.closeBuffer(view,_buffer);								return;							}						}					}						if(_buffer != null)						buffer = _buffer;				}				else				{					// if a file is selected in OPEN_DIALOG or					// SAVE_DIALOG mode, just let the listener(s)					// handle it				}			}				if(buffer != null)			{				switch(mode)				{				case M_OPEN:					view.setBuffer(buffer);					break;				case M_OPEN_NEW_VIEW:					jEdit.newView(view,buffer,false);					break;				case M_OPEN_NEW_PLAIN_VIEW:					jEdit.newView(view,buffer,true);					break;				case M_OPEN_NEW_SPLIT:					view.splitHorizontally().setBuffer(buffer);					break;				}			}				Object[] listeners = listenerList.getListenerList();			for(int i = 0; i < listeners.length; i++)			{				if(listeners[i] == BrowserListener.class)				{					BrowserListener l = (BrowserListener)listeners[i+1];					l.filesActivated(this,selectedFiles);				}			}		}	
public void move(String newPosition)		{			boolean horz = (mode != BROWSER					|| DockableWindowManager.TOP.equals(newPosition)					|| DockableWindowManager.BOTTOM.equals(newPosition));			if (horz == horizontalLayout)				return;			horizontalLayout = horz;			topBox.remove(toolbarBox);			toolbarBox = new Box(horizontalLayout					? BoxLayout.X_AXIS					: BoxLayout.Y_AXIS);			topBox.add(toolbarBox, 0);			propertiesChanged();		}	
void directoryLoaded(Object node, Object[] loadInfo,			boolean addToHistory)		{			VFSManager.runInAWTThread(new DirectoryLoadedAWTRequest(				node,loadInfo,addToHistory));		}	
void filesSelected()		{			VFSFile[] selectedFiles = browserView.getSelectedFiles();				if(mode == BROWSER)			{				for(int i = 0; i < selectedFiles.length; i++)				{					VFSFile file = selectedFiles[i];					Buffer buffer = jEdit.getBuffer(file.getPath());					if(buffer != null && view != null)						view.setBuffer(buffer);				}			}				Object[] listeners = listenerList.getListenerList();			for(int i = 0; i < listeners.length; i++)			{				if(listeners[i] == BrowserListener.class)				{					BrowserListener l = (BrowserListener)listeners[i+1];					l.filesSelected(this,selectedFiles);				}			}		}	
void endRequest()		{			requestRunning = false;		}	
private Container createMenuBar()		{			JToolBar menuBar = new JToolBar();			menuBar.setFloatable(false);				menuBar.add(new CommandsMenuButton());			menuBar.add(Box.createHorizontalStrut(3));			menuBar.add(plugins = new PluginsMenuButton());			menuBar.add(Box.createHorizontalStrut(3));			menuBar.add(favorites = new FavoritesMenuButton());				return menuBar;		}	
private Container createToolBar()		{			if(mode == BROWSER)				return GUIUtilities.loadToolBar(actionContext,					"vfs.browser.toolbar-browser");			else				return GUIUtilities.loadToolBar(actionContext,					"vfs.browser.toolbar-dialog");		}	
private void propertiesChanged()		{			showHiddenFiles = jEdit.getBooleanProperty("vfs.browser.showHiddenFiles");			sortMixFilesAndDirs = jEdit.getBooleanProperty("vfs.browser.sortMixFilesAndDirs");			sortIgnoreCase = jEdit.getBooleanProperty("vfs.browser.sortIgnoreCase");			doubleClickClose = jEdit.getBooleanProperty("vfs.browser.doubleClickClose");				browserView.propertiesChanged();				toolbarBox.removeAll();				if(jEdit.getBooleanProperty("vfs.browser.showToolbar"))			{				Container toolbar = createToolBar();				if(horizontalLayout)					toolbarBox.add(toolbar);				else				{					toolbarBox.add(toolbar);				}			}				if(jEdit.getBooleanProperty("vfs.browser.showMenubar"))			{				Container menubar = createMenuBar();				if(horizontalLayout)				{					toolbarBox.add(menubar,0);				}				else				{					menubar.add(Box.createGlue());					toolbarBox.add(menubar);				}			}			else			{				plugins = null;				favorites = null;			}				revalidate();				if(path != null)				reloadDirectory();		}	
private boolean startRequest()		{			if(requestRunning)			{				// dump stack trace for debugging purposes				Log.log(Log.DEBUG,this,new Throwable("For debugging purposes"));					GUIUtilities.error(this,"browser-multiple-io",null);				return false;			}			else			{				requestRunning = true;				return true;			}		}	
private void updateFilterEnabled()		{			filterField.setEnabled(filterCheckbox.isSelected());			filterEditor.setEnabled(filterCheckbox.isSelected());		}	
private void maybeReloadDirectory(String dir)		{			if(MiscUtilities.isURL(dir)				&& MiscUtilities.getProtocolOfURL(dir).equals(				FavoritesVFS.PROTOCOL))			{				if(favorites != null)					favorites.popup = null;			}				// this is a dirty hack and it relies on the fact			// that updates for parents are sent before updates			// for the changed nodes themselves (if this was not			// the case, the browser wouldn't be updated properly			// on delete, etc).			//			// to avoid causing '> 1 request' errors, don't reload			// directory if request already active			if(maybeReloadRequestRunning)			{				//Log.log(Log.WARNING,this,"VFS update: request already in progress");				return;			}				// save a file -> sends vfs update. if a VFS file dialog box			// is shown from the same event frame as the save, the			// VFSUpdate will be delivered before the directory is loaded,			// and before the path is set.			if(path != null)			{				try				{					maybeReloadRequestRunning = true;						browserView.maybeReloadDirectory(dir);				}				finally				{					VFSManager.runInAWTThread(new Runnable()					{						public void run()						{							maybeReloadRequestRunning = false;						}					});				}			}		}	
public void actionPerformed(ActionEvent evt)			{				if (isProcessingEvent)					return;					Object source = evt.getSource();					if (source == pathField				    || source == filterCheckbox)				{					isProcessingEvent = true;					resetLater();						updateFilterEnabled();						String p = pathField.getText();										if(p != null)						setDirectory(p);					browserView.focusOnFileView();				}					else if (source == filterField.getEditor())				{					// force the editor to refresh.					filterField.getEditor().setItem(						filterField.getEditor().getItem());				}					// depending on Swing look & feel, filterField.getEditor()				// returns some ComboBoxUI				else if (source == filterEditor)				{					// force the editor to refresh.					filterEditor.setItem(						filterEditor.getItem());					filterField.setSelectedItem(						filterEditor.getItem());					// ### ugly: 					// itemStateChanged does not seem to get fired					itemStateChanged(new ItemEvent(filterField,						ItemEvent.ITEM_STATE_CHANGED,						filterEditor.getItem(),						ItemEvent.SELECTED));				}			}	
public void itemStateChanged(ItemEvent e)			{				if (isProcessingEvent)					return;					if (e.getStateChange() != ItemEvent.SELECTED)					return;					isProcessingEvent = true;				resetLater();					filterField.setEditable(e.getItem() instanceof GlobVFSFileFilter);				updateFilterEnabled();				String path = pathField.getText();				if(path != null)					setDirectory(path);					browserView.focusOnFileView();			}	
/**			 * Why this method exists: since both actionPerformed()			 * and itemStateChanged() above can change the combo box,			 * executing one of them can cause a chain reaction causing			 * the other method to be called. This would cause the			 * VFS subsystem to be called several times, which would			 * cause a warning to show up if the first operation is			 * still in progress, or cause a second operation to happen			 * which is not really wanted especially if we're talking			 * about a remove VFS. So the methods set a flag saying			 * that something is going on, and this method resets			 * the flag after the AWT thread is done with the			 * current events.			 */			private void resetLater()			{				SwingUtilities.invokeLater(					new Runnable()					{						public void run()						{							isProcessingEvent = false;						}					}				);			}	
CommandsMenuButton()			{				setText(jEdit.getProperty("vfs.browser.commands.label"));				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("dropdown-arrow.icon")));				setHorizontalTextPosition(SwingConstants.LEADING);				setName("commands");								popup = new BrowserCommandsMenu(VFSBrowser.this,null);					CommandsMenuButton.this.setRequestFocusEnabled(false);				setMargin(new Insets(1,1,1,1));				CommandsMenuButton.this.addMouseListener(new MouseHandler());					if(OperatingSystem.isMacOSLF())					CommandsMenuButton.this.putClientProperty("JButton.buttonType","toolbar");			}	
@Override				public void mousePressed(MouseEvent evt)				{					if(!popup.isVisible())					{						popup.update();							GUIUtilities.showPopupMenu(							popup,CommandsMenuButton.this,0,							CommandsMenuButton.this.getHeight(),							false);					}					else					{						popup.setVisible(false);					}				}	
PluginsMenuButton()			{				setText(jEdit.getProperty("vfs.browser.plugins.label"));				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("dropdown-arrow.icon")));				setHorizontalTextPosition(SwingConstants.LEADING);				setName("plugins");								PluginsMenuButton.this.setRequestFocusEnabled(false);				setMargin(new Insets(1,1,1,1));				PluginsMenuButton.this.addMouseListener(new MouseHandler());					if(OperatingSystem.isMacOSLF())					PluginsMenuButton.this.putClientProperty("JButton.buttonType","toolbar");			}	
void updatePopupMenu()			{				popup = null;			}	
private void createPopupMenu()			{				if(popup != null)					return;					popup = (JPopupMenu)createPluginsMenu(new JPopupMenu(),true);			}	
@Override				public void mousePressed(MouseEvent evt)				{					createPopupMenu();						if(!popup.isVisible())					{						GUIUtilities.showPopupMenu(							popup,PluginsMenuButton.this,0,							PluginsMenuButton.this.getHeight(),							false);					}					else					{						popup.setVisible(false);					}				}	
FavoritesMenuButton()			{				setText(jEdit.getProperty("vfs.browser.favorites.label"));				setIcon(GUIUtilities.loadIcon(jEdit.getProperty("dropdown-arrow.icon")));				setHorizontalTextPosition(SwingConstants.LEADING);				setName("favorites");								FavoritesMenuButton.this.setRequestFocusEnabled(false);				setMargin(new Insets(1,1,1,1));				FavoritesMenuButton.this.addMouseListener(new MouseHandler());					if(OperatingSystem.isMacOSLF())					FavoritesMenuButton.this.putClientProperty("JButton.buttonType","toolbar");			}	
void createPopupMenu()			{				popup = new JPopupMenu();				ActionHandler actionHandler = new ActionHandler();					JMenuItem mi = new JMenuItem(					jEdit.getProperty(					"vfs.browser.favorites"					+ ".add-to-favorites.label"));				mi.setActionCommand("add-to-favorites");				mi.addActionListener(actionHandler);				popup.add(mi);					mi = new JMenuItem(					jEdit.getProperty(					"vfs.browser.favorites"					+ ".edit-favorites.label"));				mi.setActionCommand("dir@favorites:");				mi.addActionListener(actionHandler);				popup.add(mi);					popup.addSeparator();					VFSFile[] favorites = FavoritesVFS.getFavorites();				if(favorites.length == 0)				{					mi = new JMenuItem(						jEdit.getProperty(						"vfs.browser.favorites"						+ ".no-favorites.label"));					mi.setEnabled(false);					popup.add(mi);				}				else				{					Arrays.sort(favorites,						new VFS.DirectoryEntryCompare(						sortMixFilesAndDirs,						sortIgnoreCase));					for(int i = 0; i < favorites.length; i++)					{						VFSFile favorite = favorites[i];						mi = new JMenuItem(favorite.getPath());						mi.setIcon(FileCellRenderer							.getIconForFile(							favorite,false));						String cmd = (favorite.getType() ==							VFSFile.FILE							? "file@" : "dir@")							+ favorite.getPath();						mi.setActionCommand(cmd);						mi.addActionListener(actionHandler);						popup.add(mi);					}				}			}	
public void actionPerformed(ActionEvent evt)				{					String actionCommand = evt.getActionCommand();					if("add-to-favorites".equals(actionCommand))					{						// if any directories are selected, add						// them, otherwise add current directory						VFSFile[] selected = getSelectedFiles();						if(selected == null || selected.length == 0)						{							if(path.equals(FavoritesVFS.PROTOCOL + ':'))							{								GUIUtilities.error(VFSBrowser.this,									"vfs.browser.recurse-favorites",									null);							}							else							{								FavoritesVFS.addToFavorites(path,									VFSFile.DIRECTORY);							}						}						else						{							for(int i = 0; i < selected.length; i++)							{								VFSFile file = selected[i];								FavoritesVFS.addToFavorites(file.getPath(),									file.getType());							}						}					}					else if(actionCommand.startsWith("dir@"))					{						setDirectory(actionCommand.substring(4));					}					else if(actionCommand.startsWith("file@"))					{						switch(getMode())						{						case BROWSER:							jEdit.openFile(view,actionCommand.substring(5));							break;						default:							locateFile(actionCommand.substring(5));							break;						}					}				}	
@Override				public void mousePressed(MouseEvent evt)				{					if(popup != null && popup.isVisible())					{						popup.setVisible(false);						return;					}						if(popup == null)						createPopupMenu();						GUIUtilities.showPopupMenu(						popup,FavoritesMenuButton.this,0,						FavoritesMenuButton.this.getHeight(),						false);				}	
DirectoryLoadedAWTRequest(Object node, Object[] loadInfo,				boolean addToHistory)			{				this.node = node;				this.loadInfo = loadInfo;				this.addToHistory = addToHistory;			}	
public void run()			{				String path = (String)loadInfo[0];				if(path == null)				{					// there was an error					return;				}					VFSFile[] list = (VFSFile[])loadInfo[1];					if(node == null)				{					// This is the new, canonical path					VFSBrowser.this.path = path;					if(!pathField.getText().equals(path))						pathField.setText(path);					if(path.endsWith("/") ||						path.endsWith(File.separator))					{						// ensure consistent history;						// eg we don't want both						// foo/ and foo						path = path.substring(0,							path.length() - 1);					}						if(addToHistory)					{						HistoryModel.getModel("vfs.browser.path")							.addItem(path);					}				}					boolean filterEnabled = filterCheckbox.isSelected();					List<VFSFile> directoryList = new ArrayList<VFSFile>();					int directories = 0;				int files = 0;				int invisible = 0;					if(list != null)				{					VFSFileFilter filter = getVFSFileFilter();						for(int i = 0; i < list.length; i++)					{						VFSFile file = list[i];						if(file.isHidden() && !showHiddenFiles)						{							invisible++;							continue;						}							if (filter != null && (filterEnabled || filter instanceof DirectoriesOnlyFilter)						    && !filter.accept(file))						{							invisible++;							continue;						}							if(file.getType() == VFSFile.FILE)							files++;						else							directories++;							directoryList.add(file);					}						Collections.sort(directoryList,						new VFS.DirectoryEntryCompare(						sortMixFilesAndDirs,						sortIgnoreCase));				}					browserView.directoryLoaded(node,path,					directoryList);					// to notify listeners that any existing				// selection has been deactivated					// turns out under some circumstances this				// method can switch the current buffer in				// BROWSER mode.					// in any case, this is only needed for the				// directory chooser (why?), so we add a				// check. otherwise poor Rick will go insane.				if(mode == CHOOSE_DIRECTORY_DIALOG)					filesSelected();			}	
@Override			public String toString()			{				return (String)loadInfo[0];			}	
/**			 * If event source hierarchy contains a VFSDirectoryEntryTable,			 * this is the currently selected files there. Otherwise, this			 * is the currently selected item in the parent directory list.			 */			private static VFSFile[] getSelectedFiles(EventObject evt,				VFSBrowser browser)			{				Component source = (Component)evt.getSource();					if(GUIUtilities.getComponentParent(source, BrowserView.ParentDirectoryList.class)					!= null)				{					Object[] selected = browser.getBrowserView()						.getParentDirectoryList()						.getSelectedValues();					VFSFile[] returnValue = new VFSFile[						selected.length];					System.arraycopy(selected,0,returnValue,0,						selected.length);					return returnValue;				}				else				{					return browser.getSelectedFiles();				}			}	
@Override			public void invokeAction(EventObject evt, EditAction action)			{				VFSBrowser browser = (VFSBrowser)					GUIUtilities.getComponentParent(					(Component)evt.getSource(),					VFSBrowser.class);					VFSFile[] files = getSelectedFiles(evt,browser);					// in the future we will want something better,				// eg. having an 'evt' object passed to				// EditAction.invoke().					// for now, since all browser actions are				// written in beanshell we set the 'browser'				// variable directly.				NameSpace global = BeanShell.getNameSpace();				try				{					global.setVariable("browser",browser);					global.setVariable("files",files);						View view = browser.getView();					// I guess ideally all browsers					// should have views, but since they					// don't, we just use the active view					// in that case, since some actions					// depend on a view being there and					// I don't want to add checks to					// them all					if(view == null)						view = jEdit.getActiveView();					action.invoke(view);				}				catch(UtilEvalError err)				{					Log.log(Log.ERROR,this,err);				}				finally				{					try					{						global.setVariable("browser",null);						global.setVariable("files",null);					}					catch(UtilEvalError err)					{						Log.log(Log.ERROR,this,err);					}				}			}	
HistoryComboBoxEditor(String key)			{				super(key);			}	
public Object getItem()			{				if (current == null)				{					current = new GlobVFSFileFilter(getText());				}					if (!current.getGlob().equals(getText()))				{					current.setGlob(getText());				}					return current;			}	
public void setItem(Object item)			{				if (item == current)				{					// if we keep the same object, swing					// will cause an event to be fired					// on the default button of the dialog,					// causing a beep since no file is					// selected...					if (item != null)					{						GlobVFSFileFilter filter = (GlobVFSFileFilter) item;						current = new GlobVFSFileFilter(filter.getGlob());						setText(current.getGlob());					}					return;				}					// this happens when changing the selected item				// in the combo; the combo has not yet fired an				// itemStateChanged() event, so it's not put into				// non-editable mode by the handler above.				if (!(item instanceof GlobVFSFileFilter))					return;					if (item != null)				{					GlobVFSFileFilter filter = (GlobVFSFileFilter) item;					filter = new GlobVFSFileFilter(filter.getGlob());					setText(filter.getGlob());					addCurrentToHistory();					current = filter;				}				else				{					setText("*");					current = new GlobVFSFileFilter("*");				}			}	
@Override			protected void processFocusEvent(FocusEvent e)			{				// AWT will call setItem() when the editor loses				// focus; that can cause weird and unwanted things				// to happen, so ignore lost focus events.				if (e.getID() != FocusEvent.FOCUS_LOST)					super.processFocusEvent(e);				else 				{					setCaretPosition(0);					getCaret().setVisible(false);				}			}	
public Component getEditorComponent()			{				return this;			}	
@Override			public Component getListCellRendererComponent(JList list,				Object value, int index, boolean isSelected,				boolean cellHasFocus)			{				assert value instanceof VFSFileFilter : "Filter is not a VFSFileFilter";				super.getListCellRendererComponent(					list, value, index, isSelected, cellHasFocus);				setText(((VFSFileFilter)value).getDescription());				return this;			}	
public boolean accept(VFSFile file)			{				return file.getType() == VFSFile.DIRECTORY					|| file.getType() == VFSFile.FILESYSTEM;			}	
public boolean accept(String url)			{				return false;			}	
public String getDescription()			{				return jEdit.getProperty("vfs.browser.file_filter.dir_only");			}	
VFSDirectoryEntryTable(BrowserView browserView)		{			super(new VFSDirectoryEntryTableModel());			this.browserView = browserView;			setShowGrid(false);				setIntercellSpacing(new Dimension(0,0));				setDefaultRenderer(Entry.class,				renderer = new FileCellRenderer());				header = getTableHeader();			header.setReorderingAllowed(false);			addMouseListener(new MainMouseHandler());			header.addMouseListener(new MouseHandler());			header.setDefaultRenderer(new HeaderRenderer(				(DefaultTableCellRenderer)header.getDefaultRenderer()));				setRowSelectionAllowed(true);				getColumnModel().addColumnModelListener(new ColumnHandler());				setAutoResizeMode(AUTO_RESIZE_OFF);		}	
public boolean selectFile(String path)		{			for(int i = 0; i < getRowCount(); i++)			{				Entry entry = (Entry) getValueAt(i,1);				if(entry.dirEntry.getPath().equals(path))				{					setSelectedRow(i);					return true;				}			}				return false;		}	
public void doTypeSelect(String str, boolean dirsOnly)		{			if(str.length() == 0)				clearSelection();			else if(getSelectedRow() == -1)				doTypeSelect(str,0,getRowCount(),dirsOnly);			else			{				int start = getSelectionModel().getMaxSelectionIndex();				boolean retVal = doTypeSelect(str,start,getRowCount(),					dirsOnly);					if(!retVal)				{					// scan from selection to end failed, so					// scan from start to selection					doTypeSelect(str,0,start,dirsOnly);				}			}		}	
public VFSFile[] getSelectedFiles()		{			VFSDirectoryEntryTableModel model				= (VFSDirectoryEntryTableModel)getModel();				java.util.List<VFSFile> returnValue = new LinkedList<VFSFile>();			int[] selectedRows = getSelectedRows();			for(int i = 0; i < selectedRows.length; i++)			{				returnValue.add(model.files[selectedRows[i]].dirEntry);			}			return returnValue.toArray(new VFSFile[returnValue.size()]);		}	
public void getExpandedDirectories(Set<String> set)		{			VFSDirectoryEntryTableModel model				= (VFSDirectoryEntryTableModel)getModel();				if(model.files != null)			{				for(int i = 0; i < model.files.length; i++)				{					if(model.files[i].expanded)						set.add(model.files[i].dirEntry.getPath());				}			}		}	
public void toggleExpanded(final int row)		{			VFSDirectoryEntryTableModel model			= (VFSDirectoryEntryTableModel)getModel();				Entry entry = model.files[row];			if(entry.dirEntry.getType() == VFSFile.FILE)				return;				if(entry.expanded)			{				model.collapse(VFSManager.getVFSForPath(					entry.dirEntry.getPath()),row);				resizeColumns();			}			else			{				browserView.clearExpansionState();				browserView.loadDirectory(entry,entry.dirEntry.getPath(),					false);			}				VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					setSelectedRow(row);				}			});		}	
public void setDirectory(VFS vfs, Object node, java.util.List<VFSFile> list,			Set<String> tmpExpanded)		{			timer.stop();			typeSelectBuffer.setLength(0);				VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)getModel();			int startIndex;			if(node == null)			{				startIndex = 0;				model.setRoot(vfs,list);			}			else			{				startIndex =					model.expand(					vfs,					(Entry)node,					list);				startIndex++;			}				for(int i = 0; i < list.size(); i++)			{				Entry e = model.files[startIndex + i];				String path = e.dirEntry.getPath();				if(tmpExpanded.contains(path))				{					browserView.loadDirectory(e,path,false);					tmpExpanded.remove(path);				}			}				resizeColumns();		}	
public void maybeReloadDirectory(String path)		{			VFSDirectoryEntryTableModel model			= (VFSDirectoryEntryTableModel)getModel();				for(int i = 0; i < model.files.length; i++)			{				Entry e = model.files[i];				if(!e.expanded || e.dirEntry.getType() == VFSFile.FILE)					continue;					VFSFile dirEntry = e.dirEntry;				// work around for broken FTP plugin!				String otherPath;				if(dirEntry.getSymlinkPath() == null)					otherPath = dirEntry.getPath();				else					otherPath = dirEntry.getSymlinkPath();				if(MiscUtilities.pathsEqual(path,otherPath))				{					browserView.saveExpansionState();					browserView.loadDirectory(e,path,false);					return;				}			}		}	
public void propertiesChanged()		{			renderer.propertiesChanged();				VFSFile template = new VFSFile(				"foo","foo","foo",VFSFile.FILE,0L,false);			setRowHeight(renderer.getTableCellRendererComponent(				this,new Entry(template,0),				false,false,0,0).getPreferredSize().height);			Dimension prefSize = getPreferredSize();			setPreferredScrollableViewportSize(new Dimension(prefSize.width,				getRowHeight() * 12));		}	
@Override		public void scrollRectToVisible(Rectangle rect)		{			// avoid scrolling to the right			rect.width = 0;			super.scrollRectToVisible(rect);		}	
@Override		public void processKeyEvent(KeyEvent evt)		{			if(evt.getID() == KeyEvent.KEY_PRESSED)			{				VFSDirectoryEntryTableModel model =					(VFSDirectoryEntryTableModel)getModel();				int row = getSelectedRow();				ActionContext ac = VFSBrowser.getActionContext();				ActionContext jac = jEdit.getActionContext();				EditAction browserUp = ac.getAction("vfs.browser.up");							VFSBrowser browser = browserView.getBrowser();				switch(evt.getKeyCode())				{				case KeyEvent.VK_LEFT:					evt.consume();					if ((evt.getModifiers() & InputEvent.ALT_MASK)>0)					{						browser.previousDirectory();					}					else 					{						if(row != -1)						{							if(model.files[row].expanded)							{								toggleExpanded(row);								return;							}								for(int i = row - 1; i >= 0; i--)							{								if(model.files[i].expanded &&								   model.files[i].level < model.files[row].level)								{									setSelectedRow(i);									return;								}							}						}							String dir = browserView.getBrowser()							.getDirectory();						dir = MiscUtilities.getParentOfPath(dir);						browserView.getBrowser().setDirectory(dir);					}					break;				case KeyEvent.VK_TAB:					evt.consume();					if ((evt.getModifiers() & InputEvent.SHIFT_MASK) > 0)					{						browserView.getParentDirectoryList().requestFocus();					}					else					{						browser.focusOnDefaultComponent();						}					break;				case KeyEvent.VK_BACK_SPACE:					evt.consume();					ac.invokeAction(evt, browserUp);					break;				case KeyEvent.VK_UP:					if ((evt.getModifiers() & InputEvent.ALT_MASK) >0)					{						evt.consume();						ac.invokeAction(evt, browserUp);					}					break;				case KeyEvent.VK_DELETE:					evt.consume();					EditAction deleteAct = ac.getAction("vfs.browser.delete");					ac.invokeAction(evt, deleteAct);					break;				case KeyEvent.VK_N:					if ((evt.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK)					{						evt.consume();						EditAction ea = ac.getAction("vfs.browser.new-file");						ac.invokeAction(evt, ea);					}					break;				case KeyEvent.VK_INSERT:					evt.consume();					EditAction newDir = ac.getAction("vfs.browser.new-directory");					ac.invokeAction(evt, newDir);					break;				case KeyEvent.VK_ESCAPE:					EditAction cda = jac.getAction("close-docking-area");					cda.invoke(jEdit.getActiveView());					evt.consume();					break;				case KeyEvent.VK_F2:					EditAction ren = ac.getAction("vfs.browser.rename");					evt.consume();					ac.invokeAction(evt, ren);					break;				case KeyEvent.VK_F5:					evt.consume();					EditAction reload= ac.getAction("vfs.browser.reload");					ac.invokeAction(evt, reload);					break;				case KeyEvent.VK_F6:				case KeyEvent.VK_RIGHT:					evt.consume();					if ((evt.getModifiers() & InputEvent.ALT_MASK)>0)					{						browser.nextDirectory();					}					else if(row != -1)					{						if(!model.files[row].expanded)							toggleExpanded(row);					}					break;				case KeyEvent.VK_ENTER:					evt.consume();					browserView.getBrowser().filesActivated(						evt.isShiftDown()						? VFSBrowser.M_OPEN_NEW_VIEW						: VFSBrowser.M_OPEN,false);						break;				}			}			else if(evt.getID() == KeyEvent.KEY_TYPED)			{					if(evt.isControlDown() || evt.isAltDown()					|| evt.isMetaDown())				{					evt.consume();					return;				}					// hack...				if(evt.isShiftDown() && evt.getKeyChar() == '\n')				{					evt.consume();					return;				}						VFSBrowser browser = browserView.getBrowser();					switch(evt.getKeyChar())				{				case '~':					evt.consume();					if(browser.getMode() == VFSBrowser.BROWSER)						browser.setDirectory(System.getProperty(							"user.home"));					break;				case '/':					evt.consume();					if(browser.getMode() == VFSBrowser.BROWSER)						browser.rootDirectory();					break;				case '-':					evt.consume();					if(browser.getMode() == VFSBrowser.BROWSER)					{						browser.setDirectory(							browser.getView().getBuffer()							.getDirectory());					}					break;				default:					evt.consume();					typeSelectBuffer.append(evt.getKeyChar());					doTypeSelect(typeSelectBuffer.toString(),						browser.getMode() == VFSBrowser						.CHOOSE_DIRECTORY_DIALOG);						timer.stop();					timer.setInitialDelay(750);					timer.setRepeats(false);					timer.start();					return;				}			}				if(!evt.isConsumed())				super.processKeyEvent(evt);		}	
public void setSelectedRow(int row)		{			getSelectionModel().setSelectionInterval(row,row);			scrollRectToVisible(getCellRect(row,0,true));		}	
private boolean doTypeSelect(String str, int start, int end,			boolean dirsOnly)		{			VFSFile[] files = ((VFSDirectoryEntryTableModel)				getModel()).getFiles();				int index = VFSFile.findCompletion(files,start,end,str,dirsOnly);			if(index != -1)			{				setSelectedRow(index);				return true;			}			else				return false;		}	
private void resizeColumns()		{			VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)getModel();				FontRenderContext fontRenderContext = new FontRenderContext(				null,false,false);			int[] widths = new int[model.getColumnCount()];			for(int i = 0; i < widths.length; i++)			{				String columnName = model.getColumnName(i);				if(columnName != null)				{					widths[i] = (int)renderer.plainFont						.getStringBounds(columnName,						fontRenderContext).getWidth();				}			}				for(int i = 1; i < widths.length; i++)			{				//String extAttr = model.getExtendedAttribute(i);				widths[i] = Math.max(widths[i],model.getColumnWidth(i));			}				for(int i = 0; i < model.files.length; i++)			{				Entry entry = model.files[i];				Font font = entry.dirEntry.getType()					== VFSFile.FILE					? renderer.plainFont : renderer.boldFont;					widths[0] = Math.max(widths[0],renderer.getEntryWidth(					entry,font,fontRenderContext));			}				widths[0] += 10;				TableColumnModel columns = getColumnModel();				try			{				resizingColumns = true;				for(int i = 0; i < widths.length; i++)				{					columns.getColumn(i).setPreferredWidth(widths[i]);					columns.getColumn(i).setWidth(widths[i]);				}			}			finally			{				resizingColumns = false;			}				doLayout();		}	
private void saveWidths()		{			if(resizingColumns)				return;				VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)getModel();			TableColumnModel columns = getColumnModel();				for(int i = 1; i < model.getColumnCount(); i++)				model.setColumnWidth(i,columns.getColumn(i).getWidth());		}	
public void actionPerformed(ActionEvent evt)			{				typeSelectBuffer.setLength(0);			}	
public void columnAdded(TableColumnModelEvent e) {}	
public void columnRemoved(TableColumnModelEvent e) {}	
public void columnMoved(TableColumnModelEvent e) {}	
public void columnSelectionChanged(ListSelectionEvent e) {}	
public void columnMarginChanged(ChangeEvent e)			{				saveWidths();			}	
@Override			public void mouseClicked(MouseEvent e)			{				super.mouseClicked(e);				int ind = getSelectionModel().getMinSelectionIndex();				Entry node = (Entry) getModel().getValueAt(ind, 0);				boolean isDir = node.dirEntry.getType() == VFSFile.DIRECTORY;				EditBus.send(new VFSPathSelected(jEdit.getActiveView(),								 node.dirEntry.getPath(), isDir));			}	
@Override			public void mousePressed(MouseEvent evt)			{				// double click on columns header				if (evt.getSource() == header && evt.getClickCount() == 2)				{					VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel) header.getTable().getModel();					TableColumnModel columnModel = header.getColumnModel();					int viewColumn = columnModel.getColumnIndexAtX(evt.getX());					int column = columnModel.getColumn(viewColumn).getModelIndex();					saveWidths();					if(model.sortByColumn(column))					{						resizeColumns();						Log.log(Log.DEBUG,this,"VFSDirectoryEntryTable sorted by "						+ model.getColumnName(column)						+ (model.getAscending() ? " ascending" : " descending") );					}				}			}	
HeaderRenderer(DefaultTableCellRenderer tcr)			{				this.tcr = tcr;			}	
@Override			public Component getTableCellRendererComponent(JTable table, Object value,				boolean isSelected, boolean hasFocus, int row, int column)			{				JLabel l = (JLabel)tcr.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);				VFSDirectoryEntryTableModel model = (VFSDirectoryEntryTableModel)table.getModel();				Icon icon = column == model.getSortColumn()					? model.getAscending() ? ASC_ICON : DESC_ICON					: null;				l.setIcon(icon);				// l.setHorizontalTextPosition(l.LEADING);				return l;			}	
public VFSDirectoryEntryTableModel()		{			extAttrs = new ArrayList<ExtendedAttribute>();			sortColumn = 0;			ascending = true;		}	
public void setRoot(VFS vfs, List<VFSFile> list)		{			extAttrs.clear();			addExtendedAttributes(vfs);				/* if(files != null && files.length != 0)				fireTableRowsDeleted(0,files.length - 1); */				files = new Entry[list.size()];			for(int i = 0; i < files.length; i++)			{				files[i] = new Entry(list.get(i),0);			}				/* if(files.length != 0)				fireTableRowsInserted(0,files.length - 1); */				Arrays.sort(files, new EntryCompare(getSortAttribute(sortColumn), ascending));			fireTableStructureChanged();		}	
public int expand(VFS vfs, Entry entry, List<VFSFile> list)		{			int startIndex = -1;			for(int i = 0; i < files.length; i++)			{				if(files[i] == entry)					startIndex = i;			}			if (startIndex != -1)				collapse(vfs,startIndex);				addExtendedAttributes(vfs);			entry.expanded = true;				if(list != null)			{				// make a large enough destination array				Entry[] newFiles = new Entry[files.length + list.size()];				Entry[] subdirFiles = new Entry[list.size()];					for(int i = 0; i < list.size(); i++)				{					subdirFiles[i] = new Entry(						list.get(i),entry.level + 1,entry);				}					// sort expanded entries according to current sort params				Arrays.sort(subdirFiles, new EntryCompare(					getSortAttribute(sortColumn), ascending));								// make room after expanded entry for subdir files				int nextIndex = startIndex + 1;				System.arraycopy(files,0,newFiles,0,nextIndex);				System.arraycopy(subdirFiles,0,newFiles,nextIndex,list.size());				System.arraycopy(files,nextIndex,newFiles,nextIndex + list.size(),					files.length - nextIndex);					this.files = newFiles;					/* fireTableRowsInserted(startIndex + 1,					startIndex + list.size() + 1); */			}				/* fireTableRowsUpdated(startIndex,startIndex); */				fireTableStructureChanged();				return startIndex;		}	
public void collapse(VFS vfs, int index)		{			Entry entry = files[index];			if(!entry.expanded)				return;				entry.expanded = false;				int lastIndex = index + 1;			while(lastIndex < files.length)			{				Entry e = files[lastIndex];					if(e.level <= entry.level)					break;					lastIndex++;					if(e.expanded)				{					removeExtendedAttributes(VFSManager.getVFSForPath(						e.dirEntry.getPath()));				}			}				removeExtendedAttributes(vfs);				Entry[] newFiles = new Entry[files.length - lastIndex + index + 1];			System.arraycopy(files,0,newFiles,0,index + 1);			System.arraycopy(files,lastIndex,newFiles,index + 1,				files.length - lastIndex);				files = newFiles;				/* fireTableRowsUpdated(index,index);			fireTableRowsDeleted(index + 1,lastIndex); */				fireTableStructureChanged();		}	
public int getColumnCount()		{			return 1 + extAttrs.size();		}	
public int getRowCount()		{			if(files == null)				return 0;			else				return files.length;		}	
public String getColumnName(int col)		{			if(col == 0)				return jEdit.getProperty("vfs.browser.name");			else				return jEdit.getProperty("vfs.browser." + getExtendedAttribute(col));		}	
public Class getColumnClass(int col)		{			return Entry.class;		}	
public Object getValueAt(int row, int col)		{			if(files == null)				return null;			else				return files[row];		}	
public boolean getAscending()		{			return ascending;		}	
public int getSortColumn()		{			return sortColumn;		}	
public String getSortAttribute(int column)		{			return column == 0 ? "name" : getExtendedAttribute(column);		}	
public boolean sortByColumn(int column)		{			// toggle ascending/descending if column was clicked again			ascending = sortColumn != column || !ascending;				// we don't sort by some attributes			String sortBy = getSortAttribute(column);			if(sortBy == VFS.EA_STATUS)				return false;				Arrays.sort(files, new EntryCompare(sortBy, ascending));				// remember column			sortColumn = column;			fireTableStructureChanged();				return true;		}	
public String getExtendedAttribute(int index)		{			return extAttrs.get(index - 1).name;		}	
/**		 * @param i The column index		 * @return A saved column width		 * @since jEdit 4.3pre2		 */		public int getColumnWidth(int i)		{			String extAttr = getExtendedAttribute(i);			return jEdit.getIntegerProperty("vfs.browser."				+ extAttr + ".width",100);		}	
/**		 * @param i The column index		 * @param w The column width		 * @since jEdit 4.3pre2		 */		public void setColumnWidth(int i, int w)		{			String extAttr = getExtendedAttribute(i);			jEdit.setIntegerProperty("vfs.browser."				+ extAttr + ".width",w);		}	
public VFSFile[] getFiles()		{			VFSFile[] f = new VFSFile[files.length];			for(int i = 0; i < f.length; i++)				f[i] = files[i].dirEntry;			return f;		}	
private void addExtendedAttributes(VFS vfs)		{			String[] attrs = vfs.getExtendedAttributes();	vfs_attr_loop:	for(int i = 0; i < attrs.length; i++)			{				for (ExtendedAttribute attr : extAttrs)				{					if (attrs[i].equals(attr.name))					{						attr.ref++;						continue vfs_attr_loop;					}				}					// this vfs has an extended attribute which is not				// in the list. add it to the end with a ref count				// of 1				extAttrs.add(new ExtendedAttribute(attrs[i]));			}		}	
private void removeExtendedAttributes(VFS vfs)		{			String[] attrs = vfs.getExtendedAttributes();	vfs_attr_loop:	for(int i = 0; i < attrs.length; i++)			{				Iterator<ExtendedAttribute> iter = extAttrs.iterator();				while(iter.hasNext())				{					ExtendedAttribute attr = iter.next();					if(attrs[i].equals(attr.name))					{						if(--attr.ref == 0)						{							// we no longer have any							// dirs using this extended							// attribute							iter.remove();						}							continue vfs_attr_loop;					}				}					// this vfs has an extended attribute which is not				// in the list ???				Log.log(Log.WARNING,this,"We forgot about " + attrs[i]);			}		}	
Entry(VFSFile dirEntry, int level, Entry parent)			{				this(dirEntry,level);				this.parent = parent;			}	
Entry(VFSFile dirEntry, int level)			{				this.dirEntry = dirEntry;				this.level = level;				this.extension = MiscUtilities.getFileExtension(dirEntry.getName());			}	
ExtendedAttribute(String name)			{				this.name = name;				ref = 1;			}	
/**			 * Creates a new <code>EntryCompare</code>			 * Expanded branches are sorted, too, but keep with their parent entries			 * @param sortBy The extended attribute by which to sort the entries.			 * @param ascending If false, sort order is reversed.			 */			EntryCompare(String sortBy, boolean ascending)			{				this.sortMixFilesAndDirs = jEdit.getBooleanProperty(					"vfs.browser.sortMixFilesAndDirs");				this.sortIgnoreCase = jEdit.getBooleanProperty(					"vfs.browser.sortIgnoreCase");				this.sortAscending = ascending;				this.sortAttribute = sortBy;			}	
public int compare(Entry entry1, Entry entry2)			{				// we want to compare sibling ancestors of the entries				if(entry1.level < entry2.level) 					return compare(entry1, entry2.parent);				if(entry1.level > entry2.level)					return compare(entry1.parent, entry2);					// here we have entries of the same level				if(entry1.parent != entry2.parent)					return compare(entry1.parent, entry2.parent);					// here we have siblings with the same parents				// let's do the real comparison					VFSFile file1 = entry1.dirEntry;				VFSFile file2 = entry2.dirEntry;					if(!sortMixFilesAndDirs)				{					if(file1.getType() != file2.getType())						return file2.getType() - file1.getType();				}					int result;					// if the modified attribute is present, then we have a LocalFile				if(sortAttribute == VFS.EA_MODIFIED)					result = (						(Long)((FileVFS.LocalFile)file1).getModified())						.compareTo(						(Long)((FileVFS.LocalFile)file2).getModified());				// sort by size				else if(sortAttribute == VFS.EA_SIZE)					result = (						(Long)file1.getLength())						.compareTo(						(Long)file2.getLength());				// sort by type (= extension)				else if(sortAttribute == VFS.EA_TYPE)					result = StandardUtilities.compareStrings(						entry1.extension,						entry2.extension,						sortIgnoreCase);				// default: sort by name				else					result = StandardUtilities.compareStrings(						file1.getName(),						file2.getName(),						sortIgnoreCase);				return sortAscending ? result : -result;			}	
/**		 * Return the index of a file whose name matches the given string,		 * in a case-insensitive manner. Exact matches are preferred.		 * @param files The list of files		 * @param start The start index, inclusive		 * @param end The end index, exclusive		 * @param str The string to match		 * @param dirsOnly Only match directories?		 * @since jEdit 4.3pre3		 */		public static int findCompletion(VFSFile[] files, int start, int end,			String str, boolean dirsOnly)		{			for(int i = start; i < end; i++)			{				VFSFile file = files[i];				String matchAgainst = (MiscUtilities.isAbsolutePath(str)					? file.getPath() : file.getName());					if(dirsOnly && file.getType() == FILE)					continue;				/* try exact match first */				else if(matchAgainst.equals(str))					return i;				else if(matchAgainst.regionMatches(true,0,str,0,str.length()))					return i;			}				return -1;		}	
public static String findCompletion(String path, String complete,			VFSBrowser browser, boolean dirsOnly)		{			Log.log(Log.DEBUG,VFSFile.class,"findCompletion(" + path + ',' + complete				+ ',' + dirsOnly + ')');				if(complete.equals("~"))				return System.getProperty("user.home");			else if(complete.equals("-"))				return browser.getView().getBuffer().getDirectory();			else if(complete.equals(".."))				return MiscUtilities.getParentOfPath(path);				if(MiscUtilities.isAbsolutePath(complete))			{				if(MiscUtilities.isURL(complete))					return complete;				else					path = "roots:";			}				VFS vfs = VFSManager.getVFSForPath(path);			if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) == 0)				return null;			Object session = vfs.createVFSSession(path,browser);			if(session == null)				return null;				try			{				VFSFile[] files = vfs._listFiles(session,path,browser);				int index = findCompletion(files,0,files.length,complete,dirsOnly);				if(index != -1)					return files[index].path;			}			catch(IOException e)			{				VFSManager.error(e,path,browser);			}			finally			{				try				{					vfs._endVFSSession(session,browser);				}				catch(IOException e)				{					VFSManager.error(e,path,browser);				}			}						return null;		}	
/**		 * Returns the icon for the file.		 *		 * @since jEdit 4.3pre9		 */		public final Icon getIcon(boolean expanded)		{			return getIcon(expanded, jEdit._getBuffer(getSymlinkPath()) != null);		}	
/**		 * Returns the icon for the file.		 * Implementations of File system browsers can override this method		 *  		 * @since jEdit 4.3pre9		 */		public Icon getIcon(boolean expanded, boolean openBuffer)		{			return getDefaultIcon(expanded, openBuffer);		}	
/**		 * Returns the default icon for the file.		 *		 * @since jEdit 4.3pre9		 */		public final Icon getDefaultIcon(boolean expanded, boolean openBuffer)		{			if(getType() == DIRECTORY)				return expanded ? FileCellRenderer.openDirIcon : FileCellRenderer.dirIcon;			else if(getType() == FILESYSTEM)				return FileCellRenderer.filesystemIcon;			else if(openBuffer)				return FileCellRenderer.openFileIcon;			else				return FileCellRenderer.fileIcon;		}	
/**		 * Returns the default icon of the file.		 *		 * @return the default icon of the file		 * @since jEdit 4.3pre9		 */		public final Icon getDefaultIcon(boolean expanded)		{			return getDefaultIcon(expanded, jEdit._getBuffer(getSymlinkPath()) != null);		}	
/**		 * @since jEdit 4.3pre2		 */		public VFSFile()		{		}	
public VFSFile(String name, String path, String deletePath,			int type, long length, boolean hidden)		{			this.name = name;			this.path = path;			this.deletePath = deletePath;			this.symlinkPath = path;			this.type = type;			this.length = length;			this.hidden = hidden;			if(path != null)			{				// maintain backwards compatibility				VFS vfs = VFSManager.getVFSForPath(path);				canRead = ((vfs.getCapabilities() & VFS.READ_CAP) != 0);				canWrite = ((vfs.getCapabilities() & VFS.WRITE_CAP) != 0);			}		}	
/**		 * @return The originating virtual file system of this file.		 */		public VFS getVFS()		{			return VFSManager.getVFSForPath(path);		}	
public String getName()		{			return name;		}	
public void setName(String name)		{			this.name = name;		}	
/**		 * Check if a file is binary file.		 *		 * @param session the VFS session		 * @return <code>true</code> if the file was detected as binary		 * @throws IOException IOException If an I/O error occurs		 * @since jEdit 4.3pre5		 */		public boolean isBinary(Object session)			throws IOException		{			InputStream in = getVFS()._createInputStream(session,getPath(),				false,jEdit.getActiveView());			if(in == null)				throw new IOException("Unable to get a Stream for this file "+this);				try			{				return MiscUtilities.isBinary(in);			}			finally			{				IOUtilities.closeQuietly(in);			}		}	
public String getPath()		{			return path;		}	
public void setPath(String path)		{			this.path = path;		}	
public String getSymlinkPath()		{			return symlinkPath;		}	
public void setSymlinkPath(String symlinkPath)		{			this.symlinkPath = symlinkPath;		}	
public String getDeletePath()		{			return deletePath;		}	
public void setDeletePath(String deletePath)		{			this.deletePath = deletePath;		}	
public int getType()		{			return type;		}	
public void setType(int type)		{			this.type = type;		}	
public long getLength()		{			return length;		}	
public void setLength(long length)		{			this.length = length;		}	
public boolean isHidden()		{			return hidden;		}	
public void setHidden(boolean hidden)		{			this.hidden = hidden;		}	
public boolean isReadable()		{			return canRead;		}	
public void setReadable(boolean canRead)		{			this.canRead = canRead;		}	
public boolean isWriteable()		{			return canWrite;		}	
public void setWriteable(boolean canWrite)		{			this.canWrite = canWrite;		}	
/**		 * Returns the value of an extended attribute. Note that this		 * returns formatted strings (eg, "10 Mb" for a file size of		 * 1048576 bytes). If you need access to the raw data, access		 * fields and methods of this class.		 * @param name The extended attribute name		 * @since jEdit 4.2pre1		 */		public String getExtendedAttribute(String name)		{			if(name.equals(VFS.EA_TYPE))			{				switch(getType())				{				case FILE:					return jEdit.getProperty("vfs.browser.type.file");				case DIRECTORY:					return jEdit.getProperty("vfs.browser.type.directory");				case FILESYSTEM:					return jEdit.getProperty("vfs.browser.type.filesystem");				default:					throw new IllegalArgumentException();				}			}			else if(name.equals(VFS.EA_STATUS))			{				if(isReadable())				{					if(isWriteable())						return jEdit.getProperty("vfs.browser.status.rw");					else						return jEdit.getProperty("vfs.browser.status.ro");				}				else				{					if(isWriteable())						return jEdit.getProperty("vfs.browser.status.append");					else						return jEdit.getProperty("vfs.browser.status.no");				}			}			else if(name.equals(VFS.EA_SIZE))			{				if(getType() != FILE)					return null;				else					return MiscUtilities.formatFileSize(getLength());			}			else				return null;		}	
/**		 * Returns the color that will be used to display the file.		 *		 * @return the color of the file		 */		public Color getColor()		{			if(!colorCalculated)			{				colorCalculated = true;				color = VFS.getDefaultColorFor(name);			}				return color;		}	
public String toString()		{			return name;		}	
/**		 * Returns true if the attributes are already fetched.		 *		 * @see #fetchAttrs()		 * @return <code>true</code> if the attributes are already fetched		 */		protected boolean fetchedAttrs()		{			return fetchedAttrs;		}	
/**		 * Fetch some attributes of the file.		 * Some attributes are not fetched during		 * file initialization because it takes time.		 * They are fetched here.		 * VFS implementation should overwrite this		 */		protected void fetchAttrs()		{			fetchedAttrs = true;		}	
public VFSFileChooserDialog(View view, String path,			int mode, boolean multipleSelection)		{			this(view,path,mode,multipleSelection,true);		}	
/**		 * Constructs a new VFSFileChooserDialog. If <code>authoshow</code>		 * is true, the dialog will be show automatically and the call		 * will only return after the user disposes of the dialog.		 *		 * @since jEdit 4.3pre7		 */		public VFSFileChooserDialog(View view, String path,			int mode, boolean multipleSelection, boolean autoshow)		{			super(view,getDefaultTitle(),true);			setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());			_init(view,path,mode,multipleSelection,autoshow);		}	
/**		 * Constructs a new VFSFileChooserDialog.		 * This version can specify a dialog as the parent instead		 * of the view.		 * @since jEdit 4.3pre10		 */		public VFSFileChooserDialog(Dialog parent, View view, String path,			int mode, boolean multipleSelection, boolean autoshow)		{			super(parent,getDefaultTitle(),true);			setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());					_init(view,path,mode,multipleSelection,autoshow);		}	
/**		 * Constructs a new VFSFileChooserDialog.		 * This version can specify a Frame as the parent instead		 * of the view.		 * @since jEdit 4.3pre10		 */		public VFSFileChooserDialog(Frame parent, View view, String path,			int mode, boolean multipleSelection, boolean autoshow)		{			super(parent, getDefaultTitle(),true);			setFocusTraversalPolicy(new LayoutFocusTraversalPolicy());					_init(view,path,mode,multipleSelection,autoshow);		}	
/**		 * Returns the VFSBrowser instance used internally.		 * @return the VFS browser used in the dialog		 * @since jEdit 4.3pre7		 */		public VFSBrowser getBrowser()		{			return browser;		}	
@Override		public void dispose()		{			GUIUtilities.saveGeometry(this,"vfs.browser.dialog");			VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);			super.dispose();		}	
@Override		public void ok()		{			VFSFile[] files = browser.getSelectedFiles();			filename = filenameField.getText();			boolean choosingDir = (browser.getMode() ==				VFSBrowser.CHOOSE_DIRECTORY_DIALOG);				if(files.length != 0)			{				if(choosingDir)				{					isOK = true;					dispose();				}				else					browser.filesActivated(VFSBrowser.M_OPEN,false);				return;			}			else if(choosingDir && (filename == null || filename.length() == 0))			{				isOK = true;				dispose();				return;			}			else if(filename == null || filename.length() == 0)			{				getToolkit().beep();				return;			}				String bufferDir = browser.getView().getBuffer()				.getDirectory();			if(filename.equals("-"))				filename = bufferDir;			else if(filename.startsWith("-/")				|| filename.startsWith('-' + File.separator))			{				filename = MiscUtilities.constructPath(					bufferDir,filename.substring(2));			}				final int[] type = { -1 };			filename = MiscUtilities.expandVariables(filename);			final String path = MiscUtilities.constructPath(				browser.getDirectory(),filename);			final VFS vfs = VFSManager.getVFSForPath(path);			Object session = vfs.createVFSSession(path,this);			if(session == null)				return;				VFSManager.runInWorkThread(new GetFileTypeRequest(				vfs,session,path,type));			VFSManager.runInAWTThread(new Runnable()			{				public void run()				{					switch(type[0])					{					case VFSFile.FILE:						if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)							break;							if(vfs instanceof FileVFS)						{							if(doFileExistsWarning(path))								break;						}						isOK = true;						if(browser.getMode() == VFSBrowser.BROWSER_DIALOG)						{							Hashtable props = new Hashtable();							props.put(JEditBuffer.ENCODING,browser.currentEncoding);							jEdit.openFile(browser.getView(),								browser.getDirectory(),								path,false,props);						}						dispose();						break;					case VFSFile.DIRECTORY:					case VFSFile.FILESYSTEM:						browser.setDirectory(path);						break;					}				}			});		}	
@Override		public void cancel()		{			dispose();		}	
public String[] getSelectedFiles()		{			if(!isOK)				return null;				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)			{				if(browser.getSelectedFiles().length > 0)				{					return getSelectedFiles(VFSFile.DIRECTORY,						VFSFile.FILESYSTEM);				}				else					return new String[] { browser.getDirectory() };			}			else if(filename != null && filename.length() != 0)			{				String path = browser.getDirectory();				return new String[] { MiscUtilities.constructPath(					path,filename) };			}			else				return getSelectedFiles(VFSFile.FILE,VFSFile.FILE);		}	
private static String getDefaultTitle()		{			return jEdit.getProperty("vfs.browser.title");		}	
private void _init(View view, String path,			int mode, boolean multipleSelection, boolean autoshow)		{			JPanel content = new JPanel(new BorderLayout());			setContentPane(content);				String name;			if(mode == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)				name = null;			else if(path == null || path.endsWith(File.separator)				|| path.endsWith("/"))			{				name = null;			}			else			{				VFS vfs = VFSManager.getVFSForPath(path);				name = vfs.getFileName(path);				path = vfs.getParentOfPath(path);				if ((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)				{					path = null;				}			}				browser = new VFSBrowser(view, path, mode, multipleSelection, null);						browser.addBrowserListener(new BrowserHandler());			content.add(BorderLayout.CENTER,browser);				JPanel panel = new JPanel();			panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));			panel.setBorder(new EmptyBorder(12,12,12,12));						filenameField = new VFSFileNameField(browser,null);			filenameField.setText(name);			filenameField.selectAll();			filenameField.setName("filename");			browser.setDefaultFocusComponent(filenameField);			Box box = new Box(BoxLayout.Y_AXIS);			box.add(Box.createGlue());			box.add(filenameField);			box.add(Box.createGlue());				JLabel label = new JLabel(jEdit.getProperty("vfs.browser.dialog.filename"));			label.setDisplayedMnemonic(jEdit.getProperty(				"vfs.browser.dialog.filename.mnemonic").charAt(0));			label.setLabelFor(filenameField);			panel.add(label);			panel.add(Box.createHorizontalStrut(12));				panel.add(box);				panel.add(Box.createHorizontalStrut(12));				ok = new JButton();			ok.setName("ok");			getRootPane().setDefaultButton(ok);				switch(mode)			{			case VFSBrowser.OPEN_DIALOG:			case VFSBrowser.BROWSER_DIALOG:				ok.setText(jEdit.getProperty("vfs.browser.dialog.open"));				break;			case VFSBrowser.CHOOSE_DIRECTORY_DIALOG:				ok.setText(jEdit.getProperty("vfs.browser.dialog.choose-dir"));				// so that it doesn't resize...				Dimension dim = ok.getPreferredSize();				ok.setPreferredSize(dim);				break;			case VFSBrowser.SAVE_DIALOG:				ok.setText(jEdit.getProperty("vfs.browser.dialog.save"));				break;			}				ok.addActionListener(new ActionHandler());			panel.add(ok);			panel.add(Box.createHorizontalStrut(6));			cancel = new JButton(jEdit.getProperty("common.cancel"));			cancel.setName("cancel");			cancel.addActionListener(new ActionHandler());			panel.add(cancel);				content.add(BorderLayout.SOUTH,panel);				VFSManager.getIOThreadPool().addProgressListener(				workThreadHandler = new WorkThreadHandler());				pack();			GUIUtilities.loadGeometry(this,"vfs.browser.dialog");			GUIUtilities.requestFocus(this,filenameField);			if (autoshow)				setVisible(true);		}	
private boolean doFileExistsWarning(String filename)		{			if(browser.getMode() == VFSBrowser.SAVE_DIALOG				&& new File(filename).exists())			{				String[] args = { MiscUtilities.getFileName(filename) };				int result = GUIUtilities.confirm(browser,					"fileexists",args,					JOptionPane.YES_NO_OPTION,					JOptionPane.WARNING_MESSAGE);				if(result != JOptionPane.YES_OPTION)					return true;			}				return false;		}	
private String[] getSelectedFiles(int type1, int type2)		{			List<String> l = new ArrayList<String>();			VFSFile[] selectedFiles = browser.getSelectedFiles();			for(int i = 0; i < selectedFiles.length; i++)			{				VFSFile file = selectedFiles[i];				if(file.getType() == type1 || file.getType() == type2)					l.add(file.getPath());			}			return l.toArray(new String[l.size()]);		}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == ok)					ok();				else if(evt.getSource() == cancel)					cancel();			}	
public void filesSelected(VFSBrowser browser, VFSFile[] files)			{				boolean choosingDir = (browser.getMode()					== VFSBrowser.CHOOSE_DIRECTORY_DIALOG);					if(files.length == 0)				{					if(choosingDir)					{						ok.setText(jEdit.getProperty(							"vfs.browser.dialog.choose-dir"));					}				}				else if(files.length == 1)				{					if(choosingDir)					{						ok.setText(jEdit.getProperty(							"vfs.browser.dialog.choose-dir"));					}						VFSFile file = files[0];					if(file.getType() == VFSFile.FILE)					{						String path = file.getPath();						String directory = browser.getDirectory();						String parent = MiscUtilities							.getParentOfPath(path);						if(MiscUtilities.pathsEqual(parent,directory))							path = file.getName();							filenameField.setText(path);						filenameField.selectAll();					}				}				else				{					if(choosingDir)					{						ok.setText(jEdit.getProperty(							"vfs.browser.dialog.choose-dir"));					}						filenameField.setText(null);				}			}	
public void filesActivated(VFSBrowser browser, VFSFile[] files)			{				filenameField.selectAll();					if(files.length == 0)				{					// user pressed enter when the vfs table or					// file name field has focus, with nothing					// selected.					ok();					return;				}					for(int i = 0; i < files.length; i++)				{					if(files[i].getType() == VFSFile.FILE)					{						String path = files[i].getPath();						VFS vfs = VFSManager.getVFSForPath(path);						if(browser.getMode() == VFSBrowser.SAVE_DIALOG							&& vfs instanceof FileVFS)						{							if(doFileExistsWarning(path))								return;						}							isOK = true;						filenameField.setText(null);						if(browser.getMode() != VFSBrowser.CHOOSE_DIRECTORY_DIALOG)						{							dispose();						}						return;					}					else						return;				}			}	
public void statusUpdate(final WorkThreadPool threadPool,				int threadIndex)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						int requestCount = threadPool.getRequestCount();						if(requestCount == 0)						{							getContentPane().setCursor(								Cursor.getDefaultCursor());						}						else if(requestCount >= 1)						{							getContentPane().setCursor(								Cursor.getPredefinedCursor(								Cursor.WAIT_CURSOR));						}					}				});			}	
public void progressUpdate(WorkThreadPool threadPool, int threadIndex)			{			}	
GetFileTypeRequest(VFS vfs, Object session,				String path, int[] type)			{				this.vfs     = vfs;				this.session = session;				this.path    = path;				this.type    = type;			}	
public void run()			{				try				{					VFSFile entry = vfs._getFile(							session,							path,							browser);					if(entry == null)					{						// non-existent file						type[0] = VFSFile.FILE;					}					else						type[0] = entry.getType();				}				catch(IOException e)				{					VFSManager.error(e,path,browser);				}				finally				{					try					{						vfs._endVFSSession(							session,							browser);					}					catch(IOException e)					{						VFSManager.error(e,path,browser);					}				}			}	
VFSFileNameField(VFSBrowser browser, String model)		{			super(model);			setEnterAddsToHistory(false);				this.browser = browser;				Dimension dim = getPreferredSize();			dim.width = Integer.MAX_VALUE;			setMaximumSize(dim);				// Enable TAB pressed for completion instead of			// focas traversal.			final int FORWARD = KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS;			HashSet<AWTKeyStroke> keys = new HashSet<AWTKeyStroke>(					getFocusTraversalKeys(FORWARD));			keys.remove(AWTKeyStroke.getAWTKeyStroke("pressed TAB"));			setFocusTraversalKeys(FORWARD, keys);		}	
public void processKeyEvent(KeyEvent evt)		{			if(evt.getID() == KeyEvent.KEY_PRESSED)			{				String path = getText();					switch(evt.getKeyCode())				{				case KeyEvent.VK_TAB:					doComplete(path);					break;				case KeyEvent.VK_LEFT:					if ((evt.getModifiers() & KeyEvent.ALT_MASK) > 0)					{						browser.previousDirectory();						evt.consume();					}					else					{						// 				browser.getBrowserView().getTable().processKeyEvent(evt);						super.processKeyEvent(evt);					}					break;				case KeyEvent.VK_UP:					if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)					{						String p = browser.getDirectory();						browser.setDirectory(MiscUtilities.getParentOfPath(p));						evt.consume();					}					else					{						browser.getBrowserView().getTable()						.processKeyEvent(evt);					}					break;				case KeyEvent.VK_RIGHT:					if ((evt.getModifiers() & KeyEvent.ALT_MASK)>0)					{						evt.consume();						browser.nextDirectory();					}					else						super.processKeyEvent(evt);					break;				case KeyEvent.VK_DOWN:				case KeyEvent.VK_PAGE_UP:				case KeyEvent.VK_PAGE_DOWN:					browser.getBrowserView().getTable()						.processKeyEvent(evt);					break;				case KeyEvent.VK_ENTER:					browser.filesActivated(						(evt.isShiftDown()						? VFSBrowser.M_OPEN_NEW_VIEW						: VFSBrowser.M_OPEN),false);					setText(null);					evt.consume();					break;				default:					super.processKeyEvent(evt);					break;				}			}			else if(evt.getID() == KeyEvent.KEY_TYPED)			{				char ch = evt.getKeyChar();				if(ch > 0x20 && ch != 0x7f && ch != 0xff)				{					super.processKeyEvent(evt);					String path = getText();					BrowserView view = browser.getBrowserView();					view.selectNone();						if(MiscUtilities.getLastSeparatorIndex(path) == -1)					{						int mode = browser.getMode();						// fix for bug #765507						// we don't type complete in save dialog						// boxes. Press TAB to do an explicit						// complete						view.getTable().doTypeSelect(path,							mode == VFSBrowser							.CHOOSE_DIRECTORY_DIALOG							||							mode == VFSBrowser							.SAVE_DIALOG);					}				}				else					super.processKeyEvent(evt);			}		}	
public String doComplete(String path, String complete, boolean dirsOnly)		{			Log.log(Log.DEBUG,VFSFileNameField.class,				"doComplete(" + path + "," + complete				+ "," + dirsOnly);				for(;;)			{				if(complete.length() == 0)					return path;				int index = MiscUtilities.getFirstSeparatorIndex(complete);				if(index == -1)					return path;					/* Until the very last path component, we only complete on				directories */				String newPath = VFSFile.findCompletion(path,					complete.substring(0,index),browser,true);				if(newPath == null)					return null;				path = newPath;				complete = complete.substring(index + 1);			}		}	
private void doComplete(String currentText)		{			int index = MiscUtilities.getLastSeparatorIndex(currentText);			String dir;			if(index != -1)				dir = currentText.substring(0,index + 1);			else				dir = "";				if(MiscUtilities.isAbsolutePath(currentText))			{				if(dir.startsWith("/"))					dir = dir.substring(1);				dir = doComplete(VFSBrowser.getRootDirectory(),dir,false);				if(dir == null)					return;						browser.setDirectory(dir);				VFSManager.waitForRequests();					if(index == -1)				{					if(currentText.startsWith("/"))						currentText = currentText.substring(1);				}				else					currentText = currentText.substring(index + 1);			}			else			{				if(dir.length() != 0)				{					dir = doComplete(browser.getDirectory(),dir,false);					if(dir == null)						return;							browser.setDirectory(dir);					VFSManager.waitForRequests();							currentText = currentText.substring(index + 1);				}			}				BrowserView view = browser.getBrowserView();			view.selectNone();			view.getTable().doTypeSelect(currentText,				browser.getMode() == VFSBrowser				.CHOOSE_DIRECTORY_DIALOG);				String newText;				VFSFile[] files = view.getSelectedFiles();			if(files.length == 0)				newText = currentText;			else			{				String path = files[0].getPath();				String name = files[0].getName();				String parent = MiscUtilities.getParentOfPath(path);					if(MiscUtilities.isAbsolutePath(currentText)					&& !currentText.startsWith(browser.getDirectory()))				{					newText = path;				}				else				{					if(MiscUtilities.pathsEqual(parent,browser.getDirectory()))						newText = name;					else						newText = path;				}			}				setText(newText);		}	
private void goToParent()		{			String name = MiscUtilities.getFileName(browser.getDirectory());			String parent = MiscUtilities.getParentOfPath(				browser.getDirectory());			browser.setDirectory(parent);				VFS vfs = VFSManager.getVFSForPath(parent);			if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0)			{				VFSManager.waitForRequests();				setText(name);				browser.getBrowserView().getTable().doTypeSelect(					name,browser.getMode() == VFSBrowser					.CHOOSE_DIRECTORY_DIALOG);			}		}	
/**		 * Do not call.		 */		public static void init()		{			int count = jEdit.getIntegerProperty("ioThreadCount",4);			ioThreadPool = new WorkThreadPool("jEdit I/O",count);			JARClassLoader classLoader = new JARClassLoader();			for(int i = 0; i < ioThreadPool.getThreadCount(); i++)			{				ioThreadPool.getThread(i).setContextClassLoader(					classLoader);			}		}	
/**		 * Do not call.		 */		public static void start()		{			ioThreadPool.start();		}	
/**		 * Returns the local filesystem VFS.		 * @since jEdit 2.5pre1		 */		public static VFS getFileVFS()		{			return fileVFS;		}	
/**		 * Returns the URL VFS.		 * @since jEdit 2.5pre1		 */		public static VFS getUrlVFS()		{			return urlVFS;		}	
/**		 * @deprecated Use <code>getVFSForProtocol()</code> instead.		 */		public static VFS getVFSByName(String name)		{			// in new api, protocol always equals name			VFS vfs = (VFS)ServiceManager.getService(SERVICE,name);			if(vfs == null)				return vfsHash.get(name);			else				return vfs;		}	
/**		 * Returns the VFS for the specified protocol.		 * @param protocol The protocol		 * @since jEdit 2.5pre1		 */		public static VFS getVFSForProtocol(String protocol)		{			if(protocol.equals("file"))				return fileVFS;			else			{				VFS vfs = (VFS)ServiceManager.getService(SERVICE,protocol);				if(vfs == null)					vfs = protocolHash.get(protocol);					if(vfs != null)					return vfs;				else					return urlVFS;			}		}	
/**		 * Returns the VFS for the specified path.		 * @param path The path		 * @since jEdit 2.6pre4		 */		public static VFS getVFSForPath(String path)		{			if(MiscUtilities.isURL(path))				return getVFSForProtocol(MiscUtilities.getProtocolOfURL(path));			else				return fileVFS;		}	
/**		 * @deprecated Write a <code>services.xml</code> file instead;		 * see {@link org.gjt.sp.jedit.ServiceManager}.		 */		public static void registerVFS(String protocol, VFS vfs)		{			Log.log(Log.DEBUG,VFSManager.class,"Registered "				+ vfs.getName() + " filesystem for "				+ protocol + " protocol");			vfsHash.put(vfs.getName(),vfs);			protocolHash.put(protocol,vfs);		}	
/**		 * @deprecated Use <code>getVFSs()</code> instead.		 */		public static Enumeration<VFS> getFilesystems()		{			return vfsHash.elements();		}	
/**		 * Returns a list of all registered filesystems.		 * @since jEdit 4.2pre1		 */		public static String[] getVFSs()		{			// the sooner ppl move to the new api, the less we'll need			// crap like this			List<String> returnValue = new LinkedList<String>();			String[] newAPI = ServiceManager.getServiceNames(SERVICE);			if(newAPI != null)			{				for(int i = 0; i < newAPI.length; i++)				{					returnValue.add(newAPI[i]);				}			}			Enumeration<String> oldAPI = vfsHash.keys();			while(oldAPI.hasMoreElements())				returnValue.add(oldAPI.nextElement());			return returnValue.toArray(new String[returnValue.size()]);		}	
/**		 * Returns the I/O thread pool.		 */		public static WorkThreadPool getIOThreadPool()		{			return ioThreadPool;		}	
/**		 * Returns when all pending requests are complete.		 * @since jEdit 2.5pre1		 */		public static void waitForRequests()		{			ioThreadPool.waitForRequests();		}	
/**		 * Returns if the last request caused an error.		 */		public static boolean errorOccurred()		{			return error;		}	
/**		 * Returns the number of pending I/O requests.		 */		public static int getRequestCount()		{			return ioThreadPool.getRequestCount();		}	
/**		 * Executes the specified runnable in the AWT thread once all		 * pending I/O requests are complete.		 * @since jEdit 2.5pre1		 */		public static void runInAWTThread(Runnable run)		{			ioThreadPool.addWorkRequest(run,true);		}	
/**		 * Executes the specified runnable in one of the I/O threads.		 * @since jEdit 2.6pre2		 */		public static void runInWorkThread(Runnable run)		{			ioThreadPool.addWorkRequest(run,false);		}	
/**		 * Handle an I/O error.		 * @since jEdit 4.3pre3		 */		public static void error(IOException e, String path, Component comp)		{			Log.log(Log.ERROR,VFSManager.class,e);			VFSManager.error(comp,path,"ioerror",new String[] { e.toString() });		}	
/**		 * @deprecated Call the other <code>error()</code> method instead.		 */		public static void error(final Component comp, final String error, final Object[] args)		{			// if we are already in the AWT thread, take a shortcut			if(SwingUtilities.isEventDispatchThread())			{				GUIUtilities.error(comp,error,args);				return;			}				// the 'error' chicanery ensures that stuff like:			// VFSManager.waitForRequests()			// if(VFSManager.errorOccurred())			//         ...			// will work (because the below runnable will only be			// executed in the next event)			VFSManager.error = true;				runInAWTThread(new Runnable()			{				public void run()				{					VFSManager.error = false;						if(comp == null || !comp.isShowing())						GUIUtilities.error(null,error,args);					else						GUIUtilities.error(comp,error,args);				}			});		}	
/**		 * Reports an I/O error.		 *		 * @param comp The component		 * @param path The path name that caused the error		 * @param messageProp The error message property name		 * @param args Positional parameters		 * @since jEdit 4.0pre3		 */		public static void error(Component comp,			final String path,			String messageProp,			Object[] args)		{			final Frame frame = JOptionPane.getFrameForComponent(comp);				synchronized(errorLock)			{				error = true;					errors.add(new ErrorListDialog.ErrorEntry(					path,messageProp,args));					if(errors.size() == 1)				{											VFSManager.runInAWTThread(new Runnable()					{						public void run()						{							String caption = jEdit.getProperty(								"ioerror.caption" + (errors.size() == 1								? "-1" : ""),new Integer[] {								Integer.valueOf(errors.size())});							new ErrorListDialog(								frame.isShowing()								? frame								: jEdit.getFirstView(),								jEdit.getProperty("ioerror.title"),								caption,errors,false);							errors.clear();							error = false;						}					});				}			}		}	
/**		 * Sends a VFS update message.		 * @param vfs The VFS		 * @param path The path that changed		 * @param parent True if an update should be sent for the path's		 * parent too		 * @since jEdit 2.6pre4		 */		public static void sendVFSUpdate(VFS vfs, String path, boolean parent)		{			if(parent)			{				sendVFSUpdate(vfs,vfs.getParentOfPath(path),false);				sendVFSUpdate(vfs,path,false);			}			else			{				// have to do this hack until VFSPath class is written				if(path.length() != 1 && (path.endsWith("/")					|| path.endsWith(java.io.File.separator)))					path = path.substring(0,path.length() - 1);					synchronized(vfsUpdateLock)				{					for(int i = 0; i < vfsUpdates.size(); i++)					{						VFSUpdate msg = vfsUpdates.get(i);						if(msg.getPath().equals(path))						{							// don't send two updates							// for the same path							return;						}					}						vfsUpdates.add(new VFSUpdate(path));						if(vfsUpdates.size() == 1)					{						// we were the first to add an update;						// add update sending runnable to AWT						// thread						VFSManager.runInAWTThread(new SendVFSUpdatesSafely());					}				}			}		}	
public void run()			{				synchronized(vfsUpdateLock)				{					// the vfs browser has what you might call					// a design flaw, it doesn't update properly					// unless the vfs update for a parent arrives					// before any updates for the children. sorting					// the list alphanumerically guarantees this.					Collections.sort(vfsUpdates,						new StandardUtilities.StringCompare<VFSUpdate>()					);					for(int i = 0; i < vfsUpdates.size(); i++)					{						EditBus.send(vfsUpdates.get(i));					}						vfsUpdates.clear();				}			}	
private VFSManager() {}	
/**		 * @param source the View that is considered the "source" of this event		 * @param isDirectory true if the path is pointing to a folder, false if it's a regular file		 * @param path The selected path.		 */		public VFSPathSelected(View source, String path, boolean isDirectory)		{			super(source);			this.path = path;			this.isDir = isDirectory;		}	
public View getView()		{			return (View) getSource();		}	
/**		 *  @return The selected URL (or file path).		 */		public String getPath()		{			return path;		}	
/**		 * 		 * @return true if this is a directory node		 */		public boolean isDirectory()		{			return isDir;		}	
/**		 * Creates a VFS update message.		 * @param path The path in question		 */		public VFSUpdate(String path)		{			super(null);				if(path == null)				throw new NullPointerException("Path must be non-null");				this.path = path;		}	
/**		 * Returns the path that changed.		 */		public String getPath()		{			return path;		}	
public String paramString()		{			return "path=" + path + "," + super.paramString();		}	
/**		 * Returns the dockable window manager associated with this view.		 * @since jEdit 2.6pre3		 */		public DockableWindowManager getDockableWindowManager()		{			return dockableWindowManager;		}	
public static String getDockingFrameworkName()		{			String framework = jEdit.getProperty(					VIEW_DOCKING_FRAMEWORK_PROPERTY, ORIGINAL_DOCKING_FRAMEWORK);			return framework;		}	
public static DockingFrameworkProvider getDockingFrameworkProvider()		{			if (dockingFrameworkProvider == null)			{				String framework = getDockingFrameworkName();				dockingFrameworkProvider = (DockingFrameworkProvider)					ServiceManager.getService(						DOCKING_FRAMEWORK_PROVIDER_SERVICE, framework);					if (dockingFrameworkProvider == null)				{					Log.log(Log.ERROR, View.class, "No docking framework " + framework +								       " available, using the original one");					dockingFrameworkProvider = (DockingFrameworkProvider)					ServiceManager.getService(						DOCKING_FRAMEWORK_PROVIDER_SERVICE, ORIGINAL_DOCKING_FRAMEWORK);				}			}			return dockingFrameworkProvider;		}	
/**		 * Returns the view's tool bar.		 * @since jEdit 4.2pre1		 */		public Container getToolBar()		{			return toolBar;		}	
/**		 * Adds a tool bar to this view.		 * @param toolBar The tool bar		 */		public void addToolBar(Component toolBar)		{			addToolBar(DEFAULT_GROUP, DEFAULT_LAYER, toolBar);		}	
/**		 * Adds a tool bar to this view.		 * @param group The tool bar group to add to		 * @param toolBar The tool bar		 * @see org.gjt.sp.jedit.gui.ToolBarManager		 * @since jEdit 4.0pre7		 */		public void addToolBar(int group, Component toolBar)		{			addToolBar(group, DEFAULT_LAYER, toolBar);		}	
/**		 * Adds a tool bar to this view.		 * @param group The tool bar group to add to		 * @param layer The layer of the group to add to		 * @param toolBar The tool bar		 * @see org.gjt.sp.jedit.gui.ToolBarManager		 * @since jEdit 4.0pre7		 */		public void addToolBar(int group, int layer, Component toolBar)		{			toolBarManager.addToolBar(group, layer, toolBar);			getRootPane().revalidate();		}	
/**		 * Removes a tool bar from this view.		 * @param toolBar The tool bar		 */		public void removeToolBar(Component toolBar)		{			if (toolBarManager == null) return;			if (toolBar == null) return;			toolBarManager.removeToolBar(toolBar);			getRootPane().revalidate();		}	
/**		 * Shows the wait cursor. This method and		 * {@link #hideWaitCursor()} are implemented using a reference		 * count of requests for wait cursors, so that nested calls work		 * correctly; however, you should be careful to use these methods in		 * tandem.<p>		 *		 * To ensure that {@link #hideWaitCursor()} is always called		 * after a {@link #showWaitCursor()}, use a		 * <code>try</code>/<code>finally</code> block, like this:		 * <pre>try		 *{		 *    view.showWaitCursor();		 *    // ...		 *}		 *finally		 *{		 *    view.hideWaitCursor();		 *}</pre>		 */		public synchronized void showWaitCursor()		{			if(waitCount++ == 0)			{				Cursor cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);				setCursor(cursor);				visit(new SetCursorVisitor(cursor));			}		}	
/**		 * Hides the wait cursor.		 */		public synchronized void hideWaitCursor()		{			if(waitCount > 0)				waitCount--;				if(waitCount == 0)			{				// still needed even though glass pane				// has a wait cursor				Cursor cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);				setCursor(cursor);					visit(new SetCursorVisitor(cursor));			}		}	
/**		 * Returns the search bar.		 * @since jEdit 2.4pre4		 */		public final SearchBar getSearchBar()		{			return searchBar;		}	
/**		 * Returns the action bar.		 * @since jEdit 4.2pre3		 */		public final ActionBar getActionBar()		{			return actionBar;		}	
/**		 * Returns the status bar. The		 * {@link org.gjt.sp.jedit.gui.StatusBar#setMessage(String)} and		 * {@link org.gjt.sp.jedit.gui.StatusBar#setMessageAndClear(String)} methods can		 * be called on the return value of this method to display status		 * information to the user.		 * @since jEdit 3.2pre2		 */		public StatusBar getStatus()		{			return status;		}	
/**		 * Quick search.		 * @since jEdit 4.0pre3		 */		public void quickIncrementalSearch(boolean word)		{			if(searchBar == null)				searchBar = new SearchBar(this,true);			if(searchBar.getParent() == null)				addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);				searchBar.setHyperSearch(false);				JEditTextArea textArea = getTextArea();				if(word)			{				String text = textArea.getSelectedText();				if(text == null)				{					textArea.selectWord();					text = textArea.getSelectedText();				}				else if(text.indexOf('\n') != -1)					text = null;					if(text != null && SearchAndReplace.getRegexp())					text = SearchAndReplace.escapeRegexp(text,false);					searchBar.getField().setText(text);			}				searchBar.getField().requestFocus();			searchBar.getField().selectAll();		}	
/**		 * Quick HyperSearch.		 * @since jEdit 4.0pre3		 */		public void quickHyperSearch(boolean word)		{			JEditTextArea textArea = getTextArea();				if(word)			{				String text = textArea.getSelectedText();				if(text == null)				{					textArea.selectWord();					text = textArea.getSelectedText();				}					if(text != null && text.indexOf('\n') == -1)				{					if(SearchAndReplace.getRegexp())					{						text = SearchAndReplace.escapeRegexp(							text,false);					}						HistoryModel.getModel("find").addItem(text);					SearchAndReplace.setSearchString(text);					SearchAndReplace.setSearchFileSet(new CurrentBufferSet());					SearchAndReplace.hyperSearch(this);						return;				}			}				if(searchBar == null)				searchBar = new SearchBar(this,true);			if(searchBar.getParent() == null)				addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);				searchBar.setHyperSearch(true);			searchBar.getField().setText(null);			searchBar.getField().requestFocus();			searchBar.getField().selectAll();		}	
/**		 * Shows the action bar if needed, and sends keyboard focus there.		 * @since jEdit 4.2pre1		 */		public void actionBar()		{			if(actionBar == null)				actionBar = new ActionBar(this,true);			if(actionBar.getParent() == null)				addToolBar(BOTTOM_GROUP,ACTION_BAR_LAYER,actionBar);				actionBar.goToActionBar();		}	
/**		 * Returns the listener that will handle all key events in this		 * view, if any.		 * @return the key event interceptor or null		 */		public KeyListener getKeyEventInterceptor()		{			return inputHandler.getKeyEventInterceptor();		}	
/**		 * Sets the listener that will handle all key events in this		 * view. For example, the complete word command uses this so		 * that all key events are passed to the word list popup while		 * it is visible.		 * @param listener The key event interceptor.		 */		public void setKeyEventInterceptor(KeyListener listener)		{			inputHandler.setKeyEventInterceptor(listener);		}	
/**		 * Returns the input handler.		 */		public InputHandler getInputHandler()		{			return inputHandler;		}	
/**		 * Sets the input handler.		 * @param inputHandler The new input handler		 */		public void setInputHandler(InputHandler inputHandler)		{			this.inputHandler = inputHandler;		}	
/**		 * Returns the macro recorder.		 */		public Macros.Recorder getMacroRecorder()		{			return recorder;		}	
/**		 * Sets the macro recorder.		 * @param recorder The macro recorder		 */		public void setMacroRecorder(Macros.Recorder recorder)		{			this.recorder = recorder;		}	
/**		 * Forwards key events directly to the input handler.		 * This is slightly faster than using a KeyListener		 * because some Swing overhead is avoided.		 */		@Override		public void processKeyEvent(KeyEvent evt)		{			inputHandler.processKeyEvent(evt,VIEW, false);			if(!evt.isConsumed())				super.processKeyEvent(evt);		}	
/**		 * Forwards key events directly to the input handler.		 * This is slightly faster than using a KeyListener		 * because some Swing overhead is avoided.		 */		public void processKeyEvent(KeyEvent evt, boolean calledFromTextArea)		{			processKeyEvent(evt,calledFromTextArea				? TEXT_AREA				: VIEW);		}	
/**		 * Forwards key events directly to the input handler.		 * This is slightly faster than using a KeyListener		 * because some Swing overhead is avoided.		 */		public void processKeyEvent(KeyEvent evt, int from)		{			processKeyEvent(evt,from,false);		}	
/**		 * Forwards key events directly to the input handler.		 * This is slightly faster than using a KeyListener		 * because some Swing overhead is avoided.		 * @deprecated do not use, try {@link org.gjt.sp.jedit.gui.InputHandler#processKeyEvent(java.awt.event.KeyEvent, int, boolean)}		 */		@Deprecated		public void processKeyEvent(KeyEvent evt, int from, boolean global)		{			inputHandler.processKeyEvent(evt, from, global);			if(!evt.isConsumed())				super.processKeyEvent(evt);		}	
/**		 * Splits the view horizontally.		 * @return the new editPane		 * @since jEdit 4.1pre2		 */		public EditPane splitHorizontally()		{			return split(JSplitPane.VERTICAL_SPLIT);		}	
/**		 * Splits the view vertically.		 * @return the new editPane		 * @since jEdit 4.1pre2		 */		public EditPane splitVertically()		{			return split(JSplitPane.HORIZONTAL_SPLIT);		}	
/**		 * Splits the view.		 * @param orientation the orientation {@link javax.swing.JSplitPane#HORIZONTAL_SPLIT} or		 * {@link javax.swing.JSplitPane#VERTICAL_SPLIT}		 * @return the new editPane		 * @since jEdit 4.1pre2		 */		public EditPane split(int orientation)		{			PerspectiveManager.setPerspectiveDirty(true);				editPane.saveCaretInfo();			EditPane oldEditPane = editPane;			String action = jEdit.getProperty("editpane.bufferset.new");			BufferSetManager.NewBufferSetAction bufferSetAction = BufferSetManager.NewBufferSetAction.fromString(action);			EditPane newEditPane;			if (bufferSetAction == BufferSetManager.NewBufferSetAction.empty)				newEditPane = createEditPane(null);			else				newEditPane = createEditPane(oldEditPane.getBuffer());	//		setEditPane(newEditPane);			newEditPane.loadCaretInfo();				JComponent oldParent = (JComponent)oldEditPane.getParent();				final JSplitPane newSplitPane = new JSplitPane(orientation,								       jEdit.getBooleanProperty("appearance.continuousLayout"));			newSplitPane.setOneTouchExpandable(true);			newSplitPane.setBorder(null);			newSplitPane.setMinimumSize(new Dimension(0,0));			newSplitPane.setResizeWeight(0.5);				int parentSize = orientation == JSplitPane.VERTICAL_SPLIT				? oldEditPane.getHeight() : oldEditPane.getWidth();			final int dividerPosition = (int)((parentSize				- newSplitPane.getDividerSize()) * 0.5);			newSplitPane.setDividerLocation(dividerPosition);				if(oldParent instanceof JSplitPane)			{				JSplitPane oldSplitPane = (JSplitPane)oldParent;				int dividerPos = oldSplitPane.getDividerLocation();					Component left = oldSplitPane.getLeftComponent();					if(left == oldEditPane)					oldSplitPane.setLeftComponent(newSplitPane);				else					oldSplitPane.setRightComponent(newSplitPane);					newSplitPane.setLeftComponent(oldEditPane);				newSplitPane.setRightComponent(newEditPane);					oldSplitPane.setDividerLocation(dividerPos);			}			else			{				splitPane = newSplitPane;					newSplitPane.setLeftComponent(oldEditPane);				newSplitPane.setRightComponent(newEditPane);					setMainContent(newSplitPane);				}				SwingUtilities.invokeLater(new Runnable()			{				public void run()				{					newSplitPane.setDividerLocation(dividerPosition);				}			});				newEditPane.focusOnTextArea();				return newEditPane;		}	
/**		 * Unsplits the view.		 * @since jEdit 2.3pre2		 */		public void unsplit()		{			if(splitPane != null)			{				lastSplitConfig = getSplitConfig();					PerspectiveManager.setPerspectiveDirty(true);					for(EditPane _editPane: getEditPanes())				{					if(editPane != _editPane)					{						mergeBufferSets(editPane, _editPane);						_editPane.close();					}				}					setMainContent(editPane);					splitPane = null;				updateTitle();					editPane.focusOnTextArea();			}			else				getToolkit().beep();		}	
/**		 * Removes the current split.		 * @since jEdit 2.3pre2		 */		public void unsplitCurrent()		{			if(splitPane != null)			{				lastSplitConfig = getSplitConfig();					PerspectiveManager.setPerspectiveDirty(true);					// find first split pane parenting current edit pane				Component comp = editPane;				while(!(comp instanceof JSplitPane) && comp != null)				{					comp = comp.getParent();				}					// get rid of any edit pane that is a child				// of the current edit pane's parent splitter				for(EditPane _editPane: getEditPanes())				{					if(GUIUtilities.isAncestorOf(comp,_editPane)						&& _editPane != editPane)					{						mergeBufferSets(editPane, _editPane);						_editPane.close();					}				}					JComponent parent = comp == null ? null : (JComponent)comp.getParent();					if(parent instanceof JSplitPane)				{					JSplitPane parentSplit = (JSplitPane)parent;					int pos = parentSplit.getDividerLocation();					if(parentSplit.getLeftComponent() == comp)						parentSplit.setLeftComponent(editPane);					else						parentSplit.setRightComponent(editPane);					parentSplit.setDividerLocation(pos);					parent.revalidate();				}				else				{					setMainContent(editPane);					splitPane = null;				}					updateTitle();					editPane.focusOnTextArea();			}			else				getToolkit().beep();		}	
/**		 * Restore the split configuration as it was before unsplitting.		 *		 * @since jEdit 4.3pre1		 */		public void resplit()		{			if(lastSplitConfig == null)				getToolkit().beep();			else				setSplitConfig(null,lastSplitConfig);		}	
/**		*   Split configurations are recorded in a simple RPN "language".		*   @return The split configuration, describing where splitpanes		*           are, which buffers are open in each EditPane, etc.		*		*/		public String getSplitConfig()		{			StringBuilder splitConfig = new StringBuilder();				if(splitPane != null)				getSplitConfig(splitPane,splitConfig);			else			{				appendToSplitConfig(splitConfig, editPane);			}				return splitConfig.toString();		}	
/**		 * sets the split configuration as per the splitConfig.		 *		 * @param buffer if null, checks all buffers to restore View's split config.		 * @param splitConfig the split config, as returned by getSplitConfig()		 */		public void setSplitConfig(Buffer buffer, String splitConfig)		{			try			{				Component comp = restoreSplitConfig(buffer,splitConfig);				setMainContent(comp);			}			catch(IOException e)			{				// this should never throw an exception.				throw new InternalError();			}		}	
/**		 * Moves keyboard focus to the next text area.		 * @since jEdit 2.7pre4		 */		public void nextTextArea()		{			EditPane[] editPanes = getEditPanes();			for(int i = 0; i < editPanes.length; i++)			{				if(editPane == editPanes[i])				{					if(i == editPanes.length - 1)						editPanes[0].focusOnTextArea();					else						editPanes[i+1].focusOnTextArea();					break;				}			}		}	
/**		 * Moves keyboard focus to the previous text area.		 * @since jEdit 2.7pre4		 */		public void prevTextArea()		{			EditPane[] editPanes = getEditPanes();			for(int i = 0; i < editPanes.length; i++)			{				if(editPane == editPanes[i])				{					if(i == 0)						editPanes[editPanes.length - 1].focusOnTextArea();					else						editPanes[i-1].focusOnTextArea();					break;				}			}		}	
/**		 * Returns the top-level split pane, if any.		 * @return the top JSplitPane if any.		 * @since jEdit 2.3pre2		 */		public JSplitPane getSplitPane()		{			return splitPane;		}	
/**		 * Returns the current edit pane's buffer.		 * @return the current edit pane's buffer, it can be null		 */		public Buffer getBuffer()		{			if(editPane == null)				return null;			else				return editPane.getBuffer();		}	
/**		 * Sets the current edit pane's buffer.		 * @param buffer The buffer		 */		public void setBuffer(Buffer buffer)		{			setBuffer(buffer,false);		}	
/**		 * Sets the current edit pane's buffer.		 * @param buffer The buffer		 * @param disableFileStatusCheck Disables file status checking		 * regardless of the state of the checkFileStatus property		 */		public void setBuffer(Buffer buffer, boolean disableFileStatusCheck)		{			setBuffer(buffer, disableFileStatusCheck, true);		}	
/**		 * Sets the current edit pane's buffer.		 * @param buffer The buffer		 * @param disableFileStatusCheck Disables file status checking		 * regardless of the state of the checkFileStatus property		 * @param focus Whether the textarea should request focus		 * @since jEdit 4.3pre13		 */		public void setBuffer(Buffer buffer, boolean disableFileStatusCheck, boolean focus)		{			editPane.setBuffer(buffer, focus);			int check = jEdit.getIntegerProperty("checkFileStatus");			if(!disableFileStatusCheck && (check == GeneralOptionPane.checkFileStatus_all ||							  check == GeneralOptionPane.checkFileStatus_operations ||							  check == GeneralOptionPane.checkFileStatus_focusBuffer))				jEdit.checkBufferStatus(this, true);		}	
/**		 * If this buffer is open in one of the view's edit panes, sets focus		 * to that edit pane. Otherwise, opens the buffer in the currently		 * active edit pane.		 * @param buffer The buffer		 * @return the current edit pane		 * @since jEdit 4.2pre1		 */		public EditPane goToBuffer(Buffer buffer)		{			return showBuffer(buffer, true);		}	
/**		 * If this buffer is open in one of the view's edit panes, activates		 * that edit pane. Otherwise, opens the buffer in the currently		 * active edit pane. But the focus is not moved.		 * @param buffer The buffer to show		 * @return the current edit pane		 * @since jEdit 4.3pre13		 */		public EditPane showBuffer(Buffer buffer)		{			return showBuffer(buffer, false);		}	
/**		 * Returns the current edit pane's text area.		 * @return the current edit pane's text area, or <b>null</b> if there is no edit pane yet		 */		public JEditTextArea getTextArea()		{			if(editPane == null)				return null;			else				return editPane.getTextArea();		}	
/**		 * Returns the current edit pane.		 * @return the current edit pane		 * @since jEdit 2.5pre2		 */		public EditPane getEditPane()		{			return editPane;		}	
/**		 * Returns all edit panes.		 * @return an array of all edit panes in the view		 * @since jEdit 2.5pre2		 */		public EditPane[] getEditPanes()		{			if(splitPane == null)			{				EditPane[] ep = { editPane };				return ep;			}			else			{				List<EditPane> vec = new ArrayList<EditPane>();				getEditPanes(vec,splitPane);				EditPane[] ep = new EditPane[vec.size()];				vec.toArray(ep);				return ep;			}		}	
/**		 * Returns the view's local buffer set, which can be shared by		 * several editpanes.		 * @return the view's buffer set		 * @since jEdit 4.3pre17		 */		public BufferSet getLocalBufferSet()		{			return localBufferSet;		}	
/**		 * @return a ViewConfig instance for the current view		 * @since jEdit 4.2pre1		 */		public ViewConfig getViewConfig()		{			ViewConfig config = new ViewConfig();			config.plainView = isPlainView();			config.splitConfig = getSplitConfig();			config.extState = getExtendedState();			config.docking = dockableWindowManager.getDockingLayout(config);			String prefix = config.plainView ? "plain-view" : "view";			switch (config.extState)			{				case Frame.MAXIMIZED_BOTH:				case Frame.ICONIFIED:					config.x = jEdit.getIntegerProperty(prefix + ".x",getX());					config.y = jEdit.getIntegerProperty(prefix + ".y",getY());					config.width = jEdit.getIntegerProperty(prefix + ".width",getWidth());					config.height = jEdit.getIntegerProperty(prefix + ".height",getHeight());					break;					case Frame.MAXIMIZED_VERT:					config.x = getX();					config.y = jEdit.getIntegerProperty(prefix + ".y",getY());					config.width = getWidth();					config.height = jEdit.getIntegerProperty(prefix + ".height",getHeight());					break;					case Frame.MAXIMIZED_HORIZ:					config.x = jEdit.getIntegerProperty(prefix + ".x",getX());					config.y = getY();					config.width = jEdit.getIntegerProperty(prefix + ".width",getWidth());					config.height = getHeight();					break;					case Frame.NORMAL:				default:					config.x = getX();					config.y = getY();					config.width = getWidth();					config.height = getHeight();					break;			}			return config;		}	
/**		 * Returns true if this view has been closed with		 * {@link jEdit#closeView(View)}.		 * @return true if the view is closed		 */		public boolean isClosed()		{			return closed;		}	
/**		 * Returns true if this is an auxilliary view with no dockable windows.		 * @return true if the view is plain		 * @since jEdit 4.1pre2		 */		public boolean isPlainView()		{			return plainView;		}	
/**		 * Returns the next view in the list.		 * @return the next view		 */		public View getNext()		{			return next;		}	
/**		 * Returns the previous view in the list.		 * @return the preview view		 */		public View getPrev()		{			return prev;		}	
public void handleMessage(EBMessage msg)		{			if(msg instanceof PropertiesChanged)				propertiesChanged();			else if(msg instanceof SearchSettingsChanged)			{				if(searchBar != null)					searchBar.update();			}			else if(msg instanceof BufferUpdate)				handleBufferUpdate((BufferUpdate)msg);			else if(msg instanceof EditPaneUpdate)				handleEditPaneUpdate((EditPaneUpdate)msg);		}	
@Override		public Dimension getMinimumSize()		{			return new Dimension(0,0);		}	
/**		 * This socket is closed when the buffer is closed.		 */		public void setWaitSocket(Socket waitSocket)		{			this.waitSocket = waitSocket;		}	
@Override		public String toString()		{			return getClass().getName() + '['				+ (jEdit.getActiveView() == this				? "active" : "inactive")				+ ']';		}	
/**		 * Updates the title bar.		 */		public void updateTitle()		{			List<Buffer> buffers = new ArrayList<Buffer>();			EditPane[] editPanes = getEditPanes();			for(int i = 0; i < editPanes.length; i++)			{				Buffer buffer = editPanes[i].getBuffer();				if(!buffers.contains(buffer))					buffers.add(buffer);			}				StringBuilder title = new StringBuilder();				/* On Mac OS X, apps are not supposed to show their name in the			title bar. */			if(!OperatingSystem.isMacOS())				title.append(jEdit.getProperty("view.title"));				boolean unsavedChanges = false;				for(int i = 0; i < buffers.size(); i++)			{				if(i != 0)					title.append(", ");					Buffer buffer = buffers.get(i);				title.append(showFullPath && !buffer.isNewFile()					? buffer.getPath(true) : buffer.getName());				if(buffer.isDirty())				{					unsavedChanges = true;					title.append(jEdit.getProperty("view.title.dirty"));				}			}				setTitle(title.toString());		}	
public Component getPrefixFocusOwner()		{			return prefixFocusOwner;		}	
public void setPrefixFocusOwner(Component prefixFocusOwner)		{			this.prefixFocusOwner = prefixFocusOwner;		}	
/**		 * Visit the the editpanes and textareas of the view		 * @param visitor the visitor		 * @since jEdit 4.3pre13		 */		public void visit(JEditVisitor visitor)		{			EditPane[] panes = getEditPanes();			for (int i = 0; i < panes.length; i++)			{				EditPane editPane = panes[i];				visitor.visit(editPane);				visitor.visit(editPane.getTextArea());			}		}	
View(Buffer buffer, ViewConfig config)		{			fullScreenMode = false;			menuBar = null;			plainView = config.plainView;				enableEvents(AWTEvent.KEY_EVENT_MASK);				setIconImage(GUIUtilities.getEditorIcon());				mainPanel = new JPanel();			mainPanel.setLayout(new BorderLayout());			dockableWindowManager = getDockingFrameworkProvider().create(this,				DockableWindowFactory.getInstance(), config);			dockableWindowManager.setMainPanel(mainPanel);				topToolBars = new JPanel(new VariableGridLayout(				VariableGridLayout.FIXED_NUM_COLUMNS,				1));			bottomToolBars = new JPanel(new VariableGridLayout(				VariableGridLayout.FIXED_NUM_COLUMNS,				1));				toolBarManager = new ToolBarManager(topToolBars, bottomToolBars);				status = new StatusBar(this);				inputHandler = new DefaultInputHandler(this,(DefaultInputHandler)				jEdit.getInputHandler());				localBufferSet = new BufferSet();				setSplitConfig(buffer,config.splitConfig);				getContentPane().add(BorderLayout.CENTER,dockableWindowManager);				dockableWindowManager.init();				// tool bar and status bar gets added in propertiesChanged()			// depending in the 'tool bar alternate layout' setting.			propertiesChanged();				setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);			addWindowListener(new WindowHandler());				setFocusTraversalPolicy(new MyFocusTraversalPolicy());				EditBus.addToBus(this);				GUIUtilities.addSizeSaver(this, null, plainView ? "plain-view" : "view");		}	
public void updateFullScreenProps()		{			boolean alternateLayout = jEdit.getBooleanProperty(				"view.toolbar.alternateLayout");			boolean showMenu = jEdit.getBooleanProperty("fullScreenIncludesMenu");			boolean showToolbars = jEdit.getBooleanProperty("fullScreenIncludesToolbar");			boolean showStatus = jEdit.getBooleanProperty("fullScreenIncludesStatus");			if (! showMenu)			{				menuBar = getJMenuBar();				setJMenuBar(null);			}			else if (menuBar != null)				setJMenuBar(menuBar);			if (alternateLayout)			{				// Note: Bottom toolbar is the action bar, which is always enabled				if (! showToolbars)					getContentPane().remove(topToolBars);				else					getContentPane().add(BorderLayout.NORTH,topToolBars);				if (! showStatus)					removeToolBar(status);				else					addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);			}			else			{				// Note: Bottom toolbar is the action bar, which is always enabled				if (! showToolbars)					mainPanel.remove(topToolBars);				else					mainPanel.add(topToolBars, BorderLayout.NORTH);				if (! showStatus)					getContentPane().remove(status);				else					getContentPane().add(BorderLayout.SOUTH,status);			}		}	
public void toggleFullScreen()		{			fullScreenMode = (! fullScreenMode);			GraphicsDevice sd = getGraphicsConfiguration().getDevice();			dispose();			if (fullScreenMode)			{				updateFullScreenProps();				windowedBounds = getBounds();				setUndecorated(true);				setBounds(sd.getDefaultConfiguration().getBounds());				validate();			}			else			{				boolean showStatus = plainView ? jEdit.getBooleanProperty("view.status.plainview.visible") :					jEdit.getBooleanProperty("view.status.visible");				if ((menuBar != null) && (getJMenuBar() != menuBar))					setJMenuBar(menuBar);				boolean alternateLayout = jEdit.getBooleanProperty(					"view.toolbar.alternateLayout");				if (alternateLayout)				{					getContentPane().add(BorderLayout.NORTH,topToolBars);					if (showStatus)						addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);				}				else				{					mainPanel.add(topToolBars, BorderLayout.NORTH);					if (showStatus)						getContentPane().add(BorderLayout.SOUTH,status);				}				setUndecorated(false);				setBounds(windowedBounds);			}			setVisible(true);			toFront();			// so you can keep typing in your editpane afterwards...			editPane.getTextArea().requestFocus();		}	
/**		 * If the view contains dirty buffers which will be closed on		 * closing the view, show the confirmation dialog for user.		 * @return		 * 	true if there are no such buffers or user select OK		 * 	to close the view; false if user select Cancel		 */		boolean confirmToCloseDirty()		{			Set<Buffer> checkingBuffers = getOpenBuffers();			for (View view: jEdit.getViews())			{				if (view != this)				{					checkingBuffers.removeAll(						view.getOpenBuffers());				}			}			for (Buffer buffer: checkingBuffers)			{				if (buffer.isDirty())				{					return new CloseDialog(this, checkingBuffers).isOK();				}			}			return true;		}	
void close()		{			EditBus.send(new ViewUpdate(this,ViewUpdate.CLOSED));			closed = true;				// save dockable window geometry, and close 'em			dockableWindowManager.close();				EditBus.removeFromBus(this);			dispose();				EditPane[] editPanes = getEditPanes();			for(int i = 0; i < editPanes.length; i++)				editPanes[i].close();				// null some variables so that retaining references			// to closed views won't hurt as much.			toolBarManager = null;			toolBar = null;			searchBar = null;			splitPane = null;			inputHandler = null;			recorder = null;				getContentPane().removeAll();				// notify clients with -wait			if(waitSocket != null)			{				try				{					waitSocket.getOutputStream().write('\0');					waitSocket.getOutputStream().flush();					waitSocket.getInputStream().close();					waitSocket.getOutputStream().close();					waitSocket.close();				}				catch(IOException io)				{					//Log.log(Log.ERROR,this,io);				}			}		}	
private void setMainContent(Component c)		{			if (mainContent != null)				mainPanel.remove(mainContent);			mainContent = c;			mainPanel.add(mainContent, BorderLayout.CENTER);			mainPanel.revalidate();			mainPanel.repaint();		}	
private static void getEditPanes(List<EditPane> vec, Component comp)		{			if(comp instanceof EditPane)				vec.add((EditPane) comp);			else if(comp instanceof JSplitPane)			{				JSplitPane split = (JSplitPane)comp;				getEditPanes(vec,split.getLeftComponent());				getEditPanes(vec,split.getRightComponent());			}		}	
private EditPane showBuffer(Buffer buffer, boolean focus)		{			if(editPane.getBuffer() == buffer				&& editPane.getTextArea().getVisibleLines() > 1)			{				if (focus)					editPane.focusOnTextArea();				return editPane;			}				EditPane[] editPanes = getEditPanes();			for(int i = 0; i < editPanes.length; i++)			{				EditPane ep = editPanes[i];				if(ep.getBuffer() == buffer					/* ignore zero-height splits, etc */					&& ep.getTextArea().getVisibleLines() > 1)				{					setEditPane(ep);					if (focus)						ep.focusOnTextArea();					return ep;				}			}				setBuffer(buffer,false, focus);			return editPane;		}	
private static void getSplitConfig(JSplitPane splitPane,			StringBuilder splitConfig)		{			Component right = splitPane.getRightComponent();			appendToSplitConfig(splitConfig, right);				splitConfig.append(' ');				Component left = splitPane.getLeftComponent();			appendToSplitConfig(splitConfig, left);				splitConfig.append(' ');			splitConfig.append(splitPane.getDividerLocation());			splitConfig.append(' ');			splitConfig.append(splitPane.getOrientation()				== JSplitPane.VERTICAL_SPLIT ? "vertical" : "horizontal");		}	
/**		 * Append the Component to the split config.		 * The component must be a JSplitPane or an EditPane		 *		 * @param splitConfig the split config		 * @param component the component		 */		private static void appendToSplitConfig(StringBuilder splitConfig, Component component)		{			if(component instanceof JSplitPane)			{				// the component is a JSplitPane				getSplitConfig((JSplitPane)component,splitConfig);			}			else			{				// the component is an editPane				EditPane editPane = (EditPane) component;				splitConfig.append('"');				splitConfig.append(StandardUtilities.charsToEscapes(					editPane.getBuffer().getPath()));				splitConfig.append("\" buffer");				BufferSet bufferSet = editPane.getBufferSet();				Buffer[] buffers = bufferSet.getAllBuffers();				for (Buffer buffer : buffers)				{					if (!buffer.isNewFile())					{						splitConfig.append(" \"");						splitConfig.append(StandardUtilities.charsToEscapes(							buffer.getPath()));						splitConfig.append("\" buff");					}				}				splitConfig.append(" \"");				splitConfig.append(editPane.getBufferSetScope());				splitConfig.append("\" bufferset");			}		}	
private Component restoreSplitConfig(Buffer buffer, String splitConfig)			throws IOException		// this is where checked exceptions piss me off. this method only uses		// a StringReader which can never throw an exception...		{			if(buffer != null)			{				return editPane = createEditPane(buffer);			}			else if(splitConfig == null)			{				return editPane = createEditPane(jEdit.getFirstBuffer());			}			Buffer[] buffers = jEdit.getBuffers();				Stack<Object> stack = new Stack<Object>();				// we create a stream tokenizer for parsing a simple			// stack-based language			StreamTokenizer st = new StreamTokenizer(new StringReader(				splitConfig));			st.whitespaceChars(0,' ');			/* all printable ASCII characters */			st.wordChars('#','~');			st.commentChar('!');			st.quoteChar('"');			st.eolIsSignificant(false);			boolean continuousLayout = jEdit.getBooleanProperty("appearance.continuousLayout");			List<Buffer> editPaneBuffers = new ArrayList<Buffer>();	loop:		while (true)			{				switch(st.nextToken())				{				case StreamTokenizer.TT_EOF:					break loop;				case StreamTokenizer.TT_WORD:					if(st.sval.equals("vertical") ||						st.sval.equals("horizontal"))					{						int orientation							= st.sval.equals("vertical")							? JSplitPane.VERTICAL_SPLIT							: JSplitPane.HORIZONTAL_SPLIT;						int divider = ((Integer)stack.pop())							.intValue();						Object obj1 = stack.pop();						Object obj2 = stack.pop();						// Backward compatibility with pre-bufferset versions						if (obj1 instanceof Buffer)						{							Buffer b1 = buffer = (Buffer) obj1;							jEdit.getGlobalBufferSet().addBufferAt(b1, -1);							obj1 = editPane = createEditPane(b1, BufferSet.Scope.global);						}						if (obj2 instanceof Buffer)						{							Buffer b2 = (Buffer) obj2;							jEdit.getGlobalBufferSet().addBufferAt(b2, -1);							obj2 = createEditPane(b2, BufferSet.Scope.global);						}						stack.push(splitPane = new JSplitPane(							orientation,							continuousLayout,							(Component)obj1,							(Component)obj2));						splitPane.setOneTouchExpandable(true);						splitPane.setBorder(null);						splitPane.setMinimumSize(							new Dimension(0,0));						splitPane.setDividerLocation(divider);					}					else if(st.sval.equals("buffer"))					{						Object obj = stack.pop();						if(obj instanceof Integer)						{							int index = ((Integer)obj).intValue();							if(index >= 0 && index < buffers.length)								buffer = buffers[index];						}						else if(obj instanceof String)						{							String path = (String)obj;							buffer = jEdit.getBuffer(path);							if (buffer == null)								buffer = jEdit.openFile(this, path);						}							if(buffer == null)							buffer = jEdit.getFirstBuffer();						stack.push(buffer);					}					else if (st.sval.equals("buff"))					{							String path = (String)stack.pop();						buffer = jEdit.getBuffer(path);						if (buffer == null)						{							Log.log(Log.WARNING, this, "Buffer " + path + " doesn't exist");						}						else						{							editPaneBuffers.add(buffer);						}					}					else if (st.sval.equals("bufferset"))					{						BufferSet.Scope scope = BufferSet.Scope.fromString((String) stack.pop());						buffer = (Buffer) stack.pop();						editPane = createEditPane(buffer, scope);						stack.push(editPane);						BufferSetManager bufferSetManager = jEdit.getBufferSetManager();						BufferSet bufferSet = editPane.getBufferSet();						int i = 0;						for (Buffer buff : editPaneBuffers)						{							if (buff == buffer)								bufferSet.addBufferAt(buffer, i);							else								bufferSetManager.addBuffer(bufferSet, buff);							i++;						}						editPaneBuffers.clear();					}					break;				case StreamTokenizer.TT_NUMBER:					stack.push((int)st.nval);					break;				case '"':					stack.push(st.sval);					break;				}			}				// Backward compatibility with pre-bufferset versions			Object obj = stack.peek();			if (obj instanceof Buffer)			{				jEdit.getGlobalBufferSet().addBufferAt((Buffer)obj, -1);				obj = editPane = createEditPane((Buffer)obj,					BufferSet.Scope.global);			}				updateGutterBorders();				return (Component)obj;		}	
/**		 * Reloads various settings from the properties.		 */		private void propertiesChanged()		{			setJMenuBar(GUIUtilities.loadMenuBar("view.mbar"));				loadToolBars();				showFullPath = jEdit.getBooleanProperty("view.showFullPath");			updateTitle();				status.propertiesChanged();				removeToolBar(status);			getContentPane().remove(status);				boolean showStatus = plainView ? jEdit.getBooleanProperty("view.status.plainview.visible") :					    jEdit.getBooleanProperty("view.status.visible");			if (jEdit.getBooleanProperty("view.toolbar.alternateLayout"))			{				getContentPane().add(BorderLayout.NORTH,topToolBars);				getContentPane().add(BorderLayout.SOUTH,bottomToolBars);				if (showStatus)					addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);			}			else			{				mainPanel.add(topToolBars, BorderLayout.NORTH);				mainPanel.add(bottomToolBars, BorderLayout.SOUTH);				if (showStatus)					getContentPane().add(BorderLayout.SOUTH,status);			}			updateBufferSwitcherStates();				getRootPane().revalidate();				if (splitPane != null)				GUIUtilities.initContinuousLayout(splitPane);			//SwingUtilities.updateComponentTreeUI(getRootPane());				if (fullScreenMode)				updateFullScreenProps();		}	
/**		 * Enables or Disables the "Focus Buffer Switcher" menu item in the View menu		 * depending on the visible state of the buffer switcher.  The menu item		 * is intended to have the same effect as clicking on the buffer switcher		 * combo box, and it doesn't make sense to have this action available if		 * the buffer switcher isn't visible.		 * Also shows or hides the Buffer Switcher itself, since this can be invoked after		 * the toggle buffer switcher action.		 */		public void updateBufferSwitcherStates()		{			boolean show = jEdit.getBooleanProperty("view.showBufferSwitcher");			JMenuBar menubar = getJMenuBar();			if (menubar == null)			{				return;			}			String viewmenu_label = jEdit.getProperty("view.label");			viewmenu_label = viewmenu_label.replace("$", "");			String sbs_label = jEdit.getProperty("focus-buffer-switcher.label");			sbs_label = sbs_label.replace("$", "");			JMenu viewmenu = null;			for (int i = 0; i < menubar.getMenuCount(); i++)			{				JMenu menu = menubar.getMenu(i);				if (menu.getText().equals(viewmenu_label))				{					viewmenu = menu;					break;				}			}			if (viewmenu != null)			{				for (int i = 0; i < viewmenu.getMenuComponentCount(); i++)				{					Component item = viewmenu.getMenuComponent(i);					if (item instanceof JMenuItem && ((JMenuItem)item).getText().equals(sbs_label))					{						((JMenuItem)item).setEnabled(show);						// viewmenu.invalidate();					}				}			}			// Toggle the visibility of the BufferSwitcher itself			for (View v: jEdit.getViews())				for (EditPane ep: v.getEditPanes())					ep.loadBufferSwitcher();		}	
private void loadToolBars()		{			if(jEdit.getBooleanProperty("view.showToolbar") && !plainView)			{				if(toolBar != null)					toolBarManager.removeToolBar(toolBar);					toolBar = GUIUtilities.loadToolBar("view.toolbar");					addToolBar(TOP_GROUP, SYSTEM_BAR_LAYER, toolBar);			}			else if(toolBar != null)			{				removeToolBar(toolBar);				toolBar = null;			}				if(searchBar != null)			{				searchBar.propertiesChanged();				removeToolBar(searchBar);			}				if(jEdit.getBooleanProperty("view.showSearchbar") && !plainView)			{				if(searchBar == null)					searchBar = new SearchBar(this,false);				addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,searchBar);			}		}	
private EditPane createEditPane(Buffer buffer)		{			return createEditPane(buffer, BufferSet.Scope.fromString(				jEdit.getProperty("editpane.bufferset.default")));		}	
private EditPane createEditPane(Buffer buffer, BufferSet.Scope scope)		{			EditPane editPane = new EditPane(this,buffer, scope);			JEditTextArea textArea = editPane.getTextArea();			textArea.addFocusListener(new FocusHandler());			textArea.addCaretListener(new CaretHandler());			textArea.addScrollListener(new ScrollHandler());			EditBus.send(new EditPaneUpdate(editPane,EditPaneUpdate.CREATED));			return editPane;		}	
private void setEditPane(EditPane editPane)		{			this.editPane = editPane;			status.updateCaretStatus();			status.updateBufferStatus();			status.updateMiscStatus();				// repaint the gutter so that the border color			// reflects the focus state			updateGutterBorders();				EditBus.send(new ViewUpdate(this,ViewUpdate.EDIT_PANE_CHANGED));		}	
private void handleBufferUpdate(BufferUpdate msg)		{			Buffer buffer = msg.getBuffer();			if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED				|| msg.getWhat() == BufferUpdate.LOADED)			{				EditPane[] editPanes = getEditPanes();				for(int i = 0; i < editPanes.length; i++)				{					if(editPanes[i].getBuffer() == buffer)					{						updateTitle();						break;					}				}			}		}	
private void handleEditPaneUpdate(EditPaneUpdate msg)		{			EditPane editPane = msg.getEditPane();			if(editPane.getView() == this				&& msg.getWhat() == EditPaneUpdate.BUFFER_CHANGED				&& editPane.getBuffer().isLoaded())			{				closeDuplicateBuffers(msg);				status.updateCaretStatus();				status.updateBufferStatus();				status.updateMiscStatus();			}		}	
private void closeDuplicateBuffers(EditPaneUpdate epu)		{			if (!jEdit.getBooleanProperty("buffersets.exclusive"))				return;			EditPane ep = epu.getEditPane();			/* Only one view needs to handle this message, since			   we iterate through all the other views */			if (ep.getView() != this) return;			Buffer b = ep.getBuffer();			for (View v: jEdit.getViews())			{				for (EditPane epc : v.getEditPanes())				{					// if it's my editpane, skip it.					if (epc == ep) continue;					// If it's view scope, it has to be of a different view					if ((epc.getBufferSetScope() == BufferSet.Scope.view)						&&  (v == this)) continue;					// If it's global, forget it.					if (epc.getBufferSet() == jEdit.getGlobalBufferSet()) continue;					// Is it in the bufferset?					if (epc.getBufferSet().indexOf(b) < 0) continue;					// found it open in a disjoint bufferset !					jEdit.getBufferSetManager().removeBuffer(epc, b);				}			}		}	
/**		 * Updates the borders of all gutters in this view to reflect the		 * currently focused text area.		 * @since jEdit 2.6final		 */		private void updateGutterBorders()		{			EditPane[] editPanes = getEditPanes();			for(int i = 0; i < editPanes.length; i++)				editPanes[i].getTextArea().getGutter().updateBorder();		}	
private Set<Buffer> getOpenBuffers()		{			Set<Buffer> openBuffers = new HashSet<Buffer>();			for (EditPane editPane: getEditPanes())			{				openBuffers.addAll(Arrays.asList(					editPane.getBufferSet().getAllBuffers()));			}			return openBuffers;		}	
/**		 * Merge a EditPane's BufferSet into another one.		 * This is used on unsplitting panes not to close buffers.		 */		static private void mergeBufferSets(EditPane target, EditPane source)		{			BufferSet sourceBufferSet = source.getBufferSet();			BufferSet targetBufferSet = target.getBufferSet();			if (sourceBufferSet != targetBufferSet)			{				jEdit.getBufferSetManager().mergeBufferSet(					targetBufferSet, sourceBufferSet);			}		}	
public void caretUpdate(CaretEvent evt)			{				if(evt.getSource() == getTextArea())					status.updateCaretStatus();			}	
@Override			public void focusGained(FocusEvent evt)			{				// walk up hierarchy, looking for an EditPane				Component comp = (Component)evt.getSource();				while(!(comp instanceof EditPane))				{					if(comp == null)						return;						comp = comp.getParent();				}					if(comp != editPane)					setEditPane((EditPane)comp);				else					updateGutterBorders();			}	
public void scrolledVertically(TextArea textArea)			{				if(getTextArea() == textArea)					status.updateCaretStatus();			}	
public void scrolledHorizontally(TextArea textArea) {}	
@Override			public void windowActivated(WindowEvent evt)			{				boolean editPaneChanged =					jEdit.getActiveViewInternal() != View.this;				jEdit.setActiveView(View.this);					// People have reported hangs with JDK 1.4; might be				// caused by modal dialogs being displayed from				// windowActivated()				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						int check = jEdit.getIntegerProperty("checkFileStatus");						if(check == GeneralOptionPane.checkFileStatus_focus ||						   check == GeneralOptionPane.checkFileStatus_all)							jEdit.checkBufferStatus(View.this,false);						else if(check == GeneralOptionPane.checkFileStatus_focusBuffer)							jEdit.checkBufferStatus(View.this,true);					}				});					if (editPaneChanged)				{					EditBus.send(new ViewUpdate(View.this,ViewUpdate						.ACTIVATED));				}			}	
@Override			public void windowClosing(WindowEvent evt)			{				jEdit.closeView(View.this);			}	
public ViewConfig()			{			}	
public ViewConfig(boolean plainView)			{				this.plainView = plainView;				String prefix = plainView ? "plain-view" : "view";				x = jEdit.getIntegerProperty(prefix + ".x",0);				y = jEdit.getIntegerProperty(prefix + ".y",0);				width = jEdit.getIntegerProperty(prefix + ".width",0);				height = jEdit.getIntegerProperty(prefix + ".height",0);				extState = jEdit.getIntegerProperty(prefix + ".extendedState", Frame.NORMAL);			}	
public ViewConfig(boolean plainView, String splitConfig,				int x, int y, int width, int height, int extState)			{				this.plainView = plainView;				this.splitConfig = splitConfig;				this.x = x;				this.y = y;				this.width = width;				this.height = height;				this.extState = extState;			}	
private boolean isInsideScreen(View parent, Rectangle r)		{			Rectangle bounds;			if (parent == null)				bounds = GUIUtilities.getScreenBounds();			else				bounds = parent.getGraphicsConfiguration().getBounds();			int minWidth = jEdit.getIntegerProperty("view.minStartupWidth");			int minHeight = jEdit.getIntegerProperty("view.minStartupHeight");			return (r.x < bounds.width - minWidth &&					r.x + r.width > minWidth &&					r.y < bounds.height - minHeight &&					r.y + r.height > minHeight);		}	
public void adjust(View parent, ViewConfig config)		{			if(config.width != 0 && config.height != 0)			{				Rectangle desired = new Rectangle(						config.x, config.y, config.width, config.height);				if (! isInsideScreen(parent, desired))					setLocationRelativeTo(parent);				else				{					if(OperatingSystem.isX11() && Debug.GEOMETRY_WORKAROUND)						new GUIUtilities.UnixWorkaround(this,"view",desired,config.extState);					else					{						setBounds(desired);						setExtendedState(config.extState);					}				}			}			else				setLocationRelativeTo(parent);		}	
@Override			public Component getDefaultComponent(Container focusCycleRoot)			{				return GUIUtilities.getView(focusCycleRoot).getTextArea();			}	
SetCursorVisitor(Cursor cursor)			{				this.cursor = cursor;			}	
@Override			public void visit(EditPane editPane)			{				editPane.setCursor(cursor);			}	
public ViewOptionPane()		{			super("view");		}	
@Override		protected void _init()		{			/* View dock layout */			layoutIcon1 = GUIUtilities.loadIcon("dock_layout1.png");			layoutIcon2 = GUIUtilities.loadIcon("dock_layout2.png");			layoutIcon3 = GUIUtilities.loadIcon("dock_layout3.png");			layoutIcon4 = GUIUtilities.loadIcon("dock_layout4.png");				JPanel layoutPanel = new JPanel(new BorderLayout(12,12));				if(jEdit.getBooleanProperty("view.docking.alternateLayout"))			{				layout = new JLabel(jEdit.getBooleanProperty(					"view.toolbar.alternateLayout")					? layoutIcon4 : layoutIcon2);			}			else			{				layout = new JLabel(jEdit.getBooleanProperty(					"view.toolbar.alternateLayout")					? layoutIcon3 : layoutIcon1);			}				layout.setBorder(new EmptyBorder(12,12,12,12));			layoutPanel.add(BorderLayout.CENTER,layout);				JPanel buttons = new JPanel(new GridLayout(2,1,12,12));			buttons.setBorder(new EmptyBorder(0,12,12,12));			buttons.add(alternateDockingLayout = new JButton(jEdit.getProperty(				"options.view.alternateDockingLayout")));			ActionHandler actionHandler = new ActionHandler();			alternateDockingLayout.addActionListener(actionHandler);			buttons.add(alternateToolBarLayout = new JButton(jEdit.getProperty(				"options.view.alternateToolBarLayout")));			alternateToolBarLayout.addActionListener(actionHandler);			layoutPanel.add(BorderLayout.SOUTH,buttons);				TitledBorder border = new TitledBorder(jEdit.getProperty(				"options.view.viewLayout"));			border.setTitleJustification(TitledBorder.CENTER);			layoutPanel.setBorder(border);				addComponent(layoutPanel);				/* Show full path */			showFullPath = new JCheckBox(jEdit.getProperty(				"options.view.showFullPath"));			showFullPath.setSelected(jEdit.getBooleanProperty(				"view.showFullPath"));			addComponent(showFullPath);				/* Show search bar */			showSearchbar = new JCheckBox(jEdit.getProperty(				"options.view.showSearchbar"));			showSearchbar.setSelected(jEdit.getBooleanProperty(				"view.showSearchbar"));			addComponent(showSearchbar);				/* Beep on search auto wrap */			beepOnSearchAutoWrap = new JCheckBox(jEdit.getProperty(				"options.view.beepOnSearchAutoWrap"));			beepOnSearchAutoWrap.setSelected(jEdit.getBooleanProperty(				"search.beepOnSearchAutoWrap"));			addComponent(beepOnSearchAutoWrap);				/* Show buffer switcher */			showBufferSwitcher = new JCheckBox(jEdit.getProperty(				"options.view.showBufferSwitcher"));				showBufferSwitcher.setSelected(jEdit.getBooleanProperty(				"view.showBufferSwitcher"));			addComponent(showBufferSwitcher);			showBufferSwitcher.addActionListener(actionHandler);					/* Buffer switcher max row count */			bufferSwitcherMaxRowCount = new JTextField(jEdit.getProperty("bufferSwitcher.maxRowCount"));			addComponent(jEdit.getProperty("options.view.bufferSwitcherMaxRowsCount"),				bufferSwitcherMaxRowCount);			bufferSwitcherMaxRowCount.setEditable(showBufferSwitcher.isSelected());				defaultBufferSet = new JComboBox();			defaultBufferSet.addItem(BufferSet.Scope.global);			defaultBufferSet.addItem(BufferSet.Scope.view);			defaultBufferSet.addItem(BufferSet.Scope.editpane);			defaultBufferSet.setSelectedItem(BufferSet.Scope.fromString(jEdit.getProperty("editpane.bufferset.default")));			addComponent(jEdit.getProperty("options.editpane.bufferset.default"), defaultBufferSet);				newBufferSetBehavior = new JComboBox();			newBufferSetBehavior.addItem(BufferSetManager.NewBufferSetAction.copy);			newBufferSetBehavior.addItem(BufferSetManager.NewBufferSetAction.empty);			newBufferSetBehavior.addItem(BufferSetManager.NewBufferSetAction.currentbuffer);			newBufferSetBehavior.setSelectedItem(BufferSetManager.NewBufferSetAction.fromString(jEdit.getProperty("editpane.bufferset.new")));			addComponent(new JLabel(jEdit.getProperty("options.editpane.bufferset.contain")),						newBufferSetBehavior);					/* Sort buffers */			sortBuffers = new JCheckBox(jEdit.getProperty(				"options.view.sortBuffers"));			sortBuffers.setSelected(jEdit.getBooleanProperty("sortBuffers"));			sortBuffers.addActionListener(new ActionListener()			{				public void actionPerformed(ActionEvent evt)				{					sortByName.setEnabled(sortBuffers.isSelected());				}			});				addComponent(sortBuffers);				/* Sort buffers by names */			sortByName = new JCheckBox(jEdit.getProperty(				"options.view.sortByName"));			sortByName.setSelected(jEdit.getBooleanProperty("sortByName"));			sortByName.setEnabled(sortBuffers.isSelected());			addComponent(sortByName);				fullScreenIncludesMenu = new JCheckBox(jEdit.getProperty(				"options.view.fullScreenIncludesMenu"));			fullScreenIncludesMenu.setSelected(				jEdit.getBooleanProperty("fullScreenIncludesMenu"));			addComponent(fullScreenIncludesMenu);				fullScreenIncludesToolbar = new JCheckBox(jEdit.getProperty(				"options.view.fullScreenIncludesToolbar"));			fullScreenIncludesToolbar.setSelected(				jEdit.getBooleanProperty("fullScreenIncludesToolbar"));			addComponent(fullScreenIncludesToolbar);				fullScreenIncludesStatus = new JCheckBox(jEdit.getProperty(					"options.view.fullScreenIncludesStatus"));			fullScreenIncludesStatus.setSelected(					jEdit.getBooleanProperty("fullScreenIncludesStatus"));			addComponent(fullScreenIncludesStatus);			}	
@Override		protected void _save()		{			jEdit.setBooleanProperty("view.docking.alternateLayout",				layout.getIcon() == layoutIcon2				|| layout.getIcon() == layoutIcon4);			jEdit.setBooleanProperty("view.toolbar.alternateLayout",				layout.getIcon() == layoutIcon3				|| layout.getIcon() == layoutIcon4);			jEdit.setBooleanProperty("view.showFullPath",showFullPath				.isSelected());			jEdit.setBooleanProperty("view.showSearchbar",showSearchbar				.isSelected());			jEdit.setBooleanProperty("search.beepOnSearchAutoWrap",beepOnSearchAutoWrap				.isSelected());			jEdit.setBooleanProperty("view.showBufferSwitcher",				showBufferSwitcher.isSelected());			jEdit.setProperty("bufferSwitcher.maxRowCount",				bufferSwitcherMaxRowCount.getText());			jEdit.setProperty("editpane.bufferset.default", defaultBufferSet.getSelectedItem().toString());			jEdit.setProperty("editpane.bufferset.new",							  ((BufferSetManager.NewBufferSetAction)newBufferSetBehavior.getSelectedItem()).getName());			jEdit.setBooleanProperty("sortBuffers",sortBuffers.isSelected());			jEdit.setBooleanProperty("sortByName",sortByName.isSelected());			jEdit.setBooleanProperty("fullScreenIncludesMenu",fullScreenIncludesMenu.isSelected());			jEdit.setBooleanProperty("fullScreenIncludesToolbar",fullScreenIncludesToolbar.isSelected());			jEdit.setBooleanProperty("fullScreenIncludesStatus",fullScreenIncludesStatus.isSelected());			}	
public void actionPerformed(ActionEvent evt)			{				if(evt.getSource() == alternateDockingLayout)				{					if(layout.getIcon() == layoutIcon1)						layout.setIcon(layoutIcon2);					else if(layout.getIcon() == layoutIcon2)						layout.setIcon(layoutIcon1);					else if(layout.getIcon() == layoutIcon3)						layout.setIcon(layoutIcon4);					else if(layout.getIcon() == layoutIcon4)						layout.setIcon(layoutIcon3);				}				else if(evt.getSource() == alternateToolBarLayout)				{					if(layout.getIcon() == layoutIcon1)						layout.setIcon(layoutIcon3);					else if(layout.getIcon() == layoutIcon3)						layout.setIcon(layoutIcon1);					else if(layout.getIcon() == layoutIcon2)						layout.setIcon(layoutIcon4);					else if(layout.getIcon() == layoutIcon4)						layout.setIcon(layoutIcon2);				}				else if (evt.getSource() == showBufferSwitcher)				{					bufferSwitcherMaxRowCount.setEditable(showBufferSwitcher.isSelected());				}			}	
/**		 * Creates a new view update message.		 * @param view The view		 * @param what What happened		 */		public ViewUpdate(View view, Object what)		{			super(view);				if(what == null)				throw new NullPointerException("What must be non-null");				this.what = what;		}	
/**		 * Returns what caused this view update.		 */		public Object getWhat()		{			return what;		}	
/**		 * Returns the view involved.		 */		public View getView()		{			return (View)getSource();		}	
public String paramString()		{			return "what=" + what + "," + super.paramString();		}	
public void apply(JEditBuffer buffer, int thisLineIndex,				  int prevLineIndex, int prevPrevLineIndex,				  List<IndentAction> indentActions)		{			/* Don't apply this rule if the current line is empty. */			CharSequence current = buffer.getLineSegment(thisLineIndex);			boolean found = false;			for (int i = 0; i < current.length(); i++)			{				if (!Character.isWhitespace(current.charAt(i)))				{					found = true;					break;				}			}			if (!found)				return;				/* Check if the previous line is empty. */			if (prevLineIndex >= 0) {				CharSequence previous = buffer.getLineSegment(prevLineIndex);				for (int i = 0; i < previous.length(); i++)				{					if (!Character.isWhitespace(previous.charAt(i)))						return;				}			}			indentActions.add(new IndentAction.NoIncrease());		}	
/**		 * Sets if the request can be aborted.		 */		public void setAbortable(boolean abortable)		{			Thread thread = Thread.currentThread();			if(thread instanceof WorkThread)				((WorkThread)thread).setAbortable(abortable);		}	
/**		 * Sets the status text.		 * @param status The status text		 */		public void setStatus(String status)		{			Thread thread = Thread.currentThread();			if(thread instanceof WorkThread)				((WorkThread)thread).setStatus(status);		}	
/**		 * Sets the progress value.		 * @param value The progress value.		 * @deprecated use {@link #setValue(long)}		 */		public void setProgressValue(int value)		{			Thread thread = Thread.currentThread();			if(thread instanceof WorkThread)				((WorkThread)thread).setProgressValue(value);		}	
/**		 * Sets the maximum progress value.		 * @param value The progress value.		 * @deprecated use {@link #setMaximum(long)}		 */		public void setProgressMaximum(int value)		{			Thread thread = Thread.currentThread();			if(thread instanceof WorkThread)				((WorkThread)thread).setProgressMaximum(value);		}	
/**		 * Update the progress value.		 *		 * @param value the new value		 * @since jEdit 4.3pre3		 */		public void setValue(long value)		{			Thread thread = Thread.currentThread();			if(thread instanceof WorkThread)			{				if (largeValues)				{					((WorkThread)thread).setProgressValue((int) (value >> 10));				}				else				{					((WorkThread)thread).setProgressValue((int) value);				}			}		}	
/**		 * Update the maximum value.		 *		 * @param value the new maximum value		 * @since jEdit 4.3pre3		 */		public void setMaximum(long value)		{			Thread thread = Thread.currentThread();			if(thread instanceof WorkThread)			{				if (value > Integer.MAX_VALUE)				{					largeValues = true;					((WorkThread)thread).setProgressMaximum((int) (value >> 10));				}				else				{					largeValues = false;					((WorkThread)thread).setProgressMaximum((int) value);				}			}		}	
public WorkThread(WorkThreadPool pool, ThreadGroup group, String name)		{			super(group, name);			// so that jEdit doesn't exit with no views open automatically			//setDaemon(true);			setPriority(Thread.MIN_PRIORITY);				this.pool = pool;		}	
/**		 * Sets if the current request can be aborted.		 * If set to true and already aborted, the thread will be stopped		 *		 * @param abortable true if the WorkThread is abortable		 * @since jEdit 2.6pre1		 */		public void setAbortable(boolean abortable)		{			synchronized(abortLock)			{				this.abortable = abortable;				if(aborted)					stop(new Abort());			}		}	
/**		 * Returns if the work thread is currently running a request.		 * @return true if a request is currently running		 */		public boolean isRequestRunning()		{			return requestRunning;		}	
public boolean isAborted()		{			synchronized (abortLock)			{				return aborted;			}		}	
/**		 * Returns the status text.		 * @return the status label		 */		public String getStatus()		{			return status;		}	
/**		 * Sets the status text.		 * @param status the new status of the thread		 * @since jEdit 2.6pre1		 */		public void setStatus(String status)		{			this.status = status;			pool.fireProgressChanged(this);		}	
/**		 * Returns the progress value.		 * @return the progress value		 */		public int getProgressValue()		{			return progressValue;		}	
/**		 * Sets the progress value.		 * @param progressValue the new progress value		 * @since jEdit 2.6pre1		 */		public void setProgressValue(int progressValue)		{			this.progressValue = progressValue;			pool.fireProgressChanged(this);		}	
/**		 * Returns the progress maximum.		 * @return the maximum value of the progression		 */		public int getProgressMaximum()		{			return progressMaximum;		}	
/**		 * Sets the maximum progress value.		 * @param progressMaximum the maximum value of the progression		 * @since jEdit 2.6pre1		 */		public void setProgressMaximum(int progressMaximum)		{			this.progressMaximum = progressMaximum;			pool.fireProgressChanged(this);		}	
/**		 * Aborts the currently running request, if allowed.		 * @since jEdit 2.6pre1		 */		public void abortCurrentRequest()		{			synchronized(abortLock)			{				if(abortable && !aborted)					stop(new Abort());				aborted = true;			}		}	
public void run()		{			Log.log(Log.DEBUG,this,"Work request thread starting [" + getName() + "]");				for(;;)			{				doRequests();			}		}	
private void doRequests()		{			WorkThreadPool.Request request;			for(;;)			{				request = pool.getNextRequest();				if(request == null)					break;				else				{					requestRunning = true;					pool.fireStatusChanged(this);					doRequest(request);					requestRunning = false;				}			}				pool.fireStatusChanged(this);				synchronized(pool.waitForAllLock)			{				// notify a running waitForRequests() method				pool.waitForAllLock.notifyAll();			}				synchronized(pool.lock)			{				// wait for more requests				try				{					pool.lock.wait();				}				catch(InterruptedException ie)				{					Log.log(Log.ERROR,this,ie);				}			}		}	
private void doRequest(WorkThreadPool.Request request)		{			Log.log(Log.DEBUG,WorkThread.class,"Running in work thread: " + request);				try			{				request.run.run();			}			catch(Abort a)			{				Log.log(Log.ERROR,WorkThread.class,"Unhandled abort", a);			}			catch(Throwable t)			{				Log.log(Log.ERROR,WorkThread.class,"Exception in work thread: ", t);			}			finally			{				synchronized(abortLock)				{					aborted = abortable = false;				}				status = null;				progressValue = progressMaximum = 0;				pool.requestDone();				pool.fireStatusChanged(this);			}		}	
public Abort()			{				super("Work request aborted");			}	
/**		 * Creates a new work thread pool with the specified number of		 * work threads.		 * @param name The thread name prefix		 * @param count The number of work threads		 */		public WorkThreadPool(String name, int count)		{			listenerList = new EventListenerList();				if(count != 0)			{				threadGroup = new ThreadGroup(name);				threads = new WorkThread[count];				for(int i = 0; i < threads.length; i++)				{					threads[i] = new WorkThread(this,threadGroup,name + " #" + (i+1));				}			}			else				Log.log(Log.WARNING,this,"Async I/O disabled");		}	
/**		 * Starts all the threads in this thread pool.		 */		public void start()		{			/* not really needed since threads don't start until after */			synchronized(lock)			{				started = true;					if(awtRequestCount != 0 && requestCount == 0)					queueAWTRunner();			}				if(threads != null)			{				for(int i = 0; i < threads.length; i++)				{					threads[i].start();				}			}		}	
/**		 * Adds a work request to the queue.		 * @param run The runnable		 * @param inAWT If true, will be executed in AWT thread. Otherwise,		 * will be executed in work thread		 */		public void addWorkRequest(Runnable run, boolean inAWT)		{			if(threads == null)			{				run.run();				return;			}				synchronized(lock)			{				//{{{ if there are no requests, execute AWT requests immediately				if(started && inAWT && requestCount == 0 && awtRequestCount == 0)				{	//				Log.log(Log.DEBUG,this,"AWT immediate: " + run);						if(SwingUtilities.isEventDispatchThread())						run.run();					else						SwingUtilities.invokeLater(run);						return;				} //}}}					Request request = new Request(run);					//{{{ Add to AWT queue...				if(inAWT)				{					if(firstAWTRequest == null && lastAWTRequest == null)						firstAWTRequest = lastAWTRequest = request;					else					{						lastAWTRequest.next = request;						lastAWTRequest = request;					}						awtRequestCount++;						// if no requests are running, requestDone()					// will not be called, so we must queue the					// AWT runner ourselves.					if(started && requestCount == 0)						queueAWTRunner();				} //}}}				//{{{ Add to work thread queue...				else				{					if(firstRequest == null && lastRequest == null)						firstRequest = lastRequest = request;					else					{						lastRequest.next = request;						lastRequest = request;					}						requestCount++;				} //}}}					lock.notifyAll();			}		}	
/**		 * Waits until all requests are complete.		 */		public void waitForRequests()		{			if(threads == null)				return;				synchronized(waitForAllLock)			{				while(requestCount != 0)				{					try					{						waitForAllLock.wait();					}					catch(InterruptedException ie)					{						Log.log(Log.ERROR,this,ie);					}				}			}				if(SwingUtilities.isEventDispatchThread())			{				// do any queued AWT runnables				doAWTRequests();			}			else			{				try				{					SwingUtilities.invokeAndWait(new RunRequestsInAWTThread());				}				catch(Exception e)				{					Log.log(Log.ERROR,this,e);				}			}		}	
/**		 * Returns the number of pending requests.		 * @return the pending request count		 */		public int getRequestCount()		{			return requestCount;		}	
/**		 * Returns the number of threads in this pool.		 * @return the thread count		 */		public int getThreadCount()		{			if(threads == null)				return 0;			else				return threads.length;		}	
/**		 * Returns the specified thread.		 * @param index The index of the thread		 * @return a WorkThread		 */		public WorkThread getThread(int index)		{			return threads[index];		}	
/**		 * Adds a progress listener to this thread pool.		 * @param listener The listener		 */		public void addProgressListener(WorkThreadProgressListener listener)		{			listenerList.add(WorkThreadProgressListener.class,listener);		}	
/**		 * Removes a progress listener from this thread pool.		 * @param listener The listener		 */		public void removeProgressListener(WorkThreadProgressListener listener)		{			listenerList.remove(WorkThreadProgressListener.class,listener);		}	
void fireStatusChanged(WorkThread thread)		{			final Object[] listeners = listenerList.getListenerList();			if(listeners.length != 0)			{				int index = 0;				for(int i = 0; i < threads.length; i++)				{					if(threads[i] == thread)					{						index = i;						break;					}				}					for(int i = listeners.length - 2; i >= 0; i--)				{					if(listeners[i] == WorkThreadProgressListener.class)					{						((WorkThreadProgressListener)listeners[i+1])							.statusUpdate(WorkThreadPool.this,index);					}				}			}		}	
void fireProgressChanged(WorkThread thread)		{			final Object[] listeners = listenerList.getListenerList();			if(listeners.length != 0)			{				int index = 0;				for(int i = 0; i < threads.length; i++)				{					if(threads[i] == thread)					{						index = i;						break;					}				}					for(int i = listeners.length - 2; i >= 0; i--)				{					if(listeners[i] == WorkThreadProgressListener.class)					{						((WorkThreadProgressListener)listeners[i+1])							.progressUpdate(WorkThreadPool.this,index);					}				}			}		}	
void requestDone()		{			synchronized(lock)			{				requestCount--;					if(requestCount == 0 && firstAWTRequest != null)					queueAWTRunner();			}		}	
Request getNextRequest()		{			synchronized(lock)			{				Request request = firstRequest;				if(request == null)					return null;					firstRequest = firstRequest.next;				if(firstRequest == null)					lastRequest = null;					if(request.alreadyRun)					throw new InternalError("AIEE!!! Request run twice!!! " + request.run);				request.alreadyRun = true;					/* StringBuffer buf = new StringBuffer("request queue is now: ");				Request _request = request.next;				while(_request != null)				{					buf.append(_request.id);					if(_request.next != null)						buf.append(",");					_request = _request.next;				}				Log.log(Log.DEBUG,this,buf.toString()); */					return request;			}		}	
/** Must always be called with the lock held. */		private void doAWTRequests()		{			while(requestCount == 0 && firstAWTRequest != null)			{				doAWTRequest(getNextAWTRequest());			}		}	
/**		 * Must always be called with the lock held.		 * @param request the request to run		 */		private void doAWTRequest(Request request)		{	//		Log.log(Log.DEBUG,this,"Running in AWT thread: " + request);				try			{				request.run.run();			}			catch(Throwable t)			{				Log.log(Log.ERROR,WorkThread.class,"Exception "					+ "in AWT thread:");				Log.log(Log.ERROR,WorkThread.class,t);			}				awtRequestCount--;		}	
/** Must always be called with the lock held. */		private void queueAWTRunner()		{			if(!awtRunnerQueued)			{				awtRunnerQueued = true;				SwingUtilities.invokeLater(new RunRequestsInAWTThread());	//			Log.log(Log.DEBUG,this,"AWT runner queued");			}		}	
private Request getNextAWTRequest()		{			Request request = firstAWTRequest;			firstAWTRequest = firstAWTRequest.next;			if(firstAWTRequest == null)				lastAWTRequest = null;				if(request.alreadyRun)				throw new InternalError("AIEE!!! Request run twice!!! " + request.run);			request.alreadyRun = true;				/* StringBuffer buf = new StringBuffer("AWT request queue is now: ");			Request _request = request.next;			while(_request != null)			{				buf.append(_request.id);				if(_request.next != null)					buf.append(",");				_request = _request.next;			}			Log.log(Log.DEBUG,this,buf.toString()); */				return request;		}	
Request(Runnable run)			{				this.run = run;			}	
public String toString()			{				return "[id=" + id + ",run=" + run + "]";			}	
public void run()			{				synchronized(lock)				{					awtRunnerQueued = false;					if(requestCount == 0)						doAWTRequests();				}			}	
public Widget getWidget(View view) 		{			Widget wrap = new WrapWidget(view);			return wrap;		}	
public WrapWidget(final View view) 			{				wrap = new ToolTipLabel();				wrap.setHorizontalAlignment(SwingConstants.CENTER);				wrap.setToolTipText(jEdit.getProperty("view.status.wrap-tooltip"));				this.view = view;				wrap.addMouseListener(new MouseAdapter() 						      {							      @Override							      public void mouseClicked(MouseEvent evt)							      {								      view.getBuffer().toggleWordWrap(view);							      }						      });			}	
public JComponent getComponent() 			{				return wrap;			}	
public void update() 			{				Buffer buffer = view.getBuffer();				String wrap = buffer.getStringProperty("wrap");				if(wrap.equals("none"))					this.wrap.setText("-");				else if(wrap.equals("hard"))					this.wrap.setText("H");				else if(wrap.equals("soft"))					this.wrap.setText("S");			}	
public void propertiesChanged()			{				// retarded GTK look and feel!				Font font = new JLabel().getFont();				//UIManager.getFont("Label.font");				FontMetrics fm = wrap.getFontMetrics(font);				Dimension dim = new Dimension(Math.max(Math.max(fm.charWidth('-'),										fm.charWidth('H')),						fm.charWidth('S')) + 1,					fm.getHeight());				wrap.setPreferredSize(dim);				wrap.setMaximumSize(dim);			}	
public String detectEncoding(InputStream sample) throws IOException		{			// Length of longest XML PI used for encoding detection.			// <?xml version="1.0" encoding="................"?>			final int XML_PI_LENGTH = 50;						byte[] _xmlPI = new byte[XML_PI_LENGTH];			int offset = 0;			int count;			while((count = sample.read(_xmlPI,offset,				XML_PI_LENGTH - offset)) != -1)			{				offset += count;				if(offset == XML_PI_LENGTH)					break;			}			return getXMLEncoding(new String(_xmlPI,0,offset,"ASCII"));		}	
/**		 * Extract XML encoding name from PI.		 */		private static String getXMLEncoding(String xmlPI)		{			if(!xmlPI.startsWith("<?xml"))				return null;				int index = xmlPI.indexOf("encoding=");			if(index == -1 || index + 9 == xmlPI.length())				return null;				char ch = xmlPI.charAt(index + 9);			int endIndex = xmlPI.indexOf(ch,index + 10);			if(endIndex == -1)				return null;				String encoding = xmlPI.substring(index + 10,endIndex);				try			{				if(Charset.isSupported(encoding))				{					return encoding;				}				else				{					Log.log(Log.WARNING, XMLEncodingDetector.class,						"XML PI specifies unsupported encoding: " + encoding);				}			}			catch(IllegalCharsetNameException e)			{				Log.log(Log.WARNING, XMLEncodingDetector.class,					"XML PI specifies illegal encoding: " + encoding,					e);			}			return null;		}	
/**		 * Converts &lt;, &gt;, &amp; in the string to their HTML entity		 * equivalents.		 *		 * <p>If <code>xml11</code> is true, then character entities		 * are used to convert illegal XML characters (mainly ASCII		 * control characters).</p>		 *		 * @param str The string		 * @param xml11 Whether to allow XML 1.1 constructs.		 */		public static String charsToEntities(String str, boolean xml11)		{			StringBuilder buf = new StringBuilder(str.length());			for(int i = 0; i < str.length(); i++)			{				char ch = str.charAt(i);					// control characters, excluding \t, \r and \n				// See: http://www.w3.org/International/questions/qa-controls				if (((0x00 <= ch && ch <= 0x1F) || (0x7F <= ch && ch <= 0x9F))					&& ch != '\r' && ch != '\n' && ch != '\t')				{					if (xml11 && ch != 0x00)					{						buf.append("&#").append((int)ch).append(';');					}					else					{						// The character is illegal.						// But put a PI instead, to make it						// recoverable in certain apps.						buf.append("<?illegal-xml-character ")							.append((int)ch)							.append("?>");					}					continue;				}					switch(ch)				{				case '<':					buf.append("&lt;");					break;				case '>':					buf.append("&gt;");					break;				case '&':					buf.append("&amp;");					break;				default:					buf.append(ch);					break;				}			}			return buf.toString();		}	
/**		 * Convenience method for parsing an XML file. This method will		 * wrap the resource in an InputSource and set the source's		 * systemId to "jedit.jar" (so the source should be able to		 * handle any external entities by itself).		 *		 * <p>SAX Errors are caught and are not propagated to the caller;		 * instead, an error message is printed to jEdit's activity		 * log. So, if you need custom error handling, <b>do not use		 * this method</b>.		 *		 * <p>The given stream is closed before the method returns,		 * regardless whether there were errors or not.</p>		 *		 * @return true if any error occured during parsing, false if success.		 */		public static boolean parseXML(InputStream in, DefaultHandler handler)			throws IOException		{			try			{				XMLReader parser = XMLReaderFactory.createXMLReader();				InputSource isrc = new InputSource(					new BufferedInputStream(in));				isrc.setSystemId("jedit.jar");				parser.setContentHandler(handler);				parser.setDTDHandler(handler);				parser.setEntityResolver(handler);				parser.setErrorHandler(handler);				parser.parse(isrc);			}			catch(SAXParseException se)			{				int line = se.getLineNumber();				Log.log(Log.ERROR,XMLUtilities.class,					"while parsing from " + in + ": SAXParseException: line " + line + ": " , se);				return true;			}			catch(SAXException e)			{				Log.log(Log.ERROR,XMLUtilities.class,e);				return true;			}			finally			{				try				{					if(in != null)						in.close();				}				catch(IOException io)				{					Log.log(Log.ERROR,XMLUtilities.class,io);				}			}			return false;		}	
/**		 * Tries to find the given systemId in the context of the given		 * class. If the given systemId ends with the given test string,		 * then try to load a resource using the Class's		 * <code>getResourceAsStream()</code> method using the test string		 * as the resource.		 *		 * <p>This is used a lot internally while parsing XML files used		 * by jEdit, but anyone is free to use the method if it sounds		 * usable.</p>		 */		public static InputSource findEntity(String systemId, String test, Class where)		{			if (systemId != null && systemId.endsWith(test))			{				try				{					return new InputSource(new BufferedInputStream(						where.getResourceAsStream(test)));				}				catch (Exception e)				{					Log.log(Log.ERROR,XMLUtilities.class,						"Error while opening " + test + ':');					Log.log(Log.ERROR,XMLUtilities.class,e);				}			}				return null;		}	
private XMLUtilities() { }	
public XModeHandler (String modeName)		{			this.modeName = modeName;			marker = new TokenMarker();			marker.addRuleSet(new ParserRuleSet(modeName,"MAIN"));			stateStack = new Stack<TagDecl>();		}	
public InputSource resolveEntity(String publicId, String systemId)		{			return XMLUtilities.findEntity(systemId, "xmode.dtd", XModeHandler.class);		}	
public void characters(char[] c, int off, int len)		{			peekElement().setText(c, off, len);		}	
public void startElement(String uri, String localName,					 String qName, Attributes attrs)		{			TagDecl tag = pushElement(qName, attrs);				if (qName.equals("WHITESPACE"))			{				Log.log(Log.WARNING,this,modeName + ": WHITESPACE rule "					+ "no longer needed");			}			else if (qName.equals("KEYWORDS"))			{				keywords = new KeywordMap(rules.getIgnoreCase());			}			else if (qName.equals("RULES"))			{				if(tag.lastSetName == null)					tag.lastSetName = "MAIN";				rules = marker.getRuleSet(tag.lastSetName);				if(rules == null)				{					rules = new ParserRuleSet(modeName,tag.lastSetName);					marker.addRuleSet(rules);				}				rules.setIgnoreCase(tag.lastIgnoreCase);				rules.setHighlightDigits(tag.lastHighlightDigits);				if(tag.lastDigitRE != null)				{					try					{						rules.setDigitRegexp(Pattern.compile(tag.lastDigitRE,							tag.lastIgnoreCase							? Pattern.CASE_INSENSITIVE : 0));					}					catch(PatternSyntaxException e)					{						error("regexp",e);					}				}					if(tag.lastEscape != null)					rules.setEscapeRule(ParserRule.createEscapeRule(tag.lastEscape));				rules.setDefault(tag.lastDefaultID);				rules.setNoWordSep(tag.lastNoWordSep);			}		}	
public void endElement(String uri, String localName, String name)		{			TagDecl tag = popElement();			if (name.equals(tag.tagName))			{				if(tag.lastDelegateSet != null						&& ! tag.tagName.equals("IMPORT")						&& ! tag.lastDelegateSet.getModeName().equals(modeName))				{					Mode mode = ModeProvider.instance.getMode(tag.lastDelegateSet.getModeName());					if( ! reloadModes.contains(mode) )					{						reloadModes.add(mode);					}				}				//{{{ PROPERTY				if (tag.tagName.equals("PROPERTY"))				{					props.put(propName,propValue);				} //}}}				//{{{ PROPS				else if (tag.tagName.equals("PROPS"))				{					if(peekElement().tagName.equals("RULES"))						rules.setProperties(props);					else						modeProps = props;						props = new Hashtable<String, String>();				} //}}}				//{{{ RULES				else if (tag.tagName.equals("RULES"))				{					rules.setKeywords(keywords);					keywords = null;					rules = null;				} //}}}				//{{{ IMPORT				else if (tag.tagName.equals("IMPORT"))				{					// prevent lockups					if (!rules.equals(tag.lastDelegateSet))					{						rules.addRuleSet(tag.lastDelegateSet);					}				} //}}}				//{{{ TERMINATE				else if (tag.tagName.equals("TERMINATE"))				{					rules.setTerminateChar(tag.termChar);				} //}}}				//{{{ SEQ				else if (tag.tagName.equals("SEQ"))				{					if(tag.lastStart == null)					{						error("empty-tag","SEQ");						return;					}						rules.addRule(ParserRule.createSequenceRule(						tag.lastStartPosMatch,tag.lastStart.toString(),						tag.lastDelegateSet,tag.lastTokenID));				} //}}}				//{{{ SEQ_REGEXP				else if (tag.tagName.equals("SEQ_REGEXP"))				{					if(tag.lastStart == null)					{						error("empty-tag","SEQ_REGEXP");						return;					}						try					{						if (null != tag.lastHashChars)						{							rules.addRule(ParserRule.createRegexpSequenceRule(								tag.lastStartPosMatch,tag.lastHashChars.toCharArray(),								tag.lastStart.toString(),tag.lastDelegateSet,								tag.lastTokenID,findParent("RULES").lastIgnoreCase));						}						else						{							rules.addRule(ParserRule.createRegexpSequenceRule(								tag.lastHashChar,tag.lastStartPosMatch,								tag.lastStart.toString(),tag.lastDelegateSet,								tag.lastTokenID,findParent("RULES").lastIgnoreCase));						}					}					catch(PatternSyntaxException re)					{						error("regexp",re);					}				} //}}}				//{{{ SPAN				else if (tag.tagName.equals("SPAN"))				{					if(tag.lastStart == null)					{						error("empty-tag","BEGIN");						return;					}						if(tag.lastEnd == null)					{						error("empty-tag","END");						return;					}						rules.addRule(ParserRule						.createSpanRule(						tag.lastStartPosMatch,tag.lastStart.toString(),						tag.lastEndPosMatch,tag.lastEnd.toString(),						tag.lastDelegateSet,						tag.lastTokenID,tag.lastMatchType,						tag.lastNoLineBreak,						tag.lastNoWordBreak,						tag.lastEscape));				} //}}}				//{{{ SPAN_REGEXP				else if (tag.tagName.equals("SPAN_REGEXP"))				{					if(tag.lastStart == null)					{						error("empty-tag","BEGIN");						return;					}						if(tag.lastEnd == null)					{						error("empty-tag","END");						return;					}						try					{						if (null != tag.lastHashChars)						{							rules.addRule(ParserRule								.createRegexpSpanRule(								tag.lastStartPosMatch,tag.lastHashChars.toCharArray(),								tag.lastStart.toString(),								tag.lastEndPosMatch,tag.lastEnd.toString(),								tag.lastDelegateSet,								tag.lastTokenID,								tag.lastMatchType,								tag.lastNoLineBreak,								tag.lastNoWordBreak,								findParent("RULES").lastIgnoreCase,								tag.lastEscape));						}						else						{							rules.addRule(ParserRule								.createRegexpSpanRule(								tag.lastHashChar,								tag.lastStartPosMatch,tag.lastStart.toString(),								tag.lastEndPosMatch,tag.lastEnd.toString(),								tag.lastDelegateSet,								tag.lastTokenID,								tag.lastMatchType,								tag.lastNoLineBreak,								tag.lastNoWordBreak,								findParent("RULES").lastIgnoreCase,								tag.lastEscape));						}					}					catch(PatternSyntaxException re)					{						error("regexp",re);					}				} //}}}				//{{{ EOL_SPAN				else if (tag.tagName.equals("EOL_SPAN"))				{					if(tag.lastStart == null)					{						error("empty-tag","EOL_SPAN");						return;					}						rules.addRule(ParserRule.createEOLSpanRule(						tag.lastStartPosMatch,tag.lastStart.toString(),						tag.lastDelegateSet,tag.lastTokenID,						tag.lastMatchType));				} //}}}				//{{{ EOL_SPAN_REGEXP				else if (tag.tagName.equals("EOL_SPAN_REGEXP"))				{					if(tag.lastStart == null)					{						error("empty-tag","EOL_SPAN_REGEXP");						return;					}						try					{						if (null != tag.lastHashChars)						{							rules.addRule(ParserRule.createRegexpEOLSpanRule(								tag.lastStartPosMatch,tag.lastHashChars.toCharArray(),								tag.lastStart.toString(),tag.lastDelegateSet,								tag.lastTokenID,tag.lastMatchType,								findParent("RULES").lastIgnoreCase));						}						else						{							rules.addRule(ParserRule.createRegexpEOLSpanRule(								tag.lastHashChar,tag.lastStartPosMatch,								tag.lastStart.toString(),tag.lastDelegateSet,								tag.lastTokenID,tag.lastMatchType,								findParent("RULES").lastIgnoreCase));						}					}					catch(PatternSyntaxException re)					{						error("regexp",re);					}				} //}}}				//{{{ MARK_FOLLOWING				else if (tag.tagName.equals("MARK_FOLLOWING"))				{					if(tag.lastStart == null)					{						error("empty-tag","MARK_FOLLOWING");						return;					}						rules.addRule(ParserRule						.createMarkFollowingRule(						tag.lastStartPosMatch,tag.lastStart.toString(),						tag.lastTokenID,tag.lastMatchType));				} //}}}				//{{{ MARK_PREVIOUS				else if (tag.tagName.equals("MARK_PREVIOUS"))				{					if(tag.lastStart == null)					{						error("empty-tag","MARK_PREVIOUS");						return;					}						rules.addRule(ParserRule						.createMarkPreviousRule(						tag.lastStartPosMatch,tag.lastStart.toString(),						tag.lastTokenID,tag.lastMatchType));				} //}}}				//{{{ Keywords				else if (					!tag.tagName.equals("END")					&& !tag.tagName.equals("BEGIN")					&& !tag.tagName.equals("KEYWORDS")					&& !tag.tagName.equals("MODE"))				{					byte token = Token.stringToToken(tag.tagName);					if(token != -1)						addKeyword(tag.lastKeyword.toString(),token);				} //}}}			}			else			{				// can't happen				throw new InternalError();			}		}	
public void startDocument()		{			props = new Hashtable<String, String>();			pushElement(null, null);			reloadModes = new Vector<Mode>();		}	
public void endDocument()		{			ParserRuleSet[] rulesets = marker.getRuleSets();			for(int i = 0; i < rulesets.length; i++)			{				rulesets[i].resolveImports();			}			for(Mode mode : reloadModes)			{				mode.setTokenMarker(null);				mode.loadIfNecessary();			}		}	
/**		 * Returns the TokenMarker.		 *		 * @return a TokenMarker it cannot be null		 */		public TokenMarker getTokenMarker()		{			return marker;		}	
public Hashtable<String, String> getModeProperties()		{			return modeProps;		}	
private void addKeyword(String k, byte id)		{			if(k == null)			{				error("empty-keyword",null);				return;			}				if (keywords == null) return;			keywords.add(k,id);		}	
private TagDecl pushElement(String name, Attributes attrs)		{			if (name != null)			{				TagDecl tag = new TagDecl(name, attrs);				stateStack.push(tag);				return tag;			}			else			{				stateStack.push(null);				return null;			}		}	
private TagDecl peekElement()		{			return stateStack.peek();		}	
private TagDecl popElement()		{			return stateStack.pop();		}	
/**		 * Finds the first element whose tag matches 'tagName',		 * searching backwards in the stack.		 */		private TagDecl findParent(String tagName)		{			for (int idx = stateStack.size() - 1; idx >= 0; idx--)			{				TagDecl tag = stateStack.get(idx);				if (tag.tagName.equals(tagName))					return tag;			}			return null;		}	
public TagDecl(String tagName, Attributes attrs)			{				this.tagName = tagName;					String tmp;					propName = attrs.getValue("NAME");				propValue = attrs.getValue("VALUE");					tmp = attrs.getValue("TYPE");				if (tmp != null)				{					lastTokenID = Token.stringToToken(tmp);					if(lastTokenID == -1)						error("token-invalid",tmp);				}					lastMatchType = ParserRule.MATCH_TYPE_RULE;				// check for the deprecated "EXCLUDE_MATCH" and				// warn if found.				tmp = attrs.getValue("EXCLUDE_MATCH");				if (tmp != null)				{					Log.log(Log.WARNING, this, modeName + ": EXCLUDE_MATCH is deprecated");					if ("TRUE".equalsIgnoreCase(tmp))					{						lastMatchType = ParserRule.MATCH_TYPE_CONTEXT;					}				}					// override with the newer MATCH_TYPE if present				tmp = attrs.getValue("MATCH_TYPE");				if (tmp != null)				{					if ("CONTEXT".equals(tmp))					{						lastMatchType = ParserRule.MATCH_TYPE_CONTEXT;					}					else if ("RULE".equals(tmp))					{						lastMatchType = ParserRule.MATCH_TYPE_RULE;					}					else					{						lastMatchType = Token.stringToToken(tmp);						if(lastMatchType == -1)							error("token-invalid",tmp);					}				}					lastAtLineStart = "TRUE".equals(attrs.getValue("AT_LINE_START"));				lastAtWhitespaceEnd = "TRUE".equals(attrs.getValue("AT_WHITESPACE_END"));				lastAtWordStart = "TRUE".equals(attrs.getValue("AT_WORD_START"));				lastNoLineBreak = "TRUE".equals(attrs.getValue("NO_LINE_BREAK"));				lastNoWordBreak = "TRUE".equals(attrs.getValue("NO_WORD_BREAK"));				lastIgnoreCase = (attrs.getValue("IGNORE_CASE") == null ||						"TRUE".equals(attrs.getValue("IGNORE_CASE")));				lastHighlightDigits = "TRUE".equals(attrs.getValue("HIGHLIGHT_DIGITS"));				lastDigitRE = attrs.getValue("DIGIT_RE");					tmp = attrs.getValue("NO_WORD_SEP");				if (tmp != null)					lastNoWordSep = tmp;					tmp = attrs.getValue("AT_CHAR");				if (tmp != null)				{					try					{						termChar = Integer.parseInt(tmp);					}					catch (NumberFormatException e)					{						error("termchar-invalid",tmp);						termChar = -1;					}				}					lastEscape = attrs.getValue("ESCAPE");				lastSetName = attrs.getValue("SET");					tmp = attrs.getValue("DELEGATE");				if (tmp != null)				{					String delegateMode, delegateSetName;						int index = tmp.indexOf("::");						if(index != -1)					{						delegateMode = tmp.substring(0,index);						delegateSetName = tmp.substring(index + 2);					}					else					{						delegateMode = modeName;						delegateSetName = tmp;					}						TokenMarker delegateMarker = getTokenMarker(delegateMode);					if(delegateMarker == null)						error("delegate-invalid",tmp);					else					{						lastDelegateSet = delegateMarker							.getRuleSet(delegateSetName);						if(delegateMarker == marker							&& lastDelegateSet == null)						{							// stupid hack to handle referencing							// a rule set that is defined later!							lastDelegateSet = new ParserRuleSet(								delegateMode,								delegateSetName);							lastDelegateSet.setDefault(Token.INVALID);							marker.addRuleSet(lastDelegateSet);						}						else if(lastDelegateSet == null)							error("delegate-invalid",tmp);					}				}					tmp = attrs.getValue("DEFAULT");				if (tmp != null)				{					lastDefaultID = Token.stringToToken(tmp);					if(lastDefaultID == -1)					{						error("token-invalid",tmp);						lastDefaultID = Token.NULL;					}				}					lastHashChar = attrs.getValue("HASH_CHAR");				lastHashChars = attrs.getValue("HASH_CHARS");				if ((null != lastHashChar) && (null != lastHashChars))				{					error("hash-char-and-hash-chars-mutually-exclusive",null);					lastHashChars = null;				}			}	
public void setText(char[] c, int off, int len)			{				if (tagName.equals("EOL_SPAN") ||					tagName.equals("EOL_SPAN_REGEXP") ||					tagName.equals("MARK_PREVIOUS") ||					tagName.equals("MARK_FOLLOWING") ||					tagName.equals("SEQ") ||					tagName.equals("SEQ_REGEXP") ||					tagName.equals("BEGIN")				)				{					TagDecl target = this;					if (tagName.equals("BEGIN"))						target = stateStack.get(stateStack.size() - 2);						if (target.lastStart == null)					{						target.lastStart = new StringBuffer();						target.lastStart.append(c, off, len);						target.lastStartPosMatch = ((target.lastAtLineStart ? ParserRule.AT_LINE_START : 0)							| (target.lastAtWhitespaceEnd ? ParserRule.AT_WHITESPACE_END : 0)							| (target.lastAtWordStart ? ParserRule.AT_WORD_START : 0));						target.lastAtLineStart = false;						target.lastAtWordStart = false;						target.lastAtWhitespaceEnd = false;					}					else					{						target.lastStart.append(c, off, len);					}				}				else if (tagName.equals("END"))				{					TagDecl target = stateStack.get(stateStack.size() - 2);					if (target.lastEnd == null)					{						target.lastEnd = new StringBuffer();						target.lastEnd.append(c, off, len);						target.lastEndPosMatch = ((this.lastAtLineStart ? ParserRule.AT_LINE_START : 0)							| (this.lastAtWhitespaceEnd ? ParserRule.AT_WHITESPACE_END : 0)							| (this.lastAtWordStart ? ParserRule.AT_WORD_START : 0));						target.lastAtLineStart = false;						target.lastAtWordStart = false;						target.lastAtWhitespaceEnd = false;					}					else					{						target.lastEnd.append(c, off, len);					}				}				else				{					if (lastKeyword == null)						lastKeyword = new StringBuffer();					lastKeyword.append(c, off, len);				}			}	
public XThis( NameSpace namespace, Interpreter declaringInterp ) {	        super( namespace, declaringInterp );	    }	
public String toString() {	        return "'this' reference (XThis) to Bsh object: " + namespace;	    }	
/**	        Get dynamic proxy for interface, caching those it creates.	    */	    public Object getInterface( Class clas )	    {	        return getInterface( new Class[] { clas } );	    }	
/**	        Get dynamic proxy for interface, caching those it creates.	    */	    public Object getInterface( Class [] ca )	    {	        if ( interfaces == null )	            interfaces = new Hashtable();		        // Make a hash of the interface hashcodes in order to cache them	        int hash = 21;	        for(int i=0; i<ca.length; i++)	            hash *= ca[i].hashCode() + 3;	        Object hashKey = new Integer(hash);		        Object interf = interfaces.get( hashKey );		        if ( interf == null )	        {	            ClassLoader classLoader = ca[0].getClassLoader(); // ?	            interf = Proxy.newProxyInstance(	                classLoader, ca, invocationHandler );	            interfaces.put( hashKey, interf );	        }		        return interf;	    }	
public Object invoke( Object proxy, Method method, Object[] args )	            throws Throwable	        {	            try {	                return invokeImpl( proxy, method, args );	            } catch ( TargetError te ) {	                // Unwrap target exception.  If the interface declares that	                // it throws the ex it will be delivered.  If not it will be	                // wrapped in an UndeclaredThrowable	                throw te.getTarget();	            } catch ( EvalError ee ) {	                // Ease debugging...	                // XThis.this refers to the enclosing class instance	                if ( Interpreter.DEBUG )	                    Interpreter.debug( "EvalError in scripted interface: "	                    + XThis.this.toString() + ": "+ ee );	                throw ee;	            }	        }	
public Object invokeImpl( Object proxy, Method method, Object[] args )	            throws EvalError	        {	            String methodName = method.getName();	            CallStack callstack = new CallStack( namespace );		            /*	                If equals() is not explicitly defined we must override the	                default implemented by the This object protocol for scripted	                object.  To support XThis equals() must test for equality with	                the generated proxy object, not the scripted bsh This object;	                otherwise callers from outside in Java will not see a the	                proxy object as equal to itself.	            */	            BshMethod equalsMethod = null;	            try {	                equalsMethod = namespace.getMethod(	                    "equals", new Class [] { Object.class } );	            } catch ( UtilEvalError e ) {/*leave null*/ }	            if ( methodName.equals("equals" ) && equalsMethod == null ) {	                Object obj = args[0];	                return new Boolean( proxy == obj );	            }		            /*	                If toString() is not explicitly defined override the default	                to show the proxy interfaces.	            */	            BshMethod toStringMethod = null;	            try {	                toStringMethod =	                    namespace.getMethod( "toString", new Class [] { } );	            } catch ( UtilEvalError e ) {/*leave null*/ }		            if ( methodName.equals("toString" ) && toStringMethod == null)	            {	                Class [] ints = proxy.getClass().getInterfaces();	                // XThis.this refers to the enclosing class instance	                StringBuilder sb = new StringBuilder(	                    XThis.this.toString() + "\nimplements:" );	                for(int i=0; i<ints.length; i++)	                    sb.append( " "+ ints[i].getName()	                        + ((ints.length > 1)?",":"") );	                return sb.toString();	            }		            Class [] paramTypes = method.getParameterTypes();	            return Primitive.unwrap(	                invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );	        }	
public CBZip2InputStream( final InputStream input )	    {	        bsSetStream( input );	        initialize();	        initBlock();	        setupBlock();	    }	
private static void badBlockHeader()	    {	        cadvise();	    }	
private static void blockOverrun()	    {	        cadvise();	    }	
private static void cadvise()	    {	        System.out.println( "CRC Error" );	        //throw new CCoruptionError();	    }	
private static void compressedStreamEOF()	    {	        cadvise();	    }	
private static void crcError()	    {	        cadvise();	    }	
public int read()	    {	        if( m_streamEnd )	        {	            return -1;	        }	        else	        {	            int retChar = m_currentChar;	            switch( m_currentState )	            {	                case START_BLOCK_STATE:	                    break;	                case RAND_PART_A_STATE:	                    break;	                case RAND_PART_B_STATE:	                    setupRandPartB();	                    break;	                case RAND_PART_C_STATE:	                    setupRandPartC();	                    break;	                case NO_RAND_PART_A_STATE:	                    break;	                case NO_RAND_PART_B_STATE:	                    setupNoRandPartB();	                    break;	                case NO_RAND_PART_C_STATE:	                    setupNoRandPartC();	                    break;	                default:	                    break;	            }	            return retChar;	        }	    }	
private void setDecompressStructureSizes( int newSize100k )	    {	        if( !( 0 <= newSize100k && newSize100k <= 9 && 0 <= m_blockSize100k	            && m_blockSize100k <= 9 ) )	        {	            // throw new IOException("Invalid block size");	        }		        m_blockSize100k = newSize100k;		        if( newSize100k == 0 )	        {	            return;	        }		        int n = BASE_BLOCK_SIZE * newSize100k;	        m_ll8 = new char[ n ];	        m_tt = new int[ n ];	    }	
private void setupBlock()	    {	        int[] cftab = new int[ 257 ];	        char ch;		        cftab[ 0 ] = 0;	        for( int i = 1; i <= 256; i++ )	        {	            cftab[ i ] = m_unzftab[ i - 1 ];	        }	        for( int i = 1; i <= 256; i++ )	        {	            cftab[ i ] += cftab[ i - 1 ];	        }		        for( int i = 0; i <= m_last; i++ )	        {	            ch = m_ll8[ i ];	            m_tt[ cftab[ ch ] ] = i;	            cftab[ ch ]++;	        }	        cftab = null;		        m_tPos = m_tt[ m_origPtr ];		        count = 0;	        i2 = 0;	        ch2 = 256;	        /*	         * not a char and not EOF	         */	        if( m_blockRandomised )	        {	            m_rNToGo = 0;	            m_rTPos = 0;	            setupRandPartA();	        }	        else	        {	            setupNoRandPartA();	        }	    }	
private void setupNoRandPartA()	    {	        if( i2 <= m_last )	        {	            chPrev = ch2;	            ch2 = m_ll8[ m_tPos ];	            m_tPos = m_tt[ m_tPos ];	            i2++;		            m_currentChar = ch2;	            m_currentState = NO_RAND_PART_B_STATE;	            m_crc.updateCRC( ch2 );	        }	        else	        {	            endBlock();	            initBlock();	            setupBlock();	        }	    }	
private void setupNoRandPartB()	    {	        if( ch2 != chPrev )	        {	            m_currentState = NO_RAND_PART_A_STATE;	            count = 1;	            setupNoRandPartA();	        }	        else	        {	            count++;	            if( count >= 4 )	            {	                z = m_ll8[ m_tPos ];	                m_tPos = m_tt[ m_tPos ];	                m_currentState = NO_RAND_PART_C_STATE;	                j2 = 0;	                setupNoRandPartC();	            }	            else	            {	                m_currentState = NO_RAND_PART_A_STATE;	                setupNoRandPartA();	            }	        }	    }	
private void setupNoRandPartC()	    {	        if( j2 < z )	        {	            m_currentChar = ch2;	            m_crc.updateCRC( ch2 );	            j2++;	        }	        else	        {	            m_currentState = NO_RAND_PART_A_STATE;	            i2++;	            count = 0;	            setupNoRandPartA();	        }	    }	
private void setupRandPartA()	    {	        if( i2 <= m_last )	        {	            chPrev = ch2;	            ch2 = m_ll8[ m_tPos ];	            m_tPos = m_tt[ m_tPos ];	            if( m_rNToGo == 0 )	            {	                m_rNToGo = RAND_NUMS[ m_rTPos ];	                m_rTPos++;	                if( m_rTPos == 512 )	                {	                    m_rTPos = 0;	                }	            }	            m_rNToGo--;	            ch2 ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );	            i2++;		            m_currentChar = ch2;	            m_currentState = RAND_PART_B_STATE;	            m_crc.updateCRC( ch2 );	        }	        else	        {	            endBlock();	            initBlock();	            setupBlock();	        }	    }	
private void setupRandPartB()	    {	        if( ch2 != chPrev )	        {	            m_currentState = RAND_PART_A_STATE;	            count = 1;	            setupRandPartA();	        }	        else	        {	            count++;	            if( count >= 4 )	            {	                z = m_ll8[ m_tPos ];	                m_tPos = m_tt[ m_tPos ];	                if( m_rNToGo == 0 )	                {	                    m_rNToGo = RAND_NUMS[ m_rTPos ];	                    m_rTPos++;	                    if( m_rTPos == 512 )	                    {	                        m_rTPos = 0;	                    }	                }	                m_rNToGo--;	                z ^= ( ( m_rNToGo == 1 ) ? 1 : 0 );	                j2 = 0;	                m_currentState = RAND_PART_C_STATE;	                setupRandPartC();	            }	            else	            {	                m_currentState = RAND_PART_A_STATE;	                setupRandPartA();	            }	        }	    }	
private void setupRandPartC()	    {	        if( j2 < z )	        {	            m_currentChar = ch2;	            m_crc.updateCRC( ch2 );	            j2++;	        }	        else	        {	            m_currentState = RAND_PART_A_STATE;	            i2++;	            count = 0;	            setupRandPartA();	        }	    }	
private void getAndMoveToFrontDecode()	    {	        int nextSym;		        int limitLast = BASE_BLOCK_SIZE * m_blockSize100k;	        m_origPtr = readVariableSizedInt( 24 );		        recvDecodingTables();	        int EOB = m_nInUse + 1;	        int groupNo = -1;	        int groupPos = 0;		        /*	         * Setting up the unzftab entries here is not strictly	         * necessary, but it does save having to do it later	         * in a separate pass, and so saves a block's worth of	         * cache misses.	         */	        for( int i = 0; i <= 255; i++ )	        {	            m_unzftab[ i ] = 0;	        }		        final char[] yy = new char[ 256 ];	        for( int i = 0; i <= 255; i++ )	        {	            yy[ i ] = (char)i;	        }		        m_last = -1;	        int zt;	        int zn;	        int zvec;	        int zj;	        groupNo++;	        groupPos = G_SIZE - 1;		        zt = m_selector[ groupNo ];	        zn = m_minLens[ zt ];	        zvec = bsR( zn );	        while( zvec > m_limit[ zt ][ zn ] )	        {	            zn++;		            while( m_bsLive < 1 )	            {	                int zzi;	                try	                {	                    zzi = m_input.read();	                }	                catch( IOException e )	                {	                    compressedStreamEOF();						break;	                }	                if( zzi == -1 )	                {	                    compressedStreamEOF();						break;	                }	                m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );	                m_bsLive += 8;	            }		            zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;	            m_bsLive--;		            zvec = ( zvec << 1 ) | zj;	        }	        nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];		        while( true )	        {	            if( nextSym == EOB )	            {	                break;	            }		            if( nextSym == RUNA || nextSym == RUNB )	            {	                char ch;	                int s = -1;	                int N = 1;	                do	                {	                    if( nextSym == RUNA )	                    {	                        s = s + ( 0 + 1 ) * N;	                    }	                    else// if( nextSym == RUNB )	                    {	                        s = s + ( 1 + 1 ) * N;	                    }	                    N = N * 2;		                    if( groupPos == 0 )	                    {	                        groupNo++;	                        groupPos = G_SIZE;	                    }	                    groupPos--;	                    zt = m_selector[ groupNo ];	                    zn = m_minLens[ zt ];	                    zvec = bsR( zn );	                    while( zvec > m_limit[ zt ][ zn ] )	                    {	                        zn++;		                        while( m_bsLive < 1 )	                        {	                            int zzi;	                            char thech = 0;	                            try	                            {	                                thech = (char)m_input.read();	                            }	                            catch( IOException e )	                            {	                                compressedStreamEOF();	                            }	                            if( thech == -1 )	                            {	                                compressedStreamEOF();	                            }	                            zzi = thech;	                            m_bsBuff = ( m_bsBuff << 8 ) | ( zzi & 0xff );	                            m_bsLive += 8;	                        }		                        zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;	                        m_bsLive--;	                        zvec = ( zvec << 1 ) | zj;	                    }		                    nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];		                } while( nextSym == RUNA || nextSym == RUNB );		                s++;	                ch = m_seqToUnseq[ yy[ 0 ] ];	                m_unzftab[ ch ] += s;		                while( s > 0 )	                {	                    m_last++;	                    m_ll8[ m_last ] = ch;	                    s--;	                }		                if( m_last >= limitLast )	                {	                    blockOverrun();	                }	                continue;	            }	            else	            {	                char tmp;	                m_last++;	                if( m_last >= limitLast )	                {	                    blockOverrun();	                }		                tmp = yy[ nextSym - 1 ];	                m_unzftab[ m_seqToUnseq[ tmp ] ]++;	                m_ll8[ m_last ] = m_seqToUnseq[ tmp ];		                /*	                 * This loop is hammered during decompression,	                 * hence the unrolling.	                 * for (j = nextSym-1; j > 0; j--) yy[j] = yy[j-1];	                 */	                int j = nextSym - 1;	                for( ; j > 3; j -= 4 )	                {	                    yy[ j ] = yy[ j - 1 ];	                    yy[ j - 1 ] = yy[ j - 2 ];	                    yy[ j - 2 ] = yy[ j - 3 ];	                    yy[ j - 3 ] = yy[ j - 4 ];	                }	                for( ; j > 0; j-- )	                {	                    yy[ j ] = yy[ j - 1 ];	                }		                yy[ 0 ] = tmp;		                if( groupPos == 0 )	                {	                    groupNo++;	                    groupPos = G_SIZE;	                }	                groupPos--;	                zt = m_selector[ groupNo ];	                zn = m_minLens[ zt ];	                zvec = bsR( zn );	                while( zvec > m_limit[ zt ][ zn ] )	                {	                    zn++;		                    while( m_bsLive < 1 )	                    {	                        char ch = 0;	                        try	                        {	                            ch = (char)m_input.read();	                        }	                        catch( IOException e )	                        {	                            compressedStreamEOF();	                        }		                        m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );	                        m_bsLive += 8;	                    }		                    zj = ( m_bsBuff >> ( m_bsLive - 1 ) ) & 1;	                    m_bsLive--;		                    zvec = ( zvec << 1 ) | zj;	                }	                nextSym = m_perm[ zt ][ zvec - m_base[ zt ][ zn ] ];		                continue;	            }	        }	    }	
private void bsFinishedWithStream()	    {	        m_input = null;	    }	
private int readVariableSizedInt( final int numBits )	    {	        return bsR( numBits );	    }	
private char readUnsignedChar()	    {	        return (char)bsR( 8 );	    }	
private int readInt()	    {	        int u = 0;	        u = ( u << 8 ) | bsR( 8 );	        u = ( u << 8 ) | bsR( 8 );	        u = ( u << 8 ) | bsR( 8 );	        u = ( u << 8 ) | bsR( 8 );	        return u;	    }	
private int bsR( final int n )	    {	        while( m_bsLive < n )	        {	            char ch = 0;	            try	            {	                ch = (char)m_input.read();	            }	            catch( final IOException ioe )	            {	                compressedStreamEOF();	            }		            if( ch == -1 )	            {	                compressedStreamEOF();	            }		            m_bsBuff = ( m_bsBuff << 8 ) | ( ch & 0xff );	            m_bsLive += 8;	        }		        final int result = ( m_bsBuff >> ( m_bsLive - n ) ) & ( ( 1 << n ) - 1 );	        m_bsLive -= n;	        return result;	    }	
private void bsSetStream( final InputStream input )	    {	        m_input = input;	        m_bsLive = 0;	        m_bsBuff = 0;	    }	
private void complete()	    {	        m_storedCombinedCRC = readInt();	        if( m_storedCombinedCRC != m_computedCombinedCRC )	        {	            crcError();	        }		        bsFinishedWithStream();	        m_streamEnd = true;	    }	
private void endBlock()	    {	        m_computedBlockCRC = m_crc.getFinalCRC();	        /*	         * A bad CRC is considered a fatal error.	         */	        if( m_storedBlockCRC != m_computedBlockCRC )	        {	            crcError();	        }		        m_computedCombinedCRC = ( m_computedCombinedCRC << 1 )	            | ( m_computedCombinedCRC >>> 31 );	        m_computedCombinedCRC ^= m_computedBlockCRC;	    }	
private void hbCreateDecodeTables( final int[] limit,	                                       final int[] base,	                                       final int[] perm,	                                       final char[] length,	                                       final int minLen,	                                       final int maxLen,	                                       final int alphaSize )	    {	        int pp = 0;	        for( int i = minLen; i <= maxLen; i++ )	        {	            for( int j = 0; j < alphaSize; j++ )	            {	                if( length[ j ] == i )	                {	                    perm[ pp ] = j;	                    pp++;	                }	            }	        }		        for( int i = 0; i < MAX_CODE_LEN; i++ )	        {	            base[ i ] = 0;	        }		        for( int i = 0; i < alphaSize; i++ )	        {	            base[ length[ i ] + 1 ]++;	        }		        for( int i = 1; i < MAX_CODE_LEN; i++ )	        {	            base[ i ] += base[ i - 1 ];	        }		        for( int i = 0; i < MAX_CODE_LEN; i++ )	        {	            limit[ i ] = 0;	        }		        int vec = 0;	        for( int i = minLen; i <= maxLen; i++ )	        {	            vec += ( base[ i + 1 ] - base[ i ] );	            limit[ i ] = vec - 1;	            vec <<= 1;	        }		        for( int i = minLen + 1; i <= maxLen; i++ )	        {	            base[ i ] = ( ( limit[ i - 1 ] + 1 ) << 1 ) - base[ i ];	        }	    }	
private void initBlock()	    {	        final char magic1 = readUnsignedChar();	        final char magic2 = readUnsignedChar();	        final char magic3 = readUnsignedChar();	        final char magic4 = readUnsignedChar();	        final char magic5 = readUnsignedChar();	        final char magic6 = readUnsignedChar();	        if( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 &&	            magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 )	        {	            complete();	            return;	        }		        if( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 ||	            magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 )	        {	            badBlockHeader();	            m_streamEnd = true;	            return;	        }		        m_storedBlockCRC = readInt();		        if( bsR( 1 ) == 1 )	        {	            m_blockRandomised = true;	        }	        else	        {	            m_blockRandomised = false;	        }		        //        currBlockNo++;	        getAndMoveToFrontDecode();		        m_crc.initialiseCRC();	        m_currentState = START_BLOCK_STATE;	    }	
private void initialize()	    {	        final char magic3 = readUnsignedChar();	        final char magic4 = readUnsignedChar();	        if( magic3 != 'h' || magic4 < '1' || magic4 > '9' )	        {	            bsFinishedWithStream();	            m_streamEnd = true;	            return;	        }		        setDecompressStructureSizes( magic4 - '0' );	        m_computedCombinedCRC = 0;	    }	
private void makeMaps()	    {	        m_nInUse = 0;	        for( int i = 0; i < 256; i++ )	        {	            if( m_inUse[ i ] )	            {	                m_seqToUnseq[ m_nInUse ] = (char)i;	                m_unseqToSeq[ i ] = (char)m_nInUse;	                m_nInUse++;	            }	        }	    }	
private void recvDecodingTables()	    {	        buildInUseTable();	        makeMaps();	        final int alphaSize = m_nInUse + 2;		        /*	         * Now the selectors	         */	        final int groupCount = bsR( 3 );	        final int selectorCount = bsR( 15 );	        for( int i = 0; i < selectorCount; i++ )	        {	            int run = 0;	            while( bsR( 1 ) == 1 )	            {	                run++;	            }	            m_selectorMtf[ i ] = (char)run;	        }		        /*	         * Undo the MTF values for the selectors.	         */	        final char[] pos = new char[ N_GROUPS ];	        for( char v = 0; v < groupCount; v++ )	        {	            pos[ v ] = v;	        }		        for( int i = 0; i < selectorCount; i++ )	        {	            int v = m_selectorMtf[ i ];	            final char tmp = pos[ v ];	            while( v > 0 )	            {	                pos[ v ] = pos[ v - 1 ];	                v--;	            }	            pos[ 0 ] = tmp;	            m_selector[ i ] = tmp;	        }		        final char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];	        /*	         * Now the coding tables	         */	        for( int i = 0; i < groupCount; i++ )	        {	            int curr = bsR( 5 );	            for( int j = 0; j < alphaSize; j++ )	            {	                while( bsR( 1 ) == 1 )	                {	                    if( bsR( 1 ) == 0 )	                    {	                        curr++;	                    }	                    else	                    {	                        curr--;	                    }	                }	                len[ i ][ j ] = (char)curr;	            }	        }		        /*	         * Create the Huffman decoding tables	         */	        for( int k = 0; k < groupCount; k++ )	        {	            int minLen = 32;	            int maxLen = 0;	            for( int i = 0; i < alphaSize; i++ )	            {	                if( len[ k ][ i ] > maxLen )	                {	                    maxLen = len[ k ][ i ];	                }	                if( len[ k ][ i ] < minLen )	                {	                    minLen = len[ k ][ i ];	                }	            }	            hbCreateDecodeTables( m_limit[ k ], m_base[ k ], m_perm[ k ], len[ k ], minLen,	                                  maxLen, alphaSize );	            m_minLens[ k ] = minLen;	        }	    }	
private void buildInUseTable()	    {	        final boolean[] inUse16 = new boolean[ 16 ];		        /*	         * Receive the mapping table	         */	        for( int i = 0; i < 16; i++ )	        {	            if( bsR( 1 ) == 1 )	            {	                inUse16[ i ] = true;	            }	            else	            {	                inUse16[ i ] = false;	            }	        }		        for( int i = 0; i < 256; i++ )	        {	            m_inUse[ i ] = false;	        }		        for( int i = 0; i < 16; i++ )	        {	            if( inUse16[ i ] )	            {	                for( int j = 0; j < 16; j++ )	                {	                    if( bsR( 1 ) == 1 )	                    {	                        m_inUse[ i * 16 + j ] = true;	                    }	                }	            }	        }	    }	
public CBZip2OutputStream( final OutputStream output )	        throws IOException	    {	        this( output, 9 );	    }	
public CBZip2OutputStream( final OutputStream output, final int blockSize )	        throws IOException	    {	        bsSetStream( output );	        m_workFactor = 50;		        int outBlockSize = blockSize;	        if( outBlockSize > 9 )	        {	            outBlockSize = 9;	        }	        if( outBlockSize < 1 )	        {	            outBlockSize = 1;	        }	        m_blockSize100k = outBlockSize;	        allocateCompressStructures();	        initialize();	        initBlock();	    }	
private static void hbMakeCodeLengths( char[] len, int[] freq,	                                           int alphaSize, int maxLen )	    {	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int nNodes;	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int nHeap;	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int n1;	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int n2;	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int i;	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int j;	        /*	         * Nodes and heap entries run from 1.  Entry 0	         * for both the heap and nodes is a sentinel.	         */	        int k;	        boolean tooLong;		        int[] heap = new int[ MAX_ALPHA_SIZE + 2 ];	        int[] weights = new int[ MAX_ALPHA_SIZE * 2 ];	        int[] parent = new int[ MAX_ALPHA_SIZE * 2 ];		        for( i = 0; i < alphaSize; i++ )	        {	            weights[ i + 1 ] = ( freq[ i ] == 0 ? 1 : freq[ i ] ) << 8;	        }		        while( true )	        {	            nNodes = alphaSize;	            nHeap = 0;		            heap[ 0 ] = 0;	            weights[ 0 ] = 0;	            parent[ 0 ] = -2;		            for( i = 1; i <= alphaSize; i++ )	            {	                parent[ i ] = -1;	                nHeap++;	                heap[ nHeap ] = i;	                {	                    int zz;	                    int tmp;	                    zz = nHeap;	                    tmp = heap[ zz ];	                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )	                    {	                        heap[ zz ] = heap[ zz >> 1 ];	                        zz >>= 1;	                    }	                    heap[ zz ] = tmp;	                }	            }	            if( !( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) )	            {	                panic();	            }		            while( nHeap > 1 )	            {	                n1 = heap[ 1 ];	                heap[ 1 ] = heap[ nHeap ];	                nHeap--;	                {	                    int zz = 0;	                    int yy = 0;	                    int tmp = 0;	                    zz = 1;	                    tmp = heap[ zz ];	                    while( true )	                    {	                        yy = zz << 1;	                        if( yy > nHeap )	                        {	                            break;	                        }	                        if( yy < nHeap &&	                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )	                        {	                            yy++;	                        }	                        if( weights[ tmp ] < weights[ heap[ yy ] ] )	                        {	                            break;	                        }	                        heap[ zz ] = heap[ yy ];	                        zz = yy;	                    }	                    heap[ zz ] = tmp;	                }	                n2 = heap[ 1 ];	                heap[ 1 ] = heap[ nHeap ];	                nHeap--;	                {	                    int zz = 0;	                    int yy = 0;	                    int tmp = 0;	                    zz = 1;	                    tmp = heap[ zz ];	                    while( true )	                    {	                        yy = zz << 1;	                        if( yy > nHeap )	                        {	                            break;	                        }	                        if( yy < nHeap &&	                            weights[ heap[ yy + 1 ] ] < weights[ heap[ yy ] ] )	                        {	                            yy++;	                        }	                        if( weights[ tmp ] < weights[ heap[ yy ] ] )	                        {	                            break;	                        }	                        heap[ zz ] = heap[ yy ];	                        zz = yy;	                    }	                    heap[ zz ] = tmp;	                }	                nNodes++;	                parent[ n1 ] = nNodes;	                parent[ n2 ] = nNodes;		                final int v1 = weights[ n1 ];	                final int v2 = weights[ n2 ];	                final int weight = calculateWeight( v1, v2 );	                weights[ nNodes ] = weight;		                parent[ nNodes ] = -1;	                nHeap++;	                heap[ nHeap ] = nNodes;	                {	                    int zz = 0;	                    int tmp = 0;	                    zz = nHeap;	                    tmp = heap[ zz ];	                    while( weights[ tmp ] < weights[ heap[ zz >> 1 ] ] )	                    {	                        heap[ zz ] = heap[ zz >> 1 ];	                        zz >>= 1;	                    }	                    heap[ zz ] = tmp;	                }	            }	            if( !( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) )	            {	                panic();	            }		            tooLong = false;	            for( i = 1; i <= alphaSize; i++ )	            {	                j = 0;	                k = i;	                while( parent[ k ] >= 0 )	                {	                    k = parent[ k ];	                    j++;	                }	                len[ i - 1 ] = (char)j;	                if( j > maxLen )	                {	                    tooLong = true;	                }	            }		            if( !tooLong )	            {	                break;	            }		            for( i = 1; i < alphaSize; i++ )	            {	                j = weights[ i ] >> 8;	                j = 1 + ( j / 2 );	                weights[ i ] = j << 8;	            }	        }	    }	
private static int calculateWeight( final int v1, final int v2 )	    {	        final int upper = ( v1 & UPPER_BYTE_MASK ) + ( v2 & UPPER_BYTE_MASK );	        final int v1Lower = ( v1 & LOWER_BYTE_MASK );	        final int v2Lower = ( v2 & LOWER_BYTE_MASK );	        final int nnnn = ( v1Lower > v2Lower ) ? v1Lower : v2Lower;	        return upper | ( 1 + nnnn );	    }	
private static void panic()	    {	        System.out.println( "panic" );	        //throw new CError();	    }	
public void close()	        throws IOException	    {	        if( m_closed )	        {	            return;	        }		        if( m_runLength > 0 )	        {	            writeRun();	        }	        m_currentChar = -1;	        endBlock();	        endCompression();	        m_closed = true;	        super.close();	        m_bsStream.close();	    }	
public void finalize()	        throws Throwable	    {	        close();	    }	
public void flush()	        throws IOException	    {	        super.flush();	        m_bsStream.flush();	    }	
/**	     * modified by Oliver Merkel, 010128	     *	     * @param bv Description of Parameter	     * @exception java.io.IOException Description of Exception	     */	    public void write( int bv )	        throws IOException	    {	        int b = ( 256 + bv ) % 256;	        if( m_currentChar != -1 )	        {	            if( m_currentChar == b )	            {	                m_runLength++;	                if( m_runLength > 254 )	                {	                    writeRun();	                    m_currentChar = -1;	                    m_runLength = 0;	                }	            }	            else	            {	                writeRun();	                m_runLength = 1;	                m_currentChar = b;	            }	        }	        else	        {	            m_currentChar = b;	            m_runLength++;	        }	    }	
private void allocateCompressStructures()	    {	        int n = BASE_BLOCK_SIZE * m_blockSize100k;	        m_block = new char[ ( n + 1 + NUM_OVERSHOOT_BYTES ) ];	        m_quadrant = new int[ ( n + NUM_OVERSHOOT_BYTES ) ];	        m_zptr = new int[ n ];	        m_ftab = new int[ 65537 ];		        if( m_block == null || m_quadrant == null || m_zptr == null	            || m_ftab == null )	        {	            //int totalDraw = (n + 1 + NUM_OVERSHOOT_BYTES) + (n + NUM_OVERSHOOT_BYTES) + n + 65537;	            //compressOutOfMemory ( totalDraw, n );	        }		        /*	         * The back end needs a place to store the MTF values	         * whilst it calculates the coding tables.  We could	         * put them in the zptr array.  However, these values	         * will fit in a short, so we overlay szptr at the	         * start of zptr, in the hope of reducing the number	         * of cache misses induced by the multiple traversals	         * of the MTF values when calculating coding tables.	         * Seems to improve compression speed by about 1%.	         */	        //    szptr = zptr;		        m_szptr = new short[ 2 * n ];	    }	
private void bsFinishedWithStream()	        throws IOException	    {	        while( m_bsLive > 0 )	        {	            int ch = ( m_bsBuff >> 24 );	            try	            {	                m_bsStream.write( ch );// write 8-bit	            }	            catch( IOException e )	            {	                throw e;	            }	            m_bsBuff <<= 8;	            m_bsLive -= 8;	        }	    }	
private void bsPutIntVS( int numBits, int c )	        throws IOException	    {	        bsW( numBits, c );	    }	
private void bsPutUChar( int c )	        throws IOException	    {	        bsW( 8, c );	    }	
private void bsPutint( int u )	        throws IOException	    {	        bsW( 8, ( u >> 24 ) & 0xff );	        bsW( 8, ( u >> 16 ) & 0xff );	        bsW( 8, ( u >> 8 ) & 0xff );	        bsW( 8, u & 0xff );	    }	
private void bsSetStream( OutputStream f )	    {	        m_bsStream = f;	        m_bsLive = 0;	        m_bsBuff = 0;	    }	
private void bsW( int n, int v )	        throws IOException	    {	        while( m_bsLive >= 8 )	        {	            int ch = ( m_bsBuff >> 24 );	            try	            {	                m_bsStream.write( ch );// write 8-bit	            }	            catch( IOException e )	            {	                throw e;	            }	            m_bsBuff <<= 8;	            m_bsLive -= 8;	        }	        m_bsBuff |= ( v << ( 32 - m_bsLive - n ) );	        m_bsLive += n;	    }	
private void doReversibleTransformation()	    {	        int i;		        m_workLimit = m_workFactor * m_last;	        m_workDone = 0;	        m_blockRandomised = false;	        m_firstAttempt = true;		        mainSort();		        if( m_workDone > m_workLimit && m_firstAttempt )	        {	            randomiseBlock();	            m_workLimit = 0;	            m_workDone = 0;	            m_blockRandomised = true;	            m_firstAttempt = false;	            mainSort();	        }		        m_origPtr = -1;	        for( i = 0; i <= m_last; i++ )	        {	            if( m_zptr[ i ] == 0 )	            {	                m_origPtr = i;	                break;	            }	        }	        ;		        if( m_origPtr == -1 )	        {	            panic();	        }	    }	
private void endBlock()	        throws IOException	    {	        m_blockCRC = m_crc.getFinalCRC();	        m_combinedCRC = ( m_combinedCRC << 1 ) | ( m_combinedCRC >>> 31 );	        m_combinedCRC ^= m_blockCRC;		        /*	         * sort the block and establish posn of original string	         */	        doReversibleTransformation();		        /*	         * A 6-byte block header, the value chosen arbitrarily	         * as 0x314159265359 :-).  A 32 bit value does not really	         * give a strong enough guarantee that the value will not	         * appear by chance in the compressed datastream.  Worst-case	         * probability of this event, for a 900k block, is about	         * 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48 bits.	         * For a compressed file of size 100Gb -- about 100000 blocks --	         * only a 48-bit marker will do.  NB: normal compression/	         * decompression do *not* rely on these statistical properties.	         * They are only important when trying to recover blocks from	         * damaged files.	         */	        bsPutUChar( 0x31 );	        bsPutUChar( 0x41 );	        bsPutUChar( 0x59 );	        bsPutUChar( 0x26 );	        bsPutUChar( 0x53 );	        bsPutUChar( 0x59 );		        /*	         * Now the block's CRC, so it is in a known place.	         */	        bsPutint( m_blockCRC );		        /*	         * Now a single bit indicating randomisation.	         */	        if( m_blockRandomised )	        {	            bsW( 1, 1 );	        }	        else	        {	            bsW( 1, 0 );	        }		        /*	         * Finally, block's contents proper.	         */	        moveToFrontCodeAndSend();	    }	
private void endCompression()	        throws IOException	    {	        /*	         * Now another magic 48-bit number, 0x177245385090, to	         * indicate the end of the last block.  (sqrt(pi), if	         * you want to know.  I did want to use e, but it contains	         * too much repetition -- 27 18 28 18 28 46 -- for me	         * to feel statistically comfortable.  Call me paranoid.)	         */	        bsPutUChar( 0x17 );	        bsPutUChar( 0x72 );	        bsPutUChar( 0x45 );	        bsPutUChar( 0x38 );	        bsPutUChar( 0x50 );	        bsPutUChar( 0x90 );		        bsPutint( m_combinedCRC );		        bsFinishedWithStream();	    }	
private boolean fullGtU( int i1, int i2 )	    {	        int k;	        char c1;	        char c2;	        int s1;	        int s2;		        c1 = m_block[ i1 + 1 ];	        c2 = m_block[ i2 + 1 ];	        if( c1 != c2 )	        {	            return ( c1 > c2 );	        }	        i1++;	        i2++;		        c1 = m_block[ i1 + 1 ];	        c2 = m_block[ i2 + 1 ];	        if( c1 != c2 )	        {	            return ( c1 > c2 );	        }	        i1++;	        i2++;		        c1 = m_block[ i1 + 1 ];	        c2 = m_block[ i2 + 1 ];	        if( c1 != c2 )	        {	            return ( c1 > c2 );	        }	        i1++;	        i2++;		        c1 = m_block[ i1 + 1 ];	        c2 = m_block[ i2 + 1 ];	        if( c1 != c2 )	        {	            return ( c1 > c2 );	        }	        i1++;	        i2++;		        c1 = m_block[ i1 + 1 ];	        c2 = m_block[ i2 + 1 ];	        if( c1 != c2 )	        {	            return ( c1 > c2 );	        }	        i1++;	        i2++;		        c1 = m_block[ i1 + 1 ];	        c2 = m_block[ i2 + 1 ];	        if( c1 != c2 )	        {	            return ( c1 > c2 );	        }	        i1++;	        i2++;		        k = m_last + 1;		        do	        {	            c1 = m_block[ i1 + 1 ];	            c2 = m_block[ i2 + 1 ];	            if( c1 != c2 )	            {	                return ( c1 > c2 );	            }	            s1 = m_quadrant[ i1 ];	            s2 = m_quadrant[ i2 ];	            if( s1 != s2 )	            {	                return ( s1 > s2 );	            }	            i1++;	            i2++;		            c1 = m_block[ i1 + 1 ];	            c2 = m_block[ i2 + 1 ];	            if( c1 != c2 )	            {	                return ( c1 > c2 );	            }	            s1 = m_quadrant[ i1 ];	            s2 = m_quadrant[ i2 ];	            if( s1 != s2 )	            {	                return ( s1 > s2 );	            }	            i1++;	            i2++;		            c1 = m_block[ i1 + 1 ];	            c2 = m_block[ i2 + 1 ];	            if( c1 != c2 )	            {	                return ( c1 > c2 );	            }	            s1 = m_quadrant[ i1 ];	            s2 = m_quadrant[ i2 ];	            if( s1 != s2 )	            {	                return ( s1 > s2 );	            }	            i1++;	            i2++;		            c1 = m_block[ i1 + 1 ];	            c2 = m_block[ i2 + 1 ];	            if( c1 != c2 )	            {	                return ( c1 > c2 );	            }	            s1 = m_quadrant[ i1 ];	            s2 = m_quadrant[ i2 ];	            if( s1 != s2 )	            {	                return ( s1 > s2 );	            }	            i1++;	            i2++;		            if( i1 > m_last )	            {	                i1 -= m_last;	                i1--;	            }	            ;	            if( i2 > m_last )	            {	                i2 -= m_last;	                i2--;	            }	            ;		            k -= 4;	            m_workDone++;	        } while( k >= 0 );		        return false;	    }	
private void generateMTFValues()	    {	        char[] yy = new char[ 256 ];	        int i;	        int j;	        char tmp;	        char tmp2;	        int zPend;	        int wr;	        int EOB;		        makeMaps();	        EOB = m_nInUse + 1;		        for( i = 0; i <= EOB; i++ )	        {	            m_mtfFreq[ i ] = 0;	        }		        wr = 0;	        zPend = 0;	        for( i = 0; i < m_nInUse; i++ )	        {	            yy[ i ] = (char)i;	        }		        for( i = 0; i <= m_last; i++ )	        {	            char ll_i;		            ll_i = m_unseqToSeq[ m_block[ m_zptr[ i ] ] ];		            j = 0;	            tmp = yy[ j ];	            while( ll_i != tmp )	            {	                j++;	                tmp2 = tmp;	                tmp = yy[ j ];	                yy[ j ] = tmp2;	            }	            ;	            yy[ 0 ] = tmp;		            if( j == 0 )	            {	                zPend++;	            }	            else	            {	                if( zPend > 0 )	                {	                    zPend--;	                    while( true )	                    {	                        switch( zPend % 2 )	                        {	                            case 0:	                                m_szptr[ wr ] = (short)RUNA;	                                wr++;	                                m_mtfFreq[ RUNA ]++;	                                break;	                            case 1:	                                m_szptr[ wr ] = (short)RUNB;	                                wr++;	                                m_mtfFreq[ RUNB ]++;	                                break;	                        }	                        ;	                        if( zPend < 2 )	                        {	                            break;	                        }	                        zPend = ( zPend - 2 ) / 2;	                    }	                    ;	                    zPend = 0;	                }	                m_szptr[ wr ] = (short)( j + 1 );	                wr++;	                m_mtfFreq[ j + 1 ]++;	            }	        }		        if( zPend > 0 )	        {	            zPend--;	            while( true )	            {	                switch( zPend % 2 )	                {	                    case 0:	                        m_szptr[ wr ] = (short)RUNA;	                        wr++;	                        m_mtfFreq[ RUNA ]++;	                        break;	                    case 1:	                        m_szptr[ wr ] = (short)RUNB;	                        wr++;	                        m_mtfFreq[ RUNB ]++;	                        break;	                }	                if( zPend < 2 )	                {	                    break;	                }	                zPend = ( zPend - 2 ) / 2;	            }	        }		        m_szptr[ wr ] = (short)EOB;	        wr++;	        m_mtfFreq[ EOB ]++;		        m_nMTF = wr;	    }	
private void hbAssignCodes( int[] code, char[] length, int minLen,	                                int maxLen, int alphaSize )	    {	        int n;	        int vec;	        int i;		        vec = 0;	        for( n = minLen; n <= maxLen; n++ )	        {	            for( i = 0; i < alphaSize; i++ )	            {	                if( length[ i ] == n )	                {	                    code[ i ] = vec;	                    vec++;	                }	            }	            ;	            vec <<= 1;	        }	    }	
private void initBlock()	    {	        //        blockNo++;	        m_crc.initialiseCRC();	        m_last = -1;	        //        ch = 0;		        for( int i = 0; i < 256; i++ )	        {	            m_inUse[ i ] = false;	        }		        /*	         * 20 is just a paranoia constant	         */	        m_allowableBlockSize = BASE_BLOCK_SIZE * m_blockSize100k - 20;	    }	
private void initialize()	        throws IOException	    {	        /*	         * Write `magic' bytes h indicating file-format == huffmanised,	         * followed by a digit indicating blockSize100k.	         */	        bsPutUChar( 'h' );	        bsPutUChar( '0' + m_blockSize100k );		        m_combinedCRC = 0;	    }	
private void mainSort()	    {	        int i;	        int j;	        int ss;	        int sb;	        int[] runningOrder = new int[ 256 ];	        int[] copy = new int[ 256 ];	        boolean[] bigDone = new boolean[ 256 ];	        int c1;	        int c2;		        /*	         * In the various block-sized structures, live data runs	         * from 0 to last+NUM_OVERSHOOT_BYTES inclusive.  First,	         * set up the overshoot area for block.	         */	        //   if (verbosity >= 4) fprintf ( stderr, "        sort initialise ...\n" );	        for( i = 0; i < NUM_OVERSHOOT_BYTES; i++ )	        {	            m_block[ m_last + i + 2 ] = m_block[ ( i % ( m_last + 1 ) ) + 1 ];	        }	        for( i = 0; i <= m_last + NUM_OVERSHOOT_BYTES; i++ )	        {	            m_quadrant[ i ] = 0;	        }		        m_block[ 0 ] = m_block[ m_last + 1 ];		        if( m_last < 4000 )	        {	            /*	             * Use simpleSort(), since the full sorting mechanism	             * has quite a large constant overhead.	             */	            for( i = 0; i <= m_last; i++ )	            {	                m_zptr[ i ] = i;	            }	            m_firstAttempt = false;	            m_workDone = 0;	            m_workLimit = 0;	            simpleSort( 0, m_last, 0 );	        }	        else	        {	            for( i = 0; i <= 255; i++ )	            {	                bigDone[ i ] = false;	            }		            for( i = 0; i <= 65536; i++ )	            {	                m_ftab[ i ] = 0;	            }		            c1 = m_block[ 0 ];	            for( i = 0; i <= m_last; i++ )	            {	                c2 = m_block[ i + 1 ];	                m_ftab[ ( c1 << 8 ) + c2 ]++;	                c1 = c2;	            }		            for( i = 1; i <= 65536; i++ )	            {	                m_ftab[ i ] += m_ftab[ i - 1 ];	            }		            c1 = m_block[ 1 ];	            for( i = 0; i < m_last; i++ )	            {	                c2 = m_block[ i + 2 ];	                j = ( c1 << 8 ) + c2;	                c1 = c2;	                m_ftab[ j ]--;	                m_zptr[ m_ftab[ j ] ] = i;	            }		            j = ( ( m_block[ m_last + 1 ] ) << 8 ) + ( m_block[ 1 ] );	            m_ftab[ j ]--;	            m_zptr[ m_ftab[ j ] ] = m_last;		            /*	             * Now ftab contains the first loc of every small bucket.	             * Calculate the running order, from smallest to largest	             * big bucket.	             */	            for( i = 0; i <= 255; i++ )	            {	                runningOrder[ i ] = i;	            }	            {	                int vv;	                int h = 1;	                do	                {	                    h = 3 * h + 1;	                } while( h <= 256 );	                do	                {	                    h = h / 3;	                    for( i = h; i <= 255; i++ )	                    {	                        vv = runningOrder[ i ];	                        j = i;	                        while( ( m_ftab[ ( ( runningOrder[ j - h ] ) + 1 ) << 8 ]	                            - m_ftab[ ( runningOrder[ j - h ] ) << 8 ] ) >	                            ( m_ftab[ ( ( vv ) + 1 ) << 8 ] - m_ftab[ ( vv ) << 8 ] ) )	                        {	                            runningOrder[ j ] = runningOrder[ j - h ];	                            j = j - h;	                            if( j <= ( h - 1 ) )	                            {	                                break;	                            }	                        }	                        runningOrder[ j ] = vv;	                    }	                } while( h != 1 );	            }		            /*	             * The main sorting loop.	             */	            for( i = 0; i <= 255; i++ )	            {		                /*	                 * Process big buckets, starting with the least full.	                 */	                ss = runningOrder[ i ];		                /*	                 * Complete the big bucket [ss] by quicksorting	                 * any unsorted small buckets [ss, j].  Hopefully	                 * previous pointer-scanning phases have already	                 * completed many of the small buckets [ss, j], so	                 * we don't have to sort them at all.	                 */	                for( j = 0; j <= 255; j++ )	                {	                    sb = ( ss << 8 ) + j;	                    if( !( ( m_ftab[ sb ] & SETMASK ) == SETMASK ) )	                    {	                        int lo = m_ftab[ sb ] & CLEARMASK;	                        int hi = ( m_ftab[ sb + 1 ] & CLEARMASK ) - 1;	                        if( hi > lo )	                        {	                            qSort3( lo, hi, 2 );	                            if( m_workDone > m_workLimit && m_firstAttempt )	                            {	                                return;	                            }	                        }	                        m_ftab[ sb ] |= SETMASK;	                    }	                }		                /*	                 * The ss big bucket is now done.  Record this fact,	                 * and update the quadrant descriptors.  Remember to	                 * update quadrants in the overshoot area too, if	                 * necessary.  The "if (i < 255)" test merely skips	                 * this updating for the last bucket processed, since	                 * updating for the last bucket is pointless.	                 */	                bigDone[ ss ] = true;		                if( i < 255 )	                {	                    int bbStart = m_ftab[ ss << 8 ] & CLEARMASK;	                    int bbSize = ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart;	                    int shifts = 0;		                    while( ( bbSize >> shifts ) > 65534 )	                    {	                        shifts++;	                    }		                    for( j = 0; j < bbSize; j++ )	                    {	                        int a2update = m_zptr[ bbStart + j ];	                        int qVal = ( j >> shifts );	                        m_quadrant[ a2update ] = qVal;	                        if( a2update < NUM_OVERSHOOT_BYTES )	                        {	                            m_quadrant[ a2update + m_last + 1 ] = qVal;	                        }	                    }		                    if( !( ( ( bbSize - 1 ) >> shifts ) <= 65535 ) )	                    {	                        panic();	                    }	                }		                /*	                 * Now scan this big bucket so as to synthesise the	                 * sorted order for small buckets [t, ss] for all t != ss.	                 */	                for( j = 0; j <= 255; j++ )	                {	                    copy[ j ] = m_ftab[ ( j << 8 ) + ss ] & CLEARMASK;	                }		                for( j = m_ftab[ ss << 8 ] & CLEARMASK;	                     j < ( m_ftab[ ( ss + 1 ) << 8 ] & CLEARMASK ); j++ )	                {	                    c1 = m_block[ m_zptr[ j ] ];	                    if( !bigDone[ c1 ] )	                    {	                        m_zptr[ copy[ c1 ] ] = m_zptr[ j ] == 0 ? m_last : m_zptr[ j ] - 1;	                        copy[ c1 ]++;	                    }	                }		                for( j = 0; j <= 255; j++ )	                {	                    m_ftab[ ( j << 8 ) + ss ] |= SETMASK;	                }	            }	        }	    }	
private void makeMaps()	    {	        int i;	        m_nInUse = 0;	        for( i = 0; i < 256; i++ )	        {	            if( m_inUse[ i ] )	            {	                m_seqToUnseq[ m_nInUse ] = (char)i;	                m_unseqToSeq[ i ] = (char)m_nInUse;	                m_nInUse++;	            }	        }	    }	
private char med3( char a, char b, char c )	    {	        char t;	        if( a > b )	        {	            t = a;	            a = b;	            b = t;	        }	        if( b > c )	        {	            t = b;	            b = c;	            c = t;	        }	        if( a > b )	        {	            b = a;	        }	        return b;	    }	
private void moveToFrontCodeAndSend()	        throws IOException	    {	        bsPutIntVS( 24, m_origPtr );	        generateMTFValues();	        sendMTFValues();	    }	
private void qSort3( int loSt, int hiSt, int dSt )	    {	        int unLo;	        int unHi;	        int ltLo;	        int gtHi;	        int med;	        int n;	        int m;	        int sp;	        int lo;	        int hi;	        int d;	        StackElem[] stack = new StackElem[ QSORT_STACK_SIZE ];	        for( int count = 0; count < QSORT_STACK_SIZE; count++ )	        {	            stack[ count ] = new StackElem();	        }		        sp = 0;		        stack[ sp ].m_ll = loSt;	        stack[ sp ].m_hh = hiSt;	        stack[ sp ].m_dd = dSt;	        sp++;		        while( sp > 0 )	        {	            if( sp >= QSORT_STACK_SIZE )	            {	                panic();	            }		            sp--;	            lo = stack[ sp ].m_ll;	            hi = stack[ sp ].m_hh;	            d = stack[ sp ].m_dd;		            if( hi - lo < SMALL_THRESH || d > DEPTH_THRESH )	            {	                simpleSort( lo, hi, d );	                if( m_workDone > m_workLimit && m_firstAttempt )	                {	                    return;	                }	                continue;	            }		            med = med3( m_block[ m_zptr[ lo ] + d + 1 ],	                        m_block[ m_zptr[ hi ] + d + 1 ],	                        m_block[ m_zptr[ ( lo + hi ) >> 1 ] + d + 1 ] );		            unLo = lo;	            ltLo = lo;	            unHi = hi;	            gtHi = hi;		            while( true )	            {	                while( true )	                {	                    if( unLo > unHi )	                    {	                        break;	                    }	                    n = m_block[ m_zptr[ unLo ] + d + 1 ] - med;	                    if( n == 0 )	                    {	                        int temp = 0;	                        temp = m_zptr[ unLo ];	                        m_zptr[ unLo ] = m_zptr[ ltLo ];	                        m_zptr[ ltLo ] = temp;	                        ltLo++;	                        unLo++;	                        continue;	                    }	                    ;	                    if( n > 0 )	                    {	                        break;	                    }	                    unLo++;	                }	                while( true )	                {	                    if( unLo > unHi )	                    {	                        break;	                    }	                    n = m_block[ m_zptr[ unHi ] + d + 1 ] - med;	                    if( n == 0 )	                    {	                        int temp = 0;	                        temp = m_zptr[ unHi ];	                        m_zptr[ unHi ] = m_zptr[ gtHi ];	                        m_zptr[ gtHi ] = temp;	                        gtHi--;	                        unHi--;	                        continue;	                    }	                    ;	                    if( n < 0 )	                    {	                        break;	                    }	                    unHi--;	                }	                if( unLo > unHi )	                {	                    break;	                }	                int temp = 0;	                temp = m_zptr[ unLo ];	                m_zptr[ unLo ] = m_zptr[ unHi ];	                m_zptr[ unHi ] = temp;	                unLo++;	                unHi--;	            }		            if( gtHi < ltLo )	            {	                stack[ sp ].m_ll = lo;	                stack[ sp ].m_hh = hi;	                stack[ sp ].m_dd = d + 1;	                sp++;	                continue;	            }		            n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo );	            vswap( lo, unLo - n, n );	            m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi );	            vswap( unLo, hi - m + 1, m );		            n = lo + unLo - ltLo - 1;	            m = hi - ( gtHi - unHi ) + 1;		            stack[ sp ].m_ll = lo;	            stack[ sp ].m_hh = n;	            stack[ sp ].m_dd = d;	            sp++;		            stack[ sp ].m_ll = n + 1;	            stack[ sp ].m_hh = m - 1;	            stack[ sp ].m_dd = d + 1;	            sp++;		            stack[ sp ].m_ll = m;	            stack[ sp ].m_hh = hi;	            stack[ sp ].m_dd = d;	            sp++;	        }	    }	
private void randomiseBlock()	    {	        int i;	        int rNToGo = 0;	        int rTPos = 0;	        for( i = 0; i < 256; i++ )	        {	            m_inUse[ i ] = false;	        }		        for( i = 0; i <= m_last; i++ )	        {	            if( rNToGo == 0 )	            {	                rNToGo = (char)RAND_NUMS[ rTPos ];	                rTPos++;	                if( rTPos == 512 )	                {	                    rTPos = 0;	                }	            }	            rNToGo--;	            m_block[ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 );	            // handle 16 bit signed numbers	            m_block[ i + 1 ] &= 0xFF;		            m_inUse[ m_block[ i + 1 ] ] = true;	        }	    }	
private void sendMTFValues()	        throws IOException	    {	        char[][] len = new char[ N_GROUPS ][ MAX_ALPHA_SIZE ];		        int v;		        int t;		        int i;		        int j;		        int gs;		        int ge;		        int bt;		        int bc;		        int iter;	        int nSelectors = 0;	        int alphaSize;	        int minLen;	        int maxLen;	        int selCtr;	        int nGroups;		        alphaSize = m_nInUse + 2;	        for( t = 0; t < N_GROUPS; t++ )	        {	            for( v = 0; v < alphaSize; v++ )	            {	                len[ t ][ v ] = (char)GREATER_ICOST;	            }	        }		        /*	         * Decide how many coding tables to use	         */	        if( m_nMTF <= 0 )	        {	            panic();	        }		        if( m_nMTF < 200 )	        {	            nGroups = 2;	        }	        else if( m_nMTF < 600 )	        {	            nGroups = 3;	        }	        else if( m_nMTF < 1200 )	        {	            nGroups = 4;	        }	        else if( m_nMTF < 2400 )	        {	            nGroups = 5;	        }	        else	        {	            nGroups = 6;	        }	        {	            /*	             * Generate an initial set of coding tables	             */	            int nPart;	            int remF;	            int tFreq;	            int aFreq;		            nPart = nGroups;	            remF = m_nMTF;	            gs = 0;	            while( nPart > 0 )	            {	                tFreq = remF / nPart;	                ge = gs - 1;	                aFreq = 0;	                while( aFreq < tFreq && ge < alphaSize - 1 )	                {	                    ge++;	                    aFreq += m_mtfFreq[ ge ];	                }		                if( ge > gs && nPart != nGroups && nPart != 1	                    && ( ( nGroups - nPart ) % 2 == 1 ) )	                {	                    aFreq -= m_mtfFreq[ ge ];	                    ge--;	                }		                for( v = 0; v < alphaSize; v++ )	                {	                    if( v >= gs && v <= ge )	                    {	                        len[ nPart - 1 ][ v ] = (char)LESSER_ICOST;	                    }	                    else	                    {	                        len[ nPart - 1 ][ v ] = (char)GREATER_ICOST;	                    }	                }		                nPart--;	                gs = ge + 1;	                remF -= aFreq;	            }	        }		        int[][] rfreq = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];	        int[] fave = new int[ N_GROUPS ];	        short[] cost = new short[ N_GROUPS ];	        /*	         * Iterate up to N_ITERS times to improve the tables.	         */	        for( iter = 0; iter < N_ITERS; iter++ )	        {	            for( t = 0; t < nGroups; t++ )	            {	                fave[ t ] = 0;	            }		            for( t = 0; t < nGroups; t++ )	            {	                for( v = 0; v < alphaSize; v++ )	                {	                    rfreq[ t ][ v ] = 0;	                }	            }		            nSelectors = 0;	            gs = 0;	            while( true )	            {		                /*	                 * Set group start & end marks.	                 */	                if( gs >= m_nMTF )	                {	                    break;	                }	                ge = gs + G_SIZE - 1;	                if( ge >= m_nMTF )	                {	                    ge = m_nMTF - 1;	                }		                /*	                 * Calculate the cost of this group as coded	                 * by each of the coding tables.	                 */	                for( t = 0; t < nGroups; t++ )	                {	                    cost[ t ] = 0;	                }		                if( nGroups == 6 )	                {	                    short cost0 = 0;	                    short cost1 = 0;	                    short cost2 = 0;	                    short cost3 = 0;	                    short cost4 = 0;	                    short cost5 = 0;		                    for( i = gs; i <= ge; i++ )	                    {	                        short icv = m_szptr[ i ];	                        cost0 += len[ 0 ][ icv ];	                        cost1 += len[ 1 ][ icv ];	                        cost2 += len[ 2 ][ icv ];	                        cost3 += len[ 3 ][ icv ];	                        cost4 += len[ 4 ][ icv ];	                        cost5 += len[ 5 ][ icv ];	                    }	                    cost[ 0 ] = cost0;	                    cost[ 1 ] = cost1;	                    cost[ 2 ] = cost2;	                    cost[ 3 ] = cost3;	                    cost[ 4 ] = cost4;	                    cost[ 5 ] = cost5;	                }	                else	                {	                    for( i = gs; i <= ge; i++ )	                    {	                        short icv = m_szptr[ i ];	                        for( t = 0; t < nGroups; t++ )	                        {	                            cost[ t ] += len[ t ][ icv ];	                        }	                    }	                }		                /*	                 * Find the coding table which is best for this group,	                 * and record its identity in the selector table.	                 */	                bc = 999999999;	                bt = -1;	                for( t = 0; t < nGroups; t++ )	                {	                    if( cost[ t ] < bc )	                    {	                        bc = cost[ t ];	                        bt = t;	                    }	                }	                ;	                fave[ bt ]++;	                m_selector[ nSelectors ] = (char)bt;	                nSelectors++;		                /*	                 * Increment the symbol frequencies for the selected table.	                 */	                for( i = gs; i <= ge; i++ )	                {	                    rfreq[ bt ][ m_szptr[ i ] ]++;	                }		                gs = ge + 1;	            }		            /*	             * Recompute the tables based on the accumulated frequencies.	             */	            for( t = 0; t < nGroups; t++ )	            {	                hbMakeCodeLengths( len[ t ], rfreq[ t ], alphaSize, 20 );	            }	        }		        rfreq = null;	        fave = null;	        cost = null;		        if( !( nGroups < 8 ) )	        {	            panic();	        }	        if( !( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) )	        {	            panic();	        }	        {	            /*	             * Compute MTF values for the selectors.	             */	            char[] pos = new char[ N_GROUPS ];	            char ll_i;	            char tmp2;	            char tmp;	            for( i = 0; i < nGroups; i++ )	            {	                pos[ i ] = (char)i;	            }	            for( i = 0; i < nSelectors; i++ )	            {	                ll_i = m_selector[ i ];	                j = 0;	                tmp = pos[ j ];	                while( ll_i != tmp )	                {	                    j++;	                    tmp2 = tmp;	                    tmp = pos[ j ];	                    pos[ j ] = tmp2;	                }	                pos[ 0 ] = tmp;	                m_selectorMtf[ i ] = (char)j;	            }	        }		        int[][] code = new int[ N_GROUPS ][ MAX_ALPHA_SIZE ];		        /*	         * Assign actual codes for the tables.	         */	        for( t = 0; t < nGroups; t++ )	        {	            minLen = 32;	            maxLen = 0;	            for( i = 0; i < alphaSize; i++ )	            {	                if( len[ t ][ i ] > maxLen )	                {	                    maxLen = len[ t ][ i ];	                }	                if( len[ t ][ i ] < minLen )	                {	                    minLen = len[ t ][ i ];	                }	            }	            if( maxLen > 20 )	            {	                panic();	            }	            if( minLen < 1 )	            {	                panic();	            }	            hbAssignCodes( code[ t ], len[ t ], minLen, maxLen, alphaSize );	        }	        {	            /*	             * Transmit the mapping table.	             */	            boolean[] inUse16 = new boolean[ 16 ];	            for( i = 0; i < 16; i++ )	            {	                inUse16[ i ] = false;	                for( j = 0; j < 16; j++ )	                {	                    if( m_inUse[ i * 16 + j ] )	                    {	                        inUse16[ i ] = true;	                    }	                }	            }		            for( i = 0; i < 16; i++ )	            {	                if( inUse16[ i ] )	                {	                    bsW( 1, 1 );	                }	                else	                {	                    bsW( 1, 0 );	                }	            }		            for( i = 0; i < 16; i++ )	            {	                if( inUse16[ i ] )	                {	                    for( j = 0; j < 16; j++ )	                    {	                        if( m_inUse[ i * 16 + j ] )	                        {	                            bsW( 1, 1 );	                        }	                        else	                        {	                            bsW( 1, 0 );	                        }	                    }	                }	            }		        }		        /*	         * Now the selectors.	         */	        bsW( 3, nGroups );	        bsW( 15, nSelectors );	        for( i = 0; i < nSelectors; i++ )	        {	            for( j = 0; j < m_selectorMtf[ i ]; j++ )	            {	                bsW( 1, 1 );	            }	            bsW( 1, 0 );	        }		        for( t = 0; t < nGroups; t++ )	        {	            int curr = len[ t ][ 0 ];	            bsW( 5, curr );	            for( i = 0; i < alphaSize; i++ )	            {	                while( curr < len[ t ][ i ] )	                {	                    bsW( 2, 2 );	                    curr++;	                    /*	                     * 10	                     */	                }	                while( curr > len[ t ][ i ] )	                {	                    bsW( 2, 3 );	                    curr--;	                    /*	                     * 11	                     */	                }	                bsW( 1, 0 );	            }	        }		        /*	         * And finally, the block data proper	         */	        selCtr = 0;	        gs = 0;	        while( true )	        {	            if( gs >= m_nMTF )	            {	                break;	            }	            ge = gs + G_SIZE - 1;	            if( ge >= m_nMTF )	            {	                ge = m_nMTF - 1;	            }	            for( i = gs; i <= ge; i++ )	            {	                bsW( len[ m_selector[ selCtr ] ][ m_szptr[ i ] ],	                     code[ m_selector[ selCtr ] ][ m_szptr[ i ] ] );	            }		            gs = ge + 1;	            selCtr++;	        }	        if( !( selCtr == nSelectors ) )	        {	            panic();	        }	    }	
private void simpleSort( int lo, int hi, int d )	    {	        int i;	        int j;	        int h;	        int bigN;	        int hp;	        int v;		        bigN = hi - lo + 1;	        if( bigN < 2 )	        {	            return;	        }		        hp = 0;	        while( m_incs[ hp ] < bigN )	        {	            hp++;	        }	        hp--;		        for( ; hp >= 0; hp-- )	        {	            h = m_incs[ hp ];		            i = lo + h;	            while( true )	            {	                /*	                 * copy 1	                 */	                if( i > hi )	                {	                    break;	                }	                v = m_zptr[ i ];	                j = i;	                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )	                {	                    m_zptr[ j ] = m_zptr[ j - h ];	                    j = j - h;	                    if( j <= ( lo + h - 1 ) )	                    {	                        break;	                    }	                }	                m_zptr[ j ] = v;	                i++;		                /*	                 * copy 2	                 */	                if( i > hi )	                {	                    break;	                }	                v = m_zptr[ i ];	                j = i;	                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )	                {	                    m_zptr[ j ] = m_zptr[ j - h ];	                    j = j - h;	                    if( j <= ( lo + h - 1 ) )	                    {	                        break;	                    }	                }	                m_zptr[ j ] = v;	                i++;		                /*	                 * copy 3	                 */	                if( i > hi )	                {	                    break;	                }	                v = m_zptr[ i ];	                j = i;	                while( fullGtU( m_zptr[ j - h ] + d, v + d ) )	                {	                    m_zptr[ j ] = m_zptr[ j - h ];	                    j = j - h;	                    if( j <= ( lo + h - 1 ) )	                    {	                        break;	                    }	                }	                m_zptr[ j ] = v;	                i++;		                if( m_workDone > m_workLimit && m_firstAttempt )	                {	                    return;	                }	            }	        }	    }	
private void vswap( int p1, int p2, int n )	    {	        int temp = 0;	        while( n > 0 )	        {	            temp = m_zptr[ p1 ];	            m_zptr[ p1 ] = m_zptr[ p2 ];	            m_zptr[ p2 ] = temp;	            p1++;	            p2++;	            n--;	        }	    }	
private void writeRun()	        throws IOException	    {	        if( m_last < m_allowableBlockSize )	        {	            m_inUse[ m_currentChar ] = true;	            for( int i = 0; i < m_runLength; i++ )	            {	                m_crc.updateCRC( (char)m_currentChar );	            }	            switch( m_runLength )	            {	                case 1:	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    break;	                case 2:	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    break;	                case 3:	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    break;	                default:	                    m_inUse[ m_runLength - 4 ] = true;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)m_currentChar;	                    m_last++;	                    m_block[ m_last + 1 ] = (char)( m_runLength - 4 );	                    break;	            }	        }	        else	        {	            endBlock();	            initBlock();	            writeRun();	        }	    }	
public ConsoleInstall()		{			installer = new Install();				String appName = installer.getProperty("app.name");			String appVersion = installer.getProperty("app.version");				BufferedReader in = new BufferedReader(new InputStreamReader(				System.in));				System.out.println("*** " + appName + " " + appVersion + " installer");				OperatingSystem os = OperatingSystem.getOperatingSystem();				String installDir = os.getInstallDirectory(appName,appVersion);				System.out.print("Installation directory: [" + installDir + "] ");			System.out.flush();				String _installDir = readLine(in);			if(_installDir.length() != 0)				installDir = _installDir;			else 				System.out.println("Will use default");						OperatingSystem.OSTask[] osTasks = os.getOSTasks(installer);				for(int i = 0; i < osTasks.length; i++)			{				OperatingSystem.OSTask osTask = osTasks[i];				String label = osTask.getLabel();				// label == null means no configurable options				if(label != null)				{					String dir = osTask.getDirectory();					System.out.print(label + " [" + dir + "] ");					System.out.flush();						dir = readLine(in);					osTask.setEnabled(true);					if(dir.length() != 0)					{						if(dir.equals("off"))							osTask.setEnabled(false);						else							osTask.setDirectory(dir);					}					else						System.out.println("will use default");				}			}				int compCount = installer.getIntegerProperty("comp.count");			Vector components = new Vector(compCount);				System.out.println("*** Program components to install");			for(int i = 0; i < compCount; i++)			{				String fileset = installer.getProperty("comp." + i + ".fileset");					String osDep = installer.getProperty("comp." + i + ".os");				if(osDep != null)				{					if(!os.getClass().getName().endsWith(osDep))					{						continue;					}				}					System.out.print("Install "					+ installer.getProperty("comp." + i + ".name")					+ " ("					+ installer.getProperty("comp." + i + ".disk-size")					+ "Kb) [Y/n]? ");					String line = readLine(in);				if(line.length() == 0 || line.charAt(0) == 'y'					|| line.charAt(0) == 'Y')					components.addElement(fileset);			}				System.out.println("*** Starting installation...");			ConsoleProgress progress = new ConsoleProgress();			InstallThread thread = new InstallThread(				installer,progress,installDir,osTasks,				0 /* XXX */,components);			thread.start();		}	
private String readLine(BufferedReader in)		{			try			{				String line = in.readLine();				if(line == null)				{					System.err.println("\nEOF in input!");					System.exit(1);					// can't happen					throw new InternalError();				}				return line;			}			catch(IOException io)			{				System.err.println("\nI/O error: " + io);				System.exit(1);				// can't happen				throw new InternalError();			}		}	
public void setMaximum(int max)		{		}	
public void advance(int value)		{		}	
public void done()		{			System.out.println("*** Installation complete");		}	
public void message(String message)		{			System.out.println(message);		}	
public void error(String message)		{			System.err.println("*** An error occurred: " + message);		}	
protected CRC()	    {	        initialiseCRC();	    }	
int getFinalCRC()	    {	        return ~m_globalCrc;	    }	
void initialiseCRC()	    {	        m_globalCrc = 0xffffffff;	    }	
void updateCRC( final int inCh )	    {	        int temp = ( m_globalCrc >> 24 ) ^ inCh;	        if( temp < 0 )	        {	            temp = 256 + temp;	        }	        m_globalCrc = ( m_globalCrc << 8 ) ^ CRC32_TABLE[ temp ];	    }	
public static void main(String[] args)		{						String javaVersion = System.getProperty("java.version");			if(javaVersion.compareTo("1.5") < 0)			{				String message = "You are running Java version "						+ javaVersion + " from "+System.getProperty("java.vendor")+".\n"						+"This installer requires Java 1.5 or later.";				if(args.length == 0)				{					JOptionPane.showMessageDialog(null,						message,						"jEdit installer...", JOptionPane.ERROR_MESSAGE); 				}				else				{					System.err.println(message);				}				System.exit(1);			}				if(args.length == 0)				new SwingInstall();			else if(args.length == 1 && args[0].equals("text"))				new ConsoleInstall();			else if(args.length >= 2 && args[0].equals("auto"))				new NonInteractiveInstall(args);			else			{				System.err.println("Usage:");				System.err.println("java -jar <installer JAR>");				System.err.println("java -jar <installer JAR> text");				System.err.println("java -jar <installer JAR> auto"					+ " <install dir> [unix-script=<dir>] [unix-man=<dir>]");				System.err.println("text parameter starts installer in text-only mode.");				System.err.println("auto parameter starts installer in non-interactive mode.");			}		}	
public Install()		{			props = new Properties();			try			{				InputStream in = getClass().getResourceAsStream("/installer/install.props");				props.load(in);				in.close();			}			catch(IOException io)			{				System.err.println("Error loading 'install.props':");				io.printStackTrace();			}				buf = new byte[32768];		}	
public String getProperty(String name)		{			return props.getProperty(name);		}	
public int getIntegerProperty(String name)		{			try			{				return Integer.parseInt(props.getProperty(name));			}			catch(Exception e)			{				return -1;			}		}	
public void copy(InputStream in, String outfile, Progress progress)			throws IOException		{			File outFile = new File(outfile);				OperatingSystem.getOperatingSystem().mkdirs(outFile.getParent());				BufferedOutputStream out = new BufferedOutputStream(				new FileOutputStream(outFile));				int count;				for(;;)			{				count = in.read(buf,0,Math.min(in.available(),buf.length));				if(count == -1 || count == 0)					break;					out.write(buf,0,count);				if(progress != null)					progress.advance(count);			}				//in.close();			out.close();		}	
public InstallThread(Install installer, Progress progress,			String installDir, OperatingSystem.OSTask[] osTasks,			int size, Vector components)		{			super("Install thread");				this.installer = installer;			this.progress = progress;			this.installDir = installDir;			this.osTasks = osTasks;			this.size = size;			this.components = components;		}	
public void run()		{			progress.setMaximum(size * 1024);						//return value ignored : already signalled in ServerKiller			progress.message("stopping any jEdit server");			ServerKiller.quitjEditServer();						try			{				// install user-selected packages				for(int i = 0; i < components.size(); i++)				{					String comp = (String)components.elementAt(i);					progress.message("Installing " + comp);					installComponent(comp);				}					// do operating system specific stuff (creating startup				// scripts, installing man pages, etc.)				for(int i = 0; i < osTasks.length; i++)				{					progress.message("Performing task " +						osTasks[i].getName());					osTasks[i].perform(installDir,components);				}			}			catch(FileNotFoundException fnf)			{				progress.error("The installer could not create the "					+ "destination directory.\n"					+ "Maybe you do not have write permission?");				return;			}			catch(IOException io)			{				progress.error(io.toString());				return;			}				progress.done();		}	
private void installComponent(String name) throws IOException		{			InputStream in = new BufferedInputStream(				getClass().getResourceAsStream(name + ".tar.bz2"));			// skip header bytes			// maybe should check if they're valid or not?			in.read();			in.read();				TarInputStream tarInput = new TarInputStream(				new CBZip2InputStream(in));			TarEntry entry;			while((entry = tarInput.getNextEntry()) != null)			{				if(entry.isDirectory())					continue;				String fileName = entry.getName();				//System.err.println(fileName);				String outfile = installDir + File.separatorChar					+ fileName.replace('/',File.separatorChar);				installer.copy(tarInput,outfile,progress);			}				tarInput.close();		}	
public		InvalidHeaderException()			{			super();			}	
public		InvalidHeaderException( String msg )			{			super( msg );			}	
public NonInteractiveInstall(String[] args)		{			String installDir = args[1];				installer = new Install();				OperatingSystem os = OperatingSystem.getOperatingSystem();			OperatingSystem.OSTask[] osTasks = os.getOSTasks(installer);				for(int i = 2; i < args.length; i++)			{				String arg = args[i];				int index = arg.indexOf('=');				if(index == -1)				{					System.err.println("Invalid parameter: " + arg);					continue;				}					String taskName = arg.substring(0,index);				String taskDir = arg.substring(index + 1);				for(int j = 0; j < osTasks.length; j++)				{					OperatingSystem.OSTask osTask = osTasks[j];					if(osTask.getName().equals(taskName))					{						if(taskDir.equals("off"))							osTask.setEnabled(false);						else						{							osTask.setEnabled(true);							osTask.setDirectory(taskDir);						}						break;					}				}			}				int compCount = installer.getIntegerProperty("comp.count");			Vector components = new Vector(compCount);				for(int i = 0; i < compCount; i++)			{				String fileset = installer.getProperty("comp." + i + ".fileset");					String osDep = installer.getProperty("comp." + i + ".os");				if(osDep != null)				{					if(!os.getClass().getName().endsWith(osDep))					{						continue;					}				}					components.addElement(fileset);			}				//				ConsoleProgress progress = new ConsoleProgress();			InstallThread thread = new InstallThread(				installer,progress,installDir,osTasks,				0 /* XXX */,components);			thread.start();		}	
public OSTask(Install installer, String name)			{				this.installer = installer;				this.name = name;				this.label = installer.getProperty("ostask." + name + ".label");				this.directory = getDefaultDirectory(installer);					// on by default				enabled = true;			}	
public String getName()			{				return name;			}	
public String getLabel()			{				return label;			}	
public String getDefaultDirectory(Install installer)			{				return null;			}	
public String getDirectory()			{				return directory;			}	
public boolean isEnabled()			{				return enabled;			}	
public void setEnabled(boolean enabled)			{				this.enabled = enabled;			}	
public void setDirectory(String directory)			{				this.directory = directory;			}	
public OSTask[] getOSTasks(Install installer)		{			return new OSTask[0];		}	
public void mkdirs(String directory) throws IOException		{			File file = new File(directory);			if(!file.exists())				file.mkdirs();		}	
public static OperatingSystem getOperatingSystem()		{			if(os != null)				return os;				if(System.getProperty("mrj.version") != null)			{				os = new MacOS();			}			else			{				String osName = System.getProperty("os.name");				if(osName.indexOf("Windows") != -1)					os = new Windows();				else if(osName.indexOf("OS/2") != -1)					os = new HalfAnOS();				else if(osName.indexOf("VMS") != -1)					os = new VMS();				else					os = new Unix();			}				return os;		}	
public String getInstallDirectory(String name, String version)			{				String dir = "/usr/local/share/";				if(!new File(dir).canWrite())				{					dir = System.getProperty("user.home");				}					return new File(dir,name.toLowerCase() + "/" + version).getPath();			}	
public String getExtraClassPath()			{				return "";			}	
public ScriptOSTask(Install installer)				{					super(installer,"unix-script");				}	
public String getDefaultDirectory(Install installer)				{					String dir = "/usr/local/";					if(!new File(dir).canWrite())					{						dir = System.getProperty("user.home");					}						return new File(dir,"bin").getPath();				}	
public void perform(String installDir,					Vector filesets) throws IOException				{					if(!enabled)					{						return;					}						mkdirs(directory);						String name = installer.getProperty("app.name");						// create app start script					String script = directory + File.separatorChar						+ name.toLowerCase();						// Delete existing copy					new File(script).delete();						// Write simple script					FileWriter out = new FileWriter(script);					out.write("#!/bin/sh\n");					out.write("#\n");					out.write("# Runs jEdit - Programmer's Text Editor.\n");					out.write("#\n");					out.write("\n");					out.write("# Set jvm heap initial and maximum sizes (in megabytes).\n");					out.write("JAVA_HEAP_MAX_SIZE=192\n");					out.write("\n");					out.write("DEFAULT_JAVA_HOME=\""						+ System.getProperty("java.home")						+ "\"\n");					out.write("if [ -z \"$JAVA_HOME\" ]; then\n");					out.write("\tJAVA_HOME=\"$DEFAULT_JAVA_HOME\"\n");					out.write("fi\n");					out.write("\n");					out.write("# Launch application.\n");					out.write("\n");										String jar = "\""+ installDir + File.separator						+ name.toLowerCase() + ".jar"+"\"";		                	 				out.write("exec \"$JAVA_HOME/bin/java\"" +	 					  " -Xmx${JAVA_HEAP_MAX_SIZE}M -jar " +						  jar + " \"$@\"\n");					out.close();						// Make it executable					String[] chmodArgs = { "chmod", "755", script };					exec(chmodArgs);				}	
public ManPageOSTask(Install installer)				{					super(installer,"unix-man");				}	
public String getDefaultDirectory(Install installer)				{					String dir = "/usr/local/";					if(!new File(dir).canWrite())						dir = System.getProperty("user.home");						return new File(dir,"man/man1").getPath();				}	
public void perform(String installDir,					Vector filesets) throws IOException				{					if(!enabled)						return;						mkdirs(directory);						String name = installer.getProperty("app.name");						// install man page					String manpage = installer.getProperty("ostask.unix-man.manpage");						InputStream in = getClass().getResourceAsStream("/" + manpage);					installer.copy(in,new File(directory,manpage).getPath(),						null);				}	
public OSTask[] getOSTasks(Install installer)			{				return new OSTask[] { new ScriptOSTask(installer),					new ManPageOSTask(installer) };			}	
public void mkdirs(String directory) throws IOException			{				File file = new File(directory);				if(!file.exists())				{					String[] mkdirArgs = { "mkdir", "-m", "755",						"-p", directory };					exec(mkdirArgs);				}			}	
public void exec(String[] args) throws IOException			{				Process proc = Runtime.getRuntime().exec(args);				proc.getInputStream().close();				proc.getOutputStream().close();				proc.getErrorStream().close();				try				{					proc.waitFor();				}				catch(InterruptedException ie)				{				}			}	
public String getInstallDirectory(String name, String version)			{				return "/Applications/" + name + " " + version;			}	
public String getExtraClassPath()			{				return "/System/Library/Java/:";			}	
public String getInstallDirectory(String name, String version)			{				String programDir = System.getenv("ProgramFiles");				// Here is a workaround for the case that the environment				// variable is not defined. Windows 98 and ME are known as				// such environments. This makes sense while jEdit supports				// JRE 5. JRE 6 doesn't support Windows 98 and ME.				if(programDir == null)				{					// This is a hint for what is needed here.					programDir = "%ProgramFiles%";				}				return programDir + "\\" + name + " " + version;			}	
public JEditLauncherOSTask(Install installer)				{					super(installer,"jedit-launcher");				}	
public String getDefaultDirectory(Install installer)				{					return null;				}	
public void perform(String installDir,					Vector filesets)				{					if(!enabled						|| !filesets.contains("jedit-windows"))						return;						// run jEditLauncher installation					File executable = new File(installDir,"jedit.exe");					if(!executable.exists())						return;						String[] args = { executable.getPath(), "/i",						System.getProperty("java.home")						+ File.separator						+ "bin" };						try					{						Runtime.getRuntime().exec(args).waitFor();					}					catch(IOException io)					{					}					catch(InterruptedException ie)					{					}				}	
public OSTask[] getOSTasks(Install installer)			{				return new OSTask[] { /* new JEditLauncherOSTask(installer) */ };			}	
public String getInstallDirectory(String name, String version)			{				return "C:\\" + name + " " + version;			}	
public String getInstallDirectory(String name, String version)			{				return "./" + name.toLowerCase() + "/" + version;			}	
/**		 * try to contact a running instance of jEdit Server		 * and ask it to close.		 * @return	true	either if no server was detected, or the server was shut-down,		 *		false otherwise		 */		public static boolean quitjEditServer()		{						/* {{{ default server file location */			String settingsDirectory = System.getProperty("user.home");			File portFile;			File f = new File(settingsDirectory);			portFile = new File(f,".jedit/server");			/* }}} */						if(portFile.exists())			{				try				{					BufferedReader in = new BufferedReader(new FileReader(portFile));					String check = in.readLine();					if(!check.equals("b"))					{						System.out.println("Wrong port file format");						return false;					}	 					int port = Integer.parseInt(in.readLine());					int key = Integer.parseInt(in.readLine());						Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),port);					DataOutputStream out = new DataOutputStream(						socket.getOutputStream());					out.writeInt(key);						// we can't close the socket cleanly, because we want					// to wait for complete exit, and then it's too late.					// so the socket is closed when the JVM is shut down.					String script;						script = "jEdit.exit(null,true);\n";						out.writeUTF(script);						// block until its closed					try					{						socket.getInputStream().read();					}					catch(Exception e)					{						//should get an exception !					}						in.close();					out.close();				}				catch(FileNotFoundException fnfe)				{					//it exists : we checked that earlier !				}				catch(UnknownHostException uhe)				{					//localhost doesn't exist ?				}				catch(IOException ioe)				{					System.out.println("Exception while trying to connect to existing server:");					System.out.println(ioe);					System.out.println("Don't worry too much !");					return false; //warn the user				}			}			return true;		}	
/**		 * try to connect to any running server instance and close it.		 * exit with an error code on failure, but not if no server was found.		 */		public static void main(String[] args)		{			boolean success = quitjEditServer();			if(!success)			{				System.exit(-1);			}		}	
public SwingInstall()		{			installer = new Install();			osTasks = OperatingSystem.getOperatingSystem().getOSTasks(installer);				appName = installer.getProperty("app.name");			appVersion = installer.getProperty("app.version");				setTitle(appName + " " + appVersion + " installer");				JPanel content = new JPanel(new WizardLayout());			setContentPane(content);				caption = new JLabel();			caption.setFont(new Font("SansSerif",Font.BOLD,18));				ActionHandler actionHandler = new ActionHandler();				cancelButton = new JButton("Cancel");			cancelButton.setRequestFocusEnabled(false);			cancelButton.addActionListener(actionHandler);			prevButton = new JButton("Previous");			prevButton.setRequestFocusEnabled(false);			prevButton.addActionListener(actionHandler);			nextButton = new JButton();			nextButton.setRequestFocusEnabled(false);			nextButton.addActionListener(actionHandler);				content.add(caption);			content.add(cancelButton);			content.add(prevButton);			content.add(nextButton);				String clazz = OperatingSystem.getOperatingSystem()					.getClass().getName();			String completedInfo = "done-" + clazz.substring(				clazz.indexOf('$') + 1) + ".html";				pages = new Component[] {				new TextPanel(installer.getProperty("app.readme")),				new TextPanel(installer.getProperty("app.license")),				chooseDirectory = new ChooseDirectory(),				selectComponents = new SelectComponents(),				progress = new SwingProgress(),				new TextPanel(completedInfo)			};				for(int i = 0; i < pages.length; i++)				content.add(pages[i]);				pageChanged();				setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);			addWindowListener(new WindowHandler());				Dimension screen = getToolkit().getScreenSize();			pack();			setLocation((screen.width - getSize().width) / 2,				(screen.height - getSize().height) / 2);			setVisible(true);		}	
void install()		{			Vector components = new Vector();			int size = 0;				JPanel comp = selectComponents.comp;			Vector ids = selectComponents.filesets;				for(int i = 0; i < comp.getComponentCount(); i++)			{				if(((JCheckBox)comp.getComponent(i))					.getModel().isSelected())				{					size += installer.getIntegerProperty(						"comp." + ids.elementAt(i) + ".real-size");					components.addElement(installer.getProperty(						"comp." + ids.elementAt(i) + ".fileset"));				}			}				String installDir = chooseDirectory.installDir.getText();				Map osTaskDirs = chooseDirectory.osTaskDirs;			Iterator keys = osTaskDirs.keySet().iterator();			while(keys.hasNext())			{				OperatingSystem.OSTask osTask = (OperatingSystem.OSTask)keys.next();				String dir = ((JTextField)osTaskDirs.get(osTask)).getText();				if(dir != null && dir.trim().length() != 0)				{					osTask.setEnabled(true);					osTask.setDirectory(dir);				}				else					osTask.setEnabled(false);			}				InstallThread thread = new InstallThread(				installer,progress,				installDir,osTasks,				size,components);			progress.setThread(thread);			thread.start();		}	
private void pageChanged()		{			switch(currentPage)			{			case 0:				caption.setText("Installing " + appName);					nextButton.setText("Next");				prevButton.setEnabled(false);				nextButton.setEnabled(true);				break;			case 1:				caption.setText(installer.getProperty("app.license.title"));					nextButton.setText("Next");				prevButton.setEnabled(true);				nextButton.setEnabled(true);				break;			case 2:				caption.setText("Specify where " + appName					+ " is to be installed");					nextButton.setText("Next");				prevButton.setEnabled(true);				if(!chooseDirectory.isOK())nextButton.setEnabled(false);				break;			case 3:				caption.setText("Choose components to install");					nextButton.setText("Install");				prevButton.setEnabled(true);				nextButton.setEnabled(true);				break;			case 4:				caption.setText("Installing " + appName);					nextButton.setText("Finish");				prevButton.setEnabled(false);				nextButton.setEnabled(false);				install();				break;			case 5:				caption.setText("Installation complete");					nextButton.setText("Finish");				prevButton.setEnabled(false);				nextButton.setEnabled(true);				cancelButton.setEnabled(false);				break;			}				getRootPane().invalidate();			getRootPane().validate();		}	
public void actionPerformed(ActionEvent evt)			{				Object source = evt.getSource();				if(source == cancelButton)					System.exit(0);				else if(source == prevButton)				{					currentPage--;					pageChanged();				}				else if(source == nextButton)				{					if(currentPage == pages.length - 1)						System.exit(0);					else					{						currentPage++;						pageChanged();					}				}			}	
public void windowClosing(WindowEvent evt)			{				System.exit(0);			}	
public void addLayoutComponent(String name, Component comp)			{			}	
public void removeLayoutComponent(Component comp)			{			}	
public Dimension preferredLayoutSize(Container parent)			{				Dimension dim = new Dimension();					Dimension captionSize = caption.getPreferredSize();				dim.width = captionSize.width;					for(int i = 0; i < pages.length; i++)				{					Dimension _dim = pages[i].getPreferredSize();					dim.width = Math.max(_dim.width,dim.width);					dim.height = Math.max(_dim.height,dim.height);				}					dim.width += PADDING * 2;				dim.height += PADDING * 2;				dim.height += nextButton.getPreferredSize().height;				dim.height += captionSize.height;				return dim;			}	
public Dimension minimumLayoutSize(Container parent)			{				return preferredLayoutSize(parent);			}	
public void layoutContainer(Container parent)			{				Dimension size = parent.getSize();					Dimension captionSize = caption.getPreferredSize();				caption.setBounds(PADDING,PADDING,captionSize.width,					captionSize.height);					// make all buttons the same size				Dimension buttonSize = cancelButton.getPreferredSize();				buttonSize.width = Math.max(buttonSize.width,prevButton.getPreferredSize().width);				buttonSize.width = Math.max(buttonSize.width,nextButton.getPreferredSize().width);					// cancel button goes on far left				cancelButton.setBounds(					PADDING,					size.height - buttonSize.height - PADDING,					buttonSize.width,					buttonSize.height);					// prev and next buttons are on the right				prevButton.setBounds(					size.width - buttonSize.width * 2 - 6 - PADDING,					size.height - buttonSize.height - PADDING,					buttonSize.width,					buttonSize.height);					nextButton.setBounds(					size.width - buttonSize.width - PADDING,					size.height - buttonSize.height - PADDING,					buttonSize.width,					buttonSize.height);					// calculate size for current page				Rectangle currentPageBounds = new Rectangle();				currentPageBounds.x = PADDING;				currentPageBounds.y = PADDING * 2 + captionSize.height;				currentPageBounds.width = size.width - currentPageBounds.x					- PADDING;				currentPageBounds.height = size.height - buttonSize.height					- currentPageBounds.y - PADDING * 2;					for(int i = 0; i < pages.length; i++)				{					Component page = pages[i];					page.setBounds(currentPageBounds);					page.setVisible(i == currentPage);				}			}	
TextPanel(String file)			{				super(new BorderLayout());					JEditorPane text = new JEditorPane();					try				{					text.setPage(TextPanel.this.getClass().getResource(file));				}				catch(Exception e)				{					text.setText("Error loading '" + file + "'");					e.printStackTrace();				}					text.setEditable(false);					JScrollPane scrollPane = new JScrollPane(text);				Dimension dim = new Dimension();				dim.width = 450;				dim.height = 200;				scrollPane.setPreferredSize(dim);				TextPanel.this.add(BorderLayout.CENTER,scrollPane);			}	
public DirVerifier(JComponent parent, Object pos)			{				super();				message = new JTextArea(" ");				message.setEditable(false);				message.setBackground(parent.getBackground());				this.parent = parent;				this.pos = pos;			}	
public boolean shouldYieldFocus(JComponent input)			{				return verify(input);			}	
public boolean verify(JComponent input)			{				if(input instanceof JTextComponent)				{					String dir = ((JTextComponent)input).getText();					if(checkNull(dir) &&						checkExistNotDirectory(dir) &&						checkExistNotEmpty(dir) &&						checkRelative(dir))					{						//everything is perfect, clean label						if(message.getParent()!=null)						{							SwingUtilities.invokeLater(new Runnable()								{									public void run()									{										parent.remove(message);										parent.revalidate();										parent.repaint();									}								});						}					}					else					{						if(message.getParent()==null)						{							SwingUtilities.invokeLater(new Runnable()								{									public void run()									{										parent.add(message,pos);										parent.revalidate();										parent.repaint();									}								});						}						else message.repaint();					}				}				return true;			}	
private boolean checkNull(String file)			{				if(file.trim().length()==0)				{					message.setForeground(Color.red);					message.setText(installer.getProperty("dir.null"));					return false;				}				else return true;			}	
private boolean checkRelative(String dir)			{				File f = new File(dir);				if(!f.isAbsolute())				{					String msg = installer.getProperty("dir.relative");					try					{						String full = f.getCanonicalPath();						message.setForeground(Color.orange);						message.setText(msg+'\n'+full);					}					catch(IOException ioe)					{						message.setForeground(Color.red);						msg = installer.getProperty("dir.cant-resolve");						message.setText(msg);					}					return false;				}				else return true;			}	
private boolean checkExistNotDirectory(String dir)			{				File f = new File(dir);				if(f.exists() && !f.isDirectory())				{					message.setForeground(Color.red);					message.setText(installer.getProperty("dir.not-directory"));					return false;				}				else return true;			}	
private boolean checkExistNotEmpty(String dir)			{				File f = new File(dir);				String[]cnt = f.list();				if(cnt!=null && cnt.length>0)				{					message.setForeground(Color.orange);					message.setText(installer.getProperty("dir.not-empty"));					return false;				}				else return true;			}	
ChooseDirectory()			{				super(new BorderLayout());				osTaskDirs = new HashMap();									JPanel directoryPanel = new JPanel(new GridBagLayout());					installDir = addField(directoryPanel,"Install program in:",					OperatingSystem.getOperatingSystem()					.getInstallDirectory(appName,appVersion));					installDir.addFocusListener(new FocusAdapter()					{						public void focusLost(FocusEvent fe)						{							nextButton.setEnabled(isOK());						}					});				for(int i = 0; i < osTasks.length; i++)				{					OperatingSystem.OSTask osTask = osTasks[i];					String label = osTask.getLabel();					if(label != null)					{						JTextField field = addField(directoryPanel,label,							osTask.getDirectory());						osTaskDirs.put(osTask,field);					}				}				ChooseDirectory.this.add(BorderLayout.NORTH,directoryPanel);			}	
boolean isOK()			{				if(installDir.getText().length()==0)return false;				File f = new File(installDir.getText());				return !(f.exists()&&!f.isDirectory());			}	
private JTextField addField(JPanel directoryPanel, String label,				String defaultText)			{								//new line				c.gridy++;								//message				JTextField field = new JTextField(defaultText);				c.insets.bottom=3;				c.gridx=0;				c.gridwidth=3;				c.insets.left=0;				c.insets.right=0;				c.anchor=GridBagConstraints.LINE_START;				DirVerifier verif = new DirVerifier(directoryPanel,c.clone());												field.setInputVerifier(verif);								c.insets.bottom=12;				c.gridx=0;				c.gridy++;				c.gridwidth=1;				c.anchor=GridBagConstraints.LINE_END;				directoryPanel.add(new JLabel(label,SwingConstants.RIGHT),c);					c.gridx=1;				c.fill=GridBagConstraints.HORIZONTAL;				c.anchor=GridBagConstraints.CENTER;				c.insets.left=12;				c.insets.right=12;				c.weightx=1.0;				directoryPanel.add(field,c);												JButton choose = new JButton("Choose...");				choose.setRequestFocusEnabled(false);				choose.addActionListener(new ActionHandler(field));				c.gridx=2;				c.insets.left=0;				c.insets.right=0;				c.fill=GridBagConstraints.NONE;				c.weightx=0;				directoryPanel.add(choose,c);					return field;			}	
ActionHandler(JTextField field)				{					this.field = field;				}	
public void actionPerformed(ActionEvent evt)				{					File directory = new File(field.getText());					JFileChooser chooser = new JFileChooser(directory.getParent());					chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);					chooser.setSelectedFile(directory);						if(chooser.showOpenDialog(SwingInstall.this)						== JFileChooser.APPROVE_OPTION)					{							field.setText(chooser.getSelectedFile().getPath());							field.getInputVerifier().verify(field);					}				}	
SelectComponents()			{				super(new BorderLayout());					comp = createCompPanel();				SelectComponents.this.add(BorderLayout.NORTH,comp);					sizeLabel = new JLabel("",SwingConstants.LEFT);				SelectComponents.this.add(BorderLayout.SOUTH,sizeLabel);					updateSize();			}	
public void actionPerformed(ActionEvent evt)			{				updateSize();			}	
private JPanel createCompPanel()			{				filesets = new Vector();					int count = installer.getIntegerProperty("comp.count");				JPanel panel = new JPanel(new GridLayout(count,1));					String osClass = OperatingSystem.getOperatingSystem()					.getClass().getName();				osClass = osClass.substring(osClass.indexOf('$') + 1);					for(int i = 0; i < count; i++)				{					String os = installer.getProperty("comp." + i + ".os");						if(os != null && !osClass.equals(os))						continue;						JCheckBox checkBox = new JCheckBox(						installer.getProperty("comp." + i + ".name")						+ " (" + installer.getProperty("comp." + i						+ ".disk-size") + "Kb)");					checkBox.getModel().setSelected(true);					checkBox.addActionListener(this);					checkBox.setRequestFocusEnabled(false);						filesets.addElement(new Integer(i));						panel.add(checkBox);				}					Dimension dim = panel.getPreferredSize();				dim.width = Integer.MAX_VALUE;				panel.setMaximumSize(dim);					return panel;			}	
private void updateSize()			{				int size = 0;					for(int i = 0; i < filesets.size(); i++)				{					if(((JCheckBox)comp.getComponent(i))						.getModel().isSelected())					{						size += installer.getIntegerProperty("comp."							+ filesets.elementAt(i)							+ ".disk-size");					}				}					sizeLabel.setText("Estimated disk usage of selected"					+ " components: " + size + "Kb");			}	
SwingProgress()			{				super(new BorderLayout());					progress = new JProgressBar();				progress.setStringPainted(true);					SwingProgress.this.add(BorderLayout.NORTH,progress);			}	
public void setMaximum(final int max)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						progress.setMaximum(max);					}				});			}	
public void advance(final int value)			{				try				{					SwingUtilities.invokeAndWait(new Runnable()					{						public void run()						{							progress.setValue(progress								.getValue() + value);						}					});					Thread.yield();				}				catch(Exception e)				{				}			}	
public void done()			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						currentPage++;						pageChanged();					}				});			}	
public void error(final String message)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						dispose();						JOptionPane.showMessageDialog(null,							message,							"Installation aborted",							JOptionPane.ERROR_MESSAGE);						System.exit(1);					}				});			}	
public void message(final String message)			{				SwingUtilities.invokeLater(new Runnable()				{					public void run()					{						progress.setString(message);					}				});			}	
public void setThread(InstallThread thread)			{				this.thread = thread;			}	
public		TarBuffer( InputStream inStream )			{			this( inStream, TarBuffer.DEFAULT_BLKSIZE );			}	
public		TarBuffer( InputStream inStream, int blockSize )			{			this( inStream, blockSize, TarBuffer.DEFAULT_RCDSIZE );			}	
public		TarBuffer( InputStream inStream, int blockSize, int recordSize )			{			this.inStream = inStream;			this.outStream = null;			this.initialize( blockSize, recordSize );			}	
public		TarBuffer( OutputStream outStream )			{			this( outStream, TarBuffer.DEFAULT_BLKSIZE );			}	
public		TarBuffer( OutputStream outStream, int blockSize )			{			this( outStream, blockSize, TarBuffer.DEFAULT_RCDSIZE );			}	
public		TarBuffer( OutputStream outStream, int blockSize, int recordSize )			{			this.inStream = null;			this.outStream = outStream;			this.initialize( blockSize, recordSize );			}	
/**		 * Initialization common to all constructors.		 */		private void		initialize( int blockSize, int recordSize )			{			this.debug = false;			this.blockSize = blockSize;			this.recordSize = recordSize;			this.recsPerBlock = ( this.blockSize / this.recordSize );			this.blockBuffer = new byte[ this.blockSize ];				if ( this.inStream != null )				{				this.currBlkIdx = -1;				this.currRecIdx = this.recsPerBlock;				}			else				{				this.currBlkIdx = 0;				this.currRecIdx = 0;				}			}	
/**		 * Get the TAR Buffer's block size. Blocks consist of multiple records.		 */		public int		getBlockSize()			{			return this.blockSize;			}	
/**		 * Get the TAR Buffer's record size.		 */		public int		getRecordSize()			{			return this.recordSize;			}	
/**		 * Set the debugging flag for the buffer.		 *		 * @param debug If true, print debugging output.		 */		public void		setDebug( boolean debug )			{			this.debug = debug;			}	
/**		 * Determine if an archive record indicate End of Archive. End of		 * archive is indicated by a record that consists entirely of null bytes.		 *		 * @param record The record data to check.		 */		public boolean		isEOFRecord( byte[] record )			{			for ( int i = 0, sz = this.getRecordSize() ; i < sz ; ++i )				if ( record[i] != 0 )					return false;				return true;			}	
/**		 * Skip over a record on the input stream.		 */			public void		skipRecord()			throws IOException			{			if ( this.debug )				{				System.err.println					( "SkipRecord: recIdx = " + this.currRecIdx						+ " blkIdx = " + this.currBlkIdx );				}				if ( this.inStream == null )				throw new IOException					( "reading (via skip) from an output buffer" );				if ( this.currRecIdx >= this.recsPerBlock )				{				if ( ! this.readBlock() )					return; // UNDONE				}				this.currRecIdx++;			}	
/**		 * Read a record from the input stream and return the data.		 *		 * @return The record data.		 */			public byte[]		readRecord()			throws IOException			{			if ( this.debug )				{				System.err.println					( "ReadRecord: recIdx = " + this.currRecIdx						+ " blkIdx = " + this.currBlkIdx );				}				if ( this.inStream == null )				throw new IOException					( "reading from an output buffer" );				if ( this.currRecIdx >= this.recsPerBlock )				{				if ( ! this.readBlock() )					return null;				}				byte[] result = new byte[ this.recordSize ];				System.arraycopy(				this.blockBuffer, (this.currRecIdx * this.recordSize),				result, 0, this.recordSize );				this.currRecIdx++;				return result;			}	
/**		 * @return false if End-Of-File, else true		 */			private boolean		readBlock()			throws IOException			{			if ( this.debug )				{				System.err.println					( "ReadBlock: blkIdx = " + this.currBlkIdx );				}				if ( this.inStream == null )				throw new IOException					( "reading from an output buffer" );				this.currRecIdx = 0;				int offset = 0;			int bytesNeeded = this.blockSize;			for ( ; bytesNeeded > 0 ; )				{				long numBytes =					this.inStream.read						( this.blockBuffer, offset, bytesNeeded );					//				// NOTE				// We have fit EOF, and the block is not full!				//				// This is a broken archive. It does not follow the standard				// blocking algorithm. However, because we are generous, and				// it requires little effort, we will simply ignore the error				// and continue as if the entire block were read. This does				// not appear to break anything upstream. We used to return				// false in this case.				//				// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.				//					if ( numBytes == -1 )					break;					offset += numBytes;				bytesNeeded -= numBytes;				if ( numBytes != this.blockSize )					{					if ( this.debug )						{						System.err.println							( "ReadBlock: INCOMPLETE READ " + numBytes								+ " of " + this.blockSize + " bytes read." );						}					}				}				this.currBlkIdx++;				return true;			}	
/**		 * Get the current block number, zero based.		 *		 * @return The current zero based block number.		 */		public int		getCurrentBlockNum()			{			return this.currBlkIdx;			}	
/**		 * Get the current record number, within the current block, zero based.		 * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.		 *		 * @return The current zero based record number.		 */		public int		getCurrentRecordNum()			{			return this.currRecIdx - 1;			}	
/**		 * Write an archive record to the archive.		 *		 * @param record The record data to write to the archive.		 */			public void		writeRecord( byte[] record )			throws IOException			{			if ( this.debug )				{				System.err.println					( "WriteRecord: recIdx = " + this.currRecIdx						+ " blkIdx = " + this.currBlkIdx );				}				if ( this.outStream == null )				throw new IOException					( "writing to an input buffer" );				if ( record.length != this.recordSize )				throw new IOException					( "record to write has length '" + record.length						+ "' which is not the record size of '"						+ this.recordSize + "'" );				if ( this.currRecIdx >= this.recsPerBlock )				{				this.writeBlock();				}				System.arraycopy(				record, 0,				this.blockBuffer, (this.currRecIdx * this.recordSize),				this.recordSize );				this.currRecIdx++;			}	
/**		 * Write an archive record to the archive, where the record may be		 * inside of a larger array buffer. The buffer must be "offset plus		 * record size" long.		 *		 * @param buf The buffer containing the record data to write.		 * @param offset The offset of the record data within buf.		 */			public void		writeRecord( byte[] buf, int offset )			throws IOException			{			if ( this.debug )				{				System.err.println					( "WriteRecord: recIdx = " + this.currRecIdx						+ " blkIdx = " + this.currBlkIdx );				}				if ( this.outStream == null )				throw new IOException					( "writing to an input buffer" );				if ( (offset + this.recordSize) > buf.length )				throw new IOException					( "record has length '" + buf.length						+ "' with offset '" + offset						+ "' which is less than the record size of '"						+ this.recordSize + "'" );				if ( this.currRecIdx >= this.recsPerBlock )				{				this.writeBlock();				}				System.arraycopy(				buf, offset,				this.blockBuffer, (this.currRecIdx * this.recordSize),				this.recordSize );				this.currRecIdx++;			}	
/**		 * Write a TarBuffer block to the archive.		 */		private void		writeBlock()			throws IOException			{			if ( this.debug )				{				System.err.println					( "WriteBlock: blkIdx = " + this.currBlkIdx );				}				if ( this.outStream == null )				throw new IOException					( "writing to an input buffer" );				this.outStream.write( this.blockBuffer, 0, this.blockSize );			this.outStream.flush();				this.currRecIdx = 0;			this.currBlkIdx++;			}	
/**		 * Flush the current data block if it has any data in it.		 */			private void		flushBlock()			throws IOException			{			if ( this.debug )				{				System.err.println( "TarBuffer.flushBlock() called." );				}				if ( this.outStream == null )				throw new IOException					( "writing to an input buffer" );				if ( this.currRecIdx > 0 )				{				this.writeBlock();				}			}	
/**		 * Close the TarBuffer. If this is an output buffer, also flush the		 * current block before closing.		 */		public void		close()			throws IOException			{			if ( this.debug )				{				System.err.println( "TarBuffer.closeBuffer()." );				}				if ( this.outStream != null )				{				this.flushBlock();					if ( this.outStream != System.out						&& this.outStream != System.err )					{					this.outStream.close();					this.outStream = null;					}				}			else if ( this.inStream != null )				{				if ( this.inStream != System.in )					{					this.inStream.close();					this.inStream = null;					}				}			}	
/**		 * Construct an entry with only a name. This allows the programmer		 * to construct the entry's header "by hand". File is set to null.		 */		public		TarEntry( String name )			{			this.initialize();			this.nameTarHeader( this.header, name );			}	
/**		 * Construct an entry for a file. File is set to file, and the		 * header is constructed from information from the file.		 *		 * @param file The file that the entry represents.		 */		public		TarEntry( File file )			throws InvalidHeaderException			{			this.initialize();			this.getFileTarHeader( this.header, file );			}	
/**		 * Construct an entry from an archive's header bytes. File is set		 * to null.		 *		 * @param headerBuf The header bytes from a tar archive entry.		 */		public		TarEntry( byte[] headerBuf )			throws InvalidHeaderException			{			this.initialize();			this.parseTarHeader( this.header, headerBuf );			}	
/**		 * Initialization code common to all constructors.		 */		private void		initialize()			{			this.file = null;			this.header = new TarHeader();			}	
/**		 * Determine if the two entries are equal. Equality is determined		 * by the header names being equal.		 *		 * @return it Entry to be checked for equality.		 * @return True if the entries are equal.		 */		public boolean		equals( TarEntry it )			{			return				this.header.name.toString().equals					( it.header.name.toString() );			}	
/**		 * Determine if the given entry is a descendant of this entry.		 * Descendancy is determined by the name of the descendant		 * starting with this entry's name.		 *		 * @param desc Entry to be checked as a descendent of this.		 * @return True if entry is a descendant of this.		 */		public boolean		isDescendent( TarEntry desc )			{			return				desc.header.name.toString().startsWith					( this.header.name.toString() );			}	
/**		 * Get this entry's header.		 *		 * @return This entry's TarHeader.		 */		public TarHeader		getHeader()			{			return this.header;			}	
/**		 * Get this entry's name.		 *		 * @return This entry's name.		 */		public String		getName()			{			return this.header.name.toString();			}	
/**		 * Set this entry's name.		 *		 * @param name This entry's new name.		 */		public void		setName( String name )			{			this.header.name =				new StringBuffer( name );			}	
/**		 * Get this entry's user id.		 *		 * @return This entry's user id.		 */		public int		getUserId()			{			return this.header.userId;			}	
/**		 * Set this entry's user id.		 *		 * @param userId This entry's new user id.		 */		public void		setUserId( int userId )			{			this.header.userId = userId;			}	
/**		 * Get this entry's group id.		 *		 * @return This entry's group id.		 */		public int		getGroupId()			{			return this.header.groupId;			}	
/**		 * Set this entry's group id.		 *		 * @param groupId This entry's new group id.		 */		public void		setGroupId( int groupId )			{			this.header.groupId = groupId;			}	
/**		 * Get this entry's user name.		 *		 * @return This entry's user name.		 */		public String		getUserName()			{			return this.header.userName.toString();			}	
/**		 * Set this entry's user name.		 *		 * @param userName This entry's new user name.		 */		public void		setUserName( String userName )			{			this.header.userName =				new StringBuffer( userName );			}	
/**		 * Get this entry's group name.		 *		 * @return This entry's group name.		 */		public String		getGroupName()			{			return this.header.groupName.toString();			}	
/**		 * Set this entry's group name.		 *		 * @param groupName This entry's new group name.		 */		public void		setGroupName( String groupName )			{			this.header.groupName =				new StringBuffer( groupName );			}	
/**		 * Convenience method to set this entry's group and user ids.		 *		 * @param userId This entry's new user id.		 * @param groupId This entry's new group id.		 */		public void		setIds( int userId, int groupId )			{			this.setUserId( userId );			this.setGroupId( groupId );			}	
/**		 * Convenience method to set this entry's group and user names.		 *		 * @param userName This entry's new user name.		 * @param groupName This entry's new group name.		 */		public void		setNames( String userName, String groupName )			{			this.setUserName( userName );			this.setGroupName( groupName );			}	
/**		 * Set this entry's modification time. The parameter passed		 * to this method is in "Java time".		 *		 * @param time This entry's new modification time.		 */		public void		setModTime( long time )			{			this.header.modTime = time / 1000;			}	
/**		 * Set this entry's modification time.		 *		 * @param time This entry's new modification time.		 */		public void		setModTime( Date time )			{			this.header.modTime = time.getTime() / 1000;			}	
/**		 * Set this entry's modification time.		 *		 * @param time This entry's new modification time.		 */		public Date		getModTime()			{			return new Date( this.header.modTime * 1000 );			}	
/**		 * Get this entry's file.		 *		 * @return This entry's file.		 */		public File		getFile()			{			return this.file;			}	
/**		 * Get this entry's file size.		 *		 * @return This entry's file size.		 */		public long		getSize()			{			return this.header.size;			}	
/**		 * Set this entry's file size.		 *		 * @param size This entry's new file size.		 */		public void		setSize( long size )			{			this.header.size = size;			}	
/**		 * Convenience method that will modify an entry's name directly		 * in place in an entry header buffer byte array.		 *		 * @param outbuf The buffer containing the entry header to modify.		 * @param newName The new name to place into the header buffer.		 */		public void		adjustEntryName( byte[] outbuf, String newName )			{			int offset = 0;			offset = TarHeader.getNameBytes				( new StringBuffer( newName ),					outbuf, offset, TarHeader.NAMELEN );			}	
/**		 * Return whether or not this entry represents a directory.		 *		 * @return True if this entry is a directory.		 */		public boolean		isDirectory()			{			if ( this.file != null )				return this.file.isDirectory();				if ( this.header != null )				{				if ( this.header.linkFlag == TarHeader.LF_DIR )					return true;					if ( this.header.name.toString().endsWith( "/" ) )					return true;				}				return false;			}	
/**		 * Fill in a TarHeader with information from a File.		 *		 * @param hdr The TarHeader to fill in.		 * @param file The file from which to get the header information.		 */		public void		getFileTarHeader( TarHeader hdr, File file )			throws InvalidHeaderException			{			this.file = file;				String name = file.getPath();			String osname = System.getProperty( "os.name" );			if ( osname != null )				{				// Strip off drive letters!				// REVIEW Would a better check be "(File.separator == '\')"?					// String Win32Prefix = "Windows";				// String prefix = osname.substring( 0, Win32Prefix.length() );				// if ( prefix.equalsIgnoreCase( Win32Prefix ) )					// if ( File.separatorChar == '\\' )					// Per Patrick Beard:				String Win32Prefix = "windows";				if ( osname.toLowerCase().startsWith( Win32Prefix ) )					{					if ( name.length() > 2 )						{						char ch1 = name.charAt(0);						char ch2 = name.charAt(1);						if ( ch2 == ':'							&& ( (ch1 >= 'a' && ch1 <= 'z')								|| (ch1 >= 'A' && ch1 <= 'Z') ) )							{							name = name.substring( 2 );							}						}					}				}				name = name.replace( File.separatorChar, '/' );				// No absolute pathnames			// Windows (and Posix?) paths can start with "\\NetworkDrive\",			// so we loop on starting /'s.						for ( ; name.startsWith( "/" ) ; )				name = name.substring( 1 );		 		hdr.linkName = new StringBuffer( "" );				hdr.name = new StringBuffer( name );				if ( file.isDirectory() )				{				hdr.mode = 040755;				hdr.linkFlag = TarHeader.LF_DIR;				if ( hdr.name.charAt( hdr.name.length() - 1 ) != '/' )					hdr.name.append( "/" );				}			else				{				hdr.mode = 0100644;				hdr.linkFlag = TarHeader.LF_NORMAL;				}				// UNDONE When File lets us get the userName, use it!				hdr.size = file.length();			hdr.modTime = file.lastModified() / 1000;			hdr.checkSum = 0;			hdr.devMajor = 0;			hdr.devMinor = 0;			}	
/**		 * If this entry represents a file, and the file is a directory, return		 * an array of TarEntries for this entry's children.		 *		 * @return An array of TarEntry's for this entry's children.		 */		public TarEntry[]		getDirectoryEntries()			throws InvalidHeaderException			{			if ( this.file == null					|| ! this.file.isDirectory() )				{				return new TarEntry[0];				}				String[] list = this.file.list();				TarEntry[] result = new TarEntry[ list.length ];				for ( int i = 0 ; i < list.length ; ++i )				{				result[i] =					new TarEntry						( new File( this.file, list[i] ) );				}				return result;			}	
/**		 * Compute the checksum of a tar entry header.		 *		 * @param buf The tar entry's header buffer.		 * @return The computed checksum.		 */		public long		computeCheckSum( byte[] buf )			{			long sum = 0;				for ( int i = 0 ; i < buf.length ; ++i )				{				sum += 255 & buf[ i ];				}				return sum;			}	
/**		 * Write an entry's header information to a header buffer.		 *		 * @param outbuf The tar entry header buffer to fill in.		 */		public void		writeEntryHeader( byte[] outbuf )			{			int offset = 0;				offset = TarHeader.getNameBytes				( this.header.name, outbuf, offset, TarHeader.NAMELEN );				offset = TarHeader.getOctalBytes				( this.header.mode, outbuf, offset, TarHeader.MODELEN );				offset = TarHeader.getOctalBytes				( this.header.userId, outbuf, offset, TarHeader.UIDLEN );				offset = TarHeader.getOctalBytes				( this.header.groupId, outbuf, offset, TarHeader.GIDLEN );				long size = this.header.size;				offset = TarHeader.getLongOctalBytes				( size, outbuf, offset, TarHeader.SIZELEN );				offset = TarHeader.getLongOctalBytes				( this.header.modTime, outbuf, offset, TarHeader.MODTIMELEN );				int csOffset = offset;			for ( int c = 0 ; c < TarHeader.CHKSUMLEN ; ++c )				outbuf[ offset++ ] = (byte) ' ';				outbuf[ offset++ ] = this.header.linkFlag;				offset = TarHeader.getNameBytes				( this.header.linkName, outbuf, offset, TarHeader.NAMELEN );				offset = TarHeader.getNameBytes				( this.header.magic, outbuf, offset, TarHeader.MAGICLEN );				offset = TarHeader.getNameBytes				( this.header.userName, outbuf, offset, TarHeader.UNAMELEN );				offset = TarHeader.getNameBytes				( this.header.groupName, outbuf, offset, TarHeader.GNAMELEN );				offset = TarHeader.getOctalBytes				( this.header.devMajor, outbuf, offset, TarHeader.DEVLEN );				offset = TarHeader.getOctalBytes				( this.header.devMinor, outbuf, offset, TarHeader.DEVLEN );				for ( ; offset < outbuf.length ; )				outbuf[ offset++ ] = 0;				long checkSum = this.computeCheckSum( outbuf );				TarHeader.getCheckSumOctalBytes				( checkSum, outbuf, csOffset, TarHeader.CHKSUMLEN );			}	
/**		 * Parse an entry's TarHeader information from a header buffer.		 *		 * @param hdr The TarHeader to fill in from the buffer information.		 * @param header The tar entry header buffer to get information from.		 */		public void		parseTarHeader( TarHeader hdr, byte[] header )			throws InvalidHeaderException			{			int offset = 0;				hdr.name =				TarHeader.parseName( header, offset, TarHeader.NAMELEN );				offset += TarHeader.NAMELEN;				hdr.mode = (int)				TarHeader.parseOctal( header, offset, TarHeader.MODELEN );				offset += TarHeader.MODELEN;				hdr.userId = (int)				TarHeader.parseOctal( header, offset, TarHeader.UIDLEN );				offset += TarHeader.UIDLEN;				hdr.groupId = (int)				TarHeader.parseOctal( header, offset, TarHeader.GIDLEN );				offset += TarHeader.GIDLEN;				hdr.size =				TarHeader.parseOctal( header, offset, TarHeader.SIZELEN );				offset += TarHeader.SIZELEN;				hdr.modTime =				TarHeader.parseOctal( header, offset, TarHeader.MODTIMELEN );				offset += TarHeader.MODTIMELEN;				hdr.checkSum = (int)				TarHeader.parseOctal( header, offset, TarHeader.CHKSUMLEN );				offset += TarHeader.CHKSUMLEN;				hdr.linkFlag = header[ offset++ ];				hdr.linkName =				TarHeader.parseName( header, offset, TarHeader.NAMELEN );				offset += TarHeader.NAMELEN;				hdr.magic =				TarHeader.parseName( header, offset, TarHeader.MAGICLEN );				offset += TarHeader.MAGICLEN;				hdr.userName =				TarHeader.parseName( header, offset, TarHeader.UNAMELEN );				offset += TarHeader.UNAMELEN;				hdr.groupName =				TarHeader.parseName( header, offset, TarHeader.GNAMELEN );				offset += TarHeader.GNAMELEN;				hdr.devMajor = (int)				TarHeader.parseOctal( header, offset, TarHeader.DEVLEN );				offset += TarHeader.DEVLEN;				hdr.devMinor = (int)				TarHeader.parseOctal( header, offset, TarHeader.DEVLEN );			}	
/**		 * Fill in a TarHeader given only the entry's name.		 *		 * @param hdr The TarHeader to fill in.		 * @param name The tar entry name.		 */		public void		nameTarHeader( TarHeader hdr, String name )			{			boolean isDir = name.endsWith( "/" );				hdr.checkSum = 0;			hdr.devMajor = 0;			hdr.devMinor = 0;				hdr.name = new StringBuffer( name );			hdr.mode = isDir ? 040755 : 0100644;			hdr.userId = 0;			hdr.groupId = 0;			hdr.size = 0;			hdr.checkSum = 0;				hdr.modTime =				(new java.util.Date()).getTime() / 1000;				hdr.linkFlag =				isDir ? TarHeader.LF_DIR : TarHeader.LF_NORMAL;				hdr.linkName = new StringBuffer( "" );			hdr.userName = new StringBuffer( "" );			hdr.groupName = new StringBuffer( "" );				hdr.devMajor = 0;			hdr.devMinor = 0;			}	
public		TarHeader()			{			this.magic = new StringBuffer( TarHeader.TMAGIC );				this.name = new StringBuffer();			this.linkName = new StringBuffer();				String user =				System.getProperty( "user.name", "" );				if ( user.length() > 31 )				user = user.substring( 0, 31 );				this.userId = 0;			this.groupId = 0;			this.userName = new StringBuffer( user );			this.groupName = new StringBuffer( "" );			}	
/**		 * TarHeaders can be cloned.		 */		public Object		clone()			{			TarHeader hdr = null;				try {				hdr = (TarHeader) super.clone();					hdr.name =					(this.name == null ) ? null						: new StringBuffer( this.name.toString() );				hdr.mode = this.mode;				hdr.userId = this.userId;				hdr.groupId = this.groupId;				hdr.size = this.size;				hdr.modTime = this.modTime;				hdr.checkSum = this.checkSum;				hdr.linkFlag = this.linkFlag;				hdr.linkName =					(this.linkName == null ) ? null						: new StringBuffer( this.linkName.toString() );				hdr.magic =					(this.magic == null ) ? null						: new StringBuffer( this.magic.toString() );				hdr.userName =					(this.userName == null ) ? null						: new StringBuffer( this.userName.toString() );				hdr.groupName =					(this.groupName == null ) ? null						: new StringBuffer( this.groupName.toString() );				hdr.devMajor = this.devMajor;				hdr.devMinor = this.devMinor;				}			catch ( CloneNotSupportedException ex )				{				ex.printStackTrace();				}				return hdr;			}	
/**		 * Get the name of this entry.		 *		 * @return Teh entry's name.		 */		public String		getName()			{			return this.name.toString();			}	
/**		 * Parse an octal string from a header buffer. This is used for the		 * file permission mode value.		 *		 * @param header The header buffer from which to parse.		 * @param offset The offset into the buffer from which to parse.		 * @param length The number of header bytes to parse.		 * @return The long value of the octal string.		 */		public static long		parseOctal( byte[] header, int offset, int length )			throws InvalidHeaderException			{			long result = 0;			boolean stillPadding = true;				int end = offset + length;			for ( int i = offset ; i < end ; ++i )				{				if ( header[i] == 0 )					break;					if ( header[i] == (byte) ' ' || header[i] == '0' )					{					if ( stillPadding )						continue;						if ( header[i] == (byte) ' ' )						break;					}								stillPadding = false;					result =					(result << 3)						+ (header[i] - '0');				}				return result;			}	
/**		 * Parse an entry name from a header buffer.		 *		 * @param header The header buffer from which to parse.		 * @param offset The offset into the buffer from which to parse.		 * @param length The number of header bytes to parse.		 * @return The header's entry name.		 */		public static StringBuffer		parseName( byte[] header, int offset, int length )			throws InvalidHeaderException			{			StringBuffer result = new StringBuffer( length );				int end = offset + length;			for ( int i = offset ; i < end ; ++i )				{				if ( header[i] == 0 )					break;				result.append( (char)header[i] );				}				return result;			}	
/**		 * Determine the number of bytes in an entry name.		 *		 * @param header The header buffer from which to parse.		 * @param offset The offset into the buffer from which to parse.		 * @param length The number of header bytes to parse.		 * @return The number of bytes in a header's entry name.		 */		public static int		getNameBytes( StringBuffer name, byte[] buf, int offset, int length )			{			int i;				for ( i = 0 ; i < length && i < name.length() ; ++i )				{				buf[ offset + i ] = (byte) name.charAt( i );				}				for ( ; i < length ; ++i )				{				buf[ offset + i ] = 0;				}				return offset + length;			}	
/**		 * Parse an octal integer from a header buffer.		 *		 * @param header The header buffer from which to parse.		 * @param offset The offset into the buffer from which to parse.		 * @param length The number of header bytes to parse.		 * @return The integer value of the octal bytes.		 */		public static int		getOctalBytes( long value, byte[] buf, int offset, int length )			{			byte[] result = new byte[ length ];				int idx = length - 1;				buf[ offset + idx ] = 0;			--idx;			buf[ offset + idx ] = (byte) ' ';			--idx;				if ( value == 0 )				{				buf[ offset + idx ] = (byte) '0';				--idx;				}			else				{				for ( long val = value ; idx >= 0 && val > 0 ; --idx )					{					buf[ offset + idx ] = (byte)						( (byte) '0' + (byte) (val & 7) );					val = val >> 3;					}				}				for ( ; idx >= 0 ; --idx )				{				buf[ offset + idx ] = (byte) ' ';				}				return offset + length;			}	
/**		 * Parse an octal long integer from a header buffer.		 *		 * @param header The header buffer from which to parse.		 * @param offset The offset into the buffer from which to parse.		 * @param length The number of header bytes to parse.		 * @return The long value of the octal bytes.		 */		public static int		getLongOctalBytes( long value, byte[] buf, int offset, int length )			{			byte[] temp = new byte[ length + 1 ];			TarHeader.getOctalBytes( value, temp, 0, length + 1 );			System.arraycopy( temp, 0, buf, offset, length );			return offset + length;			}	
/**		 * Parse the checksum octal integer from a header buffer.		 *		 * @param header The header buffer from which to parse.		 * @param offset The offset into the buffer from which to parse.		 * @param length The number of header bytes to parse.		 * @return The integer value of the entry's checksum.		 */		public static int		getCheckSumOctalBytes( long value, byte[] buf, int offset, int length )			{			TarHeader.getOctalBytes( value, buf, offset, length );			buf[ offset + length - 1 ] = (byte) ' ';			buf[ offset + length - 2 ] = 0;			return offset + length;			}	
public		TarInputStream( InputStream is )			{			this( is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE );			}	
public		TarInputStream( InputStream is, int blockSize )			{			this( is, blockSize, TarBuffer.DEFAULT_RCDSIZE );			}	
public		TarInputStream( InputStream is, int blockSize, int recordSize )			{			super( is );				this.buffer = new TarBuffer( is, blockSize, recordSize );				this.readBuf = null;			this.oneBuf = new byte[1];			this.debug = false;			this.hasHitEOF = false;			this.eFactory = null;			}	
/**		 * Sets the debugging flag.		 *		 * @param debugF True to turn on debugging.		 */		public void		setDebug( boolean debugF )			{			this.debug = debugF;			}	
/**		 * Sets the debugging flag.		 *		 * @param debugF True to turn on debugging.		 */		public void		setEntryFactory( EntryFactory factory )			{			this.eFactory = factory;			}	
/**		 * Sets the debugging flag in this stream's TarBuffer.		 *		 * @param debugF True to turn on debugging.		 */		public void		setBufferDebug( boolean debug )			{			this.buffer.setDebug( debug );			}	
/**		 * Closes this stream. Calls the TarBuffer's close() method.		 */		public void		close()			throws IOException			{			this.buffer.close();			}	
/**		 * Get the record size being used by this stream's TarBuffer.		 *		 * @return The TarBuffer record size.		 */		public int		getRecordSize()			{			return this.buffer.getRecordSize();			}	
/**		 * Get the available data that can be read from the current		 * entry in the archive. This does not indicate how much data		 * is left in the entire archive, only in the current entry.		 * This value is determined from the entry's size header field		 * and the amount of data already read from the current entry.		 * 		 *		 * @return The number of available bytes for the current entry.		 */		public int		available()			throws IOException			{			return this.entrySize - this.entryOffset;			}	
/**		 * Skip bytes in the input buffer. This skips bytes in the		 * current entry's data, not the entire archive, and will		 * stop at the end of the current entry's data if the number		 * to skip extends beyond that point.		 *		 * @param numToSkip The number of bytes to skip.		 */		public void		skip( int numToSkip )			throws IOException			{			// REVIEW			// This is horribly inefficient, but it ensures that we			// properly skip over bytes via the TarBuffer...			//				byte[] skipBuf = new byte[ 8 * 1024 ];				for ( int num = numToSkip ; num > 0 ; )				{				int numRead =					this.read( skipBuf, 0,						( num > skipBuf.length ? skipBuf.length : num ) );					if ( numRead == -1 )					break;					num -= numRead;				}			}	
/**		 * Since we do not support marking just yet, we return false.		 *		 * @return False.		 */		public boolean		markSupported()			{			return false;			}	
/**		 * Since we do not support marking just yet, we do nothing.		 *		 * @param markLimit The limit to mark.		 */		public void		mark( int markLimit )			{			}	
/**		 * Since we do not support marking just yet, we do nothing.		 */		public void		reset()			{			}	
/**		 * Get the next entry in this tar archive. This will skip		 * over any remaining data in the current entry, if there		 * is one, and place the input stream at the header of the		 * next entry, and read the header and instantiate a new		 * TarEntry from the header bytes and return that entry.		 * If there are no more entries in the archive, null will		 * be returned to indicate that the end of the archive has		 * been reached.		 *		 * @return The next TarEntry in the archive, or null.		 */		public TarEntry		getNextEntry()			throws IOException			{			if ( this.hasHitEOF )				return null;				if ( this.currEntry != null )				{				int numToSkip = this.entrySize - this.entryOffset;					if ( this.debug )				System.err.println					( "TarInputStream: SKIP currENTRY '"					+ this.currEntry.getName() + "' SZ "					+ this.entrySize + " OFF " + this.entryOffset					+ "  skipping " + numToSkip + " bytes" );					if ( numToSkip > 0 )					{					this.skip( numToSkip );					}					this.readBuf = null;				}				byte[] headerBuf = this.buffer.readRecord();				if ( headerBuf == null )				{				if ( this.debug )					{					System.err.println( "READ NULL RECORD" );					}					this.hasHitEOF = true;				}			else if ( this.buffer.isEOFRecord( headerBuf ) )				{				if ( this.debug )					{					System.err.println( "READ EOF RECORD" );					}					this.hasHitEOF = true;				}				if ( this.hasHitEOF )				{				this.currEntry = null;				}			else				{				try {					if ( this.eFactory == null )						{						this.currEntry = new TarEntry( headerBuf );						}					else						{						this.currEntry =							this.eFactory.createEntry( headerBuf );						}						if ( ! ( headerBuf[257] == 'u' && headerBuf[258] == 's'							&& headerBuf[259] == 't' && headerBuf[260] == 'a'							&& headerBuf[261] == 'r' ) )						{						throw new InvalidHeaderException							( "header magic is not 'ustar', but '"								+ headerBuf[257] + headerBuf[258] + headerBuf[259]								+ headerBuf[260] + headerBuf[261] + "', or (dec) "								+ ((int)headerBuf[257]) + ", "								+ ((int)headerBuf[258]) + ", "								+ ((int)headerBuf[259]) + ", "								+ ((int)headerBuf[260]) + ", "								+ ((int)headerBuf[261]) );						}						if ( this.debug )					System.err.println						( "TarInputStream: SET CURRENTRY '"							+ this.currEntry.getName()							+ "' size = " + this.currEntry.getSize() );						this.entryOffset = 0;					// REVIEW How do we resolve this discrepancy?!					this.entrySize = (int) this.currEntry.getSize();					}				catch ( InvalidHeaderException ex )					{					this.entrySize = 0;					this.entryOffset = 0;					this.currEntry = null;					throw new InvalidHeaderException						( "bad header in block "							+ this.buffer.getCurrentBlockNum()							+ " record "							+ this.buffer.getCurrentRecordNum()							+ ", " + ex.getMessage() );					}				}				return this.currEntry;			}	
/**		 * Reads a byte from the current tar archive entry.		 *		 * This method simply calls read( byte[], int, int ).		 *		 * @return The byte read, or -1 at EOF.		 */		public int		read()			throws IOException			{			int num = this.read( this.oneBuf, 0, 1 );			if ( num == -1 )				return num;			else				return this.oneBuf[0];			}	
/**		 * Reads bytes from the current tar archive entry.		 *		 * This method simply calls read( byte[], int, int ).		 *		 * @param buf The buffer into which to place bytes read.		 * @return The number of bytes read, or -1 at EOF.		 */		public int		read( byte[] buf )			throws IOException			{			return this.read( buf, 0, buf.length );			}	
/**		 * Reads bytes from the current tar archive entry.		 *		 * This method is aware of the boundaries of the current		 * entry in the archive and will deal with them as if they		 * were this stream's start and EOF.		 *		 * @param buf The buffer into which to place bytes read.		 * @param offset The offset at which to place bytes read.		 * @param numToRead The number of bytes to read.		 * @return The number of bytes read, or -1 at EOF.		 */		public int		read( byte[] buf, int offset, int numToRead )			throws IOException			{			int totalRead = 0;				if ( this.entryOffset >= this.entrySize )				return -1;				if ( (numToRead + this.entryOffset) > this.entrySize )				{				numToRead = (this.entrySize - this.entryOffset);				}				if ( this.readBuf != null )				{				int sz = ( numToRead > this.readBuf.length )							? this.readBuf.length : numToRead;					System.arraycopy( this.readBuf, 0, buf, offset, sz );					if ( sz >= this.readBuf.length )					{					this.readBuf = null;					}				else					{					int newLen = this.readBuf.length - sz;					byte[] newBuf = new byte[ newLen ];					System.arraycopy( this.readBuf, sz, newBuf, 0, newLen );					this.readBuf = newBuf;					}					totalRead += sz;				numToRead -= sz;				offset += sz;				}				for ( ; numToRead > 0 ; )				{				byte[] rec = this.buffer.readRecord();				if ( rec == null )					{					// Unexpected EOF!					throw new IOException						( "unexpected EOF with " + numToRead + " bytes unread" );					}					int sz = numToRead;				int recLen = rec.length;					if ( recLen > sz )					{					System.arraycopy( rec, 0, buf, offset, sz );					this.readBuf = new byte[ recLen - sz ];					System.arraycopy( rec, sz, this.readBuf, 0, recLen - sz );					}				else					{					sz = recLen;					System.arraycopy( rec, 0, buf, offset, recLen );					}					totalRead += sz;				numToRead -= sz;				offset += sz;				}				this.entryOffset += totalRead;				return totalRead;			}	
/**		 * Copies the contents of the current tar archive entry directly into		 * an output stream.		 *		 * @param out The OutputStream into which to write the entry's data.		 */		public void		copyEntryContents( OutputStream out )			throws IOException			{			byte[] buf = new byte[ 32 * 1024 ];				for ( ; ; )				{				int numRead = this.read( buf, 0, buf.length );				if ( numRead == -1 )					break;				out.write( buf, 0, numRead );				}			}	
public TarEntry			createEntry( String name )				{				return new TarEntry( name );				}	
public TarEntry			createEntry( File path )				throws InvalidHeaderException				{				return new TarEntry( path );				}	
public TarEntry			createEntry( byte[] headerBuf )				throws InvalidHeaderException				{				return new TarEntry( headerBuf );				}	
public		TarOutputStream( OutputStream os )			{			this( os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE );			}	
public		TarOutputStream( OutputStream os, int blockSize )			{			this( os, blockSize, TarBuffer.DEFAULT_RCDSIZE );			}	
public		TarOutputStream( OutputStream os, int blockSize, int recordSize )			{			super( os );				this.buffer = new TarBuffer( os, blockSize, recordSize );						this.debug = false;			this.assemLen = 0;			this.assemBuf = new byte[ recordSize ];			this.recordBuf = new byte[ recordSize ];			this.oneBuf = new byte[1];			}	
/**		 * Sets the debugging flag.		 *		 * @param debugF True to turn on debugging.		 */		public void		setDebug( boolean debugF )			{			this.debug = debugF;			}	
/**		 * Sets the debugging flag in this stream's TarBuffer.		 *		 * @param debugF True to turn on debugging.		 */		public void		setBufferDebug( boolean debug )			{			this.buffer.setDebug( debug );			}	
/**		 * Ends the TAR archive without closing the underlying OutputStream.		 * The result is that the EOF record of nulls is written.		 */			public void		finish()			throws IOException			{			this.writeEOFRecord();			}	
/**		 * Ends the TAR archive and closes the underlying OutputStream.		 * This means that finish() is called followed by calling the		 * TarBuffer's close().		 */			public void		close()			throws IOException			{			this.finish();			this.buffer.close();			}	
/**		 * Get the record size being used by this stream's TarBuffer.		 *		 * @return The TarBuffer record size.		 */		public int		getRecordSize()			{			return this.buffer.getRecordSize();			}	
/**		 * Put an entry on the output stream. This writes the entry's		 * header record and positions the output stream for writing		 * the contents of the entry. Once this method is called, the		 * stream is ready for calls to write() to write the entry's		 * contents. Once the contents are written, closeEntry()		 * <B>MUST</B> be called to ensure that all buffered data		 * is completely written to the output stream.		 *		 * @param entry The TarEntry to be written to the archive.		 */		public void		putNextEntry( TarEntry entry )			throws IOException			{			if ( entry.getHeader().name.length() > TarHeader.NAMELEN )				throw new InvalidHeaderException					( "file name '" + entry.getHeader().name						+ "' is too long ( > "						+ TarHeader.NAMELEN + " bytes )" );				entry.writeEntryHeader( this.recordBuf );			this.buffer.writeRecord( this.recordBuf );				this.currBytes = 0;				if ( entry.isDirectory() )				this.currSize = 0;			else				this.currSize = (int)entry.getSize();			}	
/**		 * Close an entry. This method MUST be called for all file		 * entries that contain data. The reason is that we must		 * buffer data written to the stream in order to satisfy		 * the buffer's record based writes. Thus, there may be		 * data fragments still being assembled that must be written		 * to the output stream before this entry is closed and the		 * next entry written.		 */		public void		closeEntry()			throws IOException			{			if ( this.assemLen > 0 )				{				for ( int i = this.assemLen ; i < this.assemBuf.length ; ++i )					this.assemBuf[i] = 0;					this.buffer.writeRecord( this.assemBuf );					this.currBytes += this.assemLen;				this.assemLen = 0;				}				if ( this.currBytes < this.currSize )				throw new IOException					( "entry closed at '" + this.currBytes						+ "' before the '" + this.currSize						+ "' bytes specified in the header were written" );			}	
/**		 * Writes a byte to the current tar archive entry.		 *		 * This method simply calls read( byte[], int, int ).		 *		 * @param b The byte written.		 */		public void		write( int b )			throws IOException			{			this.oneBuf[0] = (byte) b;			this.write( this.oneBuf, 0, 1 );			}	
/**		 * Writes bytes to the current tar archive entry.		 *		 * This method simply calls read( byte[], int, int ).		 *		 * @param wBuf The buffer to write to the archive.		 * @return The number of bytes read, or -1 at EOF.		 */		public void		write( byte[] wBuf )			throws IOException			{			this.write( wBuf, 0, wBuf.length );			}	
/**		 * Writes bytes to the current tar archive entry. This method		 * is aware of the current entry and will throw an exception if		 * you attempt to write bytes past the length specified for the		 * current entry. The method is also (painfully) aware of the		 * record buffering required by TarBuffer, and manages buffers		 * that are not a multiple of recordsize in length, including		 * assembling records from small buffers.		 *		 * This method simply calls read( byte[], int, int ).		 *		 * @param wBuf The buffer to write to the archive.		 * @param wOffset The offset in the buffer from which to get bytes.		 * @param numToWrite The number of bytes to write.		 */		public void		write( byte[] wBuf, int wOffset, int numToWrite )			throws IOException			{			if ( (this.currBytes + numToWrite) > this.currSize )				throw new IOException					( "request to write '" + numToWrite						+ "' bytes exceeds size in header of '"						+ this.currSize + "' bytes" );				//			// We have to deal with assembly!!!			// The programmer can be writing little 32 byte chunks for all			// we know, and we must assemble complete records for writing.			// REVIEW Maybe this should be in TarBuffer? Could that help to			//        eliminate some of the buffer copying.			//			if ( this.assemLen > 0 )				{				if ( (this.assemLen + numToWrite ) >= this.recordBuf.length )					{					int aLen = this.recordBuf.length - this.assemLen;						System.arraycopy						( this.assemBuf, 0, this.recordBuf, 0, this.assemLen );						System.arraycopy						( wBuf, wOffset, this.recordBuf, this.assemLen, aLen );						this.buffer.writeRecord( this.recordBuf );						this.currBytes += this.recordBuf.length;						wOffset += aLen;					numToWrite -= aLen;					this.assemLen = 0;					}				else // ( (this.assemLen + numToWrite ) < this.recordBuf.length )					{					System.arraycopy						( wBuf, wOffset, this.assemBuf,							this.assemLen, numToWrite );					wOffset += numToWrite;					this.assemLen += numToWrite; 					numToWrite -= numToWrite;					}				}				//			// When we get here we have EITHER:			//   o An empty "assemble" buffer.			//   o No bytes to write (numToWrite == 0)			//				for ( ; numToWrite > 0 ; )				{				if ( numToWrite < this.recordBuf.length )					{					System.arraycopy						( wBuf, wOffset, this.assemBuf, this.assemLen, numToWrite );					this.assemLen += numToWrite;					break;					}					this.buffer.writeRecord( wBuf, wOffset );					int num = this.recordBuf.length;				this.currBytes += num;				numToWrite -= num;				wOffset += num;				}			}	
/**		 * Write an EOF (end of archive) record to the tar archive.		 * An EOF record consists of a record of all zeros.		 */		private void		writeEOFRecord()			throws IOException			{			for ( int i = 0 ; i < this.recordBuf.length ; ++i )				this.recordBuf[i] = 0;			this.buffer.writeRecord( this.recordBuf );			}	
public VariableGridLayout(int mode, int size, int hgap, int vgap) {			if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS) {				throw new IllegalArgumentException("illegal mode; value is " + mode);			}			if (size <= 0) {				throw new IllegalArgumentException("size cannot be zero or less; value is " + size);			}			if (hgap < 0) {				throw new IllegalArgumentException("hgap cannot be negative; value is " + hgap);			}			if (vgap < 0) {				throw new IllegalArgumentException("vgap cannot be negative; value is " + vgap);			}			this.mode = mode;			this.size = size;			this.hgap = hgap;			this.vgap = vgap;		}	
/**		 * Creates a variable grid layout manager with the specified mode		 * and zero horizontal and vertical gap.		 */		public VariableGridLayout(int mode, int size) {			this(mode, size, 0, 0);		}	
/**		 * Creates a variable grid layout manager with mode FIXED_NUM_ROWS,		 * number of rows == 1 and zero horizontal and vertical gap.		 */		public VariableGridLayout() {			this(FIXED_NUM_ROWS, 1, 0, 0);		}	
/**		 * Not used in this class.		 */		public void addLayoutComponent(String name, Component component) { }	
/**		 * Not used in this class.		 */		public void addLayoutComponent(Component component, Object constraints) { }	
/**		 * Not used in this class.		 */		public void removeLayoutComponent(Component component) { }	
/**		 * Always returns 0.5.		 */		public float getLayoutAlignmentX(Container container) {			return 0.5f;		}	
/**		 * Always returns 0.5.		 */		public float getLayoutAlignmentY(Container container) {			return 0.5f;		}	
public Dimension preferredLayoutSize(Container parent) {			return getLayoutSize(parent, 2);		}	
public Dimension minimumLayoutSize(Container parent) {			return getLayoutSize(parent, 0);		}	
public Dimension maximumLayoutSize(Container parent) {			return getLayoutSize(parent, 1);		}	
public void layoutContainer(Container parent) {			synchronized (parent.getTreeLock()) {				update(parent);					int ncomponents = parent.getComponentCount();					if (ncomponents == 0) {					return;				}					// Pass 1: compute preferred row heights / column widths				int total_height = 0;				for (int r = 0, i = 0; r < nrows; r++) {					for (int c = 0; c < ncols; c++, i++) {						if (i < ncomponents) {							Dimension d = parent.getComponent(i).getPreferredSize();							row_heights[r] = Math.max(row_heights[r], d.height);							col_widths[c] = Math.max(col_widths[c], d.width);						} else {							break;						}					}					total_height += row_heights[r];				}					int total_width = 0;				for (int c = 0; c < ncols; c++) {					total_width += col_widths[c];				}					// Pass 2: redistribute free space				Dimension parent_size = parent.getSize();				Insets insets = parent.getInsets();				int free_height = parent_size.height - insets.top - insets.bottom - (nrows - 1) * vgap;				int free_width = parent_size.width - insets.left - insets.right - (ncols - 1) * hgap;					if (total_height != free_height) {					double dy = (double)free_height / (double)total_height;					for (int r = 0; r < nrows; r++) {						row_heights[r] = (int) ((double)row_heights[r] * dy);					}				}					if (total_width != free_width) {					double dx = ((double)free_width) / ((double)total_width);					for (int c = 0; c < ncols; c++) {						col_widths[c] = (int) ((double)col_widths[c] * dx);					}				}					// Pass 3: layout components				for (int r = 0, y = insets.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++) {					for (int c = 0, x = insets.left; c < ncols; x += col_widths[c] + hgap, c++, i++) {						if (i < ncomponents) {							parent.getComponent(i).setBounds(x, y, col_widths[c], row_heights[r]);						}					}				}				} // synchronized		}	
public void invalidateLayout(Container container) {}	
/**		 * Returns the string representation of this variable grid layout's values.		 * @return  a string representation of this variable grid layout.		 */		public String toString() {			return getClass().getName() + "[mode=" + mode + ",size=" + size				   + ",hgap=" + hgap + ",vgap=" + vgap + "]";		}	
/**		 * @param  which  if 0 compute minimum layout size,		 *				if 1 compute maximum layout size,		 *				otherwise compute preferred layout size.		 */		private Dimension getLayoutSize(Container parent, int which) {			synchronized (parent.getTreeLock()){				update(parent);					int ncomponents = parent.getComponentCount();				int h = 0;				int w = 0;					for (int r = 0, i = 0; r < nrows; r++) {					int row_height = 0;					for (int c = 0; c < ncols; c++, i++) {						if (i < ncomponents) {							switch (which) {								case 0:									row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);									break;								case 1:									row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);									break;								default:									row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);									break;							}						} else {							break;						}					}					h += row_height;				}					for (int c = 0; c < ncols; c++) {					int col_width = 0;					for (int r = 0; r < nrows; r++) {						int i = r * ncols + c;						if (i < ncomponents) {							switch (which) {								case 0:									col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);									break;								case 1:									col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);									break;								default:									col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);									break;							}						} else {							break;						}					}					w += col_width;				}					Insets insets = parent.getInsets();				return new Dimension(w + insets.left + insets.right + ((ncols - 1) * hgap),									 h + insets.top + insets.bottom + ((nrows - 1) * vgap));			}		}	
private void update(Container container) {			int ncomponents = container.getComponentCount();			int old_nrows = nrows;			int old_ncols = ncols;			if (this.mode == FIXED_NUM_ROWS) {				nrows = this.size;				ncols = (ncomponents + nrows - 1) / nrows;			} else {				ncols = this.size;				nrows = (ncomponents + ncols - 1) / ncols;			}			if (old_nrows != nrows) {				row_heights = new int[nrows];			}			if (old_ncols != ncols) {				col_widths = new int[ncols];			}		}	
